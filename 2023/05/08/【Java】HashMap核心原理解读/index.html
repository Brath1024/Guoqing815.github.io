<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>【Java】HashMap核心原理解读 - Brath-Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Brath-Blog"><meta name="msapplication-TileImage" content="https://brath.cloud/avatar.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Brath-Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="# 【Java】HashMap 核心原理解读 # 一、前言 得益于 Doug Lea  老爷子的操刀，让 HashMap  成为使用和面试最频繁的 API，没办法设计的太优秀了！ HashMap 最早出现在 JDK 1.2 中，底层基于散列算法实现。HashMap 允许 null 键和 null 值，在计算哈键的哈希值时，null 键哈希值为 0。HashMap 并不保证键值对的顺序，这意味着在"><meta property="og:type" content="blog"><meta property="og:title" content="【Java】HashMap核心原理解读"><meta property="og:url" content="http://example.com/2023/05/08/%E3%80%90Java%E3%80%91HashMap%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E8%AF%BB/"><meta property="og:site_name" content="Brath-Blog"><meta property="og:description" content="# 【Java】HashMap 核心原理解读 # 一、前言 得益于 Doug Lea  老爷子的操刀，让 HashMap  成为使用和面试最频繁的 API，没办法设计的太优秀了！ HashMap 最早出现在 JDK 1.2 中，底层基于散列算法实现。HashMap 允许 null 键和 null 值，在计算哈键的哈希值时，null 键哈希值为 0。HashMap 并不保证键值对的顺序，这意味着在"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/interview-4-01.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/interview-4-02.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/interview-4-03.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/interview-4-04.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/interview-4-05.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/interview-4-06.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/12e5dce6bacfa7d4db320d87936b45db.jpeg"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png"><meta property="article:published_time" content="2023-05-08T14:04:55.000Z"><meta property="article:modified_time" content="2023-05-09T00:27:14.814Z"><meta property="article:author" content="Brath"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2023/05/08/%E3%80%90Java%E3%80%91HashMap%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E8%AF%BB/"},"headline":"【Java】HashMap核心原理解读","image":["https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/interview-4-01.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/interview-4-02.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/interview-4-03.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/interview-4-04.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/interview-4-05.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/interview-4-06.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png"],"datePublished":"2023-05-08T14:04:55.000Z","dateModified":"2023-05-09T00:27:14.814Z","author":{"@type":"Person","name":"Brath"},"publisher":{"@type":"Organization","name":"Brath-Blog","logo":{"@type":"ImageObject","url":"https://brath.cloud/avatar.png"}},"description":"# 【Java】HashMap 核心原理解读 # 一、前言 得益于 Doug Lea  老爷子的操刀，让 HashMap  成为使用和面试最频繁的 API，没办法设计的太优秀了！ HashMap 最早出现在 JDK 1.2 中，底层基于散列算法实现。HashMap 允许 null 键和 null 值，在计算哈键的哈希值时，null 键哈希值为 0。HashMap 并不保证键值对的顺序，这意味着在"}</script><link rel="canonical" href="http://example.com/2023/05/08/%E3%80%90Java%E3%80%91HashMap%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E8%AF%BB/"><link rel="icon" href="https://brath.cloud/avatar.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://brath.cloud/avatar.png" alt="Brath-Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">文章列表</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">更多</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Guoqing815"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-05-08T14:04:55.000Z" title="2023/5/8 22:04:55">2023-05-08</time>发表</span><span class="level-item"><time dateTime="2023-05-09T00:27:14.814Z" title="2023/5/9 08:27:14">2023-05-09</time>更新</span><span class="level-item">1 小时读完 (大约9856个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">【Java】HashMap核心原理解读</h1><div class="content"><p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png" alt="InterviewCoder"></p>
<h1 id="javahashmap核心原理解读"><a class="markdownIt-Anchor" href="#javahashmap核心原理解读">#</a> 【Java】HashMap 核心原理解读</h1>
<h2 id="一-前言"><a class="markdownIt-Anchor" href="#一-前言">#</a> 一、前言</h2>
<p>得益于 <code>Doug Lea</code>  老爷子的操刀，让 <code>HashMap</code>  成为使用和面试最频繁的 API，没办法设计的太优秀了！</p>
<p>HashMap 最早出现在 JDK 1.2 中，底层基于散列算法实现。HashMap 允许 null 键和 null 值，在计算哈键的哈希值时，null 键哈希值为 0。HashMap 并不保证键值对的顺序，这意味着在进行某些操作后，键值对的顺序可能会发生变化。另外，需要注意的是，HashMap 是非线程安全类，在多线程环境下可能会存在问题。</p>
<h2 id="二-源码分析"><a class="markdownIt-Anchor" href="#二-源码分析">#</a> 二、源码分析</h2>
<h3 id="1-写一个最简单的hashmap"><a class="markdownIt-Anchor" href="#1-写一个最简单的hashmap">#</a> 1. 写一个最简单的 HashMap</h3>
<p>学习 HashMap 前，最好的方式是先了解这是一种怎么样的数据结构来存放数据。而 HashMap 经过多个版本的迭代后，乍一看代码还是很复杂的。就像你原来只穿个裤衩，现在还有秋裤和风衣。所以我们先来看看最根本的 HashMap 是什么样，也就是只穿裤衩是什么效果，之后再去分析它的源码。</p>
<p><strong>问题：</strong> 假设我们有一组 7 个字符串，需要存放到数组中，但要求在获取每个元素的时候时间复杂度是 O (1)。也就是说你不能通过循环遍历的方式进行获取，而是要定位到数组 ID 直接获取相应的元素。</p>
<p><strong>方案：</strong> 如果说我们需要通过 ID 从数组中获取元素，那么就需要把每个字符串都计算出一个在数组中的位置 ID。<em>字符串获取 ID 你能想到什么方式？</em> 一个字符串最直接的获取跟数字相关的信息就是 HashCode，可 HashCode 的取值范围太大了 <code>[-2147483648, 2147483647]</code> ，不可能直接使用。那么就需要使用 HashCode 与数组长度做与运算，得到一个可以在数组中出现的位置。如果说有两个元素得到同样的 ID，那么这个数组 ID 下就存放两个字符串。</p>
<p>以上呢其实就是我们要把字符串散列到数组中的一个基本思路，接下来我们就把这个思路用代码实现出来。</p>
<h4 id="11-代码实现"><a class="markdownIt-Anchor" href="#11-代码实现">#</a> 1.1 代码实现</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一组字符串</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;jlkk&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;lopi&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;小傅哥&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;e4we&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;alpo&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;yhjk&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;plop&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义要存放的数组</span></span><br><span class="line">String[] tab = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环存放</span></span><br><span class="line"><span class="keyword">for</span> (String key : list) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);  <span class="comment">// 计算索引位置</span></span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;key值=%s Idx=%d&quot;</span>, key, idx));</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == tab[idx]) &#123;</span><br><span class="line">        tab[idx] = key;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tab[idx] = tab[idx] + <span class="string">&quot;-&gt;&quot;</span> + key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出测试结果</span></span><br><span class="line">System.out.println(JSON.toJSONString(tab));</span><br></pre></td></tr></table></figure>
<p>这段代码整体看起来也是非常简单，并没有什么复杂度，主要包括以下内容；</p>
<ol>
<li>初始化一组字符串集合，这里初始化了 7 个。</li>
<li>定义一个数组用于存放字符串，注意这里的长度是 8，也就是 2 的 3 次幂。这样的数组长度才会出现一个  <code>0111</code>  除高位以外都是 1 的特征，也是为了散列。</li>
<li>接下来就是循环存放数据，计算出每个字符串在数组中的位置。 <code>key.hashCode() &amp; (tab.length - 1)</code> 。</li>
<li>在字符串存放到数组的过程，如果遇到相同的元素，进行连接操作 <code>模拟链表的过程</code> 。</li>
<li>最后输出存放结果。</li>
</ol>
<p><strong>测试结果</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">key值=jlkk Idx=<span class="number">2</span></span><br><span class="line">key值=lopi Idx=<span class="number">4</span></span><br><span class="line">key值=小傅哥 Idx=<span class="number">7</span></span><br><span class="line">key值=e4we Idx=<span class="number">5</span></span><br><span class="line">key值=alpo Idx=<span class="number">2</span></span><br><span class="line">key值=yhjk Idx=<span class="number">0</span></span><br><span class="line">key值=plop Idx=<span class="number">5</span></span><br><span class="line">测试结果：[<span class="string">&quot;yhjk&quot;</span>,<span class="literal">null</span>,<span class="string">&quot;jlkk-&gt;alpo&quot;</span>,<span class="literal">null</span>,<span class="string">&quot;lopi&quot;</span>,<span class="string">&quot;e4we-&gt;plop&quot;</span>,<span class="literal">null</span>,<span class="string">&quot;小傅哥&quot;</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>在测试结果首先是计算出每个元素在数组的 Idx，也有出现重复的位置。</li>
<li>最后是测试结果的输出，1、3、6，位置是空的，2、5，位置有两个元素被链接起来 <code>e4we-&gt;plop</code> 。</li>
<li>这就达到了我们一个最基本的要求，将串元素散列存放到数组中，最后通过字符串元素的索引 ID 进行获取对应字符串。这样是 HashMap 的一个最基本原理，有了这个基础后面就会更容易理解 HashMap 的源码实现。</li>
</ul>
<h4 id="12-hash散列示意图"><a class="markdownIt-Anchor" href="#12-hash散列示意图">#</a> 1.2 Hash 散列示意图</h4>
<p>如果上面的测试结果不能在你的头脑中很好的建立出一个数据结构，那么可以看以下这张散列示意图，方便理解；</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/interview-4-01.png" alt="bugstack.cn Hash散列示意图"></p>
<ul>
<li>这张图就是上面代码实现的全过程，将每一个字符串元素通过 Hash 计算索引位置，存放到数组中。</li>
<li>黄色的索引 ID 是没有元素存放、绿色的索引 ID 存放了一个元素、红色的索引 ID 存放了两个元素。</li>
</ul>
<h4 id="httpsbugstackcnmdjavainterview2020-08-07-面经手册-第3篇hashmap核心知识扰动函数-负载因子-扩容链表拆分深度学习html_1-3-这个简单的hashmap有哪些问题13-这个简单的hashmap有哪些问题"><a class="markdownIt-Anchor" href="#httpsbugstackcnmdjavainterview2020-08-07-面经手册-第3篇hashmap核心知识扰动函数-负载因子-扩容链表拆分深度学习html_1-3-这个简单的hashmap有哪些问题13-这个简单的hashmap有哪些问题">#</a> [#](<a target="_blank" rel="noopener" href="https://bugstack.cn/md/java/interview/2020-08-07-%E9%9D%A2%E7%BB%8F%E6%89%8B%E5%86%8C">https://bugstack.cn/md/java/interview/2020-08-07 - 面经手册</a>・第 3 篇《HashMap 核心知识，扰动函数、负载因子、扩容链表拆分，深度学习》.html#_1-3 - 这个简单的 hashmap 有哪些问题) 1.3 这个简单的 HashMap 有哪些问题</h4>
<p>以上我们实现了一个简单的 HashMap，或者说还算不上 HashMap，只能算做一个散列数据存放的雏形。但这样的一个数据结构放在实际使用中，会有哪些问题呢？</p>
<ol>
<li>这里所有的元素存放都需要获取一个索引位置，而如果元素的位置不够散列碰撞严重，那么就失去了散列表存放的意义，没有达到预期的性能。</li>
<li>在获取索引 ID 的计算公式中，需要数组长度是 2 的幂次方，那么怎么进行初始化这个数组大小。</li>
<li>数组越小碰撞的越大，数组越大碰撞的越小，时间与空间如何取舍。</li>
<li>目前存放 7 个元素，已经有两个位置都存放了 2 个字符串，那么链表越来越长怎么优化。</li>
<li>随着元素的不断添加，数组长度不足扩容时，怎么把原有的元素，拆分到新的位置上去。</li>
</ol>
<p>以上这些问题可以归纳为； <code>扰动函数</code> 、 <code>初始化容量</code> 、 <code>负载因子</code> 、 <code>扩容方法</code> 以及 <code>链表和红黑树</code> 转换的使用等。接下来我们会逐个问题进行分析。</p>
<h3 id="2-扰动函数"><a class="markdownIt-Anchor" href="#2-扰动函数">#</a> 2. 扰动函数</h3>
<p>在 HashMap 存放元素时候有这样一段代码来处理哈希值，这是 <code>java 8</code>  的散列值扰动函数，用于优化散列效果；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="21-为什么使用扰动函数"><a class="markdownIt-Anchor" href="#21-为什么使用扰动函数">#</a> 2.1 为什么使用扰动函数</h4>
<p>理论上来说字符串的 <code>hashCode</code>  是一个 int 类型值，那可以直接作为数组下标了，且不会出现碰撞。但是这个 <code>hashCode</code>  的取值范围是 [-2147483648, 2147483647]，有将近 40 亿的长度，谁也不能把数组初始化的这么大，内存也是放不下的。</p>
<p>我们默认初始化的 Map 大小是 16 个长度  <code>DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4</code> ，所以获取的 Hash 值并不能直接作为下标使用，需要与数组长度进行取模运算得到一个下标值，也就是我们上面做的散列列子。</p>
<p>那么，hashMap 源码这里不只是直接获取哈希值，还进行了一次扰动计算， <code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code> 。把哈希值右移 16 位，也就正好是自己长度的一半，之后与原哈希值做异或运算，这样就混合了原哈希值中的高位和低位，增大了<strong>随机性</strong>。计算方式如下图；</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/interview-4-02.png" alt="bugstack.cn 扰动函数"></p>
<ul>
<li>说白了，使用扰动函数就是为了增加随机性，让数据元素更加均衡的散列，减少碰撞。</li>
</ul>
<h4 id="22-实验验证扰动函数"><a class="markdownIt-Anchor" href="#22-实验验证扰动函数">#</a> 2.2 实验验证扰动函数</h4>
<p>从上面的分析可以看出，扰动函数使用了哈希值的高半区和低半区做异或，混合原始哈希码的高位和低位，以此来加大低位区的随机性。</p>
<p>但看不到实验数据的话，这终究是一段理论，具体这段哈希值真的被增加了随机性没有，并不知道。所以这里我们要做一个实验，这个实验是这样做；</p>
<ol>
<li>选取 10 万个单词词库</li>
<li>定义 128 位长度的数组格子</li>
<li>分别计算在扰动和不扰动下，10 万单词的下标分配到 128 个格子的数量</li>
<li>统计各个格子数量，生成波动曲线。如果扰动函数下的波动曲线相对更平稳，那么证明扰动函数有效果。</li>
</ol>
<h5 id="221-扰动代码测试"><a class="markdownIt-Anchor" href="#221-扰动代码测试">#</a> 2.2.1 扰动代码测试</h5>
<p><strong>扰动函数对比方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Disturb</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">disturbHashIdx</span><span class="params">(String key, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (size - <span class="number">1</span>) &amp; (key.hashCode() ^ (key.hashCode() &gt;&gt;&gt; <span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hashIdx</span><span class="params">(String key, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (size - <span class="number">1</span>) &amp; key.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>disturbHashIdx</code>  扰动函数下，下标值计算</li>
<li><code>hashIdx</code>  非扰动函数下，下标值计算</li>
</ul>
<p><strong>单元测试</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 10万单词已经初始化到words中</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_disturb</span><span class="params">()</span> &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">        <span class="comment">// 使用扰动函数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> Disturb.disturbHashIdx(word, <span class="number">128</span>);</span><br><span class="line">        <span class="comment">// 不使用扰动函数</span></span><br><span class="line">        <span class="comment">// int idx = Disturb.hashIdx(word, 128);</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(idx)) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> map.get(idx);</span><br><span class="line">            map.put(idx, ++integer);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(idx, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(map.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上分别统计两种函数下的下标值分配，最终将统计结果放到 excel 中生成图表。</p>
<h5 id="httpsbugstackcnmdjavainterview2020-08-07-面经手册-第3篇hashmap核心知识扰动函数-负载因子-扩容链表拆分深度学习html_2-2-2-扰动函数散列图表222-扰动函数散列图表"><a class="markdownIt-Anchor" href="#httpsbugstackcnmdjavainterview2020-08-07-面经手册-第3篇hashmap核心知识扰动函数-负载因子-扩容链表拆分深度学习html_2-2-2-扰动函数散列图表222-扰动函数散列图表">#</a> [#](<a target="_blank" rel="noopener" href="https://bugstack.cn/md/java/interview/2020-08-07-%E9%9D%A2%E7%BB%8F%E6%89%8B%E5%86%8C">https://bugstack.cn/md/java/interview/2020-08-07 - 面经手册</a>・第 3 篇《HashMap 核心知识，扰动函数、负载因子、扩容链表拆分，深度学习》.html#_2-2-2 - 扰动函数散列图表) 2.2.2 扰动函数散列图表</h5>
<p>以上的两张图，分别是没有使用扰动函数和使用扰动函数的，下标分配。实验数据；</p>
<ol>
<li>10 万个不重复的单词</li>
<li>128 个格子，相当于 128 长度的数组</li>
</ol>
<p><strong>未使用扰动函数</strong></p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/interview-4-03.png" alt="bugstack.cn 未使用扰动函数"></p>
<p><strong>使用扰动函数</strong></p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/interview-4-04.png" alt="bugstack.cn 使用扰动函数"></p>
<ul>
<li>从这两种的对比图可以看出来，在使用了扰动函数后，数据分配的更加均匀了。</li>
<li>数据分配均匀，也就是散列的效果更好，减少了 hash 的碰撞，让数据存放和获取的效率更佳。</li>
</ul>
<h3 id="3-初始化容量和负载因子"><a class="markdownIt-Anchor" href="#3-初始化容量和负载因子">#</a> 3. 初始化容量和负载因子</h3>
<p>接下来我们讨论下一个问题，从我们模仿 HashMap 的例子中以及 HashMap 默认的初始化大小里，都可以知道，散列数组需要一个 2 的幂次方的长度，因为只有 2 的幂次方在减 1 的时候，才会出现 <code>01111</code>  这样的值。</p>
<p>那么这里就有一个问题，我们在初始化 HashMap 的时候，如果传一个 17 个的值 <code>new HashMap&lt;&gt;(17);</code> ，它会怎么处理呢？</p>
<h4 id="31-寻找2的幂次方最小值"><a class="markdownIt-Anchor" href="#31-寻找2的幂次方最小值">#</a> 3.1 寻找 2 的幂次方最小值</h4>
<p>在 HashMap 的初始化中，有这样一段方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>阈值 <code>threshold</code> ，通过方法 <code>tableSizeFor</code>  进行计算，是根据初始化来计算的。</li>
<li>这个方法也就是要寻找比初始值大的，最小的那个 2 进制数值。比如传了 17，我应该找到的是 32（2 的 4 次幂是 16&lt;17, 所以找到 2 的 5 次幂 32）。</li>
</ul>
<p>计算阈值大小的方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>MAXIMUM_CAPACITY = 1 &lt;&lt; 30，这个是临界范围，也就是最大的 Map 集合。</li>
<li>乍一看可能有点晕😵怎么都在向右移位 1、2、4、8、16，这主要是为了把二进制的各个位置都填上 1，当二进制的各个位置都是 1 以后，就是一个标准的 2 的幂次方减 1 了，最后把结果加 1 再返回即可。</li>
</ul>
<p>那这里我们把 17 这样一个初始化计算阈值的过程，用图展示出来，方便理解；</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/interview-4-05.png" alt="bugstack.cn 计算阈值"></p>
<h4 id="32-负载因子"><a class="markdownIt-Anchor" href="#32-负载因子">#</a> 3.2 负载因子</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;  </span><br></pre></td></tr></table></figure>
<p><strong>负载因子是做什么的？</strong></p>
<p>负载因子，可以理解成一辆车可承重重量超过某个阈值时，把货放到新的车上。</p>
<p>那么在 HashMap 中，负载因子决定了数据量多少了以后进行扩容。<em>这里要提到上面做的 HashMap 例子，我们准备了 7 个元素，但是最后还有 3 个位置空余，2 个位置存放了 2 个元素。</em> 所以可能即使你数据比数组容量大时也是不一定能正正好好的把数组占满的，而是在某些小标位置出现了大量的碰撞，只能在同一个位置用链表存放，那么这样就失去了 Map 数组的性能。</p>
<p>所以，要选择一个合理的大小下进行扩容，默认值 0.75 就是说当阈值容量占了 3/4 时赶紧扩容，减少 Hash 碰撞。</p>
<p>同时 0.75 是一个默认构造值，在创建 HashMap 也可以调整，比如你希望用更多的空间换取时间，可以把负载因子调的更小一些，减少碰撞。</p>
<h3 id="4-扩容元素拆分"><a class="markdownIt-Anchor" href="#4-扩容元素拆分">#</a> 4. 扩容元素拆分</h3>
<p>为什么扩容，因为数组长度不足了。那扩容最直接的问题，就是需要把元素拆分到新的数组中。拆分元素的过程中，原 jdk1.7 中会需要重新计算哈希值，但是到 jdk1.8 中已经进行优化，不再需要重新计算，提升了拆分的性能，设计的还是非常巧妙的。</p>
<h4 id="41-测试数据"><a class="markdownIt-Anchor" href="#41-测试数据">#</a> 4.1 测试数据</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_hashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;jlkk&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;lopi&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;jmdw&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;e4we&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;io98&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;nmhg&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;vfg6&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;gfrt&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;alpo&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;vfbh&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;bnhj&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;zuio&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;iu8e&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;yhjk&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;plop&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;dd0p&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String key : list) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode() ^ (key.hashCode() &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串：&quot;</span> + key + <span class="string">&quot; \tIdx(16)：&quot;</span> + ((<span class="number">16</span> - <span class="number">1</span>) &amp; hash) + <span class="string">&quot; \tBit值：&quot;</span> + Integer.toBinaryString(hash) + <span class="string">&quot; - &quot;</span> + Integer.toBinaryString(hash &amp; <span class="number">16</span>) + <span class="string">&quot; \t\tIdx(32)：&quot;</span> + ((</span><br><span class="line">        System.out.println(Integer.toBinaryString(key.hashCode()) +<span class="string">&quot; &quot;</span>+ Integer.toBinaryString(hash) + <span class="string">&quot; &quot;</span> + Integer.toBinaryString((<span class="number">32</span> - <span class="number">1</span>) &amp; hash));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p><strong>测试结果</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">字符串：jlkk 	<span class="title function_">Idx</span><span class="params">(<span class="number">16</span>)</span>：<span class="number">3</span> 	Bit值：<span class="number">1100011101001000010011</span> - <span class="number">10000</span> 		Idx(<span class="number">32</span>)：<span class="number">19</span></span><br><span class="line"><span class="number">1100011101001000100010</span> <span class="number">1100011101001000010011</span> <span class="number">10011</span></span><br><span class="line">字符串：lopi 	<span class="title function_">Idx</span><span class="params">(<span class="number">16</span>)</span>：<span class="number">14</span> 	Bit值：<span class="number">1100101100011010001110</span> - <span class="number">0</span> 		Idx(<span class="number">32</span>)：<span class="number">14</span></span><br><span class="line"><span class="number">1100101100011010111100</span> <span class="number">1100101100011010001110</span> <span class="number">1110</span></span><br><span class="line">字符串：jmdw 	<span class="title function_">Idx</span><span class="params">(<span class="number">16</span>)</span>：<span class="number">7</span> 	Bit值：<span class="number">1100011101010100100111</span> - <span class="number">0</span> 		Idx(<span class="number">32</span>)：<span class="number">7</span></span><br><span class="line"><span class="number">1100011101010100010110</span> <span class="number">1100011101010100100111</span> <span class="number">111</span></span><br><span class="line">字符串：e4we 	<span class="title function_">Idx</span><span class="params">(<span class="number">16</span>)</span>：<span class="number">3</span> 	Bit值：<span class="number">1011101011101101010011</span> - <span class="number">10000</span> 		Idx(<span class="number">32</span>)：<span class="number">19</span></span><br><span class="line"><span class="number">1011101011101101111101</span> <span class="number">1011101011101101010011</span> <span class="number">10011</span></span><br><span class="line">字符串：io98 	<span class="title function_">Idx</span><span class="params">(<span class="number">16</span>)</span>：<span class="number">4</span> 	Bit值：<span class="number">1100010110001011110100</span> - <span class="number">10000</span> 		Idx(<span class="number">32</span>)：<span class="number">20</span></span><br><span class="line"><span class="number">1100010110001011000101</span> <span class="number">1100010110001011110100</span> <span class="number">10100</span></span><br><span class="line">字符串：nmhg 	<span class="title function_">Idx</span><span class="params">(<span class="number">16</span>)</span>：<span class="number">13</span> 	Bit值：<span class="number">1100111010011011001101</span> - <span class="number">0</span> 		Idx(<span class="number">32</span>)：<span class="number">13</span></span><br><span class="line"><span class="number">1100111010011011111110</span> <span class="number">1100111010011011001101</span> <span class="number">1101</span></span><br><span class="line">字符串：vfg6 	<span class="title function_">Idx</span><span class="params">(<span class="number">16</span>)</span>：<span class="number">8</span> 	Bit值：<span class="number">1101110010111101101000</span> - <span class="number">0</span> 		Idx(<span class="number">32</span>)：<span class="number">8</span></span><br><span class="line"><span class="number">1101110010111101011111</span> <span class="number">1101110010111101101000</span> <span class="number">1000</span></span><br><span class="line">字符串：gfrt 	<span class="title function_">Idx</span><span class="params">(<span class="number">16</span>)</span>：<span class="number">1</span> 	Bit值：<span class="number">1100000101111101010001</span> - <span class="number">10000</span> 		Idx(<span class="number">32</span>)：<span class="number">17</span></span><br><span class="line"><span class="number">1100000101111101100001</span> <span class="number">1100000101111101010001</span> <span class="number">10001</span></span><br><span class="line">字符串：alpo 	<span class="title function_">Idx</span><span class="params">(<span class="number">16</span>)</span>：<span class="number">7</span> 	Bit值：<span class="number">1011011011101101000111</span> - <span class="number">0</span> 		Idx(<span class="number">32</span>)：<span class="number">7</span></span><br><span class="line"><span class="number">1011011011101101101010</span> <span class="number">1011011011101101000111</span> <span class="number">111</span></span><br><span class="line">字符串：vfbh 	<span class="title function_">Idx</span><span class="params">(<span class="number">16</span>)</span>：<span class="number">1</span> 	Bit值：<span class="number">1101110010111011000001</span> - <span class="number">0</span> 		Idx(<span class="number">32</span>)：<span class="number">1</span></span><br><span class="line"><span class="number">1101110010111011110110</span> <span class="number">1101110010111011000001</span> <span class="number">1</span></span><br><span class="line">字符串：bnhj 	<span class="title function_">Idx</span><span class="params">(<span class="number">16</span>)</span>：<span class="number">0</span> 	Bit值：<span class="number">1011100011011001100000</span> - <span class="number">0</span> 		Idx(<span class="number">32</span>)：<span class="number">0</span></span><br><span class="line"><span class="number">1011100011011001001110</span> <span class="number">1011100011011001100000</span> <span class="number">0</span></span><br><span class="line">字符串：zuio 	<span class="title function_">Idx</span><span class="params">(<span class="number">16</span>)</span>：<span class="number">8</span> 	Bit值：<span class="number">1110010011100110011000</span> - <span class="number">10000</span> 		Idx(<span class="number">32</span>)：<span class="number">24</span></span><br><span class="line"><span class="number">1110010011100110100001</span> <span class="number">1110010011100110011000</span> <span class="number">11000</span></span><br><span class="line">字符串：iu8e 	<span class="title function_">Idx</span><span class="params">(<span class="number">16</span>)</span>：<span class="number">8</span> 	Bit值：<span class="number">1100010111100101101000</span> - <span class="number">0</span> 		Idx(<span class="number">32</span>)：<span class="number">8</span></span><br><span class="line"><span class="number">1100010111100101011001</span> <span class="number">1100010111100101101000</span> <span class="number">1000</span></span><br><span class="line">字符串：yhjk 	<span class="title function_">Idx</span><span class="params">(<span class="number">16</span>)</span>：<span class="number">8</span> 	Bit值：<span class="number">1110001001010010101000</span> - <span class="number">0</span> 		Idx(<span class="number">32</span>)：<span class="number">8</span></span><br><span class="line"><span class="number">1110001001010010010000</span> <span class="number">1110001001010010101000</span> <span class="number">1000</span></span><br><span class="line">字符串：plop 	<span class="title function_">Idx</span><span class="params">(<span class="number">16</span>)</span>：<span class="number">9</span> 	Bit值：<span class="number">1101001000110011101001</span> - <span class="number">0</span> 		Idx(<span class="number">32</span>)：<span class="number">9</span></span><br><span class="line"><span class="number">1101001000110011011101</span> <span class="number">1101001000110011101001</span> <span class="number">1001</span></span><br><span class="line">字符串：dd0p 	<span class="title function_">Idx</span><span class="params">(<span class="number">16</span>)</span>：<span class="number">14</span> 	Bit值：<span class="number">1011101111001011101110</span> - <span class="number">0</span> 		Idx(<span class="number">32</span>)：<span class="number">14</span></span><br><span class="line"><span class="number">1011101111001011000000</span> <span class="number">1011101111001011101110</span> <span class="number">1110</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这里我们随机使用一些字符串计算他们分别在 16 位长度和 32 位长度数组下的索引分配情况，看哪些数据被重新路由到了新的地址。</li>
<li>同时，这里还可以观察🕵出一个非常重要的信息，原哈希值与扩容新增出来的长度 16，进行 &amp; 运算，如果值等于 0，则下标位置不变。如果不为 0，那么新的位置则是原来位置上加 16。｛这个地方需要好好理解下，并看实验数据｝</li>
<li>这样一来，就不需要在重新计算每一个数组中元素的哈希值了。</li>
</ul>
<p>4.2 数据迁移</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/interview-4-06.png" alt="bugstack.cn 数据迁移"></p>
<ul>
<li>这张图就是原 16 位长度数组元素，向 32 位扩容后数组转移的过程。</li>
<li>对 31 取模保留低 5 位，对 15 取模保留低 4 位，两者的差异就在于第 5 位是否为 1，是的话则需要加上增量，为 0 的话则不需要改变</li>
<li>其中黄色区域元素 <code>zuio</code>  因计算结果  <code>hash &amp; oldCap</code>  低位第 5 位为 1，则被迁移到下标位置 24。</li>
<li>同时还是用重新计算哈希值的方式验证了，确实分配到 24 的位置，因为这是在二进制计算中补 1 的过程，所以可以通过上面简化的方式确定哈希值的位置。</li>
</ul>
<p>那么为什么 e.hash &amp; oldCap == 0 为什么可以判断当前节点是否需要移位，而不是再次计算 hash;</p>
<p>仍然是原始长度为 16 举例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">old:</span><br><span class="line"><span class="number">10</span>: <span class="number">0000</span> <span class="number">1010</span></span><br><span class="line"><span class="number">15</span>: <span class="number">0000</span> <span class="number">1111</span></span><br><span class="line">&amp;: <span class="number">0000</span> <span class="number">1010</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span>:</span><br><span class="line"><span class="number">10</span>: <span class="number">0000</span> <span class="number">1010</span></span><br><span class="line"><span class="number">31</span>: <span class="number">0001</span> <span class="number">1111</span></span><br><span class="line">&amp;: <span class="number">0000</span> <span class="number">1010</span> </span><br></pre></td></tr></table></figure>
<p>从上面的示例可以很轻易的看出，两次 indexFor () 的差别只是第二次参与位于比第一次左边有一位从 0 变为 1, 而这个变化的 1 刚好是 oldCap, 那么只需要判断原 key 的 hash 这个位上是否为 1: 若是 1, 则需要移动至 oldCap + i 的槽位，若为 0, 则不需要移动；</p>
<p>这也是 HashMap 的长度必须保证是 2 的幂次方的原因，正因为这种环环相扣的设计，HashMap.loadFactor 的选值是 3/4 就能理解了，table.length * 3/4 可以被优化为 ((table.length&gt;&gt; 2) &lt;&lt; 2) - (table.length &gt;&gt; 2) == table.length - (table.length &gt;&gt; 2), JAVA 的位运算比乘除的效率更高，所以取 3/4 在保证 hash 冲突小的情况下兼顾了效率；</p>
<h1 id="面试题总结"><a class="markdownIt-Anchor" href="#面试题总结">#</a> 面试题总结</h1>
<h1 id="question"><a class="markdownIt-Anchor" href="#question">#</a> Question</h1>
<h4 id="1为什么hashmap哈希表中数组长度总是取-2-的幂次方"><a class="markdownIt-Anchor" href="#1为什么hashmap哈希表中数组长度总是取-2-的幂次方">#</a> 1. 为什么 HashMap 哈希表中数组长度总是取 2 的幂次方？</h4>
<h6 id="散列数组需要一个2的幂次方的长度因为只有2的幂次方在减1的时候才会出现01111这样的值"><a class="markdownIt-Anchor" href="#散列数组需要一个2的幂次方的长度因为只有2的幂次方在减1的时候才会出现01111这样的值">#</a> 散列数组需要一个 2 的幂次方的长度，因为只有 2 的幂次方在减 1 的时候，才会出现 01111 这样的值。</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过获取存储内容的hashcode，并且对长度是 2 的幂次方的数组长度-1进行与运算得到一个可以在数组中出现的位置</span></span><br><span class="line"><span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">哈希表中数组长度总是取 <span class="number">2</span> 的幂次方，这是因为对于大多数的质数来说，它们的二进制表示中只有少数位是为 <span class="number">1</span>。如果使用一个不是 <span class="number">2</span> 的幂次方的数组长度，那么当元素的哈希映射到索引时，就会出现某些索引永远无法被访问到的情况，这就浪费了哈希表的空间。</span><br><span class="line"></span><br><span class="line">举个例子，比如我们要在一个大小为 <span class="number">5</span> 的数组中插入 <span class="number">10</span> 个元素 &#123;a,b,c,d,e,f,g,h,i,j&#125;，而哈希函数将他们依次映射到下标位置：[<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]，可以看到，有三个下标（<span class="number">5</span>、<span class="number">6</span>、<span class="number">7</span>）始终没有被映射到，完全浪费了这几个下标的存储空间。但如果数组长度为 <span class="number">8</span>，那么上述元素的哈希值按照上面的映射规则可以得到的下标分别是 [<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] % <span class="number">8</span> = [<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]，不会出现任何下标被浪费的情况。</span><br><span class="line"></span><br><span class="line">这种情况下，如果将数组长度改为 <span class="number">7</span>，那么上述元素的哈希值按照上面的映射规则可以得到的下标分别是 [<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] % <span class="number">7</span> = [<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>]，可以看到，索引为 <span class="number">5</span>、<span class="number">6</span> 的空间仍然被浪费了。</span><br><span class="line"></span><br><span class="line">因此，为了避免在哈希表中浪费存储空间，我们一般都会选择使用 <span class="number">2</span> 的幂次方作为哈希表的大小。这样，在计算元素的位置时，只需要对哈希码进行位运算即可，不需要进行除法等复杂的计算。同时，由于 <span class="number">2</span> 的幂次方满足 <span class="number">2</span>^n2*n*，所以用位运算来代替除法或取模操作也能够提高运行效率。</span><br></pre></td></tr></table></figure>
<h4 id="2hashmap怎么保证哈希表长度是-2-的幂次方"><a class="markdownIt-Anchor" href="#2hashmap怎么保证哈希表长度是-2-的幂次方">#</a> 2.HashMap 怎么保证哈希表长度是 2 的幂次方？</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在 Java 中，哈希表的长度总是 <span class="number">2</span> 的幂次方。这是通过 HashMap 类中的一个名为 `tableSizeFor(<span class="type">int</span> cap)` 的静态方法来实现的。</span><br><span class="line"></span><br><span class="line">这个方法会首先将传入的参数减去 <span class="number">1</span>，然后将结果右移一位，在这个值上加 <span class="number">1</span>，最终得到的结果就是大于等于原始参数且最接近原始参数的 <span class="number">2</span> 的幂次方。例如，如果传入的参数是 <span class="number">7</span>，则按照上述算法可以得到 <span class="number">8</span>：(((<span class="number">7</span> - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>) = ((<span class="number">0110</span>)_2 &gt;&gt;&gt; <span class="number">1</span> + <span class="number">1</span>) = (<span class="number">0011</span>)_2 + (<span class="number">0001</span>)_2 = (<span class="number">0100</span>)_2 = <span class="number">8</span>(((<span class="number">7</span>−<span class="number">1</span>)&gt;&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>)=((<span class="number">0110</span>)<span class="number">2</span>&gt;&gt;&gt;<span class="number">1</span>+<span class="number">1</span>)=(<span class="number">0011</span>)<span class="number">2</span>+(<span class="number">0001</span>)<span class="number">2</span>=(<span class="number">0100</span>)<span class="number">2</span>=<span class="number">8</span>。</span><br><span class="line"></span><br><span class="line">因此，当我们创建一个新的哈希表时，只需要将初始容量设置为需要存储的元素数目除以负载因子（load factor），然后调用 `tableSizeFor` 方法进行处理即可。这样就能够保证哈希表的长度始终是 <span class="number">2</span> 的幂次方，并达到较好的性能和空间利用率。</span><br><span class="line"></span><br><span class="line">需要注意的是，虽然这种方式确实可以保证哈希表的长度是 <span class="number">2</span> 的幂次方，但有时候也可能会出现哈希冲突的情况。因此，在实际应用中，还需要根据具体情况选择合适的哈希函数、负载因子等参数来避免哈希冲突，并提高哈希表的性能。</span><br></pre></td></tr></table></figure>
<h4 id="3在hashmap存放元素时候有这样一段代码来处理哈希值这是java-8的散列值扰动函数用于优化散列效果"><a class="markdownIt-Anchor" href="#3在hashmap存放元素时候有这样一段代码来处理哈希值这是java-8的散列值扰动函数用于优化散列效果">#</a> 3. 在 HashMap 存放元素时候有这样一段代码来处理哈希值，这是 java 8 的散列值扰动函数，用于优化散列效果</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span>&#123;</span><br><span class="line">	<span class="type">int</span> h;</span><br><span class="line">	<span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashcode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4hash为什么用31计算"><a class="markdownIt-Anchor" href="#4hash为什么用31计算">#</a> 4.Hash 为什么用 31 计算？</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	使用 <span class="number">31</span> 这个系数的原因是因为它既是一个质数，又可以通过移位和减法等简单的运算来实现乘法。同时，由于 <span class="number">31</span> 在二进制中只有一个非零的比特位，因此用 <span class="number">31</span> 进行乘法相当于进行了位运算和加法的组合，这样不仅能够保证高效运算，还能够避免哈希冲突。</span><br><span class="line">	</span><br><span class="line"><span class="number">31</span>具有两个优点：</span><br><span class="line">	<span class="number">1.</span>小质数：<span class="number">31</span> 是一个较小的质数，在哈希表中被用来乘以键的哈希码，使得结果不会太大，从而提高性能。相对于其他的质数，<span class="number">31</span> 更易于被 CPU 缓存，这也有助于提升哈希表的查询速度。</span><br><span class="line">	<span class="number">2.</span>可逆性：因为 <span class="number">31</span> 是质数且比较小，所以只要哈希表的大小足够大，在乘法过程中产生的数据溢出是不会影响哈希结果的。而且，<span class="number">31</span> 的逆元 <span class="number">0x9e3779b1</span> 是一个固定的常量，也很容易计算，这有助于在需要恢复哈希码时进行逆运算。</span><br><span class="line"></span><br><span class="line">	在实现哈希函数时，使用系数 <span class="number">31</span> 可以保证高效性、可逆性和低冲突率，因此在 Java 中被广泛使用。</span><br></pre></td></tr></table></figure>
<h4 id="5hashmap扰动函数的作用是什么以及它可以被应用在哪些地方"><a class="markdownIt-Anchor" href="#5hashmap扰动函数的作用是什么以及它可以被应用在哪些地方">#</a> 5.HashMap 扰动函数的作用是什么，以及它可以被应用在哪些地方？</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">扰动函数是一种用于增强哈希函数的技术。它通常被用来对原始哈希值进行混淆和扰动，从而减小哈希冲突的发生率。</span><br><span class="line">	</span><br><span class="line">	具体来说，扰动函数会将原始哈希值与另一个数值进行混合，并再次运用哈希函数产生最终的哈希值。这个额外的数值可以是任意的固定值或随机数，目的是使得不同的哈希值在进行混淆之后，仍然能够保持一定的分散性，从而减小哈希冲突的概率。</span><br><span class="line"></span><br><span class="line">扰动函数可以被应用在许多地方，例如：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>哈希表：在哈希表中，扰动函数可以用来增加键的随机性，减少哈希冲突的发生率，从而提高哈希表的性能。Java 中的 HashMap 就使用了扰动函数对键的哈希码进行混淆。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>加密算法：在一些加密算法中，也会使用扰动函数来增加密码熵，并提高加密强度。例如，MD5 算法就采用了一系列扰动函数对数据进行混淆。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>图像处理：在图像处理中，扰动函数可以用来对像素值随机化，增加图像的噪声，从而实现一些特殊效果，如毛玻璃效果、雨滴效果等。</span><br><span class="line"></span><br><span class="line">总之，扰动函数是一种通用的技术，可以在许多场景下使用。通过引入随机数和混淆操作，扰动函数可以增强数据的随机性和复杂性，从而提高系统的安全性和性能。</span><br></pre></td></tr></table></figure>
<h4 id="6hashmap负载因子"><a class="markdownIt-Anchor" href="#6hashmap负载因子">#</a> 6.HashMap 负载因子？</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">负载因子，可以理解成一辆车可承重重量超过某个阈值时，把货放到新的车上。</span><br><span class="line"></span><br><span class="line">	那么在HashMap中，负载因子决定了数据量多少了以后进行扩容。这里要提到上面做的HashMap例子，我们准备了<span class="number">7</span>个元素，但是最后还有<span class="number">3</span>个位置空余，<span class="number">2</span>个位置存放了<span class="number">2</span>个元素。 所以可能即使你数据比数组容量大时也是不一定能正正好好的把数组占满的，而是在某些小标位置出现了大量的碰撞，只能在同一个位置用链表存放，那么这样就失去了Map数组的性能。</span><br><span class="line"></span><br><span class="line">	所以，要选择一个合理的大小下进行扩容，默认值<span class="number">0.75</span>就是说当阈值容量占了<span class="number">3</span>/<span class="number">4</span>时赶紧扩容，减少Hash碰撞。</span><br><span class="line"></span><br><span class="line">	同时<span class="number">0.75</span>是一个默认构造值，在创建HashMap也可以调整，比如你希望用更多的空间换取时间，可以把负载因子调的更小一些，减少碰撞。</span><br></pre></td></tr></table></figure>
<h4 id="7hashmap是开放寻址还是拉链寻址"><a class="markdownIt-Anchor" href="#7hashmap是开放寻址还是拉链寻址">#</a> 7.HashMap 是开放寻址还是拉链寻址？</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HashMap 是一种拉链式哈希表，也就是说，它使用了链表来解决哈希冲突。</span><br><span class="line"></span><br><span class="line">	具体来说，当多个不同的键映射到同一个桶时，HashMap 会将它们存储在同一个桶中，并通过链表或红黑树等数据结构组织起来。这样，在进行查找、插入、删除等操作时，就可以遍历对应桶中的链表，找到所需的元素。</span><br><span class="line"></span><br><span class="line">	相对于开放寻址法，拉链法能够更好地处理哈希冲突，并且支持动态扩容。因为在拉链法中，哈希表的每个桶都可以存储多个元素，而在开放寻址法中，每个位置只能存储一个元素，这使得动态扩容变得更加困难和低效。</span><br><span class="line"></span><br><span class="line">	但是，由于链表的空间和时间开销，当哈希冲突较为频繁时，拉链法可能会导致性能下降。为了解决这个问题，Java8 引入了基于红黑树的优化机制，即当链表长度超过一定阈值时，将链表转换为红黑树，以提高查询效率。</span><br><span class="line"></span><br><span class="line">总之，HashMap 是一种基于拉链法实现的哈希表，能够高效处理哈希冲突，并且支持动态扩容和基于红黑树的优化。</span><br></pre></td></tr></table></figure>
<h4 id="8hashmap链表什么时候树化以及迁移数据算法是什么"><a class="markdownIt-Anchor" href="#8hashmap链表什么时候树化以及迁移数据算法是什么">#</a> 8.HashMap 链表什么时候树化以及迁移数据算法是什么？</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在JDK1<span class="number">.8</span>中，HashMap是以数组+链表+红黑树构成的。</span><br><span class="line"></span><br><span class="line">	具体来说，当某个桶中的链表长度超过了阈值时，HashMap 会将这个链表转换成一棵红黑树，以便支持更快的查找、插入和删除等操作。这个过程中，需要进行以下步骤：</span><br><span class="line"></span><br><span class="line">	<span class="number">1.</span>创建一棵空的红黑树，并将原始链表中的所有元素插入到这棵树中。</span><br><span class="line">	<span class="number">2.</span>删除原始链表中的所有元素，并设置哈希表的结构类型为 TREEBIN。</span><br><span class="line">	<span class="number">3.</span>在进行插入、删除等操作时，先判断当前桶的数据结构类型，如果是链表，则采用链表的方法进行操作；否则，采用红黑树的方法进行操作。</span><br><span class="line"></span><br><span class="line">	总之，在 JDK8 及以后版本中，HashMap 在树化和迁移数据方面做了一些优化，使得它能够更好地支持大规模并发和高效内存使用。</span><br></pre></td></tr></table></figure>
<h4 id="9hashmap-中的-key若为-object类型-则需实现哪些方法"><a class="markdownIt-Anchor" href="#9hashmap-中的-key若为-object类型-则需实现哪些方法">#</a> 9.HashMap 中的 key 若为 Object 类型， 则需实现哪些方法？</h4>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/12e5dce6bacfa7d4db320d87936b45db.jpeg" alt="HashMap 在 JDK1.7 和 JDK1.8 中有哪些区别？_数组_07"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果 HashMap 中的 key 是 Object 类型，则该对象需要正确地实现 equals() 和 hashCode() 方法。这两个方法用于确定两个对象是否相等，并计算对象的哈希码。</span><br><span class="line"></span><br><span class="line">具体来说，equals() 方法用于比较两个对象是否相等。在 HashMap 中，当两个 key 的哈希值相同时，会调用它们的 equals() 方法进行比较，以确定它们是否真正相等。因此，正确实现 equals() 方法可以防止哈希冲突和键值对重复的问题。</span><br><span class="line">       </span><br><span class="line">hashCode() 方法用于计算对象的哈希码，它将一个对象映射到一个整数值，用于确定该对象在哈希表中的位置。在 HashMap 中，当插入或查找键值对时，会首先计算 key 的哈希码，并根据哈希码查找对应的桶。因此，正确实现 hashCode() 方法可以提高哈希表的性能和效率。</span><br><span class="line"></span><br><span class="line">需要注意的是，如果在 HashMap 中使用自定义的对象作为 key，默认情况下，它们的 equals() 方法和 hashCode() 方法是通过继承 Object 类而来的，这可能导致 key 的比较和哈希码计算不准确。因此，我们通常需要自己重写 equals() 和 hashCode() 方法，以满足我们的具体需求。同时，还需要遵循一些规则，例如：如果两个对象相等，那么它们的哈希码必须相等；反之亦然。</span><br></pre></td></tr></table></figure>
<h4 id="10hashmap中的扰动函数是如何计算的"><a class="markdownIt-Anchor" href="#10hashmap中的扰动函数是如何计算的">#</a> 10.HashMap 中的扰动函数是如何计算的？</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用扰动函数就是为了增加随机性，让数据元素更加均衡的散列，减少碰撞</span></span><br><span class="line"><span class="comment"> * 把哈希值右移16位，也就正好是自己长度的一半，之后与原哈希值做异或运算</span></span><br><span class="line"><span class="comment"> * 这样就混合了原哈希值中的高位和低位，增大了随机性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">hashIndex</span> <span class="operator">=</span> (size - <span class="number">1</span>) &amp; (key.hashCode() ^ (key.hashCode() &gt;&gt;&gt; <span class="number">16</span>));</span><br></pre></td></tr></table></figure>
<h4 id="11为什么hashmap中要使用-1-30-来作为最大限制"><a class="markdownIt-Anchor" href="#11为什么hashmap中要使用-1-30-来作为最大限制">#</a> 11. 为什么 hashMap 中要使用 （1 &lt;&lt; 30） 来作为最大限制</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在 HashMap 中，使用 <span class="number">1</span> &lt;&lt; <span class="number">30</span> 来作为容量的最大限制是因为 Java 中的数组长度不能超过 Integer.MAX_VALUE（即 <span class="number">2</span>^<span class="number">31</span>-<span class="number">1</span>）。而 HashMap 内部的实现需要使用一个数组来保存数据，因此其容量也必须受到这个限制。</span><br><span class="line"></span><br><span class="line">为了保证 HashMap 的最大容量不超过 Integer.MAX_VALUE，同时又要尽可能地提高 HashMap 的容量，Java 开发团队选择了 <span class="number">1</span> &lt;&lt; <span class="number">30</span> 作为 HashMap 的最大容量。这个值是一个 <span class="number">2</span> 的幂次方，可以充分利用位运算的优势，同时又不会超过数组长度的最大限制。</span><br><span class="line"></span><br><span class="line">需要注意的是，HashMap 实际上并不会直接使用 <span class="number">1</span> &lt;&lt; <span class="number">30</span> 作为容量的最大限制。在初始化 HashMap 时，如果传入的初始容量大于等于 <span class="number">1</span> &lt;&lt; <span class="number">30</span>，则会将容量设置为 Integer.MAX_VALUE；如果传入的初始容量小于 <span class="number">1</span> &lt;&lt; <span class="number">30</span>，则会将容量调整为大于等于传入值且最接近 <span class="number">2</span> 的幂次方的数。这样可以确保 HashMap 容量的合理性，同时避免出现数组长度超过 Integer.MAX_VALUE 的情况。</span><br></pre></td></tr></table></figure>
<h4 id="12hashmap如何寻找2的幂次方最小值"><a class="markdownIt-Anchor" href="#12hashmap如何寻找2的幂次方最小值">#</a> 12.HashMap 如何寻找 2 的幂次方最小值？</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK1.8中：把二进制的各个位置都填上1，当二进制的各个位置都是1以后，就是一个标准的2的幂次方减1了，最后把结果加1再返回即可。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//JDK1.8之后：（二分法）通过多次右移和减小位宽的方式来逐步缩小搜索范围，最终得到最高位 0 的个数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> -<span class="number">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class="number">1</span>);</span><br><span class="line">     <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="12为什么重写equals一定要重写hashcode"><a class="markdownIt-Anchor" href="#12为什么重写equals一定要重写hashcode">#</a> 12. 为什么重写 equals 一定要重写 hashcode</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">在 Java 中，每个类都继承了 Object 类，Object 类提供了两个有关哈希值的方法，一个是 equals() 方法，另一个是 hashCode() 方法。其中，equals() 方法用于判断两个对象是否相等，而 hashCode() 方法则返回该对象的哈希码。</span><br><span class="line"></span><br><span class="line">如果在一个类中重写了 equals() 方法，但没有重写 hashCode() 方法，则可能会导致出现以下情况：</span><br><span class="line"></span><br><span class="line">	在使用 HashMap、HashSet 等哈希数据结构时，由于不同的对象可以返回相同的哈希值，因此可能会将这些对象误认为是同一个对象，从而引发程序错误。</span><br><span class="line">	在使用自定义对象作为键来进行 Map 操作时，由于不同的键可以返回相同的哈希值，因此可能无法正确地定位到对应的键值对，从而导致数据丢失或查找失败。</span><br><span class="line">因此，如果要重写 equals() 方法，则必须同时重写 hashCode() 方法，以确保它们的行为一致并满足一些约定：</span><br><span class="line"></span><br><span class="line">	如果两个对象使用 equals() 方法比较返回相等，则它们的 hashCode() 值必须相等。</span><br><span class="line">	如果两个对象的 hashCode() 值相等，则它们不一定相等（即可能存在哈希冲突），因此需要再次使用 equals() 方法进行比较。</span><br><span class="line">通过遵循这些约定，可以保证在使用哈希数据结构或自定义对象作为键值对时不会出现问题。</span><br></pre></td></tr></table></figure>
<h4 id="13为什么在-java-的-hashmap-实现中数组的大小即容量必须始终保持为-2-的幂次方"><a class="markdownIt-Anchor" href="#13为什么在-java-的-hashmap-实现中数组的大小即容量必须始终保持为-2-的幂次方">#</a> 13. 为什么在 Java 的 HashMap 实现中，数组的大小（即容量）必须始终保持为 2 的幂次方？</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashMap的长度必须保证是<span class="number">2</span>的幂次方，是为了避免出现HashMap为空或者HashMap中存储的元素个数不足<span class="number">2</span>的幂次方的情况。</span><br><span class="line"></span><br><span class="line">如果HashMap的长度不是<span class="number">2</span>的幂次方，可能会导致以下问题：</span><br><span class="line"></span><br><span class="line">	如果HashMap的长度为<span class="number">1</span>，那么它的哈希冲突解决方式只能是链地址法（即将冲突的键值对插入到链表中），这种方式不能处理哈希冲突。</span><br><span class="line">	如果HashMap的长度为<span class="number">0</span>，那么它的哈希冲突解决方式只能是开放地址法（即将冲突的键值对直接放在HashMap中），这种方式不能处理哈希冲突。</span><br><span class="line"></span><br><span class="line">因此，为了保证HashMap的正确性和性能，我们需要确保它的长度是<span class="number">2</span>的幂次方，或者为一个固定的最大值。如果需要动态地调整HashMap的长度，可以使用链表法或者开放地址法。</span><br></pre></td></tr></table></figure>
<h4 id="14为什么hashmaploadfactor的选值是34而不是24"><a class="markdownIt-Anchor" href="#14为什么hashmaploadfactor的选值是34而不是24">#</a> 14. 为什么 HashMap.loadFactor 的选值是 3/4，而不是 2/4?</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先，当loadFactor的值比较小的时候，虽然能够减少空间的浪费，但是会导致哈希表更加频繁地进行扩容操作，这会影响到HashMap的性能。</span><br><span class="line">其次，当loadFactor的值比较大的时候，虽然能够减少扩容操作的次数，但是会导致哈希链表长度过长，查找效率会变得较低。</span><br><span class="line">因此，为了平衡空间利用率和时间效率，选择一个适当的loadFactor值非常重要。经过实验和分析，发现loadFactor取<span class="number">0.75</span>时，可以在保证哈希表查找效率的同时，稍微减少空间的浪费。另外，这个值也是比较常见的一个取值，很多编程语言中也采用了类似的值。</span><br></pre></td></tr></table></figure>
<h4 id="15hashmap什么时候会触发扩容机制如何扩容"><a class="markdownIt-Anchor" href="#15hashmap什么时候会触发扩容机制如何扩容">#</a> 15.HashMap 什么时候会触发扩容机制？如何扩容？</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">HashMap在存储键值对时，会将键通过哈希函数映射到桶里面，每个桶是一个链表或红黑树。当HashMap中的元素数量增加到超过了负载因子（默认为0.75），就会触发扩容机制。</span><br><span class="line"></span><br><span class="line">具体地说，在添加元素时，如果当前的元素数量达到了阈值（即容量乘以负载因子），就会启动扩容机制。这个阈值通过如下公式计算：</span><br><span class="line"></span><br><span class="line">threshold = capacity * loadFactor</span><br><span class="line"></span><br><span class="line">其中capacity是当前HashMap的容量，loadFactor是负载因子，默认值为0.75。当HashMap中元素个数达到了threshold值时，就会触发扩容机制。</span><br><span class="line"></span><br><span class="line">扩容操作包括以下几个步骤：</span><br><span class="line"></span><br><span class="line">	1.创建一个新的Entry数组，长度为原数组的两倍。</span><br><span class="line">	2.将原来数组中所有的元素重新分配到新的数组中，这一步需要重新计算每个元素的hash值，并且根据新的数组长度求出它们在新数组中的位置。</span><br><span class="line">	3.在重新分配元素的过程中，如果某个位置上有多个元素，则会形成一个链表或红黑树，这取决于链表长度是否大于等于8，并且桶容量大于64。如果链表长度大于等于8并且桶容量大于64的话，则会将其转换为红黑树，否则仍然使用链表。这一步是为了提高查询效率，因为红黑树的查询时间复杂度是O(log n)，而链表的查询时间复杂度是O(n)。</span><br><span class="line">	4.更新HashMap的容量和阈值。</span><br><span class="line">	</span><br><span class="line">扩容操作会比较耗时，因为需要重新计算hash值、重新分配元素等，所以应该尽可能避免频繁触发扩容。可以通过调整负载因子的大小来控制HashMap的性能和空间占用</span><br></pre></td></tr></table></figure>
<h2 id="关于我"><a class="markdownIt-Anchor" href="#关于我">#</a> 关于我</h2>
<p>Brath 是一个热爱技术的 Java 程序猿，公众号「InterviewCoder」定期分享有趣有料的精品原创文章！</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png" alt="InterviewCoder"></p>
<p>非常感谢各位人才能看到这里，原创不易，文章如果有帮助可以关注、点赞、分享或评论，这都是对我的莫大支持！</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>【Java】HashMap核心原理解读</p><p><a href="http://example.com/2023/05/08/【Java】HashMap核心原理解读/">http://example.com/2023/05/08/【Java】HashMap核心原理解读/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Brath</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-05-08</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-05-09</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="sharethis-inline-share-buttons"></div><script src="https://brath.cn" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="https://brath.cloud/zfb.jpg" alt="支付宝"></span></a><a class="button donate" href="https://brath.cloud/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E5%AE%9D%E4%BA%8C%E5%90%88%E4%B8%80.png" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a><a class="button donate" href="https://brath.cloud/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E5%AE%9D%E4%BA%8C%E5%90%88%E4%B8%80.png" target="_blank" rel="noopener" data-type="patreon"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="https://brath.cloud/wx.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2023/05/08/%E3%80%90Java%E3%80%91%E5%A4%9A%E7%A7%8D%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">【Java】多种代理的实现方式</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2023/05/06/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0Map/"><span class="level-item">【数据结构】手写实现Hash表，并解决哈希冲突</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="SOHUCS" sid="2023/05/08/【Java】HashMap核心原理解读/"></div><script charset="utf-8" src="https://changyan.sohu.com/upload/changyan.js"></script><script>window.changyan.api.config({appid: 'cywzQRCbe',conf: '485cd826ef6d780dcea71d0f3b37304a'});</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-05-08T14:20:55.000Z">2023-05-08</time></p><p class="title"><a href="/2023/05/08/%E3%80%90Java%E3%80%91volatile%E5%85%B3%E9%94%AE%E5%AD%97/">【Java】volatile关键字</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-05-08T14:14:55.000Z">2023-05-08</time></p><p class="title"><a href="/2023/05/08/%E3%80%90Java%E3%80%91%E5%A4%9A%E7%A7%8D%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/">【Java】多种代理的实现方式</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-05-08T14:04:55.000Z">2023-05-08</time></p><p class="title"><a href="/2023/05/08/%E3%80%90Java%E3%80%91HashMap%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E8%AF%BB/">【Java】HashMap核心原理解读</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-05-06T09:23:40.000Z">2023-05-06</time></p><p class="title"><a href="/2023/05/06/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0Map/">【数据结构】手写实现Hash表，并解决哈希冲突</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-05-06T07:53:40.000Z">2023-05-06</time></p><p class="title"><a href="/2023/05/06/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0ArrayList/">【数据结构】手写实现ArrayList</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">40</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/"><span class="level-start"><span class="level-item">2022</span></span><span class="level-end"><span class="level-item tag">50</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/"><span class="level-start"><span class="level-item">2021</span></span><span class="level-end"><span class="level-item tag">44</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/"><span class="level-start"><span class="level-item">2020</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png" alt="InterviewCoder"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">InterviewCoder</p><p class="is-size-6 is-block">面试记官方公众号</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">141</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://mp.weixin.qq.com/s/jWs6lLHl5L-atXJhHc4YvA" target="_blank" rel="noopener">关注我</a></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://brath.cloud/me.png" alt="Brath"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Brath</p><p class="is-size-6 is-block">技能改变人生，知识改变命运。</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·江苏·无锡</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">141</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Guoqing815" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Guoqing815"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Gitee" href="https://gitee.com/Guoqing-Li"><i class="fab fa-gitee"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://schokolade.cn/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">泠灵(特别呜谢)</span></span><span class="level-right"><span class="level-item tag">schokolade.cn</span></span></a></li><li><a class="level is-mobile" href="https://gitee.com/Guoqing-Li" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Gitee(码云)</span></span><span class="level-right"><span class="level-item tag">gitee.com</span></span></a></li><li><a class="level is-mobile" href="https://blog.csdn.net/Brath?type=blog" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">CSDN</span></span><span class="level-right"><span class="level-item tag">blog.csdn.net</span></span></a></li><li><a class="level is-mobile" href="https://juejin.cn/user/settings/profile" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">掘金</span></span><span class="level-right"><span class="level-item tag">juejin.cn</span></span></a></li><li><a class="level is-mobile" href="https://oss.console.aliyun.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">AliCloud(阿里云)</span></span><span class="level-right"><span class="level-item tag">oss.console.aliyun.com</span></span></a></li><li><a class="level is-mobile" href="https://cloud.tencent.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">TencentCloud(腾讯云)</span></span><span class="level-right"><span class="level-item tag">cloud.tencent.com</span></span></a></li><li><a class="level is-mobile" href="https://www.zhipin.com/web/user/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">BOSS</span></span><span class="level-right"><span class="level-item tag">www.zhipin.com</span></span></a></li><li><a class="level is-mobile" href="https://www.bilibili.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bilibili(B站)</span></span><span class="level-right"><span class="level-item tag">www.bilibili.com</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://brath.cloud/avatar.png" alt="Brath-Blog" height="28"></a><p class="is-size-7"><span>&copy; 2023 Brath</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p><p class="is-size-7">© 2029</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>