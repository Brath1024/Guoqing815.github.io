<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>【设计模式】23 种设计模式详解（全23种） - Brath-Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Brath-Blog"><meta name="msapplication-TileImage" content="https://brath.cloud/me.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Brath-Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="# 【设计模式】23 种设计模式详解（全 23 种） # 设计模式的分类 总体来说设计模式分为三大类： 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访"><meta property="og:type" content="blog"><meta property="og:title" content="【设计模式】23 种设计模式详解（全23种）"><meta property="og:url" content="http://example.com/2023/04/29/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%9123%20%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%88%E5%85%A823%E7%A7%8D%EF%BC%89/"><meta property="og:site_name" content="Brath-Blog"><meta property="og:description" content="# 【设计模式】23 种设计模式详解（全 23 种） # 设计模式的分类 总体来说设计模式分为三大类： 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609001610870.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609001610872.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609001610898.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609001610907.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609030328860.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609172340456.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609172340477.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609184856243.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609210401275.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609210401318.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609210401289.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609223457210.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609222716270.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/2019061001123986.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/2019061001123984.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610154828945.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610154828952.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610180930798.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610180930823.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610180930831.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610180930861.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610180930821.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612191511416.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/201906121917147.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610202655697.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610202655744.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610203118380.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610215352532.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610215352527.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610215352523.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612192139396.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612192139362.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190611172644555.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190611172644540.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190611195714196.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190611195714224.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/2019061120335378.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190611203353118.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612194014850.gif"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612194307560.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612003537747.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612003537942.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612143829622.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612143829817.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612154308216.gif"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612175348613.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612175348612.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png"><meta property="article:published_time" content="2023-04-29T11:42:37.000Z"><meta property="article:modified_time" content="2023-04-29T11:44:45.229Z"><meta property="article:author" content="Brath"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2023/04/29/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%9123%20%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%88%E5%85%A823%E7%A7%8D%EF%BC%89/"},"headline":"【设计模式】23 种设计模式详解（全23种）","image":["https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609001610870.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609001610872.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609001610898.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609001610907.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609030328860.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609172340456.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609172340477.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609184856243.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609210401275.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609210401318.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609210401289.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609223457210.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609222716270.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/2019061001123986.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/2019061001123984.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610154828945.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610154828952.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610180930798.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610180930823.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610180930831.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610180930861.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610180930821.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612191511416.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/201906121917147.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610202655697.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610202655744.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610203118380.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610215352532.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610215352527.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610215352523.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612192139396.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612192139362.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190611172644555.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190611172644540.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190611195714196.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190611195714224.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/2019061120335378.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190611203353118.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612194014850.gif","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612194307560.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612003537747.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612003537942.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612143829622.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612143829817.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612154308216.gif","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612175348613.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612175348612.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png"],"datePublished":"2023-04-29T11:42:37.000Z","dateModified":"2023-04-29T11:44:45.229Z","author":{"@type":"Person","name":"Brath"},"publisher":{"@type":"Organization","name":"Brath-Blog","logo":{"@type":"ImageObject","url":"https://brath.cloud/me.png"}},"description":"# 【设计模式】23 种设计模式详解（全 23 种） # 设计模式的分类 总体来说设计模式分为三大类： 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访"}</script><link rel="canonical" href="http://example.com/2023/04/29/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%9123%20%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%88%E5%85%A823%E7%A7%8D%EF%BC%89/"><link rel="icon" href="https://brath.cloud/me.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://brath.cloud/me.png" alt="Brath-Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">文章列表</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">更多</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Guoqing815"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-04-29T11:42:37.000Z" title="2023/4/29 19:42:37">2023-04-29</time>发表</span><span class="level-item"><time dateTime="2023-04-29T11:44:45.229Z" title="2023/4/29 19:44:45">2023-04-29</time>更新</span><span class="level-item">2 小时读完 (大约20643个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">【设计模式】23 种设计模式详解（全23种）</h1><div class="content"><p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png" alt="InterviewCoder"></p>
<h1 id="设计模式23-种设计模式详解全23种"><a class="markdownIt-Anchor" href="#设计模式23-种设计模式详解全23种">#</a> 【设计模式】23 种设计模式详解（全 23 种）</h1>
<h1 id="设计模式的分类"><a class="markdownIt-Anchor" href="#设计模式的分类">#</a> 设计模式的分类</h1>
<p>总体来说设计模式分为三大类：</p>
<p>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p>
<p>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p>
<p>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>
<h2 id=""><a class="markdownIt-Anchor" href="#">#</a> </h2>
<h1 id="a-创建模式5种"><a class="markdownIt-Anchor" href="#a-创建模式5种">#</a> A、创建模式（5 种）</h1>
<p><strong>工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</strong></p>
<h2 id="1-工厂模式"><a class="markdownIt-Anchor" href="#1-工厂模式">#</a> 1 工厂模式</h2>
<h3 id="11-简单工厂模式"><a class="markdownIt-Anchor" href="#11-简单工厂模式">#</a> 1.1 简单工厂模式</h3>
<p>** 定义：** 定义了一个创建对象的类，由这个类来封装实例化对象的行为。</p>
<p><strong>举例：</strong>（我们举一个 pizza 工厂的例子）</p>
<p>pizza 工厂一共生产三种类型的 pizza：chesse,pepper,greak。通过工厂类（SimplePizzaFactory）实例化这三种类型的对象。类图如下：</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609001610870.png" class="has" width="503" height="276" />
<p>工厂类的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimplePizzaFactory</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> Pizza <span class="title function_">CreatePizza</span><span class="params">(String ordertype)</span> &#123;</span><br><span class="line">              <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">              <span class="keyword">if</span> (ordertype.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">                     pizza = <span class="keyword">new</span> <span class="title class_">CheesePizza</span>();</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ordertype.equals(<span class="string">&quot;greek&quot;</span>)) &#123;</span><br><span class="line">                     pizza = <span class="keyword">new</span> <span class="title class_">GreekPizza</span>();</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ordertype.equals(<span class="string">&quot;pepper&quot;</span>)) &#123;</span><br><span class="line">                     pizza = <span class="keyword">new</span> <span class="title class_">PepperPizza</span>();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> pizza;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>简单工厂存在的问题与解决方法：</strong> 简单工厂模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了开闭原则，所以，从设计角度考虑，有一定的问题，如何解决？我们可以定义一个创建对象的抽象方法并创建多个不同的工厂类实现该抽象方法，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。这种方法也就是我们接下来要说的工厂方法模式。</p>
<h3 id="12-工厂方法模式"><a class="markdownIt-Anchor" href="#12-工厂方法模式">#</a> 1.2 工厂方法模式</h3>
<p>** 定义：** 定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。</p>
<p><strong>举例：</strong>（我们依然举 pizza 工厂的例子，不过这个例子中，pizza 产地有两个：伦敦和纽约）。添加了一个新的产地，如果用简单工厂模式的的话，我们要去修改工厂代码，并且会增加一堆的 if else 语句。而工厂方法模式克服了简单工厂要修改代码的缺点，它会直接创建两个工厂，纽约工厂和伦敦工厂。类图如下：</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609001610872.png" class="has" width="279" height="144" />
<p>OrderPizza 中有个抽象的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abstract Pizza createPizza();</span><br></pre></td></tr></table></figure>
<p>两个工厂类继承 OrderPizza 并实现抽象方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class LDOrderPizza extends OrderPizza &#123;</span><br><span class="line">       Pizza createPizza(String ordertype) &#123;</span><br><span class="line">              Pizza pizza = null;</span><br><span class="line">              if (ordertype.equals(&quot;cheese&quot;)) &#123;</span><br><span class="line">                     pizza = new LDCheesePizza();</span><br><span class="line">              &#125; else if (ordertype.equals(&quot;pepper&quot;)) &#123;</span><br><span class="line">                     pizza = new LDPepperPizza();</span><br><span class="line">              &#125;</span><br><span class="line">              return pizza;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class NYOrderPizza extends OrderPizza &#123;</span><br><span class="line"></span><br><span class="line">    Pizza createPizza(String ordertype) &#123;</span><br><span class="line">        Pizza pizza = null;</span><br><span class="line"></span><br><span class="line">        if (ordertype.equals(&quot;cheese&quot;)) &#123;</span><br><span class="line">            pizza = new NYCheesePizza();</span><br><span class="line">        &#125; else if (ordertype.equals(&quot;pepper&quot;)) &#123;</span><br><span class="line">            pizza = new NYPepperPizza();</span><br><span class="line">        &#125;</span><br><span class="line">        return pizza;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>、通过不同的工厂会得到不同的实例化的对象，PizzaStroe 的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class PizzaStroe &#123;</span><br><span class="line">       public static void main(String[] args) &#123;</span><br><span class="line">              OrderPizza mOrderPizza;</span><br><span class="line">              mOrderPizza = new NYOrderPizza();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>** 解决了简单工厂模式的问题：** 增加一个新的 pizza 产地（北京），只要增加一个 BJOrderPizza 类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class BJOrderPizza extends OrderPizza &#123;</span><br><span class="line">       Pizza createPizza(String ordertype) &#123;</span><br><span class="line">              Pizza pizza = null;</span><br><span class="line">              if (ordertype.equals(&quot;cheese&quot;)) &#123;</span><br><span class="line">                     pizza = new LDCheesePizza();</span><br><span class="line">              &#125; else if (ordertype.equals(&quot;pepper&quot;)) &#123;</span><br><span class="line">                     pizza = new LDPepperPizza();</span><br><span class="line">              &#125;</span><br><span class="line">              return pizza;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这个模式的好处就是，如果你现在想增加一个功能，只需做一个实现类就 OK 了，无需去改动现成的代码。这样做，拓展性较好！</p>
<p>** 工厂方法存在的问题与解决方法：** 客户端需要创建类的具体的实例。简单来说就是用户要订纽约工厂的披萨，他必须去纽约工厂，想订伦敦工厂的披萨，必须去伦敦工厂。 当伦敦工厂和纽约工厂发生变化了，用户也要跟着变化，这无疑就增加了用户的操作复杂性。为了解决这一问题，我们可以把工厂类抽象为接口，用户只需要去找默认的工厂提出自己的需求（传入参数），便能得到自己想要产品，而不用根据产品去寻找不同的工厂，方便用户操作。这也就是我们接下来要说的抽象工厂模式。</p>
<h3 id="13-抽象工厂模式"><a class="markdownIt-Anchor" href="#13-抽象工厂模式">#</a> 1.3 抽象工厂模式</h3>
<p>** 定义：** 定义了一个接口用于创建相关或有依赖关系的对象族，而无需明确指定具体类。</p>
<p><strong>举例：</strong>（我们依然举 pizza 工厂的例子，pizza 工厂有两个：纽约工厂和伦敦工厂）。类图如下：</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609001610898.png" class="has" width="433" height="208" />
<p>工厂的接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface AbsFactory &#123;</span><br><span class="line">       Pizza CreatePizza(String ordertype) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>工厂的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class LDFactory implements AbsFactory &#123;</span><br><span class="line">       @Override</span><br><span class="line">       public Pizza CreatePizza(String ordertype) &#123;</span><br><span class="line">              Pizza pizza = null;</span><br><span class="line">              if (&quot;cheese&quot;.equals(ordertype)) &#123;</span><br><span class="line">                     pizza = new LDCheesePizza();</span><br><span class="line">              &#125; else if (&quot;pepper&quot;.equals(ordertype)) &#123;</span><br><span class="line">                     pizza = new LDPepperPizza();</span><br><span class="line">              &#125;</span><br><span class="line">              return pizza;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PizzaStroe 的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class PizzaStroe &#123;</span><br><span class="line">       public static void main(String[] args) &#123;</span><br><span class="line">              OrderPizza mOrderPizza;</span><br><span class="line">              mOrderPizza = new OrderPizza(&quot;London&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>** 解决了工厂方法模式的问题：** 在抽象工厂中 PizzaStroe 中只需要传入参数就可以实例化对象。</p>
<h3 id="14-工厂模式适用的场合"><a class="markdownIt-Anchor" href="#14-工厂模式适用的场合">#</a> 1.4 工厂模式适用的场合</h3>
<p>大量的产品需要创建，并且这些产品具有共同的接口 。</p>
<h3 id="15-三种工厂模式的使用选择"><a class="markdownIt-Anchor" href="#15-三种工厂模式的使用选择">#</a> 1.5  三种工厂模式的使用选择</h3>
<p>简单工厂 ： 用来生产同一等级结构中的任意产品。（不支持拓展增加产品）</p>
<p>工厂方法 ：用来生产同一等级结构中的固定产品。（支持拓展增加产品）</p>
<p>抽象工厂 ：用来生产不同产品族的全部产品。（支持拓展增加产品；支持增加产品族）</p>
<p>** 简单工厂的适用场合：** 只有伦敦工厂（只有这一个等级），并且这个工厂只生产三种类型的 pizza：chesse,pepper,greak（固定产品）。</p>
<p><strong>工厂方法的适用场合</strong>：现在不光有伦敦工厂，还增设了纽约工厂（仍然是同一等级结构，但是支持了产品的拓展），这两个工厂依然只生产三种类型的 pizza：chesse,pepper,greak（固定产品）。</p>
<p>** 抽象工厂的适用场合：** 不光增设了纽约工厂（仍然是同一等级结构，但是支持了产品的拓展），这两个工厂还增加了一种新的类型的 pizza：chinese pizza（增加产品族）。</p>
<p>** 所以说抽象工厂就像工厂，而工厂方法则像是工厂的一种产品生产线。<strong>因此，我们可以用抽象工厂模式创建工厂，而用工厂方法模式创建生产线。比如，我们可以使用抽象工厂模式创建伦敦工厂和纽约工厂，使用工厂方法实现 cheese pizza 和 greak pizza 的生产。类图如下：</strong>     **</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609001610907.png" class="has" width="697" height="258" />
<p>总结一下三种模式：</p>
<p><strong>简单工厂模式就是建立一个实例化对象的类，在该类中对多个对象实例化。工厂方法模式是定义了一个创建对象的抽象方法，由子类决定要实例化的类。这样做的好处是再有新的类型的对象需要实例化只要增加子类即可。抽象工厂模式定义了一个接口用于创建对象族，而无需明确指定具体类。抽象工厂也是把对象的实例化交给了子类，即支持拓展。同时提供给客户端接口，避免了用户直接操作子类工厂。</strong></p>
<h3 id="-2"><a class="markdownIt-Anchor" href="#-2">#</a> </h3>
<h2 id="2-单例模式"><a class="markdownIt-Anchor" href="#2-单例模式">#</a> 2 单例模式</h2>
<p>** 定义：** 确保一个类最多只有一个实例，并提供一个全局访问点</p>
<p>单例模式可以分为两种：预加载和懒加载</p>
<h3 id="21-预加载"><a class="markdownIt-Anchor" href="#21-预加载">#</a> 2.1 预加载</h3>
<p>顾名思义，就是预先加载。再进一步解释就是还没有使用该单例对象，但是，该单例对象就已经被加载到内存了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class PreloadSingleton &#123;</span><br><span class="line">       </span><br><span class="line">       public static PreloadSingleton instance = new PreloadSingleton();</span><br><span class="line">   </span><br><span class="line">       //其他的类无法实例化单例类的对象</span><br><span class="line">       private PreloadSingleton() &#123;</span><br><span class="line">       &#125;;</span><br><span class="line">       </span><br><span class="line">       public static PreloadSingleton getInstance() &#123;</span><br><span class="line">              return instance;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>很明显，没有使用该单例对象，该对象就被加载到了内存，会造成内存的浪费。</strong></p>
<h3 id="22-懒加载"><a class="markdownIt-Anchor" href="#22-懒加载">#</a> 2.2 懒加载</h3>
<p>为了避免内存的浪费，我们可以采用懒加载，即用到该单例对象的时候再创建。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">       </span><br><span class="line">       private static Singleton instance=null;</span><br><span class="line">       </span><br><span class="line">       private Singleton()&#123;</span><br><span class="line">       &#125;;</span><br><span class="line">       </span><br><span class="line">       public static Singleton getInstance()</span><br><span class="line">       &#123;</span><br><span class="line">              if(instance==null)</span><br><span class="line">              &#123;</span><br><span class="line">                     instance=new Singleton();</span><br><span class="line">              &#125;</span><br><span class="line">              return instance;</span><br><span class="line">              </span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="23-单例模式和线程安全"><a class="markdownIt-Anchor" href="#23-单例模式和线程安全">#</a> 2.3 单例模式和线程安全</h3>
<p>（1）预加载只有一条语句 return instance, 这显然可以保证线程安全。但是，我们知道预加载会造成内存的浪费。</p>
<p>（2）懒加载不浪费内存，但是无法保证线程的安全。首先，if 判断以及其内存执行代码是非原子性的。其次，new Singleton () 无法保证执行的顺序性。</p>
<p>不满足原子性或者顺序性，线程肯定是不安全的，这是基本的常识，不再赘述。我主要讲一下为什么 new Singleton () 无法保证顺序性。我们知道创建一个对象分三步:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">memory=allocate();//1:初始化内存空间</span><br><span class="line"></span><br><span class="line">ctorInstance(memory);//2:初始化对象</span><br><span class="line"></span><br><span class="line">instance=memory();//3:设置instance指向刚分配的内存地址</span><br></pre></td></tr></table></figure>
<p>**jvm 为了提高程序执行性能，会对没有依赖关系的代码进行重排序，上面 2 和 3 行代码可能被重新排序。** 我们用两个线程来说明线程是不安全的。线程 A 和线程 B 都创建对象。其中，A2 和 A3 的重排序，将导致线程 B 在 B1 处判断出 instance 不为空，线程 B 接下来将访问 instance 引用的对象。此时，线程 B 将会访问到一个还未初始化的对象（线程不安全）。</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609030328860.png" class="has" width="674" height="386" />
<h3 id="24-保证懒加载的线程安全"><a class="markdownIt-Anchor" href="#24-保证懒加载的线程安全">#</a> 2.4 保证懒加载的线程安全</h3>
<p><span style="color:#000000;">我们首先想到的就是使用</span><span style="color:#f33b45;">synchronized</span><span style="color:#000000;">关键字。</span><span style="color:#f33b45;">synchronized</span>加载 getInstace () 函数上确实保证了线程的安全。但是，如果要经常的调用<span style="color:#000000;"><span style="color:#7f0055;"><span style="color:#7f0055;"><span style="color:#333333;">getInstance () 方法，不管有没有初始化实例，都会唤醒和阻塞线程。为了避免线程的上下文切换消耗大量时间，如果对象已经实例化了，我们没有必要再使用</span></span></span></span><span style="color:#f33b45;">synchronized</span><span style="color:#000000;"><span style="color:#7f0055;"><span style="color:#7f0055;"><span style="color:#333333;">加锁，直接返回对象。</span></span></span></span></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">       private static Singleton instance = null;</span><br><span class="line">       private Singleton() &#123;</span><br><span class="line">       &#125;;</span><br><span class="line">       public static synchronized Singleton getInstance() &#123;</span><br><span class="line">              if (instance == null) &#123;</span><br><span class="line">                     instance = new Singleton();</span><br><span class="line">              &#125;</span><br><span class="line">              return instance;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们把<span style="color:#f33b45;">sychronized</span>加在 if (instance==null) 判断语句里面，<strong>保证 instance 未实例化的时候才加锁</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">       private static Singleton instance = null;</span><br><span class="line">       private Singleton() &#123;</span><br><span class="line">       &#125;;</span><br><span class="line">       public static synchronized Singleton getInstance() &#123;</span><br><span class="line">              if (instance == null) &#123;</span><br><span class="line">                     synchronized (Singleton.class) &#123;</span><br><span class="line">                           if (instance == null) &#123;</span><br><span class="line">                                  instance = new Singleton();</span><br><span class="line">                           &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              return instance;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们经过 2.3 的讨论知道 new 一个对象的代码是无法保证顺序性的，因此，我们需要使用另一个关键字<span style="color:#f33b45;">volatile</span>保证对象实例化过程的顺序性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">       private static volatile Singleton instance = null;</span><br><span class="line">       private Singleton() &#123;</span><br><span class="line">       &#125;;</span><br><span class="line">       public static synchronized Singleton getInstance() &#123;</span><br><span class="line">              if (instance == null) &#123;</span><br><span class="line">                     synchronized (instance) &#123;</span><br><span class="line">                           if (instance == null) &#123;</span><br><span class="line">                                  instance = new Singleton();</span><br><span class="line">                           &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              return instance;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>到此，我们就保证了懒加载的线程安全。</strong></p>
<h2 id="3-生成器模式"><a class="markdownIt-Anchor" href="#3-生成器模式">#</a> 3 生成器模式</h2>
<p>** 定义：** 封装一个复杂对象构造过程，并允许按步骤构造。</p>
<p><strong>定义解释：</strong> 我们可以将生成器模式理解为，假设我们有一个对象需要建立，这个对象是由多个组件（Component）组合而成，每个组件的建立都比较复杂，但运用组件来建立所需的对象非常简单，所以我们就可以将构建复杂组件的步骤与运用组件构建对象分离，使用 builder 模式可以建立。</p>
<h3 id="31-模式的结构和代码示例"><a class="markdownIt-Anchor" href="#31-模式的结构和代码示例">#</a> 3.1 模式的结构和代码示例</h3>
<p>生成器模式结构中包括四种角色：</p>
<p>（1）产品 (Product)：具体生产器要构造的复杂对象；</p>
<p>（2）抽象生成器 (Bulider)：抽象生成器是一个接口，该接口除了为创建一个 Product 对象的各个组件定义了若干个方法之外，还要定义返回 Product 对象的方法（<strong>定义构造步骤</strong>）；</p>
<p>（3）具体生产器 (ConcreteBuilder)：实现 Builder 接口的类，具体生成器将实现 Builder 接口所定义的方法（<strong>生产各个组件</strong>）；</p>
<p>（4）指挥者 (Director)：指挥者是一个类，该类需要含有 Builder 接口声明的变量。指挥者的职责是负责向用户提供具体生成器，即指挥者将请求具体生成器类来构造用户所需要的 Product 对象，如果所请求的具体生成器成功地构造出 Product 对象，指挥者就可以让该具体生产器返回所构造的 Product 对象。（<strong>按照步骤组装部件，并返回 Product</strong>）</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609172340456.png" class="has" width="680" height="225" />
<p><strong>举例</strong>（我们如果构建生成一台电脑，那么我们可能需要这么几个步骤（1）需要一个主机（2）需要一个显示器（3）需要一个键盘（4）需要一个鼠标）</p>
<p>虽然我们具体在构建一台主机的时候，每个对象的实际步骤是不一样的，比如，有的对象构建了 i7cpu 的主机，有的对象构建了 i5cpu 的主机，有的对象构建了普通键盘，有的对象构建了机械键盘等。但不管怎样，你总是需要经过一个步骤就是构建一台主机，一台键盘。对于这个例子，我们就可以使用生成器模式来生成一台电脑，他需要通过多个步骤来生成。类图如下：</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609172340477.png" class="has" width="470" height="437" />
<p>ComputerBuilder 类定义构造步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ComputerBuilder &#123;</span><br><span class="line">   </span><br><span class="line">    protected Computer computer;</span><br><span class="line">   </span><br><span class="line">    public Computer getComputer() &#123;</span><br><span class="line">        return computer;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public void buildComputer() &#123;</span><br><span class="line">        computer = new Computer();</span><br><span class="line">        System.out.println(&quot;生成了一台电脑！！！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public abstract void buildMaster();</span><br><span class="line">    public abstract void buildScreen();</span><br><span class="line">    public abstract void buildKeyboard();</span><br><span class="line">    public abstract void buildMouse();</span><br><span class="line">    public abstract void buildAudio();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HPComputerBuilder 定义各个组件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class HPComputerBuilder extends ComputerBuilder &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void buildMaster() &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        computer.setMaster(&quot;i7,16g,512SSD,1060&quot;);</span><br><span class="line">        System.out.println(&quot;(i7,16g,512SSD,1060)的惠普主机&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void buildScreen() &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        computer.setScreen(&quot;1080p&quot;);</span><br><span class="line">        System.out.println(&quot;(1080p)的惠普显示屏&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void buildKeyboard() &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        computer.setKeyboard(&quot;cherry 青轴机械键盘&quot;);</span><br><span class="line">        System.out.println(&quot;(cherry 青轴机械键盘)的键盘&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void buildMouse() &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        computer.setMouse(&quot;MI 鼠标&quot;);</span><br><span class="line">        System.out.println(&quot;(MI 鼠标)的鼠标&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void buildAudio() &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        computer.setAudio(&quot;飞利浦 音响&quot;);</span><br><span class="line">        System.out.println(&quot;(飞利浦 音响)的音响&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Director 类对组件进行组装并生成产品</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Director &#123;</span><br><span class="line">   </span><br><span class="line">    private ComputerBuilder computerBuilder;</span><br><span class="line">    public void setComputerBuilder(ComputerBuilder computerBuilder) &#123;</span><br><span class="line">        this.computerBuilder = computerBuilder;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public Computer getComputer() &#123;</span><br><span class="line">        return computerBuilder.getComputer();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public void constructComputer() &#123;</span><br><span class="line">        computerBuilder.buildComputer();</span><br><span class="line">        computerBuilder.buildMaster();</span><br><span class="line">        computerBuilder.buildScreen();</span><br><span class="line">        computerBuilder.buildKeyboard();</span><br><span class="line">        computerBuilder.buildMouse();</span><br><span class="line">        computerBuilder.buildAudio();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="32-生成器模式的优缺点"><a class="markdownIt-Anchor" href="#32-生成器模式的优缺点">#</a> 3.2 生成器模式的优缺点</h3>
<h3 id="优点"><a class="markdownIt-Anchor" href="#优点">#</a> 优点</h3>
<ul>
<li>
<p>将一个对象分解为各个组件</p>
</li>
<li>
<p>将对象组件的构造封装起来</p>
</li>
<li>
<p>可以控制整个对象的生成过程</p>
</li>
</ul>
<h3 id="缺点"><a class="markdownIt-Anchor" href="#缺点">#</a> 缺点</h3>
<ul>
<li>对不同类型的对象需要实现不同的具体构造器的类，这可能回答大大增加类的数量</li>
</ul>
<h3 id="33-生成器模式与工厂模式的不同"><a class="markdownIt-Anchor" href="#33-生成器模式与工厂模式的不同">#</a> 3.3 生成器模式与工厂模式的不同</h3>
<p>生成器模式构建对象的时候，对象通常构建的过程中需要多个步骤，就像我们例子中的先有主机，再有显示屏，再有鼠标等等，生成器模式的作用就是将这些复杂的构建过程封装起来。工厂模式构建对象的时候通常就只有一个步骤，调用一个工厂方法就可以生成一个对象。</p>
<h2 id="4-原型模式"><a class="markdownIt-Anchor" href="#4-原型模式">#</a> 4 原型模式</h2>
<p>** 定义：** 通过复制现有实例来创建新的实例，无需知道相应类的信息。</p>
<p>简单地理解，其实就是当需要创建一个指定的对象时，我们刚好有一个这样的对象，但是又不能直接使用，我会 clone 一个一毛一样的新对象来使用；基本上这就是原型模式。关键字：<strong>Clone</strong>。</p>
<h3 id="41-深拷贝和浅拷贝"><a class="markdownIt-Anchor" href="#41-深拷贝和浅拷贝">#</a> 4.1 深拷贝和浅拷贝</h3>
<p>浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。</p>
<p>深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。clone 明显是深复制，clone 出来的对象是是不能去影响原型对象的</p>
<h3 id="42-原型模式的结构和代码示例"><a class="markdownIt-Anchor" href="#42-原型模式的结构和代码示例">#</a> 4.2 原型模式的结构和代码示例</h3>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609184856243.png" class="has" width="367" height="237" />
<p>Client：使用者</p>
<p>Prototype：接口（抽象类），声明具备 clone 能力，例如 java 中得 Cloneable 接口</p>
<p>ConcretePrototype：具体的原型类</p>
<p>可以看出设计模式还是比较简单的，重点在于 Prototype 接口和 Prototype 接口的实现类 ConcretePrototype。原型模式的具体实现：一个原型类，只需要实现 Cloneable 接口，覆写 clone 方法，此处 clone 方法可以改成任意的名称，因为 Cloneable 接口是个空接口，你可以任意定义实现类的方法名，如 cloneA 或者 cloneB，因为此处的重点是 super.clone () 这句话，super.clone () 调用的是 Object 的 clone () 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Prototype implements Cloneable &#123;  </span><br><span class="line">     public Object clone() throws CloneNotSupportedException &#123;  </span><br><span class="line">         Prototype proto = (Prototype) super.clone();  </span><br><span class="line">         return proto;  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>** 举例（<strong>银行发送大量邮件，使用 clone 和不使用 clone 的时间对比</strong>）：** 我们模拟创建一个对象需要耗费比较长的时间，因此，在构造函数中我们让当前线程 sleep 一会</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public Mail(EventTemplate et) &#123;</span><br><span class="line">              this.tail = et.geteventContent();</span><br><span class="line">              this.subject = et.geteventSubject();</span><br><span class="line">              try &#123;</span><br><span class="line">                     Thread.sleep(1000);</span><br><span class="line">              &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                     // TODO Auto-generated catch block</span><br><span class="line">                     e.printStackTrace();</span><br><span class="line">              &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>不使用 clone, 发送十个邮件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">              int i = 0;</span><br><span class="line">              int MAX_COUNT = 10;</span><br><span class="line">              EventTemplate et = new EventTemplate(&quot;9月份信用卡账单&quot;, &quot;国庆抽奖活动...&quot;);</span><br><span class="line">              long start = System.currentTimeMillis();</span><br><span class="line">              while (i &lt; MAX_COUNT) &#123;</span><br><span class="line">                     // 以下是每封邮件不同的地方</span><br><span class="line">                     Mail mail = new Mail(et);</span><br><span class="line">                     mail.setContent(getRandString(5) + &quot;,先生（女士）:你的信用卡账单...&quot; + mail.getTail());</span><br><span class="line">                     mail.setReceiver(getRandString(5) + &quot;@&quot; + getRandString(8) + &quot;.com&quot;);</span><br><span class="line">                     // 然后发送邮件</span><br><span class="line">                     sendMail(mail);</span><br><span class="line">                     i++;</span><br><span class="line">              &#125;</span><br><span class="line">              long end = System.currentTimeMillis();</span><br><span class="line">              System.out.println(&quot;用时:&quot; + (end - start));</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p><strong>用时：10001</strong></p>
<p>使用 clone, 发送十个邮件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">          int i = 0;</span><br><span class="line">          int MAX_COUNT = 10;</span><br><span class="line">          EventTemplate et = new EventTemplate(&quot;9月份信用卡账单&quot;, &quot;国庆抽奖活动...&quot;);</span><br><span class="line">          long start=System.currentTimeMillis();</span><br><span class="line">          Mail mail = new Mail(et);         </span><br><span class="line">          while (i &lt; MAX_COUNT) &#123;</span><br><span class="line">                 Mail cloneMail = mail.clone();</span><br><span class="line">                 mail.setContent(getRandString(5) + &quot;,先生（女士）:你的信用卡账单...&quot;</span><br><span class="line">                              + mail.getTail());</span><br><span class="line">                 mail.setReceiver(getRandString(5) + &quot;@&quot; + getRandString(8) + &quot;.com&quot;);</span><br><span class="line">                 sendMail(cloneMail);</span><br><span class="line">                 i++;</span><br><span class="line">          &#125;</span><br><span class="line">          long end=System.currentTimeMillis();</span><br><span class="line">          System.out.println(&quot;用时:&quot;+(end-start));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><strong>用时：1001</strong></p>
<h3 id="43-总结"><a class="markdownIt-Anchor" href="#43-总结">#</a> 4.3 总结</h3>
<p><strong>原型模式的本质就是 clone，可以解决构建复杂对象的资源消耗问题，能再某些场景中提升构建对象的效率；还有一个重要的用途就是保护性拷贝，可以通过返回一个拷贝对象的形式，实现只读的限制。</strong></p>
<h1 id="b-结构模式7种"><a class="markdownIt-Anchor" href="#b-结构模式7种">#</a> B、结构模式（7 种）</h1>
<p>适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p>
<h3 id="-3"><a class="markdownIt-Anchor" href="#-3">#</a> </h3>
<h2 id="5-适配器模式"><a class="markdownIt-Anchor" href="#5-适配器模式">#</a> 5 适配器模式</h2>
<p><strong>定义：</strong> 适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。</p>
<p>** 主要分为三类：** 类的适配器模式、对象的适配器模式、接口的适配器模式。</p>
<h3 id="51-类适配器模式"><a class="markdownIt-Anchor" href="#51-类适配器模式">#</a> 5.1 类适配器模式</h3>
<p>通过多重<strong>继承</strong>目标接口和被适配者类方式来实现适配</p>
<p><strong>举例</strong> (将 USB 接口转为 VGA 接口)，类图如下：</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609210401275.png" class="has" width="329" height="268" />
<p>USBImpl 的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class USBImpl implements USB&#123;</span><br><span class="line">       @Override</span><br><span class="line">       public void showPPT() &#123;</span><br><span class="line">              // TODO Auto-generated method stub</span><br><span class="line">              System.out.println(&quot;PPT内容演示&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AdatperUSB2VGA 首先继承 USBImpl 获取 USB 的功能，其次，实现 VGA 接口，表示该类的类型为 VGA。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class AdapterUSB2VGA extends USBImpl implements VGA &#123;</span><br><span class="line">       @Override</span><br><span class="line">       public void projection() &#123;</span><br><span class="line">              super.showPPT();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Projector 将 USB 映射为 VGA，只有 VGA 接口才可以连接上投影仪进行投影</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Projector&lt;T&gt; &#123;</span><br><span class="line">       public void projection(T t) &#123;</span><br><span class="line">              if (t instanceof VGA) &#123;</span><br><span class="line">                     System.out.println(&quot;开始投影&quot;);</span><br><span class="line">                     VGA v = new VGAImpl();</span><br><span class="line">                     v = (VGA) t;</span><br><span class="line">                     v.projection();</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                     System.out.println(&quot;接口不匹配，无法投影&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>test 代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test2()&#123;</span><br><span class="line">       //通过适配器创建一个VGA对象，这个适配器实际是使用的是USB的showPPT（）方法</span><br><span class="line">       VGA a=new AdapterUSB2VGA();</span><br><span class="line">       //进行投影</span><br><span class="line">       Projector p1=new Projector();</span><br><span class="line">       p1.projection(a);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="52-对象适配器模式"><a class="markdownIt-Anchor" href="#52-对象适配器模式">#</a> 5.2 对象适配器模式</h3>
<p>对象适配器和类适配器使用了不同的方法实现适配，对象适配器使用组合，类适配器使用继承。</p>
<p><strong>举例</strong> (将 USB 接口转为 VGA 接口)，类图如下：</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609210401318.png" class="has" width="356" height="278" />
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class AdapterUSB2VGA implements VGA &#123;</span><br><span class="line">       USB u = new USBImpl();</span><br><span class="line">       @Override</span><br><span class="line">       public void projection() &#123;</span><br><span class="line">              u.showPPT();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现 VGA 接口，表示适配器类是 VGA 类型的，适配器方法中直接使用 USB 对象。</p>
<h3 id="53-接口适配器模式"><a class="markdownIt-Anchor" href="#53-接口适配器模式">#</a> 5.3 接口适配器模式</h3>
<p>当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求，<strong>它适用于一个接口不想使用其所有的方法的情况。</strong></p>
<p><strong>举例</strong> (将 USB 接口转为 VGA 接口，VGA 中的 b () 和 c () 不会被实现)，类图如下：</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609210401289.png" class="has" width="451" height="351" />
<p><span style="color:#333333;">AdapterUSB2VGA</span>抽象类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AdapterUSB2VGA implements VGA &#123;</span><br><span class="line">       USB u = new USBImpl();</span><br><span class="line">       @Override</span><br><span class="line">       public void projection() &#123;</span><br><span class="line">              u.showPPT();</span><br><span class="line">       &#125;</span><br><span class="line">       @Override</span><br><span class="line">       public void b() &#123;</span><br><span class="line">       &#125;;</span><br><span class="line">       @Override</span><br><span class="line">       public void c() &#123;</span><br><span class="line">       &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span style="color:#333333;">AdapterUSB2VGA 实现，不用去实现 b () 和 c () 方法。</span></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class AdapterUSB2VGAImpl extends AdapterUSB2VGA &#123;</span><br><span class="line">       public void projection() &#123;</span><br><span class="line">              super.projection();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="54-总结"><a class="markdownIt-Anchor" href="#54-总结">#</a> 5.4 总结</h3>
<p>总结一下三种适配器模式的应用场景：</p>
<p><strong>类适配器模式：<strong>当希望将</strong>一个类</strong>转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。</p>
<p>** 对象适配器模式：** 当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个 Wrapper 类，持有原类的一个实例，在 Wrapper 类的方法中，调用实例的方法就行。</p>
<p>** 接口适配器模式：** 当不希望实现一个接口中所有的方法时，可以创建一个抽象类 Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可。</p>
<p><strong>命名规则：</strong></p>
<p><strong>我个人理解，三种命名方式，是根据 src 是以怎样的形式给到 Adapter（在 Adapter 里的形式）来命名的。</strong></p>
<p>类适配器，以类给到，在 Adapter 里，就是将 src 当做类，继承，</p>
<p>对象适配器，以对象给到，在 Adapter 里，将 src 作为一个对象，持有。</p>
<p>接口适配器，以接口给到，在 Adapter 里，将 src 作为一个接口，实现。</p>
<p><strong>使用选择：</strong></p>
<p><strong>根据合成复用原则，组合大于继承。因此，类的适配器模式应该少用。</strong></p>
<h3 id="-4"><a class="markdownIt-Anchor" href="#-4">#</a> </h3>
<h2 id="6-装饰者模式"><a class="markdownIt-Anchor" href="#6-装饰者模式">#</a> 6 装饰者模式</h2>
<p><strong>定义：</strong><span style="color:#4d4d4d;">动态的将新功能附加到对象上。在对象功能扩展方面，它</span><span style="color:#4d4d4d;">比继承更有弹性。</span></p>
<h3 id="span-stylecolor4d4d4d61-装饰者模式结构图与代码示例span"><a class="markdownIt-Anchor" href="#span-stylecolor4d4d4d61-装饰者模式结构图与代码示例span">#</a> <span style="color:#4d4d4d;">6.1 装饰者模式结构图与代码示例</span></h3>
<p><span style="color:#4d4d4d;">1.Component（被装饰对象的基类）</span></p>
<p><span style="color:#4d4d4d;">   定义一个对象接口，可以给这些对象动态地添加职责。</span></p>
<p><span style="color:#4d4d4d;">2.ConcreteComponent（具体被装饰对象）</span></p>
<p><span style="color:#4d4d4d;">   定义一个对象，可以给这个对象添加一些职责。</span></p>
<p><span style="color:#4d4d4d;">3.Decorator（装饰者抽象类）</span></p>
<p><span style="color:#4d4d4d;">   维持一个指向 Component 实例的引用，并定义一个与 Component 接口一致的接口。</span></p>
<p><span style="color:#4d4d4d;">4.ConcreteDecorator（具体装饰者）</span></p>
<p><span style="color:#4d4d4d;">   具体的装饰对象，给内部持有的具体被装饰对象，增加具体的职责。</span></p>
<p><strong>被装饰对象和修饰者继承自同一个超类</strong></p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609223457210.png" class="has" width="561" height="287" />
<p><strong><span style="color:#4d4d4d;">举例</span></strong><span style="color:#4d4d4d;">(<span style="color:#4d4d4d;">咖啡馆订单项目：</span></span><span style="color:#4d4d4d;">1）、咖啡种类：Espresso、ShortBlack、LongBlack、Decaf</span><span style="color:#4d4d4d;">2）、<strong>调料（装饰者）</strong>：Milk、Soy、Chocolate</span><span style="color:#4d4d4d;">)，类图如下：</span></p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609222716270.png" class="has" width="561" height="287" />
<p>被装饰的对象和装饰者都继承自同一个超类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Drink &#123;</span><br><span class="line">       public String description=&quot;&quot;;</span><br><span class="line">       private float price=0f;;</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       public void setDescription(String description)</span><br><span class="line">       &#123;</span><br><span class="line">              this.description=description;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       public String getDescription()</span><br><span class="line">       &#123;</span><br><span class="line">              return description+&quot;-&quot;+this.getPrice();</span><br><span class="line">       &#125;</span><br><span class="line">       public float getPrice()</span><br><span class="line">       &#123;</span><br><span class="line">              return price;</span><br><span class="line">       &#125;</span><br><span class="line">       public void setPrice(float price)</span><br><span class="line">       &#123;</span><br><span class="line">              this.price=price;</span><br><span class="line">       &#125;</span><br><span class="line">       public abstract float cost();</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>被装饰的对象，不用去改造。原来怎么样写，现在还是怎么写。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public  class Coffee extends Drink &#123;</span><br><span class="line">       @Override</span><br><span class="line">       public float cost() &#123;</span><br><span class="line">              // TODO Auto-generated method stub</span><br><span class="line">              return super.getPrice();</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>coffee 类的实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Decaf extends Coffee &#123;</span><br><span class="line">       public Decaf()</span><br><span class="line">       &#123;</span><br><span class="line">              super.setDescription(&quot;Decaf&quot;);</span><br><span class="line">              super.setPrice(3.0f);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>装饰者</p>
<p>装饰者不仅要考虑自身，还要考虑被它修饰的对象，它是在被修饰的对象上继续添加修饰。例如，咖啡里面加牛奶，再加巧克力。加糖后价格为 coffee+milk。再加牛奶价格为 coffee+milk+chocolate。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Decorator extends Drink &#123;</span><br><span class="line">       private Drink Obj;</span><br><span class="line">       public Decorator(Drink Obj) &#123;</span><br><span class="line">              this.Obj = Obj;</span><br><span class="line">       &#125;;</span><br><span class="line">       @Override</span><br><span class="line">       public float cost() &#123;</span><br><span class="line">              // TODO Auto-generated method stub</span><br><span class="line">              return super.getPrice() + Obj.cost();</span><br><span class="line">       &#125;</span><br><span class="line">       @Override</span><br><span class="line">       public String getDescription() &#123;</span><br><span class="line">              return super.description + &quot;-&quot; + super.getPrice() + &quot;&amp;&amp;&quot; + Obj.getDescription();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>装饰者实例化（加牛奶）。这里面要对被修饰的对象进行实例化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Milk extends Decorator &#123;</span><br><span class="line">       public Milk(Drink Obj) &#123;          </span><br><span class="line">              super(Obj);</span><br><span class="line">              // TODO Auto-generated constructor stub</span><br><span class="line">              super.setDescription(&quot;Milk&quot;);</span><br><span class="line">              super.setPrice(2.0f);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>coffee 店：初始化一个被修饰对象，修饰者实例需要对被修改者实例化，才能对具体的被修饰者进行修饰。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class CoffeeBar &#123;</span><br><span class="line">       public static void main(String[] args) &#123;</span><br><span class="line">              Drink order;</span><br><span class="line">              order = new Decaf();</span><br><span class="line">              System.out.println(&quot;order1 price:&quot; + order.cost());</span><br><span class="line">              System.out.println(&quot;order1 desc:&quot; + order.getDescription());</span><br><span class="line">              System.out.println(&quot;****************&quot;);</span><br><span class="line">              order = new LongBlack();</span><br><span class="line">              order = new Milk(order);</span><br><span class="line">              order = new Chocolate(order);</span><br><span class="line">              order = new Chocolate(order);</span><br><span class="line">              System.out.println(&quot;order2 price:&quot; + order.cost());</span><br><span class="line">              System.out.println(&quot;order2 desc:&quot; + order.getDescription());</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6.2 总结</p>
<p><strong>装饰者和被装饰者之间必须是一样的类型，也就是要有共同的超类。在这里应用继承并不是实现方法的复制，而是实现类型的匹配。因为装饰者和被装饰者是同一个类型，因此装饰者可以取代被装饰者，这样就使被装饰者拥有了装饰者独有的行为。根据装饰者模式的理念，我们可以在任何时候，实现新的装饰者增加新的行为。如果是用继承，每当需要增加新的行为时，就要修改原程序了。</strong></p>
<h3 id="-5"><a class="markdownIt-Anchor" href="#-5">#</a> </h3>
<h3 id="-6"><a class="markdownIt-Anchor" href="#-6">#</a> </h3>
<h2 id="7-代理模式"><a class="markdownIt-Anchor" href="#7-代理模式">#</a> 7 代理模式</h2>
<p>** 定义：** 代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活中常见的中介。</p>
<p>举个例子来说明：假如说我现在想买一辆二手车，虽然我可以自己去找车源，做质量检测等一系列的车辆过户流程，但是这确实太浪费我得时间和精力了。我只是想买一辆车而已为什么我还要额外做这么多事呢？于是我就通过中介公司来买车，他们来给我找车源，帮我办理车辆过户流程，我只是负责选择自己喜欢的车，然后付钱就可以了。用图表示如下：</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/2019061001123986.png" class="has" width="633" height="210" />
<h3 id="71-为什么要用代理模式"><a class="markdownIt-Anchor" href="#71-为什么要用代理模式">#</a> 7.1 为什么要用代理模式？</h3>
<p>** 中介隔离作用：** 在某些情况下，一个客户类不想或者不能直接引用一个委托对象，而代理类对象可以在客户类和委托对象之间起到中介的作用，其特征是代理类和委托类实现相同的接口。</p>
<p>** 开闭原则，增加功能：** 代理类除了是客户类和委托类的中介之外，我们还可以通过给代理类增加额外的功能来扩展委托类的功能，这样做我们只需要修改代理类而不需要再修改委托类，符合代码设计的开闭原则。代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后对返回结果的处理等。代理类本身并不真正实现服务，而是同过调用委托类的相关方法，来提供特定的服务。真正的业务功能还是由委托类来实现，但是可以在业务功能执行的前后加入一些公共的服务。例如我们想给项目加入缓存、日志这些功能，我们就可以使用代理类来完成，而没必要打开已经封装好的委托类。</p>
<p><strong>代理模式分为三类：1. 静态代理 2. 动态代理 3. CGLIB 代理</strong></p>
<p>7.2 静态代理</p>
<p><span style="color:#4d4d4d;"><strong>举例</strong></span><span style="color:#4d4d4d;">(买房</span><span style="color:#4d4d4d;">），类图如下：</span></p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/2019061001123984.png" class="has" width="359" height="179" />
<p>第一步：创建服务类接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface BuyHouse &#123;</span><br><span class="line">    void buyHosue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二步：实现服务接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class BuyHouseImpl implements BuyHouse &#123;</span><br><span class="line">       @Override</span><br><span class="line">       public void buyHosue() &#123;</span><br><span class="line">              System.out.println(&quot;我要买房&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三步：创建代理类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class BuyHouseProxy implements BuyHouse &#123;</span><br><span class="line">       private BuyHouse buyHouse;</span><br><span class="line">       public BuyHouseProxy(final BuyHouse buyHouse) &#123;</span><br><span class="line">              this.buyHouse = buyHouse;</span><br><span class="line">       &#125;</span><br><span class="line">       @Override</span><br><span class="line">       public void buyHosue() &#123;</span><br><span class="line">              System.out.println(&quot;买房前准备&quot;);</span><br><span class="line">              buyHouse.buyHosue();</span><br><span class="line">              System.out.println(&quot;买房后装修&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<p>优点：可以做到在符合开闭原则的情况下对目标对象进行功能扩展。</p>
<p>缺点： <strong>代理对象与目标对象要实现相同的接口，我们得为每一个服务都得创建代理类，工作量太大</strong>，不易管理。同时接口一旦发生改变，代理类也得相应修改。</p>
<h3 id="73-动态代理"><a class="markdownIt-Anchor" href="#73-动态代理">#</a> 7.3 动态代理</h3>
<p>动态代理有以下特点:</p>
<p>1. 代理对象，不需要实现接口</p>
<p>2. 代理对象的生成，是利用 JDK 的 API, 动态的在内存中构建代理对象 (需要我们指定创建代理对象 / 目标对象实现的接口的类型)</p>
<p>代理类不用再实现接口了。但是，要求被代理对象必须有接口。</p>
<p><strong>动态代理实现：</strong></p>
<p>Java.lang.reflect.Proxy 类可以直接生成一个代理对象</p>
<ul>
<li>
<p>Proxy.newProxyInstance (ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 生成一个代理对象</p>
<ul>
<li>
<p>参数 1:ClassLoader loader 代理对象的类加载器 一般使用被代理对象的类加载器</p>
</li>
<li>
<p>参数 2:Class&lt;?&gt;[] interfaces 代理对象的要实现的接口 一般使用的被代理对象实现的接口</p>
</li>
<li>
<p>参数 3:InvocationHandler h (接口) 执行处理类</p>
</li>
</ul>
</li>
<li>
<p>InvocationHandler 中的 invoke (Object proxy, Method method, Object [] args) 方法：调用代理类的任何方法，此方法都会执行</p>
<ul>
<li>
<p>参数 3.1: 代理对象 (慎用)</p>
</li>
<li>
<p>参数 3.2: 当前执行的方法</p>
</li>
<li>
<p>参数 3.3: 当前执行的方法运行时传递过来的参数</p>
</li>
</ul>
</li>
</ul>
<p>第一步：编写动态处理器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicProxyHandler implements InvocationHandler &#123;</span><br><span class="line">       private Object object;</span><br><span class="line">       public DynamicProxyHandler(final Object object) &#123;</span><br><span class="line">              this.object = object;</span><br><span class="line">       &#125;</span><br><span class="line">       @Override</span><br><span class="line">       public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">              System.out.println(&quot;买房前准备&quot;);</span><br><span class="line">              Object result = method.invoke(object, args);</span><br><span class="line">              System.out.println(&quot;买房后装修&quot;);</span><br><span class="line">              return result;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二步：编写测试类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicProxyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BuyHouse buyHouse = new BuyHouseImpl();</span><br><span class="line">        BuyHouse proxyBuyHouse = (BuyHouse) Proxy.newProxyInstance(BuyHouse.class.getClassLoader(), new</span><br><span class="line">                Class[]&#123;BuyHouse.class&#125;, new DynamicProxyHandler(buyHouse));</span><br><span class="line">        proxyBuyHouse.buyHosue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>** 动态代理总结：** 虽然相对于静态代理，动态代理大大减少了我们的开发任务，同时减少了对业务接口的依赖，降低了耦合度。但是还是有一点点小小的遗憾之处，那就是它始终无法摆脱仅支持 interface 代理的桎梏（我们要使用被代理的对象的接口），因为它的设计注定了这个遗憾。</p>
<p>7.4 CGLIB 代理</p>
<p><strong>CGLIB 原理</strong>：动态生成一个要代理类的子类，子类重写要代理的类的所有不是 final 的方法。在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。它比使用 java 反射的 JDK 动态代理要快。</p>
<p><strong>CGLIB 底层</strong>：使用字节码处理框架 ASM，来转换字节码并生成新的类。不鼓励直接使用 ASM，因为它要求你必须对 JVM 内部结构包括 class 文件的格式和指令集都很熟悉。</p>
<p><strong>CGLIB 缺点</strong>：对于 final 方法，无法进行代理。</p>
<p>CGLIB 的实现步骤：</p>
<p>第一步：建立拦截器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public Object intercept(Object object, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;买房前准备&quot;);</span><br><span class="line"></span><br><span class="line">        Object result = methodProxy.invoke(object, args);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;买房后装修&quot;);</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>参数：Object 为由 CGLib 动态生成的代理类实例，Method 为上文中实体类所调用的被代理的方法引用，Object [] 为参数值列表，MethodProxy 为生成的代理类对方法的代理引用。</p>
<p>返回：从代理实例的方法调用返回的值。</p>
<p>其中，<strong>proxy.invokeSuper(obj,arg)</strong> 调用代理类实例上的 proxy 方法的父类方法（即实体类 TargetObject 中对应的方法）</p>
<p>第二步： 生成动态代理类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class CglibProxy implements MethodInterceptor &#123;</span><br><span class="line">    private Object target;</span><br><span class="line">    public Object getInstance(final Object target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">        Enhancer enhancer = new Enhancer();</span><br><span class="line">        enhancer.setSuperclass(this.target.getClass());</span><br><span class="line">        enhancer.setCallback(this);</span><br><span class="line">        return enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">    public Object intercept(Object object, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;买房前准备&quot;);</span><br><span class="line">        Object result = methodProxy.invoke(object, args);</span><br><span class="line">        System.out.println(&quot;买房后装修&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 Enhancer 类是 CGLib 中的一个字节码增强器，它可以方便的对你想要处理的类进行扩展，以后会经常看到它。</p>
<p>首先将被代理类 TargetObject 设置成父类，然后设置拦截器 TargetInterceptor，最后执行 enhancer.create () 动态生成一个代理类，并从 Object 强制转型成父类型 TargetObject。</p>
<p>第三步：测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class CglibProxyTest &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        BuyHouse buyHouse = new BuyHouseImpl();</span><br><span class="line">        CglibProxy cglibProxy = new CglibProxy();</span><br><span class="line">        BuyHouseImpl buyHouseCglibProxy = (BuyHouseImpl) cglibProxy.getInstance(buyHouse);</span><br><span class="line">        buyHouseCglibProxy.buyHosue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CGLIB 代理总结：** CGLIB 创建的动态代理对象比 JDK 创建的动态代理对象的性能更高，但是 CGLIB 创建代理对象时所花费的时间却比 JDK 多得多。所以对于单例的对象，因为无需频繁创建对象，用 CGLIB 合适，反之使用 JDK 方式要更为合适一些。同时由于 CGLib 由于是采用动态创建子类的方法，对于 final 修饰的方法无法进行代理。**</p>
<h2 id="8-外观模式"><a class="markdownIt-Anchor" href="#8-外观模式">#</a> 8 外观模式</h2>
<p><strong>定义：</strong> 隐藏了系统的复杂性，并向客户端提供了一个可以访问系统的接口。</p>
<h3 id="81-模式结构和代码示例"><a class="markdownIt-Anchor" href="#81-模式结构和代码示例">#</a> 8.1 模式结构和代码示例</h3>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610154828945.png" class="has" width="666" height="408" />
<p>简单来说，该模式就是把一些复杂的流程封装成一个接口供给外部用户更简单的使用。这个模式中，设计到 3 个角色。</p>
<p>1）. 门面角色：外观模式的核心。它被客户角色调用，它熟悉子系统的功能。内部根据客户角色的需求预定了几种功能的组合。（<strong>客户调用，同时自身调用子系统功能</strong>）</p>
<p>2）. 子系统角色：实现了子系统的功能。它对客户角色和 Facade 时未知的。它内部可以有系统内的相互交互，也可以由供外界调用的接口。（实现具体功能）</p>
<p>3）. 客户角色：通过调用 Facede 来完成要实现的功能（<strong>调用门面角色</strong>）。</p>
<p>举例（每个 Computer 都有 CPU、Memory、Disk。在 Computer 开启和关闭的时候，相应的部件也会开启和关闭），类图如下：</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610154828952.png" class="has" width="473" height="187" />
<p>首先是子系统类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class CPU &#123;</span><br><span class="line"></span><br><span class="line">    public void start() &#123;</span><br><span class="line">        System.out.println(&quot;cpu is start...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void shutDown() &#123;</span><br><span class="line">        System.out.println(&quot;CPU is shutDown...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Disk &#123;</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        System.out.println(&quot;Disk is start...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void shutDown() &#123;</span><br><span class="line">        System.out.println(&quot;Disk is shutDown...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Memory &#123;</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        System.out.println(&quot;Memory is start...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void shutDown() &#123;</span><br><span class="line">        System.out.println(&quot;Memory is shutDown...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是，门面类 Facade</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Computer &#123;</span><br><span class="line"></span><br><span class="line">    private CPU cpu;</span><br><span class="line">    private Memory memory;</span><br><span class="line">    private Disk disk;</span><br><span class="line"></span><br><span class="line">    public Computer() &#123;</span><br><span class="line">        cpu = new CPU();</span><br><span class="line">        memory = new Memory();</span><br><span class="line">        disk = new Disk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void start() &#123;</span><br><span class="line">        System.out.println(&quot;Computer start begin&quot;);</span><br><span class="line">        cpu.start();</span><br><span class="line">        disk.start();</span><br><span class="line">        memory.start();</span><br><span class="line">        System.out.println(&quot;Computer start end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void shutDown() &#123;</span><br><span class="line">        System.out.println(&quot;Computer shutDown begin&quot;);</span><br><span class="line">        cpu.shutDown();</span><br><span class="line">        disk.shutDown();</span><br><span class="line">        memory.shutDown();</span><br><span class="line">        System.out.println(&quot;Computer shutDown end...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后为，客户角色</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Computer computer = new Computer();</span><br><span class="line">        computer.start();</span><br><span class="line">        System.out.println(&quot;=================&quot;);</span><br><span class="line">        computer.shutDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="82-优点"><a class="markdownIt-Anchor" href="#82-优点">#</a> 8.2 优点</h3>
<p>**　- 松散耦合 **</p>
<p>使得客户端和子系统之间解耦，让子系统内部的模块功能更容易扩展和维护；</p>
<p>**　　- 简单易用 **</p>
<p>客户端根本不需要知道子系统内部的实现，或者根本不需要知道子系统内部的构成，它只需要跟 Facade 类交互即可。</p>
<p>**　- 更好的划分访问层次 **</p>
<p>有些方法是对系统外的，有些方法是系统内部相互交互的使用的。子系统把那些暴露给外部的功能集中到门面中，这样就可以实现客户端的使用，很好的隐藏了子系统内部的细节。</p>
<h2 id="9-桥接模式"><a class="markdownIt-Anchor" href="#9-桥接模式">#</a> 9 桥接模式</h2>
<p><strong>定义：</strong> 将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p>
<h3 id="91-案例"><a class="markdownIt-Anchor" href="#91-案例">#</a> 9.1 案例</h3>
<p>看下图手机与手机软件的类图</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610180930798.png" class="has" width="710" height="417" />
<p>增加一款新的手机软件，需要在所有手机品牌类下添加对应的手机软件类，当手机软件种类较多时，将导致类的个数急剧膨胀，难以维护</p>
<p>手机和手机中的软件是什么关系？</p>
<p>手机中的软件从本质上来说并不是一种手机，手机软件运行在手机中，是一种包含与被包含关系，而不是一种父与子或者说一般与特殊的关系，通过继承手机类实现手机软件类的设计是违反一般规律的。</p>
<p>如果 Oppo 手机实现了 wifi 功能，继承它的 Oppo 应用商城也会继承 wifi 功能，并且 Oppo 手机类的任何变动，都会影响其子类</p>
<p>换一种解决思路</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610180930823.png" class="has" width="710" height="430" />
<p>从类图上看起来更像是手机软件类图，涉及到手机本身相关的功能，比如说：wifi 功能，放到哪个类中实现呢？放到 OppoAppStore 中实现显然是不合适的</p>
<p>引起整个结构变化的元素有两个，一个是手机品牌，一个是手机软件，所以我们将这两个点抽出来，分别进行封装</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610180930831.png" class="has" width="690" height="331" />
<h3 id="92-桥接模式结构和代码示例"><a class="markdownIt-Anchor" href="#92-桥接模式结构和代码示例">#</a> 9.2 桥接模式结构和代码示例</h3>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610180930861.png" class="has" width="556" height="274" />
<p><strong>类图：</strong></p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610180930821.png" class="has" width="451" height="197" />
<p><strong>实现：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public interface Software &#123;</span><br><span class="line">    public void run();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class AppStore implements Software &#123;</span><br><span class="line">     </span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;run app store&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Camera implements Software &#123;</span><br><span class="line">     </span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;run camera&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Phone &#123;</span><br><span class="line"></span><br><span class="line">    protected Software software;</span><br><span class="line"></span><br><span class="line">    public void setSoftware(Software software) &#123;</span><br><span class="line">        this.software = software;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void run();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class Oppo extends Phone &#123;</span><br><span class="line">     </span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        software.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Vivo extends Phone &#123;</span><br><span class="line">     </span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        software.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比最初的设计，将抽象部分（手机）与它的实现部分（手机软件类）分离，将实现部分抽象成单独的类，使它们都可以独立地变化。整个类图看起来像一座桥，所以称为桥接模式</p>
<p>继承是一种强耦合关系，子类的实现与它的父类有非常紧密的依赖关系，父类的任何变化 都会导致子类发生变化，因此继承或者说强耦合关系严重影响了类的灵活性，并最终限制了可复用性</p>
<p>从桥接模式的设计上我们可以看出聚合是一种比继承要弱的关联关系，手机类和软件类都可独立的进行变化，不会互相影响</p>
<h3 id="span-stylecolor00000093-适用场景span"><a class="markdownIt-Anchor" href="#span-stylecolor00000093-适用场景span">#</a> <span style="color:#000000;">9.3 适用场景</span></h3>
<p>桥接模式通常适用于以下场景。</p>
<ol>
<li>
<p>当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。</p>
</li>
<li>
<p>当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。</p>
</li>
<li>
<p>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。</p>
</li>
</ol>
<h3 id="span-stylecolor00000094-优缺点span"><a class="markdownIt-Anchor" href="#span-stylecolor00000094-优缺点span">#</a> <span style="color:#000000;">9.4 优缺点</span></h3>
<p><strong>优点：</strong></p>
<p>(1) 在很多情况下，桥接模式可以取代多层继承方案，多层继承方案违背了 “单一职责原则”，复用性较差，且类的个数非常多，桥接模式是比多层继承方案更好的解决方法，它极大减少了子类的个数。</p>
<p>(2) 桥接模式提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，符合 “开闭原则”。</p>
<p><strong>缺点：</strong></p>
<p>桥接模式的使用会增加系统的理解与设计难度，由于关联关系建立在抽象层，要求开发者一开始就针对抽象层进行设计与编程。</p>
<h2 id="10-组合模式"><a class="markdownIt-Anchor" href="#10-组合模式">#</a> 10 组合模式</h2>
<p>** 定义：** 有时又叫作<span style="color:#006400;">部分 - 整体模式</span>，它是一种将对象组合成树状的层次结构的模式，用来表示 “部分 - 整体” 的关系，使用户对单个对象和组合对象具有一致的访问性。</p>
<p>** 意图：** 将对象组合成树形结构以表示 &quot;部分 - 整体&quot; 的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<p>** 主要解决：** 它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。</p>
<p><strong>何时使用：</strong> 1、您想表示对象的部分 - 整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</p>
<p>** 如何解决：** 树枝和叶子实现统一接口，树枝内部组合该接口。</p>
<p>** 关键代码：** 树枝内部组合该接口，并且含有内部属性 List，里面放 Component。</p>
<p>组合模式的主要优点有：</p>
<ol>
<li>
<p>组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；</p>
</li>
<li>
<p>更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足 “开闭原则”；</p>
</li>
</ol>
<p>其主要缺点是：</p>
<ol>
<li>
<p>设计较复杂，客户端需要花更多时间理清类之间的层次关系；</p>
</li>
<li>
<p>不容易限制容器中的构件；</p>
</li>
<li>
<p>不容易用继承的方法来增加构件的新功能；</p>
</li>
</ol>
<h3 id="101-模式结构和代码示例"><a class="markdownIt-Anchor" href="#101-模式结构和代码示例">#</a> 10.1 模式结构和代码示例</h3>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612191511416.png" class="has" width="529" height="565" />
<ul>
<li>
<p>抽象构件（Component）角色：它的主要作用是为树叶构件和树枝构件声明公共接口，并实现它们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。</p>
</li>
<li>
<p>树叶构件（Leaf）角色：是组合中的叶节点对象，它没有子节点，用于实现抽象构件角色中 声明的公共接口。</p>
</li>
<li>
<p>树枝构件（Composite）角色：是组合中的分支节点对象，它有子节点。它实现了抽象构件角色中声明的接口，它的主要作用是存储和管理子部件，通常包含 Add ()、Remove ()、GetChild () 等方法</p>
</li>
</ul>
<p>举例（访问一颗树），类图如下：</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/201906121917147.png" class="has" width="286" height="216" />
<p>1 组件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Component &#123;</span><br><span class="line">    public void add(Component c);</span><br><span class="line">    public void remove(Component c);</span><br><span class="line">    public Component getChild(int i);</span><br><span class="line">    public void operation();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2 叶子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Leaf implements Component&#123;</span><br><span class="line">    </span><br><span class="line">    private String name;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    public Leaf(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void add(Component c) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void remove(Component c) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Component getChild(int i) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void operation() &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">         System.out.println(&quot;树叶&quot;+name+&quot;：被访问！&quot;); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3 树枝</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Composite implements Component &#123;</span><br><span class="line"></span><br><span class="line">    private ArrayList&lt;Component&gt; children = new ArrayList&lt;Component&gt;();</span><br><span class="line"></span><br><span class="line">    public void add(Component c) &#123;</span><br><span class="line">        children.add(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void remove(Component c) &#123;</span><br><span class="line">        children.remove(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Component getChild(int i) &#123;</span><br><span class="line">        return children.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void operation() &#123;</span><br><span class="line">        for (Object obj : children) &#123;</span><br><span class="line">            ((Component) obj).operation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="-7"><a class="markdownIt-Anchor" href="#-7">#</a> </h3>
<h2 id="11-享元模式"><a class="markdownIt-Anchor" href="#11-享元模式">#</a> 11 享元模式</h2>
<p>** 定义：** 通过共享的方式高效的支持大量细粒度的对象。</p>
<p>** 主要解决：** 在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。</p>
<p><strong>何时使用：</strong> 1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 5、系统不依赖于这些对象身份，这些对象是不可分辨的。</p>
<p>** 如何解决：** 用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。</p>
<p>** 关键代码：** 用 HashMap 存储这些对象。</p>
<p><strong>应用实例：</strong> 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。</p>
<p>** 优点：** 大大减少对象的创建，降低系统的内存，使效率提高。</p>
<p>** 缺点：** 提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。</p>
<p><span style="color:#f33b45;">简单来说，我们抽取出一个对象的外部状态（不能共享）和内部状态（可以共享）。然后根据外部状态的决定是否创建内部状态对象。内部状态对象是通过哈希表保存的，当外部状态相同的时候，不再重复的创建内部状态对象，从而减少要创建对象的数量。</span></p>
<h3 id="111-享元模式的结构图和代码示例"><a class="markdownIt-Anchor" href="#111-享元模式的结构图和代码示例">#</a> 11.1 享元模式的结构图和代码示例</h3>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610202655697.png" class="has" width="563" height="320" />
<p>1、Flyweight (享元抽象类)：一般是接口或者抽象类，定义了享元类的公共方法。这些方法可以分享内部状态的数据，也可以调用这些方法修改外部状态。</p>
<p>2、ConcreteFlyweight (具体享元类)：具体享元类实现了抽象享元类的方法，为享元对象开辟了内存空间来保存享元对象的内部数据，同时可以通过和单例模式结合只创建一个享元对象。</p>
<p>3、FlyweightFactory (享元工厂类)：享元工厂类创建并且管理享元类，享元工厂类针对享元类来进行编程，通过提供一个享元池来进行享元对象的管理。一般享元池设计成<strong>键值对</strong>，或者其他的存储结构来存储。当客户端进行享元对象的请求时，如果享元池中有对应的享元对象则直接返回对应的对象，否则工厂类创建对应的享元对象并保存到享元池。</p>
<p>举例（JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面）。类图如下：</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610202655744.png" class="has" width="310" height="187" />
<p>（1）创建享元对象接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface IFlyweight &#123;</span><br><span class="line">    void print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）创建具体享元对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Flyweight implements IFlyweight &#123;</span><br><span class="line">    private String id;</span><br><span class="line">    public Flyweight(String id)&#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void print() &#123;</span><br><span class="line">        System.out.println(&quot;Flyweight.id = &quot; + getId() + &quot; ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public String getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）创建工厂，这里要特别注意，为了避免享元对象被重复创建，我们使用 HashMap 中的 key 值保证其唯一。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class FlyweightFactory &#123;</span><br><span class="line">    private Map&lt;String, IFlyweight&gt; flyweightMap = new HashMap();</span><br><span class="line">    public IFlyweight getFlyweight(String str)&#123;</span><br><span class="line">        IFlyweight flyweight = flyweightMap.get(str);</span><br><span class="line">        if(flyweight == null)&#123;</span><br><span class="line">            flyweight = new Flyweight(str);</span><br><span class="line">            flyweightMap.put(str, flyweight);</span><br><span class="line">        &#125;</span><br><span class="line">        return  flyweight;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getFlyweightMapSize()&#123;</span><br><span class="line">        return flyweightMap.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（4）测试，我们创建三个字符串，但是只会产生两个享元对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class MainTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        FlyweightFactory flyweightFactory = new FlyweightFactory();</span><br><span class="line">        IFlyweight flyweight1 = flyweightFactory.getFlyweight(&quot;A&quot;);</span><br><span class="line">        IFlyweight flyweight2 = flyweightFactory.getFlyweight(&quot;B&quot;);</span><br><span class="line">        IFlyweight flyweight3 = flyweightFactory.getFlyweight(&quot;A&quot;);</span><br><span class="line">        flyweight1.print();</span><br><span class="line">        flyweight2.print();</span><br><span class="line">        flyweight3.print();</span><br><span class="line">        System.out.println(flyweightFactory.getFlyweightMapSize());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610203118380.png" class="has" width="466" height="100" />
<h2 id="-8"><a class="markdownIt-Anchor" href="#-8">#</a> </h2>
<h1 id="c-关系模式11种"><a class="markdownIt-Anchor" href="#c-关系模式11种">#</a> <strong>C、关系模式（11 种）</strong></h1>
<p>先来张图，看看这 11 中模式的关系：</p>
<p>第一类：通过父类与子类的关系进行实现。</p>
<p>第二类：两个类之间。</p>
<p>第三类：类的状态。</p>
<p>第四类：通过中间类</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610215352532.png" class="has" width="675" height="323" />
<h2 id="12-策略模式"><a class="markdownIt-Anchor" href="#12-策略模式">#</a> 12 策略模式</h2>
<p><strong>定义：</strong> 策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。</p>
<p>** 意图：** 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。</p>
<p>** 主要解决：** 在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。</p>
<p>** 何时使用：** 一个系统有许多许多类，而区分它们的只是他们直接的行为。</p>
<p>** 如何解决：** 将这些算法封装成一个一个的类，任意地替换。</p>
<p>** 关键代码：** 实现同一个接口。</p>
<p><strong>优点：</strong> 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。</p>
<p><strong>缺点：</strong> 1、策略类会增多。 2、所有策略类都需要对外暴露。</p>
<h3 id="121-策略模式结构和示例代码"><a class="markdownIt-Anchor" href="#121-策略模式结构和示例代码">#</a> 12.1 策略模式结构和示例代码</h3>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610215352527.png" class="has" width="725" height="311" />
<p><strong>抽象策略角色:</strong> 这个是一个抽象的角色，通常情况下使用接口或者抽象类去实现。对比来说，就是我们的 Comparator 接口。</p>
<p><strong>具体策略角色:</strong> 包装了具体的算法和行为。对比来说，就是实现了 Comparator 接口的实现一组实现类。</p>
<p><strong>环境角色:</strong> 内部会持有一个抽象角色的引用，给客户端调用。</p>
<p>举例如下（ 实现一个加减的功能），类图如下：</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610215352523.png" class="has" width="335" height="261" />
<p>1、定义抽象策略角色</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Strategy &#123;</span><br><span class="line"></span><br><span class="line">    public int calc(int num1,int num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、定义具体策略角色</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class AddStrategy implements Strategy &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int calc(int num1, int num2) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        return num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class SubstractStrategy implements Strategy &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int calc(int num1, int num2) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        return num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、环境角色</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Environment &#123;</span><br><span class="line">    private Strategy strategy;</span><br><span class="line"></span><br><span class="line">    public Environment(Strategy strategy) &#123;</span><br><span class="line">        this.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int calculate(int a, int b) &#123;</span><br><span class="line">        return strategy.calc(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class MainTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        </span><br><span class="line">        Environment environment=new Environment(new AddStrategy());</span><br><span class="line">        int result=environment.calculate(20, 5);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        </span><br><span class="line">        Environment environment1=new Environment(new SubstractStrategy());</span><br><span class="line">        int result1=environment1.calculate(20, 5);</span><br><span class="line">        System.out.println(result1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="-9"><a class="markdownIt-Anchor" href="#-9">#</a> </h3>
<h2 id="13-模板模式"><a class="markdownIt-Anchor" href="#13-模板模式">#</a> 13 模板模式</h2>
<p>** 定义：** 定义一个操作中算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变算法的结构即可重定义该算法的某些特定步骤。</p>
<p>通俗点的理解就是 ：完成一件事情，有固定的数个步骤，但是每个步骤根据对象的不同，而实现细节不同；就可以在父类中定义一个完成该事情的总方法，按照完成事件需要的步骤去调用其每个步骤的实现方法。每个步骤的具体实现，由子类完成。</p>
<h3 id="131-模式结构和代码示例"><a class="markdownIt-Anchor" href="#131-模式结构和代码示例">#</a> 13.1 模式结构和代码示例</h3>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612192139396.png" class="has" width="713" height="582" />
<p>抽象父类（AbstractClass）：实现了模板方法，定义了算法的骨架。</p>
<p>具体类（ConcreteClass)：实现抽象类中的抽象方法，即不同的对象的具体实现细节。</p>
<p>举例（ 我们做菜可以分为三个步骤 （1）备料 （2）具体做菜 （3）盛菜端给客人享用，这三部就是算法的骨架 ；然而做不同菜需要的料，做的方法，以及如何盛装给客人享用都是不同的这个就是不同的实现细节。）。类图如下：</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612192139362.png" class="has" width="425" height="250" />
<p>a. 先来写一个抽象的做菜父类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Dish &#123;    </span><br><span class="line">    /**</span><br><span class="line">     * 具体的整个过程</span><br><span class="line">     */</span><br><span class="line">    protected void dodish()&#123;</span><br><span class="line">        this.preparation();</span><br><span class="line">        this.doing();</span><br><span class="line">        this.carriedDishes();</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 备料</span><br><span class="line">     */</span><br><span class="line">    public abstract void preparation();</span><br><span class="line">    /**</span><br><span class="line">     * 做菜</span><br><span class="line">     */</span><br><span class="line">    public abstract void doing();</span><br><span class="line">    /**</span><br><span class="line">     * 上菜</span><br><span class="line">     */</span><br><span class="line">    public abstract void carriedDishes ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>b. 下来做两个番茄炒蛋（EggsWithTomato）和红烧肉（Bouilli）实现父类中的抽象方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class EggsWithTomato extends Dish &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void preparation() &#123;</span><br><span class="line">        System.out.println(&quot;洗并切西红柿，打鸡蛋。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doing() &#123;</span><br><span class="line">        System.out.println(&quot;鸡蛋倒入锅里，然后倒入西红柿一起炒。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void carriedDishes() &#123;</span><br><span class="line">        System.out.println(&quot;将炒好的西红寺鸡蛋装入碟子里，端给客人吃。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class Bouilli extends Dish&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void preparation() &#123;</span><br><span class="line">        System.out.println(&quot;切猪肉和土豆。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doing() &#123;</span><br><span class="line">        System.out.println(&quot;将切好的猪肉倒入锅中炒一会然后倒入土豆连炒带炖。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void carriedDishes() &#123;</span><br><span class="line">        System.out.println(&quot;将做好的红烧肉盛进碗里端给客人吃。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>c. 在测试类中我们来做菜：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MainTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Dish eggsWithTomato = new EggsWithTomato();</span><br><span class="line">        eggsWithTomato.dodish();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;-----------------------------&quot;);</span><br><span class="line"></span><br><span class="line">        Dish bouilli = new Bouilli();</span><br><span class="line">        bouilli.dodish();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="132-模板模式的优点和缺点"><a class="markdownIt-Anchor" href="#132-模板模式的优点和缺点">#</a> 13.2  模板模式的优点和缺点</h3>
<p>优点：</p>
<p>（1）具体细节步骤实现定义在子类中，子类定义详细处理算法是不会改变算法整体结构。</p>
<p>（2）代码复用的基本技术，在数据库设计中尤为重要。</p>
<p>（3）存在一种反向的控制结构，通过一个父类调用其子类的操作，通过子类对父类进行扩展增加新的行为，符合 “开闭原则”。</p>
<h3 id="缺点-2"><a class="markdownIt-Anchor" href="#缺点-2">#</a> 缺点：</h3>
<pre><code>每个不同的实现都需要定义一个子类，会导致类的个数增加，系统更加庞大。
</code></pre>
<h3 id="-10"><a class="markdownIt-Anchor" href="#-10">#</a> </h3>
<h2 id="14-观察者模式"><a class="markdownIt-Anchor" href="#14-观察者模式">#</a> 14 观察者模式</h2>
<p><strong>定义：</strong> 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
<p>** 主要解决：** 一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。</p>
<p>** 何时使用：** 一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。</p>
<p>** 如何解决：** 使用面向对象技术，可以将这种依赖关系弱化。</p>
<p>** 关键代码：** 在抽象类里有一个 ArrayList 存放观察者们。</p>
<p><strong>优点：</strong> 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。</p>
<p><strong>缺点：</strong> 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</p>
<h3 id="141-模式结构图和代码示例"><a class="markdownIt-Anchor" href="#141-模式结构图和代码示例">#</a> 14.1 模式结构图和代码示例</h3>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190611172644555.png" class="has" width="505" height="416" />
<ul>
<li>
<p><strong>抽象被观察者角色</strong>：也就是一个抽象主题，它把所有对观察者对象的引用保存在一个集合中，每个主题都可以有任意数量的观察者。抽象主题提供一个接口，可以增加和删除观察者角色。一般用一个抽象类和接口来实现。</p>
</li>
<li>
<p><strong>抽象观察者角色</strong>：为所有的具体观察者定义一个接口，在得到主题通知时更新自己。</p>
</li>
<li>
<p><strong>具体被观察者角色</strong>：也就是一个具体的主题，在集体主题的内部状态改变时，所有登记过的观察者发出通知。</p>
</li>
<li>
<p><strong>具体观察者角色</strong>：实现抽象观察者角色所需要的更新接口，一边使本身的状态与制图的状态相协调。</p>
</li>
</ul>
<p>举例（有一个微信公众号服务，不定时发布一些消息，关注公众号就可以收到推送消息，取消关注就收不到推送消息。）类图如下：</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190611172644540.png" class="has" width="545" height="359" />
<p>1、定义一个抽象被观察者接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Subject &#123;</span><br><span class="line">    </span><br><span class="line">      public void registerObserver(Observer o);</span><br><span class="line">      public void removeObserver(Observer o);</span><br><span class="line">      public void notifyObserver();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、定义一个抽象观察者接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Observer &#123;</span><br><span class="line">    </span><br><span class="line">    public void update(String message);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、定义被观察者，实现了 Observerable 接口，对 Observerable 接口的三个方法进行了具体实现，同时有一个 List 集合，用以保存注册的观察者，等需要通知观察者时，遍历该集合即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class WechatServer implements Subject &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;Observer&gt; list;</span><br><span class="line">    private String message;</span><br><span class="line"></span><br><span class="line">    public WechatServer() &#123;</span><br><span class="line">        list = new ArrayList&lt;Observer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void registerObserver(Observer o) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        list.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void removeObserver(Observer o) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        if (!list.isEmpty()) &#123;</span><br><span class="line">            list.remove(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void notifyObserver() &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        for (Observer o : list) &#123;</span><br><span class="line">            o.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setInfomation(String s) &#123;</span><br><span class="line">        this.message = s;</span><br><span class="line">        System.out.println(&quot;微信服务更新消息： &quot; + s);</span><br><span class="line">        // 消息更新，通知所有观察者</span><br><span class="line">        notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、定义具体观察者，微信公众号的具体观察者为用户 User</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class User implements Observer &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private String message;</span><br><span class="line"></span><br><span class="line">    public User(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void update(String message) &#123;</span><br><span class="line">        this.message = message;</span><br><span class="line">        read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void read() &#123;</span><br><span class="line">        System.out.println(name + &quot; 收到推送消息： &quot; + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、编写一个测试类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class MainTest &#123;</span><br><span class="line">    </span><br><span class="line">     public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">            WechatServer server = new WechatServer();</span><br><span class="line">            </span><br><span class="line">            Observer userZhang = new User(&quot;ZhangSan&quot;);</span><br><span class="line">            Observer userLi = new User(&quot;LiSi&quot;);</span><br><span class="line">            Observer userWang = new User(&quot;WangWu&quot;);</span><br><span class="line">            </span><br><span class="line">            server.registerObserver(userZhang);</span><br><span class="line">            server.registerObserver(userLi);</span><br><span class="line">            server.registerObserver(userWang);</span><br><span class="line">            server.setInfomation(&quot;PHP是世界上最好用的语言！&quot;);</span><br><span class="line">            </span><br><span class="line">            System.out.println(&quot;----------------------------------------------&quot;);</span><br><span class="line">            server.removeObserver(userZhang);</span><br><span class="line">            server.setInfomation(&quot;JAVA是世界上最好用的语言！&quot;);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="15-迭代器模式"><a class="markdownIt-Anchor" href="#15-迭代器模式">#</a> 15 迭代器模式</h2>
<p>** 定义：** 提供一种方法顺序访问一个聚合对象中各个元素，而又无须暴露该对象的内部表示。</p>
<p><strong>简单来说，不同种类的对象可能需要不同的遍历方式，我们对每一种类型的对象配一个迭代器，最后多个迭代器合成一个。</strong></p>
<p>** 主要解决：** 不同的方式来遍历整个整合对象。</p>
<p>** 何时使用：** 遍历一个聚合对象。</p>
<p>** 如何解决：** 把在元素之间游走的责任交给迭代器，而不是聚合对象。</p>
<p>** 关键代码：** 定义接口：hasNext, next。</p>
<p>** 应用实例：**JAVA 中的 iterator。</p>
<p><strong>优点：</strong> 1、它支持以不同的方式遍历一个聚合对象。 2、迭代器简化了聚合类。 3、在同一个聚合上可以有多个遍历。 4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。</p>
<p>** 缺点：** 由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</p>
<h3 id="151-模式结构和代码示例"><a class="markdownIt-Anchor" href="#151-模式结构和代码示例">#</a> 15.1 模式结构和代码示例</h3>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190611195714196.png" class="has" width="726" height="380" />
<p>(1) 迭代器角色（Iterator）: 定义遍历元素所需要的方法，一般来说会有这么三个方法：取得下一个元素的方法 next ()，判断是否遍历结束的方法 hasNext ()），移出当前对象的方法 remove (),</p>
<p>(2) 具体迭代器角色（Concrete Iterator）：实现迭代器接口中定义的方法，完成集合的迭代。</p>
<p>(3) 容器角色 (Aggregate):  一般是一个接口，提供一个 iterator () 方法，例如 java 中的 Collection 接口，List 接口，Set 接口等</p>
<p>(4) 具体容器角色（ConcreteAggregate）：就是抽象容器的具体实现类，比如 List 接口的有序列表实现 ArrayList，List 接口的链表实现 LinkList，Set 接口的哈希列表的实现 HashSet 等。</p>
<p>举例（咖啡厅和中餐厅合并，他们两个餐厅的菜单一个是数组保存的，一个是 ArrayList 保存的。遍历方式不一样，使用迭代器聚合访问，只需要一种方式）</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190611195714224.png" class="has" width="494" height="360" />
<p>1 迭代器接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface Iterator &#123;</span><br><span class="line">    </span><br><span class="line">    public boolean hasNext();</span><br><span class="line">    public Object next();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2 咖啡店菜单和咖啡店菜单遍历器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class CakeHouseMenu &#123;</span><br><span class="line">    private ArrayList&lt;MenuItem&gt; menuItems;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    public CakeHouseMenu() &#123;</span><br><span class="line">        menuItems = new ArrayList&lt;MenuItem&gt;();</span><br><span class="line">        </span><br><span class="line">        addItem(&quot;KFC Cake Breakfast&quot;,&quot;boiled eggs&amp;toast&amp;cabbage&quot;,true,3.99f);</span><br><span class="line">        addItem(&quot;MDL Cake Breakfast&quot;,&quot;fried eggs&amp;toast&quot;,false,3.59f);</span><br><span class="line">        addItem(&quot;Stawberry Cake&quot;,&quot;fresh stawberry&quot;,true,3.29f);</span><br><span class="line">        addItem(&quot;Regular Cake Breakfast&quot;,&quot;toast&amp;sausage&quot;,true,2.59f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void addItem(String name, String description, boolean vegetable,</span><br><span class="line">            float price) &#123;</span><br><span class="line">        MenuItem menuItem = new MenuItem(name, description, vegetable, price);</span><br><span class="line">        menuItems.add(menuItem);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public Iterator getIterator()</span><br><span class="line">    &#123;</span><br><span class="line">        return new CakeHouseIterator() ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class CakeHouseIterator implements  Iterator</span><br><span class="line">     &#123;      </span><br><span class="line">        private int position=0;</span><br><span class="line">        public CakeHouseIterator()</span><br><span class="line">        &#123;</span><br><span class="line">              position=0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">            @Override</span><br><span class="line">            public boolean hasNext() &#123;</span><br><span class="line">            // TODO Auto-generated method stub</span><br><span class="line">            if(position&lt;menuItems.size())</span><br><span class="line">            &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Object next() &#123;</span><br><span class="line">            // TODO Auto-generated method stub</span><br><span class="line">            MenuItem menuItem =menuItems.get(position);</span><br><span class="line">            position++;</span><br><span class="line">            return menuItem;</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">    //鍏朵粬鍔熻兘浠ｇ爜</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3 中餐厅菜单和中餐厅菜单遍历器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class DinerMenu &#123;</span><br><span class="line">    private final static int Max_Items = 5;</span><br><span class="line">    private int numberOfItems = 0;</span><br><span class="line">    private MenuItem[] menuItems;</span><br><span class="line"></span><br><span class="line">    public DinerMenu() &#123;</span><br><span class="line">        menuItems = new MenuItem[Max_Items];</span><br><span class="line">        addItem(&quot;vegetable Blt&quot;, &quot;bacon&amp;lettuce&amp;tomato&amp;cabbage&quot;, true, 3.58f);</span><br><span class="line">        addItem(&quot;Blt&quot;, &quot;bacon&amp;lettuce&amp;tomato&quot;, false, 3.00f);</span><br><span class="line">        addItem(&quot;bean soup&quot;, &quot;bean&amp;potato salad&quot;, true, 3.28f);</span><br><span class="line">        addItem(&quot;hotdog&quot;, &quot;onions&amp;cheese&amp;bread&quot;, false, 3.05f);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void addItem(String name, String description, boolean vegetable,</span><br><span class="line">            float price) &#123;</span><br><span class="line">        MenuItem menuItem = new MenuItem(name, description, vegetable, price);</span><br><span class="line">        if (numberOfItems &gt;= Max_Items) &#123;</span><br><span class="line">            System.err.println(&quot;sorry,menu is full!can not add another item&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            menuItems[numberOfItems] = menuItem;</span><br><span class="line">            numberOfItems++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Iterator getIterator() &#123;</span><br><span class="line">        return new DinerIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class DinerIterator implements Iterator &#123;</span><br><span class="line">        private int position;</span><br><span class="line"></span><br><span class="line">        public DinerIterator() &#123;</span><br><span class="line">            position = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean hasNext() &#123;</span><br><span class="line">            // TODO Auto-generated method stub</span><br><span class="line">            if (position &lt; numberOfItems) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Object next() &#123;</span><br><span class="line">            // TODO Auto-generated method stub</span><br><span class="line">            MenuItem menuItem = menuItems[position];</span><br><span class="line">            position++;</span><br><span class="line">            return menuItem;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4 女服务员</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class Waitress &#123;</span><br><span class="line">    private ArrayList&lt;Iterator&gt; iterators = new ArrayList&lt;Iterator&gt;();</span><br><span class="line"></span><br><span class="line">    public Waitress() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addIterator(Iterator iterator) &#123;</span><br><span class="line">        iterators.add(iterator);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printMenu() &#123;</span><br><span class="line">        Iterator iterator;</span><br><span class="line">        MenuItem menuItem;</span><br><span class="line">        for (int i = 0, len = iterators.size(); i &lt; len; i++) &#123;</span><br><span class="line">            iterator = iterators.get(i);</span><br><span class="line"></span><br><span class="line">            while (iterator.hasNext()) &#123;</span><br><span class="line">                menuItem = (MenuItem) iterator.next();</span><br><span class="line">                System.out</span><br><span class="line">                        .println(menuItem.getName() + &quot;***&quot; + menuItem.getPrice() + &quot;***&quot; + menuItem.getDescription());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printBreakfastMenu() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printLunchMenu() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printVegetableMenu() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="16-责任链模式"><a class="markdownIt-Anchor" href="#16-责任链模式">#</a> 16 责任链模式</h2>
<p>** 定义：** 如果有多个对象有机会处理请求，责任链可使请求的发送者和接受者解耦，请求沿着责任链传递，直到有一个对象处理了它为止。</p>
<p>** 主要解决：** 职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p>
<p>** 何时使用：** 在处理消息的时候以过滤很多道。</p>
<p>** 如何解决：** 拦截的类都实现统一接口。</p>
<p>** 关键代码：**Handler 里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。</p>
<h3 id="161-模式的结构和代码示例"><a class="markdownIt-Anchor" href="#161-模式的结构和代码示例">#</a> 16.1 模式的结构和代码示例</h3>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/2019061120335378.png" class="has" width="468" height="272" />
<ol>
<li>
<p>抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</p>
</li>
<li>
<p>具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</p>
</li>
<li>
<p>客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</p>
</li>
</ol>
<p>举例（购买请求决策，价格不同要由不同的级别决定：组长、部长、副部、总裁）。类图如下：</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190611203353118.png" class="has" width="1041" height="363" />
<p>1 决策者抽象类，包含对请求处理的函数，同时还包含指定下一个决策者的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Approver &#123;</span><br><span class="line">     Approver successor;</span><br><span class="line">     String Name;</span><br><span class="line">    public Approver(String Name)</span><br><span class="line">    &#123;</span><br><span class="line">        this.Name=Name;</span><br><span class="line">    &#125;</span><br><span class="line">    public abstract void ProcessRequest( PurchaseRequest request);</span><br><span class="line">    public void SetSuccessor(Approver successor) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        this.successor=successor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2 客户端以及请求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class PurchaseRequest &#123;</span><br><span class="line">    private int Type = 0;</span><br><span class="line">    private int Number = 0;</span><br><span class="line">    private float Price = 0;</span><br><span class="line">    private int ID = 0;</span><br><span class="line"></span><br><span class="line">    public PurchaseRequest(int Type, int Number, float Price) &#123;</span><br><span class="line">        this.Type = Type;</span><br><span class="line">        this.Number = Number;</span><br><span class="line">        this.Price = Price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int GetType() &#123;</span><br><span class="line">        return Type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public float GetSum() &#123;</span><br><span class="line">        return Number * Price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int GetID() &#123;</span><br><span class="line">        return (int) (Math.random() * 1000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">    public Client() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PurchaseRequest sendRequst(int Type, int Number, float Price) &#123;</span><br><span class="line">        return new PurchaseRequest(Type, Number, Price);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3 组长、部长。。。继承决策者抽象类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class GroupApprover extends Approver &#123;</span><br><span class="line"></span><br><span class="line">    public GroupApprover(String Name) &#123;</span><br><span class="line">        super(Name + &quot; GroupLeader&quot;);</span><br><span class="line">        // TODO Auto-generated constructor stub</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void ProcessRequest(PurchaseRequest request) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">        if (request.GetSum() &lt; 5000) &#123;</span><br><span class="line">            System.out.println(&quot;**This request &quot; + request.GetID() + &quot; will be handled by &quot; + this.Name + &quot; **&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            successor.ProcessRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class DepartmentApprover extends Approver &#123;</span><br><span class="line"></span><br><span class="line">    public DepartmentApprover(String Name) &#123;</span><br><span class="line">        super(Name + &quot; DepartmentLeader&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void ProcessRequest(PurchaseRequest request) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">        if ((5000 &lt;= request.GetSum()) &amp;&amp; (request.GetSum() &lt; 10000)) &#123;</span><br><span class="line">            System.out.println(&quot;**This request &quot; + request.GetID()</span><br><span class="line">                    + &quot; will be handled by &quot; + this.Name + &quot; **&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            successor.ProcessRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4 测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class MainTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Client mClient = new Client();</span><br><span class="line">        Approver GroupLeader = new GroupApprover(&quot;Tom&quot;);</span><br><span class="line">        Approver DepartmentLeader = new DepartmentApprover(&quot;Jerry&quot;);</span><br><span class="line">        Approver VicePresident = new VicePresidentApprover(&quot;Kate&quot;);</span><br><span class="line">        Approver President = new PresidentApprover(&quot;Bush&quot;);</span><br><span class="line"></span><br><span class="line">        GroupLeader.SetSuccessor(VicePresident);</span><br><span class="line">        DepartmentLeader.SetSuccessor(President);</span><br><span class="line">        VicePresident.SetSuccessor(DepartmentLeader);</span><br><span class="line">        President.SetSuccessor(GroupLeader);</span><br><span class="line"></span><br><span class="line">        GroupLeader.ProcessRequest(mClient.sendRequst(1, 10000, 40));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="-11"><a class="markdownIt-Anchor" href="#-11">#</a> </h2>
<h2 id="17-命令模式"><a class="markdownIt-Anchor" href="#17-命令模式">#</a> 17 命令模式</h2>
<p>** 定义：** 将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。</p>
<p>** 意图：** 将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。</p>
<p>** 主要解决：** 在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。</p>
<p>** 何时使用：** 在某些场合，比如要对行为进行 &quot;记录、撤销 / 重做、事务&quot; 等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将 &quot;行为请求者&quot; 与 &quot;行为实现者&quot; 解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。</p>
<p>** 如何解决：** 通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。</p>
<h3 id="171模式结构和代码示例"><a class="markdownIt-Anchor" href="#171模式结构和代码示例">#</a> 17.1 模式结构和代码示例</h3>
<h2 id="img-srchttpsbrath4oss-cn-shenzhenaliyuncscompicgo20190612194014850gif-classhas-width550-height612"><a class="markdownIt-Anchor" href="#img-srchttpsbrath4oss-cn-shenzhenaliyuncscompicgo20190612194014850gif-classhas-width550-height612">#</a> <img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612194014850.gif" class="has" width="550" height="612" /></h2>
<ol>
<li>抽象命令类（Command）角色：声明执行命令的接口，拥有执行命令的抽象方法 execute ()。</li>
<li>具体命令角色（Concrete    Command）角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。</li>
<li>实现者 / 接收者（Receiver）角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者。</li>
<li>调用者 / 请求者（Invoker）角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。</li>
</ol>
<p>代码举例（开灯和关灯），类图如下：</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612194307560.png" class="has" width="420" height="277" />
<p>1 命令抽象类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface Command &#123;</span><br><span class="line">    </span><br><span class="line">    public void excute();</span><br><span class="line">    public void undo();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2 具体命令对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class TurnOffLight implements Command &#123;</span><br><span class="line"></span><br><span class="line">    private Light light;</span><br><span class="line"></span><br><span class="line">    public TurnOffLight(Light light) &#123;</span><br><span class="line">        this.light = light;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void excute() &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        light.Off();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void undo() &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        light.On();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3 实现者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Light &#123;</span><br><span class="line"></span><br><span class="line">    String loc = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    public Light(String loc) &#123;</span><br><span class="line">        this.loc = loc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void On() &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(loc + &quot; On&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Off() &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(loc + &quot; Off&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4 请求者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Contral&#123;</span><br><span class="line"></span><br><span class="line">    public void CommandExcute(Command command) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        command.excute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void CommandUndo(Command command) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        command.undo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="-12"><a class="markdownIt-Anchor" href="#-12">#</a> </h2>
<h2 id="18-状态模式"><a class="markdownIt-Anchor" href="#18-状态模式">#</a> 18 状态模式</h2>
<p><strong>定义</strong>： 在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。</p>
<p>简单理解，一个拥有状态的 context 对象，在不同的状态下，其行为会发生改变。</p>
<p>** 意图：** 允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。</p>
<p>** 主要解决：** 对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。</p>
<p>** 何时使用：** 代码中包含大量与对象状态有关的条件语句。</p>
<p>** 如何解决：** 将各种具体的状态类抽象出来。</p>
<p>** 关键代码：** 通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if…else 等条件选择语句。</p>
<p><strong>优点：</strong> 1、封装了转换规则。 2、枚举可能的状态，在枚举状态之前需要确定状态种类。 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</p>
<p><strong>缺点：</strong> 1、状态模式的使用必然会增加系统类和对象的个数。 2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 3、状态模式对 &quot;开闭原则&quot; 的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。</p>
<h3 id="181-模式结构和代码示例"><a class="markdownIt-Anchor" href="#181-模式结构和代码示例">#</a> 18.1 模式结构和代码示例</h3>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612003537747.png" class="has" width="585" height="357" />
<ul>
<li>
<p><strong>State 抽象状态角色</strong></p>
<p>接口或抽象类，负责对象状态定义，并且封装环境角色以实现状态切换。</p>
</li>
<li>
<p><strong>ConcreteState 具体状态角色</strong></p>
<p>具体状态主要有两个职责：一是处理本状态下的事情，二是从本状态如何过渡到其他状态。</p>
</li>
<li>
<p><strong>Context 环境角色</strong></p>
<p>定义客户端需要的接口，并且负责具体状态的切换。</p>
</li>
</ul>
<p>举例（人物在地点 A 向地点 B 移动，在地点 B 向地点 A 移动）。类图如下：</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612003537942.png" class="has" width="473" height="324" />
<p>1 state 接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface State &#123;</span><br><span class="line">    public void stop();</span><br><span class="line">    public void move();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2 状态实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class PlaceA implements State &#123;</span><br><span class="line"></span><br><span class="line">    private Player context;</span><br><span class="line"></span><br><span class="line">    public PlaceA(Player context) &#123;</span><br><span class="line">        this.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void move() &#123;</span><br><span class="line">        System.out.println(&quot;处于地点A,开始向B移动&quot;);</span><br><span class="line">        System.out.println(&quot;--------&quot;);</span><br><span class="line">        context.setDirection(&quot;AB&quot;);</span><br><span class="line">        context.setState(context.onMove);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void stop() &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        System.out.println(&quot;正处在地点A，不用停止移动&quot;);</span><br><span class="line">        System.out.println(&quot;--------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3 context (player) 拥有状态的对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class Player &#123;</span><br><span class="line"></span><br><span class="line">    State placeA;</span><br><span class="line">    State placeB;</span><br><span class="line">    State onMove;</span><br><span class="line">    private State state;</span><br><span class="line">    private String direction;</span><br><span class="line"></span><br><span class="line">    public Player() &#123;</span><br><span class="line">        direction = &quot;AB&quot;;</span><br><span class="line">        placeA = new PlaceA(this);</span><br><span class="line">        placeB = new PlaceB(this);</span><br><span class="line">        onMove = new OnMove(this);</span><br><span class="line">        this.state = placeA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void move() &#123;</span><br><span class="line">        System.out.println(&quot;指令:开始移动&quot;);</span><br><span class="line">        state.move();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void stop() &#123;</span><br><span class="line">        System.out.println(&quot;指令:停止移动&quot;);</span><br><span class="line">        state.stop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public State getState() &#123;</span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setState(State state) &#123;</span><br><span class="line">        this.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDirection(String direction) &#123;</span><br><span class="line">        this.direction = direction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDirection() &#123;</span><br><span class="line">        return direction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="-13"><a class="markdownIt-Anchor" href="#-13">#</a> </h3>
<h2 id="19-备忘录模式"><a class="markdownIt-Anchor" href="#19-备忘录模式">#</a> 19 备忘录模式</h2>
<p>定义： 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式<span style="color:#b22222;">又叫快照模式。</span></p>
<p>备忘录模式是一种对象行为型模式，其主要优点如下。</p>
<ul>
<li>
<p>提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。</p>
</li>
<li>
<p>实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。</p>
</li>
<li>
<p>简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。</p>
</li>
</ul>
<p>其主要缺点是：资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。</p>
<h3 id="191-模式结构图和代码示例"><a class="markdownIt-Anchor" href="#191-模式结构图和代码示例">#</a> 19.1 模式结构图和代码示例</h3>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612143829622.png" class="has" width="564" height="405" />
<ol>
<li>
<p>发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。</p>
</li>
<li>
<p>备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。</p>
</li>
<li>
<p>管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。</p>
</li>
</ol>
<p>举例（发起者通过备忘录存储信息和获取信息），类图如下：</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612143829817.png" class="has" width="401" height="198" />
<p>1 备忘录接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface MementoIF &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2 备忘录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Memento implements MementoIF&#123;</span><br><span class="line">    </span><br><span class="line">    private String state;</span><br><span class="line"></span><br><span class="line">    public Memento(String state) &#123;</span><br><span class="line">        this.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getState()&#123;</span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3 发起者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Originator &#123;</span><br><span class="line"></span><br><span class="line">    private String state;</span><br><span class="line"></span><br><span class="line">    public String getState() &#123;</span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setState(String state) &#123;</span><br><span class="line">        this.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Memento saveToMemento() &#123;</span><br><span class="line">        return new Memento(state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getStateFromMemento(MementoIF memento) &#123;</span><br><span class="line">        return ((Memento) memento).getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4 管理者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class CareTaker &#123;</span><br><span class="line">    </span><br><span class="line">    private List&lt;MementoIF&gt; mementoList = new ArrayList&lt;MementoIF&gt;();</span><br><span class="line"></span><br><span class="line">    public void add(MementoIF memento) &#123;</span><br><span class="line">        mementoList.add(memento);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MementoIF get(int index) &#123;</span><br><span class="line">        return mementoList.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="20-访问者模式"><a class="markdownIt-Anchor" href="#20-访问者模式">#</a> 20 访问者模式</h2>
<p>** 定义：** 将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离。</p>
<p>访问者（Visitor）模式是一种对象行为型模式，其主要优点如下。</p>
<ol>
<li>
<p>扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。</p>
</li>
<li>
<p>复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。</p>
</li>
<li>
<p>灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。</p>
</li>
<li>
<p>符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。</p>
</li>
</ol>
<p>访问者（Visitor）模式的主要缺点如下。</p>
<ol>
<li>
<p>增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了 “开闭原则”。</p>
</li>
<li>
<p>破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。</p>
</li>
<li>
<p>违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。</p>
</li>
</ol>
<h3 id="201-模式结构和代码示例"><a class="markdownIt-Anchor" href="#201-模式结构和代码示例">#</a> 20.1 模式结构和代码示例</h3>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612154308216.gif" class="has" width="500" height="443" />
<p>访问者模式包含以下主要角色。</p>
<ol>
<li>
<p>抽象访问者（Visitor）角色：定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作 visit () ，该操作中的参数类型标识了被访问的具体元素。</p>
</li>
<li>
<p>具体访问者（ConcreteVisitor）角色：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。</p>
</li>
<li>
<p>抽象元素（Element）角色：声明一个包含接受操作 accept () 的接口，被接受的访问者对象作为 accept () 方法的参数。</p>
</li>
<li>
<p>具体元素（ConcreteElement）角色：实现抽象元素角色提供的 accept () 操作，其方法体通常都是 visitor.visit (this) ，另外具体元素中可能还包含本身业务逻辑的相关操作。</p>
</li>
<li>
<p>对象结构（Object Structure）角色：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map 等聚合类实现。</p>
</li>
</ol>
<p>1 抽象访问者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Visitor &#123;</span><br><span class="line"></span><br><span class="line">    abstract public void Visit(Element element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2 具体访问者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class CompensationVisitor implements Visitor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void Visit(Element element) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        Employee employee = ((Employee) element);</span><br><span class="line"></span><br><span class="line">        System.out.println(</span><br><span class="line">                employee.getName() + &quot;&#x27;s Compensation is &quot; + (employee.getDegree() * employee.getVacationDays() * 10));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3 抽象元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Element &#123;</span><br><span class="line">    abstract public void Accept(Visitor visitor);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4 具体元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class CompensationVisitor implements Visitor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void Visit(Element element) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        Employee employee = ((Employee) element);</span><br><span class="line"></span><br><span class="line">        System.out.println(</span><br><span class="line">                employee.getName() + &quot;&#x27;s Compensation is &quot; + (employee.getDegree() * employee.getVacationDays() * 10));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5 对象结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class ObjectStructure &#123;</span><br><span class="line">    private HashMap&lt;String, Employee&gt; employees;</span><br><span class="line"></span><br><span class="line">    public ObjectStructure() &#123;</span><br><span class="line">        employees = new HashMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Attach(Employee employee) &#123;</span><br><span class="line">        employees.put(employee.getName(), employee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Detach(Employee employee) &#123;</span><br><span class="line">        employees.remove(employee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Employee getEmployee(String name) &#123;</span><br><span class="line">        return employees.get(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Accept(Visitor visitor) &#123;</span><br><span class="line">        for (Employee e : employees.values()) &#123;</span><br><span class="line">            e.Accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="-14"><a class="markdownIt-Anchor" href="#-14">#</a> </h3>
<h2 id="21-中介者模式"><a class="markdownIt-Anchor" href="#21-中介者模式">#</a> 21 中介者模式</h2>
<p>** 定义：** 定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。中介者模式又叫调停模式，它是迪米特法则的典型应用。</p>
<p>中介者模式是一种对象行为型模式，其主要优点如下。</p>
<ol>
<li>
<p>降低了对象之间的耦合性，使得对象易于独立地被复用。</p>
</li>
<li>
<p>将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展。</p>
</li>
</ol>
<p>其主要缺点是：当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。</p>
<h3 id="211-模式结构和代码示例"><a class="markdownIt-Anchor" href="#211-模式结构和代码示例">#</a> 21.1 模式结构和代码示例</h3>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612175348613.png" class="has" width="803" height="457" />
<ol>
<li>
<p>抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。</p>
</li>
<li>
<p>具体中介者（ConcreteMediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。</p>
</li>
<li>
<p>抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。</p>
</li>
<li>
<p>具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。</p>
</li>
</ol>
<p>举例（通过中介卖方），类图如下：</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612175348612.png" class="has" width="577" height="290" />
<p>1 抽象中介者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Mediator &#123;</span><br><span class="line"></span><br><span class="line">    void register(Colleague colleague); // 客户注册</span><br><span class="line"></span><br><span class="line">    void relay(String from, String to,String ad); // 转发</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2 具体中介者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteMediator implements Mediator &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;Colleague&gt; colleagues = new ArrayList&lt;Colleague&gt;();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void register(Colleague colleague) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        if (!colleagues.contains(colleague)) &#123;</span><br><span class="line">            colleagues.add(colleague);</span><br><span class="line">            colleague.setMedium(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void relay(String from, String to, String ad) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        for (Colleague cl : colleagues) &#123;</span><br><span class="line"></span><br><span class="line">            String name = cl.getName();</span><br><span class="line">            if (name.equals(to)) &#123;</span><br><span class="line">                cl.receive(from, ad);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3 抽象同事类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Colleague &#123;</span><br><span class="line"></span><br><span class="line">    protected Mediator mediator;</span><br><span class="line">    protected String name;</span><br><span class="line"></span><br><span class="line">    public Colleague(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMedium(Mediator mediator) &#123;</span><br><span class="line"></span><br><span class="line">        this.mediator = mediator;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void Send(String to, String ad);</span><br><span class="line"></span><br><span class="line">    public abstract void receive(String from, String ad);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4 具体同事类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Buyer extends Colleague &#123;</span><br><span class="line"></span><br><span class="line">    public Buyer(String name) &#123;</span><br><span class="line"></span><br><span class="line">        super(name);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void Send(String to, String ad) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        mediator.relay(name, to, ad);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void receive(String from, String ad) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        System.out.println(name + &quot;接收到来自&quot; + from + &quot;的消息:&quot; + ad);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关于我"><a class="markdownIt-Anchor" href="#关于我">#</a> 关于我</h2>
<p>Brath 是一个热爱技术的 Java 程序猿，公众号「InterviewCoder」定期分享有趣有料的精品原创文章！</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png" alt="InterviewCoder"></p>
<p>非常感谢各位人才能看到这里，原创不易，文章如果有帮助可以关注、点赞、分享或评论，这都是对我的莫大支持！</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>【设计模式】23 种设计模式详解（全23种）</p><p><a href="http://example.com/2023/04/29/【设计模式】23 种设计模式详解（全23种）/">http://example.com/2023/04/29/【设计模式】23 种设计模式详解（全23种）/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Brath</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-04-29</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-04-29</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="sharethis-inline-share-buttons"></div><script src="https://brath.cn" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="https://brath.cloud/zfb.jpg" alt="支付宝"></span></a><a class="button donate" href="https://brath.cloud/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E5%AE%9D%E4%BA%8C%E5%90%88%E4%B8%80.png" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a><a class="button donate" href="https://brath.cloud/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E5%AE%9D%E4%BA%8C%E5%90%88%E4%B8%80.png" target="_blank" rel="noopener" data-type="patreon"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="https://brath.cloud/wx.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2023/04/27/%E3%80%90Dubbo%E3%80%91Dubbo%E8%AF%A6%E8%A7%A3%EF%BC%8C%E7%94%A8%E5%BF%83%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91/"><span class="level-item">【Dubbo】Dubbo详解，用心看这一篇文章就够了【重点】</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="SOHUCS" sid="2023/04/29/【设计模式】23 种设计模式详解（全23种）/"></div><script charset="utf-8" src="https://changyan.sohu.com/upload/changyan.js"></script><script>window.changyan.api.config({appid: 'cywzQRCbe',conf: '485cd826ef6d780dcea71d0f3b37304a'});</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-29T11:42:37.000Z">2023-04-29</time></p><p class="title"><a href="/2023/04/29/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%9123%20%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%88%E5%85%A823%E7%A7%8D%EF%BC%89/">【设计模式】23 种设计模式详解（全23种）</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-27T09:20:49.000Z">2023-04-27</time></p><p class="title"><a href="/2023/04/27/%E3%80%90Dubbo%E3%80%91Dubbo%E8%AF%A6%E8%A7%A3%EF%BC%8C%E7%94%A8%E5%BF%83%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91/">【Dubbo】Dubbo详解，用心看这一篇文章就够了【重点】</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-27T09:20:49.000Z">2023-04-27</time></p><p class="title"><a href="/2023/04/27/%E3%80%90MySql%E3%80%9121%E4%B8%AAMySQL%E8%A1%A8%E8%AE%BE%E8%AE%A1%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%87%86%E5%88%99/">【MySql】21个MySQL表设计的经验准则</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-27T09:20:49.000Z">2023-04-27</time></p><p class="title"><a href="/2023/04/27/%E3%80%90Zookeeper%E3%80%91Zookeeper%E5%85%A5%E9%97%A8%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/">【Zookeeper】Zookeeper入门看这篇就够了</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-27T09:20:48.000Z">2023-04-27</time></p><p class="title"><a href="/2023/04/27/%E3%80%90Log4J%E3%80%91JAVA%E5%AE%89%E5%85%A8--log4j%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6%E5%88%86%E6%9E%90/">【Log4J】JAVA安全--log4j漏洞研究分析</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">31</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/"><span class="level-start"><span class="level-item">2022</span></span><span class="level-end"><span class="level-item tag">51</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/"><span class="level-start"><span class="level-item">2021</span></span><span class="level-end"><span class="level-item tag">44</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/"><span class="level-start"><span class="level-item">2020</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png" alt="InterviewCoder"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">InterviewCoder</p><p class="is-size-6 is-block">面试记官方公众号</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">133</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://mp.weixin.qq.com/s/jWs6lLHl5L-atXJhHc4YvA" target="_blank" rel="noopener">关注我</a></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://brath.cloud/me.png" alt="Brath"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Brath</p><p class="is-size-6 is-block">技能改变人生，知识改变命运。</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·江苏·无锡</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">133</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Guoqing815" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Guoqing815"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Gitee" href="https://gitee.com/Guoqing-Li"><i class="fab fa-gitee"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://schokolade.cn/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">泠灵(特别呜谢)</span></span><span class="level-right"><span class="level-item tag">schokolade.cn</span></span></a></li><li><a class="level is-mobile" href="https://gitee.com/Guoqing-Li" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Gitee(码云)</span></span><span class="level-right"><span class="level-item tag">gitee.com</span></span></a></li><li><a class="level is-mobile" href="https://blog.csdn.net/Brath?type=blog" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">CSDN</span></span><span class="level-right"><span class="level-item tag">blog.csdn.net</span></span></a></li><li><a class="level is-mobile" href="https://juejin.cn/user/settings/profile" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">掘金</span></span><span class="level-right"><span class="level-item tag">juejin.cn</span></span></a></li><li><a class="level is-mobile" href="https://oss.console.aliyun.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">AliCloud(阿里云)</span></span><span class="level-right"><span class="level-item tag">oss.console.aliyun.com</span></span></a></li><li><a class="level is-mobile" href="https://cloud.tencent.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">TencentCloud(腾讯云)</span></span><span class="level-right"><span class="level-item tag">cloud.tencent.com</span></span></a></li><li><a class="level is-mobile" href="https://www.zhipin.com/web/user/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">BOSS</span></span><span class="level-right"><span class="level-item tag">www.zhipin.com</span></span></a></li><li><a class="level is-mobile" href="https://www.bilibili.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bilibili(B站)</span></span><span class="level-right"><span class="level-item tag">www.bilibili.com</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://brath.cloud/me.png" alt="Brath-Blog" height="28"></a><p class="is-size-7"><span>&copy; 2023 Brath</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p><p class="is-size-7">© 2029</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>