<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Brath-Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Brath-Blog"><meta name="msapplication-TileImage" content="https://brath.cloud/avatar.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Brath-Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Brath-Blog"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="Brath-Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="Brath"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"Brath-Blog","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"Brath"},"publisher":{"@type":"Organization","name":"Brath-Blog","logo":{"@type":"ImageObject","url":"https://brath.cloud/avatar.png"}},"description":""}</script><link rel="icon" href="https://brath.cloud/avatar.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://brath.cloud/avatar.png" alt="Brath-Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">文章列表</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">更多</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Guoqing815"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-05-06T09:23:40.000Z" title="2022-5-6 17:23:40">2022-05-06</time>发表</span><span class="level-item"><time dateTime="2023-05-23T03:40:29.244Z" title="2023-5-23 11:40:29">2023-05-23</time>更新</span><span class="level-item">21 分钟读完 (大约3111个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/05/06/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0Map/">【数据结构】手写实现Hash表，并解决哈希冲突</a></p><div class="content"><p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png" alt="InterviewCoder"></p>
<h1 id="数据结构手写实现hash表并解决哈希冲突"><a class="markdownIt-Anchor" href="#数据结构手写实现hash表并解决哈希冲突">#</a> 【数据结构】手写实现 Hash 表，并解决哈希冲突</h1>
<h2 id="一-前言"><a class="markdownIt-Anchor" href="#一-前言">#</a> 一、前言</h2>
<h3 id="哈希表的历史"><a class="markdownIt-Anchor" href="#哈希表的历史">#</a> 哈希表的历史</h3>
<p>哈希散列的想法在不同的地方独立出现。1953 年 1 月，汉斯・彼得・卢恩 (Hans Peter Luhn) 编写了一份 IBM 内部备忘录，其中使用了散列和链接。开放寻址后来由 AD Linh 在 Luhn 的论文上提出。大约在同一时间，IBM Research 的 Gene Amdahl、Elaine M. McGraw、Nathaniel Rochester 和 Arthur Samuel 为 IBM 701 汇编器实现了散列。 线性探测的开放寻址归功于 Amdahl，尽管 Ershov 独立地有相同的想法。“开放寻址” 一词是由 W. Wesley Peterson 在他的文章中创造的，该文章讨论了大文件中的搜索问题。</p>
<h2 id="二-哈希数据结构"><a class="markdownIt-Anchor" href="#二-哈希数据结构">#</a> 二、哈希数据结构</h2>
<p>哈希表的存在是为了解决能通过 O (1) 时间复杂度直接索引到指定元素。</p>
<p>这是什么意思呢？通过我们使用数组存放元素，都是按照顺序存放的，当需要获取某个元素的时候，则需要对数组进行遍历，获取到指定的值。如图所示；</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/algorithms-220824-01.png" alt="img"></p>
<p>而这样通过循环遍历比对获取指定元素的操作，时间复杂度是 O (n)，也就是说如果你的业务逻辑实现中存在这样的代码是非常拉胯的。那怎么办呢？这就引入了哈希散列表的设计。</p>
<hr>
<p>在计算机科学中，一个哈希表（hash table、hash map）是一种实现关联数组的抽象数据结构，该结构将键通过哈希计算映射到值。</p>
<p>也就是说我们通过对一个 Key 值计算它的哈希并与长度为 2 的 n 次幂的数组减一做与运算，计算出槽位对应的索引，将数据存放到索引下。那么这样就解决了当获取指定数据时，只需要根据存放时计算索引 ID 的方式再计算一次，就可以把槽位上对应的数据获取处理，以此达到时间复杂度为 O (1) 的情况。如图所示；</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/algorithms-220824-02.png" alt="img"></p>
<p>哈希散列虽然解决了获取元素的时间复杂度问题，但大多数时候这只是理想情况。因为随着元素的增多，很可能发生哈希冲突，或者哈希值波动不大导致索引计算相同，也就是一个索引位置出现多个元素情况。如图所示；</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/algorithms-220824-03.png" alt="img"></p>
<p>当 <code>李二狗</code> 、 <code>拎瓢冲</code> 都有槽位的下标索引 03 的  <code>叮裆猫</code>  发生冲突时，情况就变得糟糕了，因为这样就不能满足 O (1) 时间复杂度获取元素的诉求了。</p>
<h2 id="三-实现哈希散列"><a class="markdownIt-Anchor" href="#三-实现哈希散列">#</a> 三、实现哈希散列</h2>
<p>​		哈希散列是一个非常常见的数据结构，无论是我们使用的 HashMap、ThreaLocal 还是你在刷题中位了提升索引效率，都会用到哈希散列。</p>
<p>​		只要哈希桶的长度由负载因子控制的合理，每次查找元素的平均时间复杂度与桶中存储的元素数量无关。另外许多哈希表设计还允许对键值对的任意插入和删除，每次操作的摊销固定平均成本。</p>
<h3 id="1-哈希碰撞"><a class="markdownIt-Anchor" href="#1-哈希碰撞">#</a> 1. 哈希碰撞</h3>
<p><strong>说明</strong>：通过模拟简单 HashMap 实现，去掉拉链寻址等设计，验证元素哈新索引位置碰撞。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap01</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] tab = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        tab[idx] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> (V) tab[idx];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/algorithms-220824-04.png" alt="img"></p>
<ul>
<li>HashMap01 的实现只是通过哈希计算出的下标，散列存放到固定的数组内。那么这样当发生元素下标碰撞时，原有的元素就会被新的元素替换掉。</li>
</ul>
<p><strong>测试</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_hashMap01</span><span class="params">()</span> &#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap01</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;01&quot;</span>, <span class="string">&quot;花花&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;02&quot;</span>, <span class="string">&quot;豆豆&quot;</span>);</span><br><span class="line">    logger.info(<span class="string">&quot;碰撞前 key：&#123;&#125; value：&#123;&#125;&quot;</span>, <span class="string">&quot;01&quot;</span>, map.get(<span class="string">&quot;01&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下标碰撞</span></span><br><span class="line">    map.put(<span class="string">&quot;09&quot;</span>, <span class="string">&quot;蛋蛋&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;12&quot;</span>, <span class="string">&quot;苗苗&quot;</span>);</span><br><span class="line">    logger.info(<span class="string">&quot;碰撞前 key：&#123;&#125; value：&#123;&#125;&quot;</span>, <span class="string">&quot;01&quot;</span>, map.get(<span class="string">&quot;01&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/algorithms-220824-05.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">06</span>:<span class="number">58</span>:<span class="number">41.691</span> [main] INFO cn.bugstack.algorithms.test.AlgorithmsTest - 碰撞前 key：<span class="number">01</span> value：花花</span><br><span class="line"><span class="number">06</span>:<span class="number">58</span>:<span class="number">41.696</span> [main] INFO cn.bugstack.algorithms.test.AlgorithmsTest - 碰撞前 key：<span class="number">01</span> value：苗苗</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>通过测试结果可以看到，碰撞前 map.get (“01”) 的值是 <code>花花</code> ，两次下标索引碰撞后存放的值则是 <code>苗苗</code></li>
<li>这也就是使用哈希散列必须解决的一个问题，无论是在已知元素数量的情况下，通过扩容数组长度解决，还是把碰撞的元素通过链表存放，都是可以的。</li>
</ul>
<h3 id="2-拉链寻址"><a class="markdownIt-Anchor" href="#2-拉链寻址">#</a> 2. 拉链寻址</h3>
<p><strong>说明</strong>：既然我们没法控制元素不碰撞，但我们可以对碰撞后的元素进行管理。比如像 HashMap 中拉链法一样，把碰撞的元素存放到链表上。这里我们就来简化实现一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap02BySeparateChaining</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Node&lt;K, V&gt;&gt;[] tab = <span class="keyword">new</span> <span class="title class_">LinkedList</span>[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (tab[idx] == <span class="literal">null</span>) &#123;</span><br><span class="line">            tab[idx] = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            tab[idx].add(<span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[idx].add(<span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K, V&gt; kvNode : tab[idx]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key.equals(kvNode.getKey())) &#123;</span><br><span class="line">                <span class="keyword">return</span> kvNode.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K, V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> K <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> V <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/algorithms-220824-06.png" alt="img"></p>
<ul>
<li>因为元素在存放到哈希桶上时，可能发生下标索引膨胀，所以这里我们把每一个元素都设定成一个 Node 节点，这些节点通过 LinkedList 链表关联，当然你也可以通过 Node 节点构建出链表 next 元素即可。</li>
<li>那么这时候在发生元素碰撞，相同位置的元素就都被存放到链表上了，获取的时候需要对存放多个元素的链表进行遍历获取。</li>
</ul>
<p><strong>测试</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_hashMap02</span><span class="params">()</span> &#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap02BySeparateChaining</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;01&quot;</span>, <span class="string">&quot;花花&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;05&quot;</span>, <span class="string">&quot;豆豆&quot;</span>);</span><br><span class="line">    logger.info(<span class="string">&quot;碰撞前 key：&#123;&#125; value：&#123;&#125;&quot;</span>, <span class="string">&quot;01&quot;</span>, map.get(<span class="string">&quot;01&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下标碰撞</span></span><br><span class="line">    map.put(<span class="string">&quot;09&quot;</span>, <span class="string">&quot;蛋蛋&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;12&quot;</span>, <span class="string">&quot;苗苗&quot;</span>);</span><br><span class="line">    logger.info(<span class="string">&quot;碰撞前 key：&#123;&#125; value：&#123;&#125;&quot;</span>, <span class="string">&quot;01&quot;</span>, map.get(<span class="string">&quot;01&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/algorithms-220824-07.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">07</span>:<span class="number">21</span>:<span class="number">16.654</span> [main] INFO cn.bugstack.algorithms.test.AlgorithmsTest - 碰撞前 key：<span class="number">01</span> value：花花</span><br><span class="line"><span class="number">07</span>:<span class="number">22</span>:<span class="number">44.651</span> [main] INFO cn.bugstack.algorithms.test.AlgorithmsTest - 碰撞前 key：<span class="number">01</span> value：花花</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>此时第一次和第二次获取 01 位置的元素就都是 <code>花花</code> 了，元素没有被替代。因为此时的元素是被存放到链表上了。</li>
</ul>
<h3 id="3-开放寻址"><a class="markdownIt-Anchor" href="#3-开放寻址">#</a> 3. 开放寻址</h3>
<p><strong>说明</strong>：除了对哈希桶上碰撞的索引元素进行拉链存放，还有不引入新的额外的数据结构，只是在哈希桶上存放碰撞元素的方式。它叫开放寻址，也就是 ThreaLocal 中运用斐波那契散列 + 开放寻址的处理方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap03ByOpenAddressing</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K, V&gt;[] tab = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (tab[idx] == <span class="literal">null</span>) &#123;</span><br><span class="line">            tab[idx] = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> idx; i &lt; tab.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tab[i] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    tab[i] = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> idx; i &lt; tab.length; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (tab[idx] != <span class="literal">null</span> &amp;&amp; tab[idx].key == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> tab[idx].value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K, V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/algorithms-220824-08.png" alt="img"></p>
<ul>
<li>开放寻址的设计会对碰撞的元素，寻找哈希桶上新的位置，这个位置从当前碰撞位置开始向后寻找，直到找到空的位置存放。</li>
<li>在 ThreadLocal 的实现中会使用斐波那契散列、索引计算累加、启发式清理、探测式清理等操作，以保证尽可能少的碰撞。</li>
</ul>
<p><strong>测试</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_hashMap03</span><span class="params">()</span> &#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap03ByOpenAddressing</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;01&quot;</span>, <span class="string">&quot;花花&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;05&quot;</span>, <span class="string">&quot;豆豆&quot;</span>);</span><br><span class="line">    logger.info(<span class="string">&quot;碰撞前 key：&#123;&#125; value：&#123;&#125;&quot;</span>, <span class="string">&quot;01&quot;</span>, map.get(<span class="string">&quot;01&quot;</span>));</span><br><span class="line">    <span class="comment">// 下标碰撞</span></span><br><span class="line">    map.put(<span class="string">&quot;09&quot;</span>, <span class="string">&quot;蛋蛋&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;12&quot;</span>, <span class="string">&quot;苗苗&quot;</span>);</span><br><span class="line">    logger.info(<span class="string">&quot;碰撞前 key：&#123;&#125; value：&#123;&#125;&quot;</span>, <span class="string">&quot;01&quot;</span>, map.get(<span class="string">&quot;01&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/algorithms-220824-09.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">07</span>:<span class="number">20</span>:<span class="number">22.382</span> [main] INFO cn.bugstack.algorithms.test.AlgorithmsTest - 碰撞前 key：<span class="number">01</span> value：花花</span><br><span class="line"><span class="number">07</span>:<span class="number">20</span>:<span class="number">22.387</span> [main] INFO cn.bugstack.algorithms.test.AlgorithmsTest - 碰撞前 key：<span class="number">01</span> value：花花</span><br><span class="line"><span class="number">07</span>:<span class="number">20</span>:<span class="number">22.387</span> [main] INFO cn.bugstack.algorithms.test.AlgorithmsTest - 数据结构：HashMap&#123;tab=[<span class="literal">null</span>,&#123;<span class="string">&quot;key&quot;</span>:<span class="string">&quot;01&quot;</span>,<span class="string">&quot;value&quot;</span>:<span class="string">&quot;花花&quot;</span>&#125;,&#123;<span class="string">&quot;key&quot;</span>:<span class="string">&quot;09&quot;</span>,<span class="string">&quot;value&quot;</span>:<span class="string">&quot;蛋蛋&quot;</span>&#125;,&#123;<span class="string">&quot;key&quot;</span>:<span class="string">&quot;12&quot;</span>,<span class="string">&quot;value&quot;</span>:<span class="string">&quot;苗苗&quot;</span>&#125;,<span class="literal">null</span>,&#123;<span class="string">&quot;key&quot;</span>:<span class="string">&quot;05&quot;</span>,<span class="string">&quot;value&quot;</span>:<span class="string">&quot;豆豆&quot;</span>&#125;,<span class="literal">null</span>,<span class="literal">null</span>]&#125;</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>通过测试结果可以看到，开放寻址对碰撞元素的寻址存放，也是可用解决哈希索引冲突问题的。</li>
</ul>
<h2 id="四-常见面试问题"><a class="markdownIt-Anchor" href="#四-常见面试问题">#</a> 四、常见面试问题</h2>
<ul>
<li>
<p>介绍一下散列表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答：散列表（Hash Table）是一种基于哈希函数进行快速访问的数据结构，具有极高的查询和插入效率。它的基本思想是将要存储的数据元素通过哈希函数映射到一个固定的位置上，然后在该位置上进行查找或插入操作</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>为什么使用散列表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答：散列表之所以被广泛使用，是因为它可以支持常数级别的查询、插入和删除操作，这使得它非常适合于处理大规模数据和实时数据的场景。例如，在搜索引擎中，需要对数十亿条数据进行快速检索，散列表就是一种很好的选择。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>拉链寻址和开放寻址的区别</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">答：散列表的主要问题是哈希冲突，在不同的键被映射到同一个位置上时，就会产生哈希冲突。为了解决哈希冲突，常见的方法有拉链法和开放寻址。</span><br><span class="line"></span><br><span class="line">拉链法是指在哈希表中的每个位置上维护一个链表，当多个键映射到同一个位置时，它们会被保存在该位置对应的链表上。查找某个键时，先根据哈希函数计算出该键在哈希表中的位置，然后在该位置对应的链表上进行查找。</span><br><span class="line"></span><br><span class="line">开放寻址是指当发生哈希冲突时，通过探测（probing）寻找哈希表中下一个空的位置，直到找到可以存储该键的位置或者遍历了整个哈希表。具体的探测方法包括线性探测、二次探测、双重哈希等。查找某个键时，计算该键在哈希表中的位置，并在该位置及其后续位置上进行查找。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>还有其他什么方式可以解决散列哈希索引冲突</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答：除了拉链法和开放寻址，还有一些其他方式可以解决哈希冲突，如再哈希法、建立公共溢出区等。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对应的 Java 源码中，对于哈希索引冲突提供了什么样的解决方案</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答：在 Java 中，对于哈希索引冲突，一般使用拉链法来处理。Java 的 HashMap 和 Hashtable 都采用了拉链法，并支持动态扩容和缩容，以适应不同的数据规模。同时，为了提高查询效率，在 Java 8 中，HashMap 还引入了红黑树，用于优化链表长度过长的情形。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="关于我"><a class="markdownIt-Anchor" href="#关于我">#</a> 关于我</h2>
<p>Brath 是一个热爱技术的 Java 程序猿，公众号「InterviewCoder」定期分享有趣有料的精品原创文章！</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png" alt="InterviewCoder"></p>
<p>非常感谢各位人才能看到这里，原创不易，文章如果有帮助可以关注、点赞、分享或评论，这都是对我的莫大支持！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-05-06T07:53:40.000Z" title="2022-5-6 15:53:40">2022-05-06</time>发表</span><span class="level-item"><time dateTime="2023-05-23T03:40:19.401Z" title="2023-5-23 11:40:19">2023-05-23</time>更新</span><span class="level-item">17 分钟读完 (大约2577个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/05/06/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0ArrayList/">【数据结构】手写实现ArrayList</a></p><div class="content"><p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png" alt="InterviewCoder"></p>
<h1 id="数据结构手写实现arraylist"><a class="markdownIt-Anchor" href="#数据结构手写实现arraylist">#</a> 【数据结构】手写实现 ArrayList</h1>
<h2 id="一-前言"><a class="markdownIt-Anchor" href="#一-前言">#</a> 一、前言</h2>
<h3 id="数组是数据结构还是数据类型"><a class="markdownIt-Anchor" href="#数组是数据结构还是数据类型">#</a> 数组是数据结构还是数据类型？</h3>
<p>数组只是个名称，它可以描述一组操作，也可以命名这组操作。数组的数据操作，是通过 idx-&gt;val 的方式来处理。它不是具体要求内存上要存储着连续的数据才叫数组，而是说，通过连续的索引 idx，也可以线性访问相邻的数据。</p>
<p>那么当你定义了数据的存储方式，也就定义了数据结构。所以它也是被归类为数据结构。</p>
<h2 id="二-数组数据结构"><a class="markdownIt-Anchor" href="#二-数组数据结构">#</a> 二、数组数据结构</h2>
<p>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型数据的集合。</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/algorithms-220730-01.png" alt="img"></p>
<p>数组的特点：</p>
<ol>
<li>数组是相同数据类型的元素集合（int 不能存放 double）</li>
<li>数组中各元素的存储是有先后顺序的，它们在内存中按照这个顺序连续存放到一起。内存地址连续。</li>
<li>数组获取元素的时间复杂度为 O (1)</li>
</ol>
<h3 id="1-一维数组"><a class="markdownIt-Anchor" href="#1-一维数组">#</a> 1. 一维数组</h3>
<p>一维数组是最常用的数组，其他很多数据结构的变种也都是从一维数组来的。例如 HashMap 的拉链寻址结构，ThreadLocal 的开放寻址结构，都是从一维数组上实现的。</p>
<h3 id="2-二维数组"><a class="markdownIt-Anchor" href="#2-二维数组">#</a> 2. 二维数组</h3>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/algorithms-220730-02.png" alt="img"></p>
<p>二维以及多维数组，在开发场景中使用到的到是不多，不过在一些算法逻辑，数学计算中到是可以使用。</p>
<h2 id="三-实现数组列表"><a class="markdownIt-Anchor" href="#三-实现数组列表">#</a> 三、实现数组列表</h2>
<p>在 Java 的源码中，数组是一个非常常用的数据结构，很多其他数据结构也都有数组的影子。</p>
<h3 id="1-基本设计"><a class="markdownIt-Anchor" href="#1-基本设计">#</a> 1. 基本设计</h3>
<p>数组是一个固定的、连续的、线性的数据结构，那么想把它作为一个自动扩展容量的数组列表，则需要做一些扩展。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始化空间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList 元素数组缓存区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure>
<ol>
<li>初始化 ArrayList 阶段，如果不指定大小，默认会初始化一个空的元素。这个时候是没有默认长度的。</li>
<li>那么什么时候给初始化的长度呢？是在首次添加元素的时候，因为所有的添加元素操作，也都是需要判断容量，以及是否扩容的。那么在 add 添加元素时统一完成这个事情，还是比较好处理的。</li>
<li>之后就是随着元素的添加，容量是会不足的。当容量不足的是，需要进行扩容操作。同时还得需要把旧数据迁移到新的数组上。<em>所以数据的迁移算是一个比较耗时的操作</em></li>
</ol>
<h3 id="2-添加元素"><a class="markdownIt-Anchor" href="#2-添加元素">#</a> 2. 添加元素</h3>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/algorithms-220730-03.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 确保内部容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">minCapacity</span> <span class="operator">=</span> size + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断扩容操作</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        &#125;</span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这是一份简化后的 ArrayList#add 操作</strong></p>
<ol>
<li>判断当前容量与初始化容量，使用 Math.max 函数取最大值最为最小初始化空间。</li>
<li>接下来是判断 minCapacity 和元素的数量，是否达到了扩容。首次创建 ArrayList 是一定会扩容的，也就是初始化 DEFAULT_CAPACITY = 10 的容量。</li>
<li>Arrays.copyOf 实际上是创建一个新的空间数组，之后调用的 System.arraycopy 迁移到新创建的数组上。这样后续所有的扩容操作，也就都保持统一了。</li>
<li>ArrayList 扩容完成后，就是使用 elementData [size++] = e; 添加元素操作了。</li>
</ol>
<h3 id="3-移除元素"><a class="markdownIt-Anchor" href="#3-移除元素">#</a> 3. 移除元素</h3>
<p>ArrayList 的重点离不开对 System.arraycopy 的使用，它是一个本地方法，可以让你从原数组的特定位置，迁移到新数组的指定位置和迁移数量。如图 2-5 所示，数据迁移 <em>测试代码在 java-algorithms</em></p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/algorithms-220730-05.png" alt="img"></p>
<p><strong>删除元素</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> (E) elementData[index];</span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 从原始数组的某个位置，拷贝到目标对象的某个位置开始后n个元素</span></span><br><span class="line">        System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    &#125;</span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ArrayList 的元素删除，就是在确定出元素位置后，使用 System.arraycopy 拷贝数据方式移动数据，把需要删除的元素位置覆盖掉。</li>
<li>此外它还会把已经删除的元素设置为 null 一方面让我们不会在读取到这个元素，另外一方面也是为了 GC</li>
</ul>
<h3 id="4-获取元素"><a class="markdownIt-Anchor" href="#4-获取元素">#</a> 4. 获取元素</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ArrayList&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;elementData=&quot;</span> + Arrays.toString(elementData) +</span><br><span class="line">            <span class="string">&quot;, size=&quot;</span> + size +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<ul>
<li>获取元素就比较简单了，直接从 elementData 使用索引直接获取即可。这个是一个 O (1) 操作。也正因为搜索元素的便捷性，才让 ArrayList 使用的那么广泛。同时为了兼容可以通过元素来获取数据，而不是直接通过下标，引出了 HashMap 使用哈希值计算下标的计算方式，也引出了斐波那契散列。它们的设计都是在尽可能减少元素碰撞的情况下，尽可能使用贴近 O (1) 的时间复杂度获取数据。<em>这些内容的学习可以阅读小傅哥的《Java 面经手册》也可以随着本系列章节内容的铺设逐步覆盖到算法后进行学习</em></li>
</ul>
<h2 id="四-数组列表测试"><a class="markdownIt-Anchor" href="#四-数组列表测试">#</a> 四、数组列表测试</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_array_list</span><span class="params">()</span> &#123;</span><br><span class="line">    cn.bugstack.algorithms.data.array.List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;01&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;02&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;03&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;04&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;05&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;06&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;07&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;08&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;09&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;10&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;11&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;12&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(list);</span><br><span class="line">    </span><br><span class="line">    list.remove(<span class="number">9</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试结果</strong></p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/algorithms-220730-06.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&#123;elementData=[<span class="number">01</span>, <span class="number">02</span>, <span class="number">03</span>, <span class="number">04</span>, <span class="number">05</span>, <span class="number">06</span>, <span class="number">07</span>, 08, 09, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>], size=<span class="number">12</span>&#125;</span><br><span class="line">ArrayList&#123;elementData=[<span class="number">01</span>, <span class="number">02</span>, <span class="number">03</span>, <span class="number">04</span>, <span class="number">05</span>, <span class="number">06</span>, <span class="number">07</span>, 08, 09, <span class="number">11</span>, <span class="number">12</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>], size=<span class="number">11</span>&#125;</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>测试案例中包括了在我们自己实现的 ArrayList 中顺序添加元素，逐步测试扩容迁移元素，以及删除元素后数据的迁移。</li>
<li>最终的测试结果可以看到，一共有 12 个元素，其中 idx=9 的元素被删除前后，元素的迁移变化。</li>
</ul>
<h2 id="六-常见面试问题"><a class="markdownIt-Anchor" href="#六-常见面试问题">#</a> 六、常见面试问题</h2>
<p>数据结构中有哪些是线性表数据结构？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答：线性表数据结构是指一种特殊的数据结构，其中数据元素之间存在线性关系。常见的线性表数据结构包括：数组、链表、栈和队列等。</span><br></pre></td></tr></table></figure>
<p>数组的元素删除和获取，时间复杂度是多少？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答：数组的元素删除和获取的时间复杂度均为O(1)，因为数组中的元素是连续存储的，并且可以通过下标直接访问元素。删除操作通常是将待删除元素后面的所有元素向前移动一位，然后将数组长度减一；获取操作则是直接返回对应下标的元素值。</span><br></pre></td></tr></table></figure>
<p>ArrayList 中默认的初始化长度是多少？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答：ArrayList 中默认的初始化长度是10。在创建一个新的 ArrayList 对象时，如果没有指定初始容量，那么就会使用默认容量 10 创建一个空数组。</span><br></pre></td></tr></table></figure>
<p>ArrayList 中扩容的范围是多大一次？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答：ArrayList 中扩容的范围是每次增加原来数组大小的一半。当 ArrayList 容量不足以容纳更多元素时，就会自动进行扩容操作。具体来说，ArrayList 扩容时会创建一个新的数组，其大小为原来数组大小的 1.5 倍，然后将原来数组中的元素复制到新数组中。该扩容策略可以保证 ArrayList 在大多数情况下都只需要进行少数几次扩容操作。</span><br></pre></td></tr></table></figure>
<p>ArrayList 是如何完成扩容的，System.arraycopy 各个入参的作用是什么？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">ArrayList 是通过 System.arraycopy() 方法完成扩容操作的。具体实现过程如下：</span><br><span class="line"></span><br><span class="line">1.当添加新元素时，如果当前内部数组已经满了，就需要进行扩容操作。</span><br><span class="line">2.首先计算出新数组的大小，其大小为原有数组大小的 1.5 倍。</span><br><span class="line">3.创建一个新的数组，并将原有数组中的元素复制到新数组中。这里使用 System.arraycopy() 方法来完成元素的复制操作，第一个参数是原数组，第二个参数是原数组中需要复制的起始位置，第三个参数是目标数组，第四个参数是目标数组中存放复制数据的起始位置，第五个参数是需要复制的元素个数。</span><br><span class="line">4.最后，将 ArrayList 的内部数组设置为新数组。</span><br><span class="line"></span><br><span class="line">System.arraycopy() 方法具有较高的效率，因为它可以直接利用底层系统级别的内存复制机制进行数据复制，避免了通过循环逐个复制元素的低效率问题。</span><br></pre></td></tr></table></figure>
<h2 id="关于我"><a class="markdownIt-Anchor" href="#关于我">#</a> 关于我</h2>
<p>Brath 是一个热爱技术的 Java 程序猿，公众号「InterviewCoder」定期分享有趣有料的精品原创文章！</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png" alt="InterviewCoder"></p>
<p>非常感谢各位人才能看到这里，原创不易，文章如果有帮助可以关注、点赞、分享或评论，这都是对我的莫大支持！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-05-06T05:53:40.000Z" title="2022-5-6 13:53:40">2022-05-06</time>发表</span><span class="level-item"><time dateTime="2023-05-23T03:40:24.894Z" title="2023-5-23 11:40:24">2023-05-23</time>更新</span><span class="level-item">16 分钟读完 (大约2436个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/05/06/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0LinkedList/">【数据结构】手写实现LinkedList</a></p><div class="content"><p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png" alt=""></p>
<h1 id="数据结构手写实现linkedlist"><a class="markdownIt-Anchor" href="#数据结构手写实现linkedlist">#</a> 【数据结构】手写实现 LinkedList</h1>
<h2 id="一-前言"><a class="markdownIt-Anchor" href="#一-前言">#</a> 一、前言</h2>
<h4 id="链表的历史"><a class="markdownIt-Anchor" href="#链表的历史">#</a> 链表的历史</h4>
<p>于 1955-1956 年，由兰德公司的 Allen Newell、Cliff Shaw 和 Herbert A. Simon 开发了链表，作为他们的信息处理语言的主要数据结构。链表的另一个早期出现是由 Hans Peter Luhn 在 1953 年 1 月编写的 IBM 内部备忘录建议在链式哈希表中使用链表。</p>
<p>到 1960 年代初，链表和使用这些结构作为主要数据表示的语言的实用性已经很好地建立起来。MIT 林肯实验室的 Bert Green 于 1961 年 3 月在 IRE Transactions on Human Factors in Electronics 上发表了一篇题为 “用于符号操作的计算机语言” 的评论文章，总结了链表方法的优点。1964 年 4 月，Bobrow 和 Raphael 的一篇评论文章 “列表处理计算机语言的比较” 发表在 ACM 通讯中。</p>
<h2 id="二-链表数据结构"><a class="markdownIt-Anchor" href="#二-链表数据结构">#</a> 二、链表数据结构</h2>
<p>在计算机科学中，链表是数据元素的线性集合，元素的线性顺序不是由它们在内存中的物理地址给出的。它是由一组节点组成的数据结构，每个元素指向下一个元素，这些节点一起，表示线性序列。</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/algorithms-220723-01.png" alt="img"></p>
<p>在最简单的链表结构下，每个节点由数据和指针（存放指向下一个节点的指针）两部分组成，这种数据结构允许在迭代时有效地从序列中的任何位置插入或删除元素。</p>
<p>链表的数据结构通过链的连接方式，提供了可以不需要扩容空间就更高效的插入和删除元素的操作，在适合的场景下它是一种非常方便的数据结构。但在一些需要遍历、指定位置操作、或者访问任意元素下，是需要循环遍历的，这将导致时间复杂度的提升。</p>
<h2 id="三-链表分类类型"><a class="markdownIt-Anchor" href="#三-链表分类类型">#</a> 三、链表分类类型</h2>
<p>链表的主要表现形式分为；单向链表、双向链表、循环链表，接下来我们分别介绍下。</p>
<h3 id="1-单向链表"><a class="markdownIt-Anchor" href="#1-单向链表">#</a> 1. 单向链表</h3>
<p>单链表包含具有数据字段的节点以及指向节点行中的下一个节点的 “下一个” 字段。可以对单链表执行的操作包括插入、删除和遍历。</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/algorithms-220723-02.png" alt="img"></p>
<h3 id="2-双向链表"><a class="markdownIt-Anchor" href="#2-双向链表">#</a> 2. 双向链表</h3>
<p>在 “双向链表” 中，除了下一个节点链接之外，每个节点还包含指向序列中 “前一个” 节点的第二个链接字段。这两个链接可以称为’forward（‘s’）和’backwards’，或’next’和’prev’（‘previous’）。</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/algorithms-220723-03.png" alt="img"></p>
<h3 id="3-循环链表"><a class="markdownIt-Anchor" href="#3-循环链表">#</a> 3. 循环链表</h3>
<p>在列表的最后一个节点中，链接字段通常包含一个空引用，一个特殊的值用于指示缺少进一步的节点。一个不太常见的约定是让它指向列表的第一个节点。在这种情况下，列表被称为 “循环” 或 “循环链接”；否则，它被称为 “开放” 或 “线性”。它是一个列表，其中最后一个指针指向第一个节点。</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/algorithms-220723-04.png" alt="img"></p>
<h2 id="四-实现一个链表"><a class="markdownIt-Anchor" href="#四-实现一个链表">#</a> 四、实现一个链表</h2>
<h3 id="1-链表节点"><a class="markdownIt-Anchor" href="#1-链表节点">#</a> 1. 链表节点</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>链表的数据结构核心根基就在于节点对象的使用，并在节点对象中关联当前节点的上一个和下一个节点。通过这样的方式构建出链表结构。</li>
<li>但也因为在链表上添加每个元素的时候，都需要创建新的 Node 节点，所以这也是一部分耗时的操作。</li>
</ul>
<h3 id="2-头插节点"><a class="markdownIt-Anchor" href="#2-头插节点">#</a> 2. 头插节点</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">linkFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>, e, f);</span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/algorithms-220723-05.png" alt="img"></p>
<ul>
<li>头插的操作流程，先把头节点记录下来。之后创建一个新的节点，新的节点构造函数的头节点入参为 null，通过这样的方式构建出一个新的头节点。</li>
<li>原来的头结点，设置 f.prev 连接到新的头节点，这样的就可以完成头插的操作了。另外如果原来就没有头节点，头节点设置为新的节点即可。最后记录当前链表中节点的数量，也就是你使用 LinkedList 获取 size 时候就是从这个值获取的。</li>
</ul>
<h3 id="3-尾插节点"><a class="markdownIt-Anchor" href="#3-尾插节点">#</a> 3. 尾插节点</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>) &#123;</span><br><span class="line">        first = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/algorithms-220723-06.png" alt="img"></p>
<ul>
<li>尾差节点与头插节点正好相反，通过记录当前的结尾节点，创建新的节点，并把当前的结尾节点，通过 l.next 关联到新创建的节点上。同时记录 size 节点数量值。</li>
</ul>
<h3 id="4-拆链操作"><a class="markdownIt-Anchor" href="#4-拆链操作">#</a> 4. 拆链操作</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">unlink</span><span class="params">(Node&lt;E&gt; x)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x.item = <span class="literal">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/algorithms-220723-07.png" alt="img"></p>
<ul>
<li>unlink 是一种拆链操作，只要你给定一个元素，它就可以把当前这个元素的上一个节点和一个节点进行相连，之后把自己拆除。</li>
<li>这个方法常用于 remove 移除元素操作，因为整个操作过程不需要遍历，拆除元素后也不需要复制新的空间，所以时间复杂读为 O (1)</li>
</ul>
<h3 id="5-删除节点"><a class="markdownIt-Anchor" href="#5-删除节点">#</a> 5. 删除节点</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="literal">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/algorithms-220723-08.png" alt="img"></p>
<ul>
<li>删除元素的过程需要 for 循环判断比删除元素的值，找到对应的元素，进行删除。</li>
<li>循环比对的过程是一个 O (n) 的操作，删除的过程是一个 O (1) 的操作。所以如果这个链表较大，删除的元素又都是贴近结尾，那么这个循环比对的过程也是比较耗时的。</li>
</ul>
<h2 id="五-链表使用测试"><a class="markdownIt-Anchor" href="#五-链表使用测试">#</a> 五、链表使用测试</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    list.addFirst(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    list.addLast(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    <span class="comment">// 打印列表</span></span><br><span class="line">    list.printLinkList();</span><br><span class="line">    <span class="comment">// 头插元素</span></span><br><span class="line">    list.addFirst(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    list.remove(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    <span class="comment">// 打印列表</span></span><br><span class="line">    list.printLinkList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试结果</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">目前的列表，头节点：b 尾节点：c 整体：b，a，c，</span><br><span class="line">目前的列表，头节点：d 尾节点：c 整体：d，a，c，</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>按照我们的测试链表对数据的操作过程，从测试结果可以看到，已经满足了链表数据结构的使用。</li>
</ul>
<h2 id="六-常见面试问题"><a class="markdownIt-Anchor" href="#六-常见面试问题">#</a> 六、常见面试问题</h2>
<ul>
<li>
<p>描述一下链表的数据结构？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">链表是一种常见的数据结构，用于按顺序存储和访问元素集合。它由多个节点组成，每个节点包含两个部分：数据和指向下一个节点的指针。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Java 中 LinkedList 使用的是单向链表、双向链表还是循环链表？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">Java 中的 LinkedList 使用的是双向链表，每个节点都有一个指向前置节点和后继节点的指针。这使得在 LinkedList 中进行插入和删除操作的效率比 ArrayList 更高。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>链表中数据的插入、删除、获取元素，时间复杂度是多少？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">插入元素（O(n)）：</span><br><span class="line">在链表中插入一个元素通常需要执行以下操作：</span><br><span class="line">在待插入位置之前查找元素O(n)</span><br><span class="line">将新元素插入到该位置O(1)</span><br><span class="line">因此，插入元素的时间复杂度是O(n)。</span><br><span class="line"></span><br><span class="line">删除元素（O(n)）：</span><br><span class="line">在链表中删除一个元素通常需要执行以下操作：</span><br><span class="line">在待删除位置之前查找元素O(n)</span><br><span class="line">删除该位置上的元素O(1)</span><br><span class="line">因此，删除元素的时间复杂度也是O(n)。</span><br><span class="line"></span><br><span class="line">获取元素（O(n)）：</span><br><span class="line">在链表中获取一个元素通常需要遍历整个链表，直到找到目标元素。</span><br><span class="line">因此，获取元素的时间复杂度也是O(n)。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>什么场景下使用链表更合适？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">1.频繁的进行插入和删除操作</span><br><span class="line">2.不需要随机访问元素</span><br><span class="line">3.单纯的遍历操作</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="关于我"><a class="markdownIt-Anchor" href="#关于我">#</a> 关于我</h2>
<p>Brath 是一个热爱技术的 Java 程序猿，公众号「InterviewCoder」定期分享有趣有料的精品原创文章！</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png" alt="InterviewCoder"></p>
<p>非常感谢各位人才能看到这里，原创不易，文章如果有帮助可以关注、点赞、分享或评论，这都是对我的莫大支持！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-05-05T05:58:11.000Z" title="2022-5-5 13:58:11">2022-05-05</time>发表</span><span class="level-item"><time dateTime="2023-05-23T03:40:43.418Z" title="2023-5-23 11:40:43">2023-05-23</time>更新</span><span class="level-item">16 分钟读完 (大约2361个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/05/05/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/">【算法】算法的时间与空间复杂度</a></p><div class="content"><p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png" alt="InterviewCoder"></p>
<h1 id="算法算法的时间与空间复杂度"><a class="markdownIt-Anchor" href="#算法算法的时间与空间复杂度">#</a> 【算法】算法的时间与空间复杂度</h1>
<h4 id="算法algorithm是指用来操作数据-解决程序问题的一组方法-对于同一个问题使用不同的算法也许最终得到的结果是一样的但在过程中消耗的资源和时间却会有很大的区别"><a class="markdownIt-Anchor" href="#算法algorithm是指用来操作数据-解决程序问题的一组方法-对于同一个问题使用不同的算法也许最终得到的结果是一样的但在过程中消耗的资源和时间却会有很大的区别">#</a> 算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，但在过程中消耗的资源和时间却会有很大的区别。</h4>
<h4 id="那么我们应该如何去衡量不同算法之间的优劣呢"><a class="markdownIt-Anchor" href="#那么我们应该如何去衡量不同算法之间的优劣呢">#</a> 那么我们应该如何去衡量不同算法之间的优劣呢？</h4>
<p>主要还是从算法所占用的「时间」和「空间」两个维度去考量。</p>
<ul>
<li>时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。</li>
<li>空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。</li>
</ul>
<p>因此，评价一个算法的效率主要是看它的时间复杂度和空间复杂度情况。然而，有的时候时间和空间却又是「鱼和熊掌」，不可兼得的，那么我们就需要从中去取一个平衡点。</p>
<p>下面我来分别介绍一下「时间复杂度」和「空间复杂度」的计算方式。</p>
<h2 id="一-时间复杂度"><a class="markdownIt-Anchor" href="#一-时间复杂度">#</a> <strong>一、时间复杂度</strong></h2>
<p>我们想要知道一个算法的「时间复杂度」，很多人首先想到的的方法就是把这个算法程序运行一遍，那么它所消耗的时间就自然而然知道了。</p>
<p>这种方式可以吗？当然可以，不过它也有很多弊端。<br>
这种方式非常容易受运行环境的影响，在性能高的机器上跑出来的结果与在性能低的机器上跑的结果相差会很大。而且对测试时使用的数据规模也有很大关系。再者，并我们在写算法的时候，还没有办法完整的去运行呢。</p>
<p>因此，另一种更为通用的方法就出来了：「 <strong>大 O 符号表示法</strong> 」，即 T (n) = O (f (n))</p>
<p>我们先来看个例子：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(i=1; i&lt;=n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">   j = i;</span><br><span class="line">   j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过「 大 O 符号表示法 」，这段代码的时间复杂度为：O (n) ，为什么呢？</p>
<p>在 大 O 符号表示法中，时间复杂度的公式是： T (n) = O ( f (n) )，其中 f (n) 表示每行代码执行次数之和，而 O 表示正比例关系，这个公式的全称是：<strong>算法的渐进时间复杂度</strong>。</p>
<p>我们继续看上面的例子，假设每行代码的执行时间都是一样的，我们用 1 颗粒时间 来表示，那么这个例子的第一行耗时是 1 个颗粒时间，第三行的执行时间是 n 个颗粒时间，第四行的执行时间也是 n 个颗粒时间（第二行和第五行是符号，暂时忽略），那么总时间就是 1 颗粒时间 + n 颗粒时间 + n 颗粒时间 ，即 (1+2n) 个颗粒时间，即： T (n) = (1+2n)* 颗粒时间，从这个结果可以看出，这个算法的耗时是随着 n 的变化而变化，因此，我们可以简化的将这个算法的时间复杂度表示为：T (n) = O (n)</p>
<p>为什么可以这么去简化呢，因为大 O 符号表示法并不是用于来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的。</p>
<p>所以上面的例子中，如果 n 无限大的时候，T (n) = time (1+2n) 中的常量 1 就没有意义了，倍数 2 也意义不大。因此直接简化为 T (n) = O (n) 就可以了。</p>
<p>常见的时间复杂度量级有：</p>
<ul>
<li>常数阶 O (1)</li>
<li>对数阶 O (logN)</li>
<li>线性阶 O (n)</li>
<li>线性对数阶 O (nlogN)</li>
<li>平方阶 O (n²)</li>
<li>立方阶 O (n³)</li>
<li>K 次方阶 O (n^k)</li>
<li>指数阶 (2^n)</li>
</ul>
<p>上面从上至下依次的时间复杂度越来越大，执行的效率越来越低。</p>
<p>下面选取一些较为常用的来讲解一下（没有严格按照顺序）：</p>
<ol>
<li><strong>常数阶 O (1)</strong></li>
</ol>
<p>无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是 O (1)，如：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i = 1;</span><br><span class="line">int j = 2;</span><br><span class="line">++i;</span><br><span class="line">j++;</span><br><span class="line">int m = i + j;</span><br></pre></td></tr></table></figure>
<p>上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用 O (1) 来表示它的时间复杂度。</p>
<ol>
<li><strong>线性阶 O (n)</strong></li>
</ol>
<p>这个在最开始的代码示例中就讲解过了，如：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(i=1; i&lt;=n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">   j = i;</span><br><span class="line">   j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码，for 循环里面的代码会执行 n 遍，因此它消耗的时间是随着 n 的变化而变化的，因此这类代码都可以用 O (n) 来表示它的时间复杂度。</p>
<ol>
<li><strong>对数阶 O (logN)</strong></li>
</ol>
<p>还是先来看代码：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i = 1;</span><br><span class="line">while(i&lt;n)</span><br><span class="line">&#123;</span><br><span class="line">    i = i * 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码可以看到，在 while 循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。我们试着求解一下，假设循环 x 次之后，i 就大于 n 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2^n<br>
 也就是说当循环 log2^n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：<strong>O(logn)</strong></p>
<ol>
<li><strong>线性对数阶 O (nlogN)</strong></li>
</ol>
<p>线性对数阶 O (nlogN) 其实非常容易理解，将时间复杂度为 O (logn) 的代码循环 N 遍的话，那么它的时间复杂度就是 n * O (logN)，也就是了 O (nlogN)。</p>
<p>就拿上面的代码加一点修改来举例：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(m=1; m&lt;n; m++)</span><br><span class="line">&#123;</span><br><span class="line">    i = 1;</span><br><span class="line">    while(i&lt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        i = i * 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>平方阶 O (n²)</strong></li>
</ol>
<p>平方阶 O (n²) 就更容易理解了，如果把 O (n) 的代码再嵌套循环一遍，它的时间复杂度就是 O (n²) 了。<br>
举例：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(x=1; i&lt;=n; x++)</span><br><span class="line">&#123;</span><br><span class="line">   for(i=1; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       j = i;</span><br><span class="line">       j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码其实就是嵌套了 2 层 n 循环，它的时间复杂度就是 O (n*n)，即 O (n²)<br>
 如果将其中一层循环的 n 改成 m，即：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(x=1; i&lt;=m; x++)</span><br><span class="line">&#123;</span><br><span class="line">   for(i=1; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       j = i;</span><br><span class="line">       j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那它的时间复杂度就变成了 O (m*n)</p>
<ol>
<li><strong>立方阶 O (n³)</strong>、<strong>K 次方阶 O (n^k)</strong></li>
</ol>
<p>参考上面的 O (n²) 去理解就好了，O (n³) 相当于三层 n 循环，其它的类似。</p>
<p>除此之外，其实还有 平均时间复杂度、均摊时间复杂度、最坏时间复杂度、最好时间复杂度 的分析方法，有点复杂，这里就不展开了。</p>
<h2 id="二-空间复杂度"><a class="markdownIt-Anchor" href="#二-空间复杂度">#</a> <strong>二、空间复杂度</strong></h2>
<p>既然时间复杂度不是用来计算程序具体耗时的，那么我也应该明白，空间复杂度也不是用来计算程序实际占用的空间的。</p>
<p>空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S (n) 来定义。</p>
<p>空间复杂度比较常用的有：O (1)、O (n)、O (n²)，我们下面来看看：</p>
<ol>
<li><strong>空间复杂度 O (1)</strong></li>
</ol>
<p>如果算法执行所需要的临时空间不随着某个变量 n 的大小而变化，即此算法空间复杂度为一个常量，可表示为 O (1)<br>
 举例：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i = 1;</span><br><span class="line">int j = 2;</span><br><span class="line">++i;</span><br><span class="line">j++;</span><br><span class="line">int m = i + j;</span><br></pre></td></tr></table></figure>
<p>代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S (n) = O (1)</p>
<ol>
<li><strong>空间复杂度 O (n)</strong></li>
</ol>
<p>我们先看一个代码：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int[] m = new int[n]</span><br><span class="line">for(i=1; i&lt;=n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">   j = i;</span><br><span class="line">   j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中，第一行 new 了一个数组出来，这个数据占用的大小为 n，这段代码的 2-6 行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S (n) = O (n)</p>
<p>以上，就是对算法的时间复杂度与空间复杂度基础的分析，欢迎大家一起交流。</p>
<h2 id="关于我"><a class="markdownIt-Anchor" href="#关于我">#</a> 关于我</h2>
<p>Brath 是一个热爱技术的 Java 程序猿，公众号「InterviewCoder」定期分享有趣有料的精品原创文章！</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png" alt="InterviewCoder"></p>
<p>非常感谢各位人才能看到这里，原创不易，文章如果有帮助可以关注、点赞、分享或评论，这都是对我的莫大支持！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-27T13:50:38.000Z" title="2022-4-27 21:50:38">2022-04-27</time>发表</span><span class="level-item"><time dateTime="2020-05-21T22:25:35.000Z" title="2020-5-22 6:25:35">2020-05-22</time>更新</span><span class="level-item">3 分钟读完 (大约394个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/27/%E3%80%90MySQL%E3%80%91MySQL%E4%B8%BB%E4%BB%8E%E5%BC%80%E5%85%B3%E6%9C%BA%E9%A1%BA%E5%BA%8F/">【MySQL】MySQL主从开关机顺序</a></p><div class="content"><p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png" alt="InterviewCoder"></p>
<p>MySQL 主从开关机顺序<br>
停应用 -&gt; 停数据库（先备后主） -&gt; 改配置 -&gt; 启数据库（先主后备）-&gt; 启应用</p>
<p>关闭 MySQL 从库<br>
 a. 先查看当前的主从同步状态 show slave statusG; 看是否双 yes<br>
b. 执行 stop slave<br>
c. 停止从库服务 mysqladmin shutdown -u 用户名 -p 密码<br>
 d. 查看是否还有 mysql 的进程 ps -ef | grep mysql<br>
d. 如果部署了多个实例，那每个实例都要按照以上步骤来操作</p>
<p>关闭 MySQL 主库<br>
 a. 停止主库服务 mysqladmin shutdown -u 用户名 -p 密码<br>
 b. 查看是否还有 mysql 的进程 ps -ef | grep mysql</p>
<p>启动 MySQL 主库<br>
 a. 启动主库服务 mysqladmin start -u 用户名 -p 密码<br>
 b. 查看 mysql 的进程 ps -ef | grep mysql</p>
<p>启动 MySQL 从库<br>
 a. 启动从库服务 mysqladmin start -u 用户名 -p 密码<br>
 b. 启动复制 start slave;<br>
c. 检查同步状态 show slave statusG; 是否双 yes<br>
d. 查看 mysql 的进程 ps -ef | grep mysql</p>
<h2 id="关于我"><a class="markdownIt-Anchor" href="#关于我">#</a> 关于我</h2>
<p>Brath 是一个热爱技术的 Java 程序猿，公众号「InterviewCoder」定期分享有趣有料的精品原创文章！</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png" alt="InterviewCoder"></p>
<p>非常感谢各位人才能看到这里，原创不易，文章如果有帮助可以关注、点赞、分享或评论，这都是对我的莫大支持！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-26T04:23:33.000Z" title="2022-4-26 12:23:33">2022-04-26</time>发表</span><span class="level-item"><time dateTime="2023-05-23T03:40:38.821Z" title="2023-5-23 11:40:38">2023-05-23</time>更新</span><span class="level-item">4 分钟读完 (大约611个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/26/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E4%BD%BF%E7%94%A8Java%E5%AE%9E%E7%8E%B0%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%8C%E5%A4%AA%E9%85%B7%E5%95%A6/">【算法】使用Java实现斐波那契数列的三种方法，太酷啦</a></p><div class="content"><p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png" alt="InterviewCoder"></p>
<h1 id="算法使用java实现斐波那契数列的三种方法太酷啦"><a class="markdownIt-Anchor" href="#算法使用java实现斐波那契数列的三种方法太酷啦">#</a> 【算法】使用 Java 实现斐波那契数列的三种方法，太酷啦</h1>
<h2 id="java实现斐波那契数列的三种方法"><a class="markdownIt-Anchor" href="#java实现斐波那契数列的三种方法">#</a> Java 实现<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91&amp;spm=1001.2101.3001.7020">斐波那契</a>数列的三种方法</h2>
<p><strong>什么是斐波那契数列</strong></p>
<ul>
<li>这里借用一下度娘的一段话：斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多・斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为 “兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……<br>
 其规律很明显，从第 3 个数开始，每个数都等于它前两个数的和。<br>
那么通过 java 可以如何实现斐波那契数列呢？这里介绍三种方法。</li>
<li>通过代码实现以下效果：当你输入 n 时，会获取斐波那契数列的第 n 个数的值。</li>
</ul>
<h4 id="1for循环实现"><a class="markdownIt-Anchor" href="#1for循环实现">#</a> <strong>1.for 循环实现</strong></h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   	<span class="type">int</span>[] fib = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">   	fib[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">   	fib[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">       fib[i] = fib[i-<span class="number">1</span>] + fib[i-<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fib[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2平方根实现"><a class="markdownIt-Anchor" href="#2平方根实现">#</a> <strong>2. 平方根实现</strong></h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">     <span class="type">double</span> <span class="variable">goldenRatio</span> <span class="operator">=</span> (<span class="number">1</span> + Math.sqrt(<span class="number">5</span>)) / <span class="number">2</span>;</span><br><span class="line">     <span class="keyword">return</span> (<span class="type">int</span>) Math.round(Math.pow(goldenRatio, n) / Math.sqrt(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3矩阵快速幂实现"><a class="markdownIt-Anchor" href="#3矩阵快速幂实现">#</a> 3. 矩阵快速幂实现</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[][] base = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span>[][] result = pow(base, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[][] pow(<span class="type">int</span>[][] base, <span class="type">int</span> power) &#123;</span><br><span class="line">    <span class="type">int</span>[][] result = <span class="keyword">new</span> <span class="title class_">int</span>[base.length][base.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; base.length; i++) &#123;</span><br><span class="line">        result[i][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (power &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (power % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            result = multiply(result, base);</span><br><span class="line">        &#125;</span><br><span class="line">        base = multiply(base, base);</span><br><span class="line">        power /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[][] multiply(<span class="type">int</span>[][] a, <span class="type">int</span>[][] b) &#123;</span><br><span class="line">    <span class="type">int</span>[][] c = <span class="keyword">new</span> <span class="title class_">int</span>[a.length][b[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; b[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; b.length; k++) &#123;</span><br><span class="line">                c[i][j] += a[i][k] * b[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK，到这里 java 实现斐波那契数列的三种写法就全部写完了，如果大家还有其他方法，欢迎交流～</p>
<h2 id="关于我"><a class="markdownIt-Anchor" href="#关于我">#</a> 关于我</h2>
<p>Brath 是一个热爱技术的 Java 程序猿，公众号「InterviewCoder」定期分享有趣有料的精品原创文章！</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png" alt="InterviewCoder"></p>
<p>非常感谢各位人才能看到这里，原创不易，文章如果有帮助可以关注、点赞、分享或评论，这都是对我的莫大支持！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-26T04:23:33.000Z" title="2022-4-26 12:23:33">2022-04-26</time>发表</span><span class="level-item"><time dateTime="2023-05-23T03:40:34.031Z" title="2023-5-23 11:40:34">2023-05-23</time>更新</span><span class="level-item">11 分钟读完 (大约1676个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/26/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E7%9A%84%E6%A6%82%E5%BF%B5/">【算法】斐波那契数列的概念</a></p><div class="content"><p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png" alt="InterviewCoder"></p>
<h1 id="算法斐波那契数列的概念"><a class="markdownIt-Anchor" href="#算法斐波那契数列的概念">#</a> 【算法】斐波那契数列的概念</h1>
<h1 id="斐波那契数列的概念"><a class="markdownIt-Anchor" href="#斐波那契数列的概念">#</a> <strong>斐波那契数列的概念</strong></h1>
<p>​    <strong>斐波那契数列（Fibonacci sequence）</strong>，又称<strong>黄金分割数列</strong>，因数学家莱昂纳多・斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为 “<strong>兔子数列</strong>”。</p>
<p>​    <strong>斐波那契数列</strong>指的是这样一个数列：</p>
<p>​    0，1，1，2，3，5，8，13，21，34，55，89，144，233，377，610，987，1597，2584，4181，6765，10946，17711……</p>
<p>​    它的规律是：<strong>这个数列从第 3 项开始，每一项都等于前两项之和。</strong></p>
<p>​    在数学上，斐波那契数列以如下被以递推的方法定义：<em><strong>F*(0)=0，*F*(1)=1, *F*(n)=*F*(n - 1)+*F*(n - 2)（*n* ≥ 2，*n* ∈ N*）</strong>，显然，斐波那契数列是一个</em><em>线性递推数列</em> *。</p>
<hr>
<h1 id="斐波那契数列的实现"><a class="markdownIt-Anchor" href="#斐波那契数列的实现">#</a> <strong>斐波那契数列的实现</strong></h1>
<p>​    常用的<strong>实现斐波那契数列的方法</strong>分为两大类：<strong>递归和循环。</strong></p>
<h1 id="1-递归实现"><a class="markdownIt-Anchor" href="#1-递归实现">#</a> <strong>1. 递归实现</strong></h1>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20210730212031150.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int F(int n) //斐波那契数列函数 递归形式</span><br><span class="line">&#123;</span><br><span class="line">    if(n == 0) //初始化</span><br><span class="line">		return 0;</span><br><span class="line">	if(n == 1 || n == 2)</span><br><span class="line">		return 1;</span><br><span class="line">    return F(n-1) + F(n-2);  //如果n != 1 &amp;&amp; n != 2 进行递归运算</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t,n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)</span><br><span class="line">    &#123;</span><br><span class="line">    	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    	printf(&quot;%d\n&quot;, F(n));</span><br><span class="line">	&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="2-迭代实现优先使用"><a class="markdownIt-Anchor" href="#2-迭代实现优先使用">#</a> <strong>2. 迭代实现（<strong><strong>优先使用</strong></strong>）</strong></h1>
<h1 id="6091-斐波那契数列"><a class="markdownIt-Anchor" href="#6091-斐波那契数列">#</a> <strong><a target="_blank" rel="noopener" href="http://www.tzcoder.cn/acmhome/problemdetail.do?method=showdetail&amp;id=6091">6091: 斐波那契数列</a></strong></h1>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int fibonacci(int n) //定义斐波那契函数</span><br><span class="line">&#123;</span><br><span class="line">    if(n == 0)	 //定义初始值</span><br><span class="line">        return 0;   </span><br><span class="line">    if(n == 1 || n == 2)	</span><br><span class="line">        return 1;</span><br><span class="line">    int a=1,b=1,c=0;    //定义初始值</span><br><span class="line">//用一个for循环，a、b分别为前两项，c为前两项之和，得到c后进行交换更新a、b的值，进行n次交换即可。</span><br><span class="line">    for(int i=3;i&lt;=n;i++)    //更新操作</span><br><span class="line">    &#123;</span><br><span class="line">    	c = a+b;</span><br><span class="line">    	a = b;</span><br><span class="line">    	b = c;</span><br><span class="line">	&#125;</span><br><span class="line">	return c;  //c即为结果输出</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t,n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)</span><br><span class="line">    &#123;</span><br><span class="line">    	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    	printf(&quot;%d\n&quot;, fibonacci(n));</span><br><span class="line">	&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>​    递归和迭代的改进算法可以参考 **<a target="_blank" rel="noopener" href="https://blog.csdn.net/Web_J/article/details/115696927"> 微 光的斐波那契数列</a> **。</p>
<p>​    因为递归算法存在着大量的重复计算，在 N 趋近于较大值时，可能会造成<strong>内存溢出或超时</strong>的情况，又因为使用迭代算法的情况下同样可以实现计算斐波那契数列第 N 项的功能，所以<strong>在 N 值很大时我们优先使用迭代算法。</strong></p>
<hr>
<h1 id="斐波那契数列的应用"><a class="markdownIt-Anchor" href="#斐波那契数列的应用">#</a> <strong>斐波那契数列的应用</strong></h1>
<ul>
<li>10 个连续的斐波那契数的和 = 第 7 个数的 11 倍</li>
<li>前 n 项和 =  第 n + 2 项 - 第 2 项</li>
<li>从第 2 项开始，第 2n - 1 项的平方比 2n * (2n - 2) 多 1；第 2n 项的平方比 2n * (2n - 2) 少 1。</li>
</ul>
<h2 id="1-黄金分割"><a class="markdownIt-Anchor" href="#1-黄金分割">#</a> 1**. 黄金分割 **</h2>
<p>** 黄金分割：** 把任一线段分割成两段，使 大段 / 全段 = 小段 / 大段， 比值经过计算之后，就是黄金分割比。</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/47b9219c2b1646be8cbec9fa7e8579dd.png" alt="img"></p>
<p>​    斐波那契数列：随着数列项数的增加，前一项与后一项之比越来越逼近 **<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%BB%84%E9%87%91%E5%88%86%E5%89%B2"> 黄金分割</a> *<em> 的数值 0.6180339887……*</em>**</p>
<p>​    卢卡斯数列：斐波那契数列的推广形式，卢卡斯数列的形式为：1， 3， 4， 7， 11， 18，29，47…… 卢卡斯数列的相邻两项比值的极限恰好也是二分之根号五减一，即黄金分割比。所以说，卢卡斯抓住了斐波那契数列的本质。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	double f[100];</span><br><span class="line">	f[1]=1, f[2]=1;</span><br><span class="line">	for(int i=3; i&lt;=50; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		f[i]=f[i-1]+f[i-2];</span><br><span class="line">	&#125;</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	printf(&quot;%.10lf\n&quot;,f[n]/f[n+1]);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2-杨辉三角"><a class="markdownIt-Anchor" href="#2-杨辉三角">#</a> <strong>2. 杨辉三角</strong></h2>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/937552c4735a58c66db1d43a4fd97004.png" alt="img"></p>
<p>​    如图所示作 45 度斜线，之后做直线的平行线，将每条直线所经过的数，即得之和即为<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97&amp;spm=1001.2101.3001.7020">斐波那契数列</a>。</p>
<hr>
<h2 id="3-兔子数列"><a class="markdownIt-Anchor" href="#3-兔子数列">#</a> <strong>3. 兔子数列</strong></h2>
<p>​    <em><em><em>* 斐波那契数列又因数学家 *</em><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%88%97%E6%98%82%E7%BA%B3%E5%A4%9A%C2%B7%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91"> 列昂纳多・斐波那契</a> *<em> 以兔子繁殖为例子而引入，故又称为 “*</em><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%85%94%E5%AD%90%E6%95%B0%E5%88%97"> 兔子数列</a> *</em>”。*</em>**</p>
<p>​    **** 兔子数列是指：**** 一般而言，兔子在出生两个月后，就有繁殖能力，一对兔子每个月能生出一对小兔子来。如果所有兔子都不死，那么一年以后可以繁殖多少对兔子？</p>
<p>​    很容易发现 “兔子数列” 问题和斐波那契数列问题相同，都是一样的解法。</p>
<h2 id="1376-母牛的故事"><a class="markdownIt-Anchor" href="#1376-母牛的故事">#</a> <strong><a target="_blank" rel="noopener" href="http://www.tzcoder.cn/acmhome/problemdetail.do?method=showdetail&amp;id=1376">1376: 母牛的故事</a></strong></h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt; </span><br><span class="line">void DataInit(int *a)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 4; i &lt; 55; i++)</span><br><span class="line">        a[i] = a[i-1] + a[i-3];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[55] = &#123;0, 1, 2, 3&#125;;</span><br><span class="line">    int n;</span><br><span class="line">    DataInit(a);</span><br><span class="line">    while(scanf(&quot;%d&quot;, &amp;n)!=EOF)</span><br><span class="line">    if(n)</span><br><span class="line">        printf(&quot;%ld\n&quot;, a[n]);</span><br><span class="line">    else break;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="4-排列组合"><a class="markdownIt-Anchor" href="#4-排列组合">#</a> <strong>4. 排列组合</strong></h2>
<p>​    有一段楼梯，有 10 级台阶，规定每一步只能跨一级或两级，要登上第 10 级台阶有几种不同的走法？</p>
<p>​    这也是一个斐波那契数列：</p>
<p>​    登第一级台阶，有一种走法，0-&gt;1；</p>
<p>​    登第二级台阶，有两种走法，0-&gt;1-&gt;2，0-&gt;2；</p>
<p>​    登第三级台阶，有三种走法，0-&gt;1-&gt;2-&gt;3，0-&gt;1-&gt;3，0-&gt;2-&gt;3；</p>
<p>​    登第四级台阶，有五种走法，0-&gt;1-&gt;2-&gt;3-&gt;4，0-&gt;1-&gt;2-&gt;4，0-&gt;1-&gt;3-&gt;4，0-&gt;2-&gt;3-&gt;4，0-&gt;2-&gt;4；</p>
<p>​    …</p>
<p>​    即 1， 2， 3， 5， 8， 13，… 到 10 级，就是 89 种走法，与斐波那契数列的<strong>规律契合</strong>。</p>
<p>​    类似的斐波那契数列的规律运用还有很多。</p>
<p>​    （1， 1， 2， 3， 5， 8， 13， 21， 33， 54， 89…）</p>
<h2 id="5-矩形面积"><a class="markdownIt-Anchor" href="#5-矩形面积">#</a> <strong>5. 矩形面积</strong></h2>
<p>​    <strong>右下图可知，斐波那契数列与矩形面积的生成相关。</strong></p>
<p>​    <img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/4a97beffd31d919e71655e29cf287ec0.gif" alt="img"></p>
<p>​    不难发现一个规律，即 ** 生成的矩形中，所有小正方形的面积之和等于大矩形的面积。** 即： <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9nc3MwLmJkc3RhdGljLmNvbS8tNG8zZFNhZ194STRraEdrcG9XSzFIRjZoaHkvYmFpa2UvcGljL2l0ZW0vZDQ2Mjg1MzVlNWRkZTcxMTVjZDVkOGEzYThlZmNlMWI5ZDE2NjE2NC5qcGc?x-oss-process=image/format,png" alt="img"></p>
<h2 id="关于我"><a class="markdownIt-Anchor" href="#关于我">#</a> 关于我</h2>
<p>Brath 是一个热爱技术的 Java 程序猿，公众号「InterviewCoder」定期分享有趣有料的精品原创文章！</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png" alt="InterviewCoder"></p>
<p>非常感谢各位人才能看到这里，原创不易，文章如果有帮助可以关注、点赞、分享或评论，这都是对我的莫大支持！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-22T02:20:16.000Z" title="2022-4-22 10:20:16">2022-04-22</time>发表</span><span class="level-item"><time dateTime="2023-10-12T08:25:18.000Z" title="2023-10-12 16:25:18">2023-10-12</time>更新</span><span class="level-item">12 分钟读完 (大约1839个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/22/%E3%80%90Flutter%E3%80%91flutter%E5%8F%91%E5%B1%95%E5%89%8D%E6%99%AF%E5%A6%82%E4%BD%95%EF%BC%9F/">【Flutter】flutter发展前景如何？</a></p><div class="content"><p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png" alt="InterviewCoder"></p>
<p><img src="https://pic1.zhimg.com/80/v2-184c74e7aa102e484165122bb5cec4bd_720w.webp?source=1940ef5c" alt="img"></p>
<blockquote>
<p>在 <strong>Flutter</strong> 刚刚从 <strong>Google</strong> 刚刚推向 <strong>Android</strong> 市场的时候，我就开始对 <strong>Flutter</strong> 开始了<strong>学习之路</strong>；但由于当时 <strong>Flutter</strong> 许多东西<strong>尚未完善</strong>而没有推出<strong>稳定的版本</strong>，所以也就没有对其进行<strong>深入</strong>的学习，直到如今 <strong>Flutter</strong> 又<strong>重出江湖</strong>，在<strong>市场</strong>上也得到<strong>了蓬勃发展</strong>及许多业内<strong>大佬</strong>的<strong>力推</strong>，我便又再次<strong>入坑 Flutter</strong></p>
</blockquote>
<p><strong>实现 UI 和交互</strong>是<strong>高级开发者</strong>的<strong>必备技能</strong>，也是<strong>掌握 Flutter 开发</strong>的<strong>重点</strong>；同样 <strong>Flutter</strong> <strong>跨平台</strong>的<strong>特性</strong>是<strong>原生</strong>不能比拟的，更何况还有不弱的<strong>性能</strong>表现；而<strong>性能</strong>往往是由<strong>生命周期</strong>来决定的</p>
<h3 id="何为-flutter-的生命周期"><a class="markdownIt-Anchor" href="#何为-flutter-的生命周期">#</a> <strong>何为 Flutter 的生命周期？</strong></h3>
<p>如果你是一名<strong>开发</strong>人员，那么你一定不会对<strong>生命周期</strong>感到陌生；当你在学习 <strong>Flutter</strong> 的时候，<strong>Flutter 也有自己的生命周期</strong>，只有通过了解 <strong>Flutter</strong> 的<strong>生命周期</strong>，才能知道应该在哪里来写<strong>业务逻辑</strong></p>
<h3 id="flutter-生命周期"><a class="markdownIt-Anchor" href="#flutter-生命周期">#</a> <strong>Flutter 生命周期</strong></h3>
<p><img src="https://picx.zhimg.com/80/v2-6ae547ee1a88db89634eb9c6567146d8_720w.webp?source=1940ef5c" alt="img"></p>
<p>如上图所示，<strong>Flutter 生命周期</strong>大体上可以分为<strong>三个阶段：</strong> <strong>初始化、状态变化、销毁</strong>；下面依次说明各个阶段的工作</p>
<p><strong>初始化阶段</strong>（插入<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E6%B8%B2%E6%9F%93%E6%A0%91&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2734680490%7D">渲染树</a>）</p>
<ul>
<li>对应执行构造方法和 initState</li>
</ul>
<p><strong>状态变化阶段</strong>（在渲染树中存在）</p>
<ul>
<li>开新的 widget 或者调用 setState 方法</li>
</ul>
<p><strong>销毁阶段</strong>（从渲染树种移除）</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=deactivate&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2734680490%7D">deactivate</a> 和 dispose</li>
</ul>
<p>如果之前你对 <strong>Flutter</strong> 有一点点了解的话，你会发现 <strong>Flutter</strong> 中有<strong>两个</strong>主要的 <strong>Widget：</strong> <strong>StatelessWidget（无状态）</strong> 和 <strong>StatefulWidget（有状态）</strong></p>
<h3 id="statelesswidget"><a class="markdownIt-Anchor" href="#statelesswidget">#</a> <strong>StatelessWidget</strong></h3>
<ul>
<li><strong><a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E6%97%A0%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2734680490%7D">无状态组件</a>] 是不可变的</strong>，这意味着它们的<strong>属性不能变化</strong>，所有的值都是最终的；可以理解为将<strong>外部传入的数据转化为界面展示的内容，只会渲染一次</strong></li>
<li><strong>对于无状态组件生命周期只有 build 这个过程</strong>；无状态组件的构建方法通常只在三种情况下会被调用：<strong>小组件第一次被插入树中，小组件的父组件改变其配置，以及它所依赖的 InheritedWidget 发生变化时</strong></li>
</ul>
<h3 id="statefulwidget"><a class="markdownIt-Anchor" href="#statefulwidget">#</a> <strong>StatefulWidget</strong></h3>
<ul>
<li>有状态组件持有的状态可能在 Widget 生命周期中发生变化，是定义<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E4%BA%A4%E4%BA%92%E9%80%BB%E8%BE%91&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2734680490%7D">交互逻辑</a>和业务逻辑；可以理解为具有动态可交互的内容界面，会根据数据的变化进行多次渲染</li>
</ul>
<h3 id="实现一个-statefulwidget-至少需要两个类"><a class="markdownIt-Anchor" href="#实现一个-statefulwidget-至少需要两个类">#</a> <strong>实现一个 StatefulWidget 至少需要两个类：</strong></h3>
<p><strong>一个是 StatefulWidget 类</strong> <strong>另一个是 Sate 类</strong></p>
<ul>
<li><strong>StatefulWidget 类本身是不可变的</strong>，但是 <strong>State 类</strong>在 <strong>Widget 生命周期中始终存在</strong></li>
<li><strong>StatefulWidget</strong> 将其<strong>可变</strong>的<strong>状态存储</strong>在由 <strong>createState</strong> 方法创建的 <strong>State</strong> 对象中，或者存储在该 <strong>State 订阅</strong>的对象中</li>
</ul>
<h3 id="fultter-的优势在哪里"><a class="markdownIt-Anchor" href="#fultter-的优势在哪里">#</a> <strong>Fultter 的优势在哪里？</strong></h3>
<h3 id="快速开发和迭代"><a class="markdownIt-Anchor" href="#快速开发和迭代">#</a> <strong>快速开发和迭代</strong></h3>
<p><strong>Flutter 自身具有热修复（<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%83%AD%E9%87%8D%E8%BD%BD&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2734680490%7D">热重载</a>）<strong>的功能，尽管有使用的限制，但是它依然能够为</strong>开发过程</strong>提供<strong>更高的效率</strong>；另外，<strong>Flutter SDK</strong> 还允许我们<strong>修复崩溃</strong>和继续从<strong>应用程序</strong>停止的地方进行<strong>调试</strong></p>
<h3 id="页面流畅-样式美观"><a class="markdownIt-Anchor" href="#页面流畅-样式美观">#</a> <strong>页面流畅、样式美观</strong></h3>
<p><strong>对于不同的平台（Android 和 iOS）</strong>，<strong>Flutter</strong> 提供了<strong>风格不同</strong>的<strong>控件</strong>，以<strong>满足不同平台</strong>的<strong>设计理念</strong></p>
<h3 id="提供原生性能"><a class="markdownIt-Anchor" href="#提供原生性能">#</a> <strong>提供原生性能</strong></h3>
<p><strong>Flutter</strong> 提供了一种 **<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%93%8D%E5%BA%94%E5%BC%8F%E8%A7%86%E5%9B%BE&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2734680490%7D"> 响应式视图</a><strong>，无须 <strong>JavaScript</strong> 做</strong>桥接 **；强大的 <strong>API</strong> 使得<strong>实现复杂的页面效果</strong>成为可能；高性能的 **<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2734680490%7D"> 渲染机制</a> ** 使得 <strong>120 FPS 的高频率</strong> 可以轻而易举的实现；<strong>当界面上的图片数量越来越多时，与 React Native 相比，Flutter 的优势会越来越明显</strong></p>
<h3 id="灵活的跨平台开发"><a class="markdownIt-Anchor" href="#灵活的跨平台开发">#</a> <strong>灵活的跨平台开发</strong></h3>
<p><strong>Flutter</strong> 可以单独作为<strong>开发框架</strong>完成整个 <strong>App 的开发</strong>，也可以与现有<strong>原生代码</strong>相结合实现 <strong>Hybrid 混合模式的开发</strong></p>
<h3 id="那-flutter-需要学吗"><a class="markdownIt-Anchor" href="#那-flutter-需要学吗">#</a> <strong>那 Flutter 需要学吗？</strong></h3>
<p><strong>Flutter</strong> 抛弃了<strong>原生系统控件</strong>和 <strong>Webview</strong>，使用<strong>自研高性能渲染引擎</strong>来绘制 <strong>Widget</strong>，预先 (AOT) 编译，<strong>运行时直接执行 Native (arm) 代码</strong>，<strong>Dart 代码</strong>执行 (在 UI TaskRunner)，<strong>图片下载</strong> (IO TaskRunner)，<strong>真正的渲染</strong> (GPU TaskRunner) ，<strong>同平台的通信</strong>等 (Platform TaskRunner 即 <strong>Native 概念</strong>下的 **<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E4%B8%BB%E7%BA%BF%E7%A8%8B&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2734680490%7D"> 主线程</a><strong>) 是</strong>互相隔离 ** 的</p>
<p>针对<strong>布局</strong>等的<strong>优</strong>化；<strong>布局</strong>计算时单次树走动即可完成；<strong>Relayout Boundary</strong> 机制：如果 <strong>Child</strong> 的 <strong>size</strong> 是<strong>固定</strong>的，那么不会因为 <strong>Child</strong> 的 <strong>Relayout</strong> 导致 <strong>Parent ReLayout</strong> 等<strong>布局优化</strong>，都让 <strong>Flutter 脱颖而出</strong></p>
<p>如上所述 <strong>Flutter</strong> 于谷歌而言，这是他们重新整理 <strong>跨平台生态环境</strong> 决心的体现，<strong>Flutter</strong> 所展现的内容，也是谷歌想拓展和维护的方向；对于长期苦恼于 <strong>跨平台</strong> 选择的广大 <strong>Android 开发者</strong> 而言，<strong>Flutter</strong> 可谓是谷歌为我们提供的 <strong>指路明灯</strong></p>
<p>以<strong>目前</strong>的<strong>开发速度</strong>，只要不出<strong>大的纰漏</strong>，<strong>按部就班</strong>的<strong>往前推进</strong>，在<strong>不久的将来</strong>， <strong>Google</strong> 一定可以把 <strong>Flutter</strong> 平台打造得非常完美，届时又会改变 **<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2734680490%7D"> 移动开发技术</a><strong>的</strong>格局 ** 了</p>
<p>也许，<strong>Flutter</strong> 系列的<strong>部分库</strong>还没成熟到成为你<strong>工作的第一选择</strong>，但是，深入学习 <strong>Flutter</strong> 组件会为你日常的开发带来一些想法</p>
<p><strong>总的来说，Flutter</strong> 对广大开发者而言是 <strong>利远远大于弊的</strong></p>
<h2 id="关于我"><a class="markdownIt-Anchor" href="#关于我">#</a> 关于我</h2>
<p>Brath 是一个热爱技术的 Java 程序猿，公众号「InterviewCoder」定期分享有趣有料的精品原创文章！</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png" alt="InterviewCoder"></p>
<p>非常感谢各位人才能看到这里，原创不易，文章如果有帮助可以关注、点赞、分享或评论，这都是对我的莫大支持！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-12T13:30:55.000Z" title="2022-4-12 21:30:55">2022-04-12</time>发表</span><span class="level-item"><time dateTime="2022-03-20T19:34:41.000Z" title="2022-3-21 3:34:41">2022-03-21</time>更新</span><span class="level-item">15 分钟读完 (大约2230个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/12/%E3%80%90Flutter%E3%80%91Flutter%20%E6%B5%81%E7%95%85%E5%BA%A6%E4%BC%98%E5%8C%96%E7%BB%84%E4%BB%B6%20Keframe/">Flutter 流畅度优化组件 Keframe</a></p><div class="content"><p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png" alt="InterviewCoder"></p>
<p>最近在开发一款 APP，核心场景类似于帖子这类的，所以下拉加载页面的流畅度成为最棘手的问题，在掘金上看见了这篇文章： <a target="_blank" rel="noopener" href="https://juejin.cn/post/6979781997568884766">https://juejin.cn/post/6979781997568884766</a></p>
<p>Nayuta 的 Keframe 组件正好可以满足帧率优化的问题</p>
<h3 id="项目依赖"><a class="markdownIt-Anchor" href="#项目依赖">#</a> 项目依赖：</h3>
<p>在  <code>pubspec.yaml</code>  中添加  <code>keframe</code>  依赖</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="attr">keframe:</span> <span class="string">version</span></span><br></pre></td></tr></table></figure>
<p>组件仅区分非空安全与空安全版本</p>
<p>非空安全使用：  <code>1.0.2</code></p>
<p>空安全版本使用：  <code>2.0.2</code></p>
<p>github 地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FLianjiaTech%2Fkeframe">github.com/LianjiaTech…</a></p>
<p>pub 查看：<a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.dev%2Fpackages%2Fkeframe">pub.dev/packages/ke…</a></p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#SizeCacheWidget用来包裹最外层的list</span><br><span class="line">#FrameSeparateWidget用来包裹list的子集即可    </span><br><span class="line">example:</span><br><span class="line">SizeCacheWidget(</span><br><span class="line">	child：ListView || CustomScrollView(</span><br><span class="line">    	slivers[</span><br><span class="line">            SliverList(</span><br><span class="line">            	delegate: SliverChildBuilderDelegate</span><br><span class="line">                (BuildContext context, <span class="built_in">int</span> index)&#123;</span><br><span class="line">                    <span class="keyword">return</span> FrameSeparateWidget(</span><br><span class="line">                    	child: ···</span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="快速上手"><a class="markdownIt-Anchor" href="#快速上手">#</a> 快速上手：</h3>
<p>如下图所示</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83d16f3b2a3e45b79fc73d7a52774696~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p>
<p>假如现在页面由 A、B、C、D 四部分组成，每部分耗时 10ms，在页面时构建为 40ms。使用分帧组件   <code>FrameSeparateWidget</code>  嵌套每一个部分。页面构建时会在第一帧渲染简单的占位，在后续四帧内分别渲染 A、B、C、D。</p>
<p>对于列表，在每一个 item 中嵌套  <code>FrameSeparateWidget</code> ，并将  <code>ListView</code>  嵌套在  <code>SizeCacheWidget</code>  内即可。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffecd49bf9ba4379984a22ef79663104~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p>
<hr>
<h2 id="构造函数说明"><a class="markdownIt-Anchor" href="#构造函数说明">#</a> 构造函数说明</h2>
<p>FrameSeparateWidget ：分帧组件，将嵌套的 widget 单独一帧渲染</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>参数名</th>
<th>是否必填</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Key</td>
<td>key</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>int</td>
<td>index</td>
<td>否</td>
<td>分帧组件 id，<strong>使用 SizeCacheWidget 的场景必传</strong>，SizeCacheWidget 中维护了 index 对应的 Size 信息</td>
</tr>
<tr>
<td>Widget</td>
<td>child</td>
<td>是</td>
<td>实际需要渲染的 widget</td>
</tr>
<tr>
<td>Widget</td>
<td>placeHolder</td>
<td>否</td>
<td>占位 widget，尽量设置简单的占位，不传默认是 Container ()</td>
</tr>
</tbody>
</table>
<p>SizeCacheWidget：缓存子节点中，分帧组件嵌套的<strong>实际 widget 的尺寸信息</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>参数名</th>
<th>是否必填</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Key</td>
<td>key</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>Widget</td>
<td>child</td>
<td>是</td>
<td>子节点中如果包含分帧组件，则缓存<strong>实际的 widget 尺寸</strong></td>
</tr>
<tr>
<td>int</td>
<td>estimateCount</td>
<td>否</td>
<td>预估屏幕上子节点的数量，提高快速滚动时的响应速度</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="方案设计与分析"><a class="markdownIt-Anchor" href="#方案设计与分析">#</a> 方案设计与分析：</h2>
<p>卡顿的本质，就是 <strong>单帧的绘制时间过长</strong>。基于此自然衍生出两种思路解决：</p>
<p>1、减少一帧的绘制耗时，因为导致耗时过长的原因有很多，比如不合理的刷新，或者绘制时间过长，都有可能，需要具体问题具体分析，后面我会分享一些我的优化经验。</p>
<p><strong>2、在不对耗时优化下，将一帧的任务拆分到多帧内，保证每一帧都不超时。这也是本组件的设计思路，分帧渲染。</strong></p>
<p>如下图所示:</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb09c9aadc5d45c9b966661c8d73e4c1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p>
<p>原理并不复杂，问题在于如何在 Flutter 中实践这一机制。</p>
<p>因为涉及到帧与系统的调度，自然联想到看  <code>SchedulerBinding</code>  中有无现成的 API。</p>
<p>发现了  <code>scheduleTask</code>  方法，这是系统提供的一个执行任务的方法，但这个方法存在两个问题：</p>
<ul>
<li>1、其中的渲染任务是优先级进行堆排序，而堆排序是<strong>不稳定</strong>排序，这会导致任务的执行顺序并非 FIFO。从效果上来看，就是列表不会按照顺序渲染，而是会出现跳动渲染的情况</li>
<li>2、这个方法本身存在调度问题，我已经提交 issue 与 pr，不过一直卡在单元测试上，如果感兴趣可以以在这里交流谈论。</li>
</ul>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F82781">fix: Tasks scheduled through ‘SchedulerBinding.instance.scheduleTask’… #82781 </a></p>
<p>最终，参考这个设计结合  <code>endOfFrame</code>  方法的使用，完成了分帧队列。整个渲染流程变为下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb9d177b4b0847339eaf952a7ef67cca~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p>
<p>对于列表构建场景来说，假设屏幕上能显示五个 item。首先在第一帧的时候，列表会渲染 5 个占位的 Widget，同时添加 5 个高优先级任务到队列中，这里的任务可以是简单的将占位 Widget 和实际 item 进行替换，也可通过渐变等动画提升体验。在后续的五帧中占位 Widget 依次被替换成实际的列表 item。</p>
<p>在  <a target="_blank" rel="noopener" href="https://juejin.cn/post/6940134891606507534">ListView 流畅度翻倍！！Flutter 卡顿分析和通用优化方案</a>  这篇文章中有更加详细的分析。</p>
<h2 id="一些展示效果example-说明请查看-github"><a class="markdownIt-Anchor" href="#一些展示效果example-说明请查看-github">#</a> 一些展示效果（Example 说明请查看 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FLianjiaTech%2Fkeframe%2Fblob%2Fmaster%2FREADME-ZH.md">Github</a>）</h2>
<p>卡顿的页面往往都是由多个复杂 widget 同时渲染导致。通过为复杂的 widget 嵌套分帧组件  <code>FrameSeparateWidget</code> 。渲染时，分帧组件会在第一帧同时渲染多个  <code>palceHolder</code> ，之后连续的多帧内依次渲染复杂子项，以此提升页面流畅度。</p>
<p>例如 example 中的优化前示例：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ListView.builder(</span><br><span class="line">              itemCount: childCount,</span><br><span class="line">              itemBuilder: (c, i) =&gt; CellWidget(</span><br><span class="line">                color: i % <span class="number">2</span> == <span class="number">0</span> ? Colors.red : Colors.blue,</span><br><span class="line">                index: i,</span><br><span class="line">              ),</span><br><span class="line">            )</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>其中  <code>CellWidget</code>  高度为 60，内部嵌套了三个  <code>TextField</code>  的组件（整体构建耗时在 9ms 左右）。</p>
<p>优化仅需为每一个 item 嵌套分帧组件，并为其设置  <code>placeHolder</code> （placeHolder 尽量简单，样式与实际 item 接近即可）。</p>
<p>在列表情况下，给 ListView 嵌套  <code>SizeCacheWidget</code> ，同时建议将预加载范围  <code>cacheExtent</code>  设置大一点，例如 500（该属性默认为 250），提升慢速滑动时候的体验。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f33ddd7d9de4e369b0e457f84171cc8~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="Screenrecording_20210611_194905.gif"> (占位与实际列表项不一致时，首次渲染抖动，二次渲染正常)</p>
<p>此外，也可以给 item 嵌套透明度 / 位移等动画，优化视觉上的效果。</p>
<p>效果如下图：</p>
<table>
<thead>
<tr>
<th><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb7d1361ae7842df954bb1c559e2ec54~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="Screenrecording_20210315_133310.gif"></th>
<th><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ee6827f7eed4463a1a8a5b00a58fd6e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="Screenrecording_20210315_133848.gif"></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<hr>
<h2 id="分帧的成本"><a class="markdownIt-Anchor" href="#分帧的成本">#</a> 分帧的成本</h2>
<p>当然分帧方案也非十全十美，在我看来主要有两点成本：</p>
<p>1、额外的构建开销：整个构建过程的构建消耗由「n * widget 消耗 」变成了「n *（ widget + 占位）消耗 + 系统调度 n 帧消耗」。可以看出，额外的开销主要由占位的复杂度决定。如果占位只是简单的 Container，测试后发现整体构建耗时大概提升在 15 % 左右。这种额外开销对于当下的移动设备而言，成本几乎可以不计。</p>
<p>2、视觉上的变化：如同上面的演示，组件会将 item 分帧渲染，页面在视觉上出现占位变成实际 widget 的过程。但其实由于列表存在缓存区域（建议将缓存区调大），在高端机或正常滑动情况下用户并无感知。而在中低端设备上快速滑动能感觉到切换的过程，但比严重顿挫要好。</p>
<hr>
<h2 id="优化前后对比演示"><a class="markdownIt-Anchor" href="#优化前后对比演示">#</a> 优化前后对比演示</h2>
<p>注：gif 帧率只有 20</p>
<table>
<thead>
<tr>
<th>优化前</th>
<th>优化后</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f20f593cc144b72a1df4bdae57a165c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="优化前"></td>
<td><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05aea6de421545b9bbf868c344a9afe9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="优化后"></td>
</tr>
</tbody>
</table>
<hr>
<h2 id="最后一点点思考"><a class="markdownIt-Anchor" href="#最后一点点思考">#</a> 最后：一点点思考</h2>
<p>列表优化篇到此告一段落，在整个开源实践过程中，有两点感触较深：</p>
<p>作者：Nayuta<br>
 链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6979781997568884766">https://juejin.cn/post/6979781997568884766</a></p>
<h2 id="关于我"><a class="markdownIt-Anchor" href="#关于我">#</a> 关于我</h2>
<p>Brath 是一个热爱技术的 Java 程序猿，公众号「InterviewCoder」定期分享有趣有料的精品原创文章！</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png" alt="InterviewCoder"></p>
<p>非常感谢各位人才能看到这里，原创不易，文章如果有帮助可以关注、点赞、分享或评论，这都是对我的莫大支持！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-10T13:17:57.000Z" title="2022-4-10 21:17:57">2022-04-10</time>发表</span><span class="level-item"><time dateTime="2020-09-15T06:02:25.000Z" title="2020-9-15 14:02:25">2020-09-15</time>更新</span><span class="level-item">11 分钟读完 (大约1638个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/10/%E3%80%90Node%E3%80%91node&amp;npm&amp;cnpm&amp;webpack&amp;yarn%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/">node&amp;npm&amp;cnpm&amp;webpack&amp;yarn安装教程</a></p><div class="content"><p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png" alt="InterviewCoder"></p>
<h3 id="nodejs"><a class="markdownIt-Anchor" href="#nodejs">#</a> Node.js</h3>
<p>​		nodejs 是一个让 JavaScript 运行在服务端的开发平台，它让 JavaScript 成为与 PHP、Python、Perl、Ruby 等服务端语言平起平坐的脚本语言</p>
<p>​		nodejs 能做 web 开发，REST 开发，小程序开发等等，它就是使用 JavaScript 进行开发的，也就是说，基本上每个 web 开发的人员都可以比较轻松的转到 nodejs 平台，nodejs 就像是 JavaScript 抛弃 window,document 等这些 dom 对象后的东西的一个封装</p>
<p>nodejs 下载地址：<a target="_blank" rel="noopener" href="https://nodejs.org/en/">https://nodejs.org/en/</a></p>
<h5 id="nodejs安装"><a class="markdownIt-Anchor" href="#nodejs安装">#</a> Node.js 安装：</h5>
<p>​		1 . 首先要查看本机是否已安装 nodeJs，打开命令提示符，输入 node&amp;node -v 查看。</p>
<p>​		2 . 打开 Node.js Setup 文件执行安装    选择安装路径，全部下一步。</p>
<p>​		3 . 安装完毕之后，重新打开一个命令提示符窗口，出入 node -v</p>
<p>现在，我们来 Hello World 一下，开启命令行窗口，输入 node，进入 node 的命令行，我们可以输入 console.log (“hello world”)<img src="https://img2018.cnblogs.com/blog/1033563/201906/1033563-20190604153223076-1028024327.png" alt="img"></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">或者，我们可以创建一个web服务，进入node命令行后，输入</span><br><span class="line">View Code</span><br><span class="line">回车后，在浏览器输入：http<span class="punctuation">:</span><span class="comment">//localhost:8000就输出了hello world</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="npm"><a class="markdownIt-Anchor" href="#npm">#</a> npm：</h3>
<h5 id="npm安装"><a class="markdownIt-Anchor" href="#npm安装">#</a> npm 安装：</h5>
<p>Nodejs 下的包管理器。</p>
<p>下载 Node 后自带一个旧版本的 npm。</p>
<hr>
<h3 id="cnpm"><a class="markdownIt-Anchor" href="#cnpm">#</a> cnpm:</h3>
<p>Nodejs 下的包管理器，国内淘宝镜像版本。</p>
<h5 id="cnpm安装"><a class="markdownIt-Anchor" href="#cnpm安装">#</a> cnpm 安装：</h5>
<p>首先要有 node 环境和 npm 环境–</p>
<p>1、安装 cnpm，输入以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<p>如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/a5fada1c44e9cba82055d5c6db8ea69a.png" alt="img"></p>
<p>2、输入 <code>cnpm -v</code>  ，检测是否正常</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/374a7ba6c4e04cdb785a5dca12536ad1.png" alt="img"></p>
<hr>
<h3 id="webpack"><a class="markdownIt-Anchor" href="#webpack">#</a> webpack:</h3>
<p>它主要的用途是通过 CommonJS 的语法把所有浏览器端需要发布的静态资源做相应的准备，比如资源的合并和打包。</p>
<h5 id="webpack安装"><a class="markdownIt-Anchor" href="#webpack安装">#</a> webpack 安装：</h5>
<p>首先需要安装好 nodeJs&amp;npm 的环境～</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v   <span class="comment">// 查看node的版本 不能太高</span></span><br><span class="line">npm -v   <span class="comment">//查看npm的版本</span></span><br></pre></td></tr></table></figure>
<p>全局安装:</p>
<p>打开命令行（win+R    输入 cmd）</p>
<p><img src="https://img-blog.csdn.net/20180809221529512?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTMwOTgz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-cli -g --save-dev #输入并执行下载webpack </span><br><span class="line">-g #全局安装 </span><br><span class="line">--save-dev #信息写入package.json的devDependencies中</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdn.net/20180809222148241?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTMwOTgz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>下载好后在命令行执行 webpack -v 查看 webpack 的版本号，正常显示说明安装好了</p>
<hr>
<h3 id="yarn"><a class="markdownIt-Anchor" href="#yarn">#</a> yarn：</h3>
<p>​	<strong>Yarn 是 facebook 发布的一款取代 npm 的包管理工具。</strong><br>
​	Yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。 同时利用并行下载以最大化资源利用率，因此安装速度更快，在执行代码之前，Yarn 会通过算法校验每个安装包的完整性，使用详细、简洁的锁文件格式和明确的安装算法，Yarn 能够保证在不同系统上无差异的工作。</p>
<h5 id="yarn安装"><a class="markdownIt-Anchor" href="#yarn安装">#</a> yarn 安装:</h5>
<p>首先需要 node.js &amp; npm 环境<br>
输入命令： npm install -g yarn<br>
 查看版本：yarn -V &amp; --version</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yarn 淘宝源安装，分别复制粘贴以下代码行到黑窗口运行即可</span><br><span class="line">yarn config set registry https://registry.npm.taobao.org -g</span><br><span class="line">yarn config set sass_binary_site http://cdn.npm.taobao.org/dist/node-sass -g</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">yarn的常用命令：</span><br><span class="line">安装yarn：npm install -g yarn</span><br><span class="line">安装成功后，查看版本号：yarn --version</span><br><span class="line">创建文件夹 ：md yarn</span><br><span class="line">进入yarn文件夹：cd yarn</span><br><span class="line">初始化项目：yarn init <span class="comment">// 同npm init，执行输入信息后，会生成package.json文件</span></span><br><span class="line"></span><br><span class="line">yarn的配置项：</span><br><span class="line">yarn config list <span class="comment">// 显示所有配置项</span></span><br><span class="line">yarn config get &lt;key&gt; <span class="comment">//显示某配置项</span></span><br><span class="line">yarn config delete &lt;key&gt; <span class="comment">//删除某配置项</span></span><br><span class="line">yarn config set &lt;key&gt; &lt;value&gt; <span class="punctuation">[</span>-g|--global<span class="punctuation">]</span> <span class="comment">//设置配置项</span></span><br><span class="line"></span><br><span class="line">安装包：</span><br><span class="line">yarn install <span class="comment">//安装package.json里所有包，并将包及它的所有依赖项保存进yarn.lock</span></span><br><span class="line">yarn install --flat <span class="comment">//安装一个包的单一版本</span></span><br><span class="line">yarn install --force <span class="comment">//强制重新下载所有包</span></span><br><span class="line">yarn install --production <span class="comment">//只安装dependencies里的包</span></span><br><span class="line">yarn install --no-lockfile <span class="comment">//不读取或生成yarn.lock</span></span><br><span class="line">yarn install --pure-lockfile <span class="comment">//不生成yarn.lock</span></span><br><span class="line"></span><br><span class="line">添加包（会更新package.json和yarn.lock）：</span><br><span class="line">yarn add <span class="punctuation">[</span>package<span class="punctuation">]</span> <span class="comment">// 在当前的项目中添加一个依赖包，会自动更新到package.json和yarn.lock文件中</span></span><br><span class="line">yarn add <span class="punctuation">[</span>package<span class="punctuation">]</span>@<span class="punctuation">[</span>version<span class="punctuation">]</span> <span class="comment">// 安装指定版本，这里指的是主要版本，如果需要精确到小版本，使用-E参数</span></span><br><span class="line">yarn add <span class="punctuation">[</span>package<span class="punctuation">]</span>@<span class="punctuation">[</span>tag<span class="punctuation">]</span> <span class="comment">// 安装某个tag（比如beta,next或者latest）</span></span><br><span class="line"><span class="comment">//不指定依赖类型默认安装到dependencies里，你也可以指定依赖类型：</span></span><br><span class="line"></span><br><span class="line">yarn add --dev/-D <span class="comment">// 加到 devDependencies</span></span><br><span class="line">yarn add --peer/-P <span class="comment">// 加到 peerDependencies</span></span><br><span class="line">yarn add --optional/-O <span class="comment">// 加到 optionalDependencies</span></span><br><span class="line"><span class="comment">//默认安装包的主要版本里的最新版本，下面两个命令可以指定版本：</span></span><br><span class="line"></span><br><span class="line">yarn add --exact/-E <span class="comment">// 安装包的精确版本。例如yarn add foo@1.2.3会接受1.9.1版，但是yarn add foo@1.2.3 --exact只会接受1.2.3版</span></span><br><span class="line">yarn add --tilde/-T <span class="comment">// 安装包的次要版本里的最新版。例如yarn add foo@1.2.3 --tilde会接受1.2.9，但不接受1.3.0</span></span><br><span class="line"></span><br><span class="line">发布包</span><br><span class="line">yarn publish</span><br><span class="line"></span><br><span class="line">移除一个包</span><br><span class="line">yarn remove &lt;packageName&gt;：移除一个包，会自动更新package.json和yarn.lock</span><br><span class="line"></span><br><span class="line">更新一个依赖</span><br><span class="line">yarn upgrade 用于更新包到基于规范范围的最新版本</span><br><span class="line"></span><br><span class="line">运行脚本</span><br><span class="line">yarn run 用来执行在 package.json 中 scripts 属性下定义的脚本</span><br><span class="line"></span><br><span class="line">显示某个包的信息</span><br><span class="line">yarn info &lt;packageName&gt; 可以用来查看某个模块的最新版本信息</span><br><span class="line"></span><br><span class="line">缓存</span><br><span class="line">yarn cache</span><br><span class="line">yarn cache list # 列出已缓存的每个包 yarn cache dir # 返回 全局缓存位置 yarn cache clean # 清除缓存</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="关于我"><a class="markdownIt-Anchor" href="#关于我">#</a> 关于我</h2>
<p>Brath 是一个热爱技术的 Java 程序猿，公众号「InterviewCoder」定期分享有趣有料的精品原创文章！</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png" alt="InterviewCoder"></p>
<p>非常感谢各位人才能看到这里，原创不易，文章如果有帮助可以关注、点赞、分享或评论，这都是对我的莫大支持！</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/7/">上一页</a></div><div class="pagination-next"><a href="/page/9/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/7/">7</a></li><li><a class="pagination-link is-current" href="/page/8/">8</a></li><li><a class="pagination-link" href="/page/9/">9</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/15/">15</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-06-06T00:13:41.000Z">2023-06-06</time></p><p class="title"><a href="/2023/06/06/%E3%80%90%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%E3%80%91%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB%E7%AC%AC%E4%BA%8C%E6%9C%9F-%E5%85%AC%E4%BC%97%E5%8F%B7%E6%A8%A1%E6%9D%BF%E6%B6%88%E6%81%AF-%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98%E5%88%86%E4%BA%AB/">【公众号开发】公众号技术分享第二期-公众号模板消息-模板模式实战分享</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-06-06T00:10:41.000Z">2023-06-06</time></p><p class="title"><a href="/2023/06/06/%E3%80%90%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%E3%80%91%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB%E7%AC%AC%E4%B8%80%E6%9C%9F-%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8C%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%B9%B3%E5%8F%B0%E5%B9%B6%E4%BD%BF%E7%94%A8%E5%85%AC%E4%BC%97%E5%8F%B7%E6%A8%A1%E6%9D%BF%E6%B6%88%E6%81%AF/">【公众号开发】公众号技术分享第一期-如何注册微信公众平台并使用公众号模板消息</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-06-05T17:10:41.000Z">2023-06-06</time></p><p class="title"><a href="/2023/06/06/%E3%80%90Sentinel%E3%80%91Docker%E6%90%AD%E5%BB%BASentinel/">【Sentinel】Docker搭建Sentinel</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-06-05T07:25:21.000Z">2023-06-05</time></p><p class="title"><a href="/2023/06/05/%E3%80%90Git%E3%80%91Github%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E9%81%87%E5%88%B0%E9%94%99%E8%AF%AF%EF%BC%9AERROR%20You%E2%80%98re%20using%20an%20RSA%20key%20with%20SHA-1,%20which%20is%20no%20longer%20allowed/">【Git】Github提交代码遇到错误：ERROR You‘re using an RSA key with SHA-1, which is no longer allowed</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-05-23T02:04:23.000Z">2023-05-23</time></p><p class="title"><a href="/2023/05/23/%E3%80%90Linux%E3%80%91%E9%98%BF%E9%87%8C%E4%BA%91linux%20%E6%8C%82%E8%BD%BD%E6%95%B0%E6%8D%AE%E7%9B%98%E5%B9%B6docker%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%E8%BF%81%E7%A7%BB%E5%88%B0%E6%95%B0%E6%8D%AE%E7%9B%98/">【Linux】阿里云linux 挂载数据盘并docker工作目录迁移到数据盘</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">40</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/"><span class="level-start"><span class="level-item">2022</span></span><span class="level-end"><span class="level-item tag">61</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/"><span class="level-start"><span class="level-item">2021</span></span><span class="level-end"><span class="level-item tag">43</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/"><span class="level-start"><span class="level-item">2020</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png" alt="InterviewCoder"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">InterviewCoder</p><p class="is-size-6 is-block">面试记官方公众号</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">149</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://mp.weixin.qq.com/s/jWs6lLHl5L-atXJhHc4YvA" target="_blank" rel="noopener">关注我</a></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://brath.cloud/me.png" alt="Brath"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Brath</p><p class="is-size-6 is-block">技能改变人生，知识改变命运。</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·江苏·无锡</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">149</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Guoqing815" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Guoqing815"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Gitee" href="https://gitee.com/Guoqing-Li"><i class="fab fa-gitee"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://schokolade.cn/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">泠灵(特别呜谢)</span></span><span class="level-right"><span class="level-item tag">schokolade.cn</span></span></a></li><li><a class="level is-mobile" href="https://gitee.com/Guoqing-Li" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Gitee(码云)</span></span><span class="level-right"><span class="level-item tag">gitee.com</span></span></a></li><li><a class="level is-mobile" href="https://blog.csdn.net/Brath?type=blog" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">CSDN</span></span><span class="level-right"><span class="level-item tag">blog.csdn.net</span></span></a></li><li><a class="level is-mobile" href="https://juejin.cn/user/settings/profile" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">掘金</span></span><span class="level-right"><span class="level-item tag">juejin.cn</span></span></a></li><li><a class="level is-mobile" href="https://oss.console.aliyun.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">AliCloud(阿里云)</span></span><span class="level-right"><span class="level-item tag">oss.console.aliyun.com</span></span></a></li><li><a class="level is-mobile" href="https://cloud.tencent.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">TencentCloud(腾讯云)</span></span><span class="level-right"><span class="level-item tag">cloud.tencent.com</span></span></a></li><li><a class="level is-mobile" href="https://www.zhipin.com/web/user/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">BOSS</span></span><span class="level-right"><span class="level-item tag">www.zhipin.com</span></span></a></li><li><a class="level is-mobile" href="https://www.bilibili.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bilibili(B站)</span></span><span class="level-right"><span class="level-item tag">www.bilibili.com</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://brath.cloud/avatar.png" alt="Brath-Blog" height="28"></a><p class="is-size-7"><span>&copy; 2023 Brath</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p><p class="is-size-7">© 2029</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>