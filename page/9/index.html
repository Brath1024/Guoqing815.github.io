<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Brath-Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Brath-Blog"><meta name="msapplication-TileImage" content="https://brath.cloud/me.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Brath-Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Brath-Blog"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="Brath-Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="Brath"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"Brath-Blog","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"Brath"},"publisher":{"@type":"Organization","name":"Brath-Blog","logo":{"@type":"ImageObject","url":"https://brath.cloud/me.png"}},"description":""}</script><link rel="icon" href="https://brath.cloud/me.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://brath.cloud/me.png" alt="Brath-Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">文章列表</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">更多</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Guoqing815"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-04-20T06:02:20.204Z" title="2023-4-20 14:02:20">2023-04-20</time>发表</span><span class="level-item"><time dateTime="2023-04-20T06:01:26.658Z" title="2023-4-20 14:01:26">2023-04-20</time>更新</span><span class="level-item">29 分钟读完 (大约4341个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/04/20/%E3%80%90Hbase%E3%80%91Hbase%E5%AD%A6%E4%B9%A0/">Hbase</a></p><div class="content"><p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png" alt="InterviewCoder"></p>
<h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍">#</a> 介绍：</h2>
<p>​		Hbase 是 bigtable 的开源山寨版本。是建立在 HDFS 之上，提供高可靠性、高性能、列存储、可伸缩、实时读写的数据库系统。它介于 nosql 和 RDBMS 之间，仅能通过主键 (row key) 和主键的 range 来检索数据，仅支持单行事务 (可通过 hive 支持来实现多表 join 等复杂操作)。主要用来存储非结构化和半结构化的松散数据。与 hadoop 一样，Hbase 目标主要依靠横向扩展，通过不断增加廉价的商用服务器，来增加计算和存储能力。</p>
<h2 id="特点"><a class="markdownIt-Anchor" href="#特点">#</a> 特点：</h2>
<p>​		HBase 中的表一般有这样的特点：</p>
<ol>
<li>
<p>大：一个表可以有上亿行，上百万列</p>
</li>
<li>
<p>面向列：面向列 (族) 的存储和权限控制，列 (族) 独立检索。</p>
</li>
<li>
<p>稀疏：对于为空 (null) 的列，并不占用存储空间，因此，表可以设计的非常稀疏。</p>
</li>
</ol>
<p>下面一幅图是 Hbase 在 Hadoop Ecosystem 中的位置。</p>
<p><img src="f:%5Cmd%E5%9B%BE%E7%89%87%5C20180608160429998.png" alt="20180608160429998"></p>
<h2 id="二-逻辑视图"><a class="markdownIt-Anchor" href="#二-逻辑视图">#</a> 二、 逻辑视图</h2>
<p>HBase 以表的形式存储数据。表有行和列组成。列划分为若干个列族 (row family)</p>
<p><img src="f:%5Cmd%E5%9B%BE%E7%89%87%5C20180608160501841.png" alt="20180608160501841"></p>
<p>Row Key</p>
<p>与 nosql 数据库们一样，row key 是用来检索记录的主键。访问 hbase table 中的行，只有三种方式：</p>
<p>1 通过单个 row key 访问</p>
<p>2 通过 row key 的 range</p>
<p>3 全表扫描</p>
<p>Row key 行键 (Row key) 可以是任意字符串 (最大长度是 64KB，实际应用中长度一般为 10-100bytes)，在 hbase 内部，row key 保存为字节数组。</p>
<p>存储时，数据按照 Row key 的字典序 (byte order) 排序存储。设计 key 时，要充分排序存储这个特性，将经常一起读取的行存储放到一起。(位置相关性)</p>
<p>注意：</p>
<p>字典序对 int 排序的结果是 1,10,100,11,12,13,14,15,16,17,18,19,2,20,21,…,9,91,92,93,94,95,96,97,98,99。要保持整形的自然序，行键必须用 0 作左填充。</p>
<p>行的一次读写是原子操作 (不论一次读写多少列)。这个设计决策能够使用户很容易的理解程序在对同一个行进行并发更新操作时的行为。</p>
<p>列族</p>
<p>hbase 表中的每个列，都归属与某个列族。列族是表的 chema 的一部分 (而列不是)，必须在使用表之前定义。列名都以列族作为前缀。例如<em> courses:history ， courses:math 都属于 courses</em> 这个列族。</p>
<p>访问控制、磁盘和内存的使用统计都是在列族层面进行的。实际应用中，列族上的控制权限能 帮助我们管理不同类型的应用：我们允许一些应用可以添加新的基本数据、一些应用可以读取基本数据并创建继承的列族、一些应用则只允许浏览数据（甚至可能因 为隐私的原因不能浏览所有数据）。</p>
<p>时间戳</p>
<p>HBase 中通过 row 和 columns 确定的为一个存贮单元称为 cell。每个 cell 都保存着同一份数据的多个版本。版本通过时间戳来索引。时间戳的类型是 64 位整型。时间戳可以由 hbase (在数据写入时自动) 赋值，此时时间戳是精确到毫秒的当前系统时间。时间戳也可以由客户显式赋值。如果应用程序要避免数据版本冲突，就必须自己生成具有唯一性的时间戳。每个 cell 中，不同版本的数据按照时间倒序排序，即最新的数据排在最前面。</p>
<p>为了避免数据存在过多版本造成的的管理 (包括存贮和索引) 负担，hbase 提供了两种数据版本回收方式。一是保存数据的最后 n 个版本，二是保存最近一段时间内的版本（比如最近七天）。用户可以针对每个列族进行设置。</p>
<p>Cell</p>
<p>由 *{row key, column (* =<family> + <label><em>), version}</em> 唯一确定的单元。cell 中的数据是没有类型的，全部是字节码形式存贮。</p>
<h2 id="三-物理存储"><a class="markdownIt-Anchor" href="#三-物理存储">#</a> 三、 物理存储</h2>
<p>1 . 已经提到过，Table 中的所有行都按照 row key 的字典序排列。</p>
<p>2 . Table 在行的方向上分割为多个 Hregion。</p>
<p><img src="f:%5Cmd%E5%9B%BE%E7%89%87%5C2018060816055431.png" alt="2018060816055431"></p>
<p>3 .  region 按大小分割的，每个表一开始只有一个 region，随着数据不断插入表，region 不断增大，当增大到一个阀值的时候，Hregion 就会等分会两个新的 Hregion。当 table 中的行不断增多，就会有越来越多的 Hregion。</p>
<p><img src="f:%5Cmd%E5%9B%BE%E7%89%87%5C20180608160613225.png" alt="20180608160613225"></p>
<p>4 . Hregion 是 Hbase 中分布式存储和负载均衡的最小单元。最小单元就表示不同的 Hregion 可以分布在不同的 HRegion server 上。但一个 Hregion 是不会拆分到多个 server 上的。</p>
<p><img src="f:%5Cmd%E5%9B%BE%E7%89%87%5C20180608160632130.png" alt="20180608160632130"></p>
<p>5 . HRegion 虽然是分布式存储的最小单元，但并不是存储的最小单元。</p>
<p>事实上，HRegion 由一个或者多个 Store 组成，每个 store 保存一个 columns family。</p>
<p>每个 Strore 又由一个 memStore 和 0 至多个 StoreFile 组成。如图：</p>
<p>StoreFile 以 HFile 格式保存在 HDFS 上。</p>
<p><img src="f:%5Cmd%E5%9B%BE%E7%89%87%5C2018060816065423.png" alt="2018060816065423"></p>
<p>HFile 的格式为：<img src="f:%5Cmd%E5%9B%BE%E7%89%87%5C20180608160715293.png" alt="20180608160715293"></p>
<p>Trailer 部分的格式:</p>
<p><img src="f:%5Cmd%E5%9B%BE%E7%89%87%5C20180608160733415.png" alt="20180608160733415"></p>
<p>HFile 分为六个部分：</p>
<p>Data Block 段–保存表中的数据，这部分可以被压缩</p>
<p>Meta Block 段 (可选的)–保存用户自定义的 kv 对，可以被压缩。</p>
<p>File Info 段–Hfile 的元信息，不被压缩，用户也可以在这一部分添加自己的元信息。</p>
<p>Data Block Index 段–Data Block 的索引。每条索引的 key 是被索引的 block 的第一条记录的 key。</p>
<p>Meta Block Index 段 (可选的)–Meta Block 的索引。</p>
<p>Trailer–这一段是定长的。保存了每一段的偏移量，读取一个 HFile 时，会首先 读取 Trailer，Trailer 保存了每个段的起始位置 (段的 Magic Number 用来做安全 check)，然后，DataBlock Index 会被读取到内存中，这样，当检索某个 key 时，不需要扫描整个 HFile，而只需从内存中找到 key 所在的 block，通过一次磁盘 io 将整个 block 读取到内存中，再找到需要的 key。DataBlock Index 采用 LRU 机制淘汰。</p>
<p>HFile 的 Data Block，Meta Block 通常采用压缩方式存储，压缩之后可以大大减少网络 IO 和磁盘 IO，随之而来的开销当然是需要花费 cpu 进行压缩和解压缩。</p>
<p>目标 Hfile 的压缩支持两种方式：Gzip，Lzo。</p>
<p>HLog(WAL log)</p>
<p>WAL 意为 Write ahead log (<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Write-ahead_logging">http://en.wikipedia.org/wiki/Write-ahead_logging</a>)，类似 mysql 中的 binlog, 用来 做灾难恢复只用，Hlog 记录数据的所有变更，一旦数据修改，就可以从 log 中进行恢复。</p>
<p>每个 Region Server 维护一个 Hlog, 而不是每个 Region 一个。这样不同 region (来自不同 table) 的日志会混在一起，这样做的目的是不断追加单个 文件相对于同时写多个文件而言，可以减少磁盘寻址次数，因此可以提高对 table 的写性能。带来的麻烦是，如果一台 region server 下线，为了恢复其上的 region，需要将 region server 上的 log 进行拆分，然后分发到其它 region server 上进行恢复。</p>
<p>HLog 文件就是一个普通的 Hadoop Sequence File，Sequence File 的 Key 是 HLogKey 对象，HLogKey 中记录了写入数据的归属信息，除了 table 和 region 名字外，同时还包括 sequence number 和 timestamp，timestamp 是” 写入时间”，sequence number 的起始值为 0，或者是最近一次存入文件系统中 sequence number。HLog Sequece File 的 Value 是 HBase 的 KeyValue 对象，即对应 HFile 中的 KeyValue，可参见上文描述。</p>
<h2 id="四-系统架构"><a class="markdownIt-Anchor" href="#四-系统架构">#</a> 四、 系统架构</h2>
<p><img src="f:%5Cmd%E5%9B%BE%E7%89%87%5C20180608160828501.png" alt="20180608160828501"></p>
<p>Client</p>
<p>1 包含访问 hbase 的接口，client 维护着一些 cache 来加快对 hbase 的访问，比如 regione 的位置信息。</p>
<p>Zookeeper</p>
<p>1 保证任何时候，集群中只有一个 master</p>
<p>2 存贮所有 Region 的寻址入口。</p>
<p>3 实时监控 Region Server 的状态，将 Region server 的上线和下线信息实时通知给 Master</p>
<p>4 存储 Hbase 的 schema, 包括有哪些 table，每个 table 有哪些 column family</p>
<p>Master</p>
<p>1 为 Region server 分配 region</p>
<p>2 负责 region server 的负载均衡</p>
<p>3 发现失效的 region server 并重新分配其上的 region</p>
<p>4 GFS 上的垃圾文件回收</p>
<p>5 处理 schema 更新请求</p>
<p>Region Server</p>
<p>1 Region server 维护 Master 分配给它的 region，处理对这些 region 的 IO 请求</p>
<p>2 Region server 负责切分在运行过程中变得过大的 region</p>
<p>可以看到，client 访问 hbase 上数据的过程并不需要 master 参与（寻址访问 zookeeper 和 region server，数据读写访问 regione server），master 仅仅维护者 table 和 region 的元数据信息，负载很低。</p>
<h2 id="五-关键算法-流程"><a class="markdownIt-Anchor" href="#五-关键算法-流程">#</a> 五、关键算法 / 流程</h2>
<p>region 定位</p>
<p>系统如何找到某个 row key (或者某个 row key range) 所在的 region</p>
<p>bigtable 使用三层类似 B + 树的结构来保存 region 位置。</p>
<p>第一层是保存 zookeeper 里面的文件，它持有 root region 的位置。</p>
<p>第二层 root region 是.META. 表的第一个 region 其中保存了.META.z 表其它 region 的位置。通过 root region，我们就可以访问.META. 表的数据。</p>
<p>.META. 是第三层，它是一个特殊的表，保存了 hbase 中所有数据表的 region 位置信息。</p>
<p><img src="f:%5Cmd%E5%9B%BE%E7%89%87%5C20180608160858652.png" alt="20180608160858652"></p>
<p>说明：</p>
<p>1 root region 永远不会被 split，保证了最需要三次跳转，就能定位到任意 region 。</p>
<p>2.META. 表每行保存一个 region 的位置信息，row key 采用表名 + 表的最后一样编码而成。</p>
<p>3 为了加快访问，.META. 表的全部 region 都保存在内存中。</p>
<p>假设，.META. 表的一行在内存中大约占用 1KB。并且每个 region 限制为 128MB。</p>
<p>那么上面的三层结构可以保存的 region 数目为：</p>
<p>(128MB/1KB) * (128MB/1KB) = = 2 (34) 个 region</p>
<p>4 client 会将查询过的位置信息保存缓存起来，缓存不会主动失效，因此如果 client 上的缓存全部失效，则需要进行 6 次网络来回，才能定位到正确的 region (其中三次用来发现缓存失效，另外三次用来获取位置信息)。</p>
<p>读写过程</p>
<p>上文提到，hbase 使用 MemStore 和 StoreFile 存储对表的更新。</p>
<p>数据在更新时首先写入 Log (WAL log) 和内存 (MemStore) 中，MemStore 中的数据是排序的，当 MemStore 累计到一定阈值时，就会创建一个新的 MemStore，并 且将老的 MemStore 添加到 flush 队列，由单独的线程 flush 到磁盘上，成为一个 StoreFile。于此同时，系统会在 zookeeper 中 记录一个 redo point，表示这个时刻之前的变更已经持久化了。(minor compact)</p>
<p>当系统出现意外时，可能导致内存 (MemStore) 中的数据丢失，此时使用 Log (WAL log) 来恢复 checkpoint 之后的数据。</p>
<p>前面提到过 StoreFile 是只读的，一旦创建后就不可以再修改。因此 Hbase 的更 新其实是不断追加的操作。当一个 Store 中的 StoreFile 达到一定的阈值后，就会进行一次合并 (major compact), 将对同一个 key 的修改合并到一起，形成一个大的 StoreFile，当 StoreFile 的大小达到一定阈值后，又会对 StoreFile 进行 split，等分为两个 StoreFile。</p>
<p>由于对表的更新是不断追加的，处理读请求时，需要访问 Store 中全部的 StoreFile 和 MemStore，将他们的按照 row key 进行合并，由于 StoreFile 和 MemStore 都是经过排序的，并且 StoreFile 带有内存中索引，合并的过程还是比较快。</p>
<p>写请求处理过程</p>
<p><img src="f:%5Cmd%E5%9B%BE%E7%89%87%5C20180608160916374.png" alt="20180608160916374"></p>
<p>1 client 向 region server 提交写请求</p>
<p>2 region server 找到目标 region</p>
<p>3 region 检查数据是否与 schema 一致</p>
<p>4 如果客户端没有指定版本，则获取当前系统时间作为数据版本</p>
<p>5 将更新写入 WAL log</p>
<p>6 将更新写入 Memstore</p>
<p>7 判断 Memstore 的是否需要 flush 为 Store 文件。</p>
<p>region 分配</p>
<p>任何时刻，一个 region 只能分配给一个 region server。master 记录了当前有哪些可用的 region server。以及当前哪些 region 分配给了哪些 region server，哪些 region 还没有分配。当存在未分配的 region，并且有一个 region server 上有可用空间时，master 就给这个 region server 发送一个装载请求，把 region 分配给这个 region server。region server 得到请求后，就开始对此 region 提供服务。</p>
<p>region server 上线</p>
<p>master 使用 zookeeper 来跟踪 region server 状态。当某个 region server 启动时，会首先在 zookeeper 上的 server 目录下建立代表自己的文件，并获得该文件的独占锁。由于 master 订阅了 server 目录上的变更消息，当 server 目录下的文件出现新增或删除操作时，master 可以得到来自 zookeeper 的实时通知。因此一旦 region server 上线，master 能马上得到消息。</p>
<p>region server 下线</p>
<p>当 region server 下线时，它和 zookeeper 的会话断开，zookeeper 而自动释放代表这台 server 的文件上的独占锁。而 master 不断轮询 server 目录下文件的锁状态。如果 master 发现某个 region server 丢失了它自己的独占锁，(或者 master 连续几次和 region server 通信都无法成功),master 就是尝试去获取代表这个 region server 的读写锁，一旦获取成功，就可以确定：</p>
<p>1 region server 和 zookeeper 之间的网络断开了。</p>
<p>2 region server 挂了。</p>
<p>的其中一种情况发生了，无论哪种情况，region server 都无法继续为它的 region 提供服务了，此时 master 会删除 server 目录下代表这台 region server 的文件，并将这台 region server 的 region 分配给其它还活着的同志。</p>
<p>如果网络短暂出现问题导致 region server 丢失了它的锁，那么 region server 重新连接到 zookeeper 之后，只要代表它的文件还在，它就会不断尝试获取这个文件上的锁，一旦获取到了，就可以继续提供服务。</p>
<p>master 上线</p>
<p>master 启动进行以下步骤:</p>
<p>1 从 zookeeper 上获取唯一一个代码 master 的锁，用来阻止其它 master 成为 master。</p>
<p>2 扫描 zookeeper 上的 server 目录，获得当前可用的 region server 列表。</p>
<p>3 和 2 中的每个 region server 通信，获得当前已分配的 region 和 region server 的对应关系。</p>
<p>4 扫描.META.region 的集合，计算得到当前还未分配的 region，将他们放入待分配 region 列表。</p>
<p>master 下线</p>
<p>由于 master 只维护表和 region 的元数据，而不参与表数据 IO 的过 程，master 下线仅导致所有元数据的修改被冻结 (无法创建删除表，无法修改表的 schema，无法进行 region 的负载均衡，无法处理 region 上下线，无法进行 region 的合并，唯一例外的是 region 的 split 可以正常进行，因为只有 region server 参与)，表的数据读写还可以正常进行。因此 master 下线短时间内对整个 hbase 集群没有影响。从上线过程可以看到，master 保存的 信息全是可以冗余信息（都可以从系统其它地方收集到或者计算出来），因此，一般 hbase 集群中总是有一个 master 在提供服务，还有一个以上 的’master’在等待时机抢占它的位置。</p>
<p>六、访问接口</p>
<ul>
<li>HBase Shell</li>
<li>Java clietn API</li>
<li>HBase non-java access</li>
<li>
<ul>
<li>languages talking to the JVM</li>
<li>
<ul>
<li>Jython interface to HBase</li>
<li>Groovy DSL for HBase</li>
<li>Scala interface to HBase</li>
</ul>
</li>
<li>languages with a custom protocol</li>
<li>
<ul>
<li>REST gateway specification for HBase</li>
<li>充分利用 HTTP 协议：GET POST PUT DELETE</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>§</p>
<ul>
<li>
<ul>
<li>
<ul>
<li>text/plain</li>
<li>text/xml</li>
<li>application/json</li>
<li>application/x-protobuf</li>
</ul>
</li>
<li>Thrift gateway specification for HBase</li>
<li>
<ul>
<li>java</li>
<li>cpp</li>
<li>rb</li>
<li>py</li>
<li>perl</li>
<li>php</li>
</ul>
</li>
</ul>
</li>
<li>HBase Map Reduce</li>
<li>Hive/Pig</li>
</ul>
<h2 id="关于我"><a class="markdownIt-Anchor" href="#关于我">#</a> 关于我</h2>
<p>Brath 是一个热爱技术的 Java 程序猿，公众号「InterviewCoder」定期分享有趣有料的精品原创文章！</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png" alt="InterviewCoder"></p>
<p>非常感谢各位人才能看到这里，原创不易，文章如果有帮助可以关注、点赞、分享或评论，这都是对我的莫大支持！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-04-20T06:02:20.200Z" title="2023-4-20 14:02:20">2023-04-20</time>发表</span><span class="level-item"><time dateTime="2023-04-20T06:01:26.630Z" title="2023-4-20 14:01:26">2023-04-20</time>更新</span><span class="level-item">2 分钟读完 (大约271个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/04/20/%E3%80%90GOSN%E3%80%91Gosn%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%EF%BC%9F/">【GOSN】Gosn是什么？怎么使用？</a></p><div class="content"><p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png" alt="InterviewCoder"></p>
<h1 id=""><a class="markdownIt-Anchor" href="#">#</a> </h1>
<p>Gson 是 google 开发的一个开源 Json 解析库，使用十分的方便，在<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=maven&amp;spm=1001.2101.3001.7020"> maven</a> 当中导入的方式为：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.gson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br></pre></td></tr></table></figure>
<p>其中 2.8.2 为版本号，最新版本以及源码可以在官方的 github 上查看：<a target="_blank" rel="noopener" href="https://github.com/google/gson">https://github.com/google/gson</a></p>
<p>这里给出最简单的 Gson 的使用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Object转Json字符串</span></span><br><span class="line"> </span><br><span class="line"><span class="type">String</span> <span class="variable">obstr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>().toJson(object);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Json字符串转Object</span></span><br><span class="line"> </span><br><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>().fromJson(obstr);</span><br></pre></td></tr></table></figure>
<h2 id="关于我"><a class="markdownIt-Anchor" href="#关于我">#</a> 关于我</h2>
<p>Brath 是一个热爱技术的 Java 程序猿，公众号「InterviewCoder」定期分享有趣有料的精品原创文章！</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png" alt="InterviewCoder"></p>
<p>非常感谢各位人才能看到这里，原创不易，文章如果有帮助可以关注、点赞、分享或评论，这都是对我的莫大支持！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-04-20T06:02:20.195Z" title="2023-4-20 14:02:20">2023-04-20</time>发表</span><span class="level-item"><time dateTime="2023-04-20T06:01:26.639Z" title="2023-4-20 14:01:26">2023-04-20</time>更新</span><span class="level-item">4 小时读完 (大约32940个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/04/20/%E3%80%90Go%E3%80%91Go%E8%AF%AD%E8%A8%80%E4%B8%8EJava%E8%AF%AD%E8%A8%80%E5%AF%B9%E6%AF%94/">【Go】Go语言与Java语言对比</a></p><div class="content"><p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png" alt="InterviewCoder"></p>
<h1 id="gogo语言与java语言对比"><a class="markdownIt-Anchor" href="#gogo语言与java语言对比">#</a> 【Go】Go 语言与 Java 语言对比</h1>
<h1 id="go与java"><a class="markdownIt-Anchor" href="#go与java">#</a> Go 与 Java</h1>
<h2 id="零goapi文档和中文社区网址"><a class="markdownIt-Anchor" href="#零goapi文档和中文社区网址">#</a> 零.GoApi 文档和中文社区网址</h2>
<p>Go 的中文 api 文档：<a target="_blank" rel="noopener" href="https://studygolang.com/pkgdoc">https://studygolang.com/pkgdoc</a></p>
<p>Go 中文社区网站：<a target="_blank" rel="noopener" href="https://studygolang.com/">https://studygolang.com/</a></p>
<h2 id="一关于java"><a class="markdownIt-Anchor" href="#一关于java">#</a> 一。关于 Java</h2>
<h3 id="1java的用途"><a class="markdownIt-Anchor" href="#1java的用途">#</a> 1.Java 的用途</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	首先我们来回顾下Java的主要用途和应用场景：</span><br><span class="line">1</span><br><span class="line">	用途一：服务器后端系统开发(web后端、微服务后端支付系统、业务系统、管理后台，各种后台交互的接口服务)。</span><br><span class="line"> 	</span><br><span class="line"> 	用途二：大数据框架的底层实现和Java的API支持。(Hadoop)。</span><br><span class="line"></span><br><span class="line">	用途三：其它中间件的底层开发。(Tomcat、RocketMq、Hbase、Kafka(部分)、SpringCloud，Dubbo...)。</span><br></pre></td></tr></table></figure>
<h3 id="2java的优势和特点"><a class="markdownIt-Anchor" href="#2java的优势和特点">#</a> 2.Java 的优势和特点</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	那我们看Java语言有什么优势和特点呢？</span><br><span class="line">1</span><br><span class="line">	*.做服务端系统性能高。</span><br><span class="line"></span><br><span class="line">	*.有虚拟机，跨平台。</span><br><span class="line"></span><br><span class="line">	*.功能强大，支持的类库多，生态圈类库多，开发框架和工具更易找。</span><br><span class="line"></span><br><span class="line">	*.市场占有率高，约60%的中国程序员都是做Java相关的工作。</span><br></pre></td></tr></table></figure>
<h2 id="二关于go"><a class="markdownIt-Anchor" href="#二关于go">#</a> 二。关于 Go</h2>
<h3 id="1go的出生原因"><a class="markdownIt-Anchor" href="#1go的出生原因">#</a> 1.Go 的出生原因</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Go语言是Google内部公司大佬开发的，主要起因于Google公司有大量的C程序项目，但是开发起来效率太低，维护成本高，于是就开发了Go语言来提高效率，而且性能只是差一点。</span><br><span class="line"></span><br><span class="line">（Go是2007年开始研发，2009推出发布）</span><br></pre></td></tr></table></figure>
<h3 id="2宏观看go与java的差异"><a class="markdownIt-Anchor" href="#2宏观看go与java的差异">#</a> 2. 宏观看 Go 与 Java 的差异</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">	接着，我们来看一下Go语言与Java的差异之处：</span><br><span class="line">1</span><br><span class="line">	*.无虚拟机，不跨平台(这里的平台指操作系统)(可以运行多个平台，每个平台打不同的二进制程序包)，需要打包编译成对应服务器操作系统版本(windows/linux)的可执行程序(比如windows是exe)。(注:说go跨平台的是指32位和64位相同操作系统之间的跨平台)</span><br><span class="line"></span><br><span class="line">	*.因为Go程序直接打包成操作系统可执行的文件，没有虚拟机在中间转换的一层，所以理论上执行效率会更高（理论上更高，实际情况需具体分析)。</span><br><span class="line"></span><br><span class="line">	*.相比Java的语言和代码编写风格，Go更简洁，可以用更少的代码实现同样的功能。</span><br><span class="line"></span><br><span class="line">	*.Go语言底层也是C实现的，又做了高并发的设计(Java出生时(1995)还没有多核cpu,所以他的并发支持后来添加上去的,Go(2009)出生时已经有了多核cpu的电脑，它在设计语言时就考虑了充分利用多核cpu(英特尔2005首次推出多核)的性能)，所以性能高，高并发的支持(高并发支持其中指的一个就是充分利用多核cpu的性能资源，比如go程序默认使用所有cpu(除非自己设置使用多少))也好。</span><br><span class="line"></span><br><span class="line">	*.天然的适用一些特定系统的开发，比如区块链类系统(如以太坊底层系统、以太坊上层应用程序)，云计算和容器（Docker，K8s底层都是go开发的）开发的(大公司自研运维管理项目也大多是用go做底层的开发)，网络编程(类似于java的Netty)。</span><br></pre></td></tr></table></figure>
<h3 id="3go和java的语言类型区别"><a class="markdownIt-Anchor" href="#3go和java的语言类型区别">#</a> 3.Go 和 Java 的语言类型区别</h3>
<p>计算机编程语言按照运行的方式可以分为编译型编程语言和解释型编译语言。</p>
<p>我来举一个例子，你要教别人一门沟通交流的语言，比如英语。</p>
<p>编译型的教的方式就是录 (这里的录相当于计算机中把程序编译成二进制可执行文件) 一个视频课程，语音课程，把每一句英语发音录下来，这样学生学的时候只要播放你的录音，然后跟着读就行，你只需要录制一次，学生就可以无数次听。</p>
<p>解释性的教的方式就是你亲自到学生家里给他补习，你当面教他，你读 (读相当于每次执行都重新用解释器解释一遍) 一句他学一句，</p>
<p>这样的话，你想要教他一句你必须就得先读一句，每次教都得重新一遍一遍的读。</p>
<p>这两种教学方式还有一个差别，你录 (编译) 视频语音教他，你录的英语他就只能学英语，空间环境一变，他现在要去日本，要学日语，你的视频语音教程因为已经录好了，是英语类型 (英语类型类比操作系统类型) 的，所以，你就得再录一套日语的语音教程。</p>
<p>而现场教他，你也会日语的话，你只需要读 (读相当于解释器解释) 日语给他听，让他学就行了，是不用考虑语言环境 (操作系统类型环境) 不同的问题的。</p>
<p>现在我们再来看编程语言，我们的程序执行有两种方式，一种是编译成操作系统可执行的二进制可执行程序，这样相当于编译一次，之后每次执行都不用再编译了，但是因为不同操作系统对于二进制文件的执行规范不同，不同的操作系统你要编译成不同的可执行文件。</p>
<p>解释型语言就是多了一个解释器，解释器我们可以类比为一个老师，你执行一行代码我们类比为学一句话的读音，解释器解释一句，就是老师先读一句，你跟着才能读一句，也就是解释器每解释一行代码为可运行的代码，操作系统执行一行代码，这样的话每次执行都需要解释器重新解释一遍，执行几次就得解释几次。</p>
<p>Go 是编译型的语言，运行在不同的平台需要打包成不同操作系统类型下的可执行文件。</p>
<p>Java 是半编译，半解释型语言。编译是指他的代码都会编译成 class 类型的文件，class 类型的文件只需要编译一次，可以在不同的操作系统的 Java 虚拟机上执行 ，半解释是指在 Java 虚拟机中，他还是需要一句一句的将 class 的二进制代码解释成对应操作系统可执行的代码。</p>
<h3 id="4go语言目前的主要应用场景"><a class="markdownIt-Anchor" href="#4go语言目前的主要应用场景">#</a> 4.Go 语言目前的主要应用场景</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*.和Java一样，Go语言最多的应用场景就是服务器后端系统的开发，包括Web后端，微服务后端接口。</span><br><span class="line"></span><br><span class="line">*.Go非常适用需要高性能高并发的网络编程，这里的网络编程是指不需要界面，底层只是用Socket相互传输数据的系统，类似于Java中Netty的用途。</span><br><span class="line"></span><br><span class="line">*.一些云计算容器，比如Docker，K8s，底层就是Go语言开发的，也可以用做底层自研运维项目的开发。</span><br><span class="line"></span><br><span class="line">*.一些游戏系统的开发，可以用Go语言。</span><br><span class="line"></span><br><span class="line">*.区块链的一些底层软件和一些应用软件。(区块链程序的第一开发语言)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5现在市场上都有哪些公司在使用go语言"><a class="markdownIt-Anchor" href="#5现在市场上都有哪些公司在使用go语言">#</a> 5. 现在市场上都有哪些公司在使用 Go 语言？</h3>
<p>我们不讲虚的，直接 BOSS 直聘看哪些公司招，招的是干什么系统开发的。</p>
<p>这是腾讯的一个岗位。</p>
<p><img src="https://img-blog.csdnimg.cn/318d2012a8734cd9a294c0dc64faaeb0.jpeg#pic_center" alt="在这里插入图片描述"></p>
<p>看看岗位描述，是做互联网保险 产品的业务系统开发，业务系统是啥意思，和 JAVA 后端业务系统一样啊，说明腾讯的一部分项目已经用 Go 来开发业务系统了， 至少他这个保险团队是这样的。</p>
<p><img src="https://img-blog.csdnimg.cn/5dd2275e8d24456ab66238864b55da81.jpeg#pic_center" alt="在这里插入图片描述"></p>
<p>再看小米也是：</p>
<p><img src="https://img-blog.csdnimg.cn/2e6d50d2ee344316b6027cffc3e29c4b.jpeg#pic_center" alt="在这里插入图片描述"></p>
<p>也是后端，这是要和 JAVA 抢饭碗。。。</p>
<p><img src="https://img-blog.csdnimg.cn/25f74a9c4ffa4605a4600da20375d985.jpeg#pic_center" alt="在这里插入图片描述"></p>
<p>再看一个常见的，Go 非常适合开发运维管理系统，这个估计是开发维护阿里内部的自动化运维项目的，也就是说他们的运维支持可能是他们自己用 Go 语言写的项目。(实在不理解你就想下他们自己自研开发了一个类似于 Jenkins 和 Docker 之类的环境和代码流程发布的项目)</p>
<p><img src="https://img-blog.csdnimg.cn/f3598988ec5b46e68fc71a0783da5c79.jpeg#pic_center" alt="在这里插入图片描述"></p>
<p>再来看一个字节跳动的，也是开发内部流程自动部署自动运维程序的</p>
<p><img src="https://img-blog.csdnimg.cn/3a928549a795452b8cc2dde6a0abbdb6.jpeg#pic_center" alt="在这里插入图片描述"></p>
<p>再看华为的，好像 Java 架构师的要求啊，微服务，缓存，消息中间件，数据库。。。</p>
<p><img src="https://img-blog.csdnimg.cn/f2937196c1074fc5b2540394f0298457.jpeg#pic_center" alt="在这里插入图片描述"></p>
<p>这里不多看，自己看看去吧，大多数你能知道的大公司都有用 go 语言尝试的新部门，新项目，市场占有率虽然比 Java 少，但是岗位实际上蛮多的。自己可以去 BOSS 上详细查查。</p>
<h2 id="三go和java微观对比"><a class="markdownIt-Anchor" href="#三go和java微观对比">#</a> 三.Go 和 Java 微观对比</h2>
<h3 id="1gopath和java的classpath"><a class="markdownIt-Anchor" href="#1gopath和java的classpath">#</a> 1.GoPath 和 Java 的 ClassPath</h3>
<p>我们先来看看关于 Java 的 classpath：</p>
<p>在我们的开发环境中，一个 web 程序 (war 包) 有一个 classpath, 这个 classpath 在 IDEA 的开发工具中目录体现为 src 目录和 resource 目录，实际上在真正的 war 包中他定位的是指 WEB-INF 下的 classes 文件夹下的资源 (比如 class 文件)。</p>
<p>我们编译后的文件都放在 classpath (类路径) 下。我们多个项目程序会有多个 classpath 目录。</p>
<p>在 Go 语言中，GoPath 在同一系统上的同一用户，一般规定只有一个，无论这个用户创建多少个 go 项目，都只有一个 GoPath, 并且这些项目都放在 GoPath 下的 src 目录下。</p>
<p>GoPath 下有三个目录：</p>
<p>1.bin （用于存放项目编译后的可执行文件）</p>
<p>2.pkg (用于存放类库文件，比如.a 结尾的包模块)</p>
<p>3.src （用于存放项目代码源文件）</p>
<p>注意：当我们在 windows 上开发 Go 程序时，需要新建一个文件夹 (文件夹名任意) 作为 GOPATH 的文件目录，在其中新建三个文件夹分别是：bin,pkg,src。如果是在集成开发工具上开发的话，需要在设置中把 GOPATH 路径设置为你自定义的那个文件夹，之后产生的文件和相关内容都会在其中。</p>
<p>如果是在 linux 上想跑测试开发执行 go 程序，需要在 /etc/profile 添加名为 GOPATH 的环境变量，目录设置好自己新建的。</p>
<p>例如：全局用户设置 GOPATH 环境变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br><span class="line"><span class="comment">#添加如下 目录可以灵活修改</span></span><br><span class="line"><span class="built_in">export</span> GOPATH=/pub/go/gopath</span><br><span class="line">//立即刷新环境变量生效</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>
<p>单用户设置 GOPATH 环境变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vi   ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加如下 目录可以自己灵活修改</span></span><br><span class="line"><span class="built_in">export</span> GOPATH=/home/user/local/soft/go/gopath</span><br><span class="line">//立即刷新环境变量生效</span><br><span class="line"><span class="built_in">source</span> vi   ~/.bash_profile</span><br></pre></td></tr></table></figure>
<p>注意：这是在 linux 上开发 go 程序才需要的，如果只是生产运行程序的话是不需要任何东西的，直接运行二进制可执行程序包即可，他所有的依赖全部打进包中了。</p>
<p>如果是在 windows 下的 cmd，dos 窗口运行相关的 go 命令和程序，则需要在 windows 的【此电脑】–&gt;【右键】–&gt;【属性】–&gt;【高级系统设置】–&gt;【环境变量】-【新建一个系统变量】–&gt;【变量名为 GOPATH，路径为你自己指定的自定义文件夹】（如果是在 IDEA 中开发，不需要在此配置环境变量，只需要在 IDEA 中配置好 GOPATH 的目录设置即可）</p>
<h3 id="2go的开发环境搭建"><a class="markdownIt-Anchor" href="#2go的开发环境搭建">#</a> 2.Go 的开发环境搭建</h3>
<p>（配置环境变量 GOPATH 参考上一节内容）</p>
<p>我们要开发 Go 的程序，需要如下两样东西：</p>
<p>1.Go SDK</p>
<p>GO 中文社区 SDK 下载地址：<a target="_blank" rel="noopener" href="https://studygolang.com/dl">https://studygolang.com/dl</a></p>
<p>go1.14 (最新的)</p>
<p>我们用 1.14 版就可以，因为 1.13 后才完全支持 Module 功能。</p>
<p>有两种安装模式，一种是压缩包解压的方式，一种是图形化安装。</p>
<p>推荐使用 windows 图形安装傻瓜式安装，windows 图形安装下载这个</p>
<p><a target="_blank" rel="noopener" href="https://studygolang.com/dl/golang/go1.14.6.windows-amd64.msi">https://studygolang.com/dl/golang/go1.14.6.windows-amd64.msi</a></p>
<ol>
<li>
<p>Go 的集成软件开发环境</p>
<p>参考三 (4) 中的 go 集成开发环境选择。</p>
</li>
</ol>
<h3 id="3go与java的文件结构对比"><a class="markdownIt-Anchor" href="#3go与java的文件结构对比">#</a> 3.Go 与 Java 的文件结构对比</h3>
<h4 id="1go文件结构模板"><a class="markdownIt-Anchor" href="#1go文件结构模板">#</a> 1).go 文件结构模板</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主程序必须是写成main包名</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//导入别的类库</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>    </span><br><span class="line"></span><br><span class="line"><span class="comment">//全局常量定义</span></span><br><span class="line"><span class="keyword">const</span>  num = <span class="number">10</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//全局变量定义</span></span><br><span class="line"><span class="keyword">var</span> name <span class="type">string</span> = <span class="string">&quot;li_ming&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型定义</span></span><br><span class="line"><span class="keyword">type</span> P <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//初始化函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main函数:程序入口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Hello World!!!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2java文件结构"><a class="markdownIt-Anchor" href="#2java文件结构">#</a> 2).Java 文件结构</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包名</span></span><br><span class="line"><span class="keyword">package</span> my_package;</span><br><span class="line">       </span><br><span class="line"><span class="comment">//导入包中的类</span></span><br><span class="line"><span class="keyword">import</span> java.io.*；</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Class MainTest&#123; </span><br><span class="line">	<span class="comment">//main方法:程序入口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">static</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//people类</span></span><br><span class="line">Class People &#123;</span><br><span class="line">	<span class="comment">//成员变量</span></span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">            </span><br><span class="line">	<span class="comment">//成员方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">	            </span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4go与java的集成开发环境"><a class="markdownIt-Anchor" href="#4go与java的集成开发环境">#</a> 4.Go 与 Java 的集成开发环境</h3>
<h4 id="1go的集成开发环境"><a class="markdownIt-Anchor" href="#1go的集成开发环境">#</a> 1).Go 的集成开发环境</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">最常用的有三种：</span><br><span class="line"></span><br><span class="line">Visual Studio Code(VS Code) 微软开发的一款Go语言开发工具。</span><br><span class="line"></span><br><span class="line">LiteIDE 是国人开发的Go语言开发工具。</span><br><span class="line"></span><br><span class="line">GoLand 这个非常好用，和Java中的IDEA是一家公司。(推荐使用)</span><br></pre></td></tr></table></figure>
<h4 id="2java的集成开发环境"><a class="markdownIt-Anchor" href="#2java的集成开发环境">#</a> 2).Java 的集成开发环境</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyEclipse,Eclipse(已过时)。</span><br><span class="line"></span><br><span class="line">IntelliJ IDEA(大多数用这个)。</span><br></pre></td></tr></table></figure>
<h3 id="5go和java常用包的对比"><a class="markdownIt-Anchor" href="#5go和java常用包的对比">#</a> 5.Go 和 Java 常用包的对比</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Go中文API文档地址：</span><br><span class="line">https://studygolang.com/pkgdoc</span><br><span class="line">12</span><br><span class="line">     			Go                                              Java         </span><br><span class="line"></span><br><span class="line">IO流操作：      bufio/os                                     java.lang.io</span><br><span class="line">字符串操作：      strings                                    java.lang.String</span><br><span class="line">容器           container(heap/list/ring)           	      java.lang.Collection</span><br><span class="line">锁               sync                                       juc</span><br><span class="line">时间              time                                      java.time/java.lang.Date</span><br><span class="line">算数操作          math                                       java.math</span><br><span class="line">底层Unsafe       unsafe                                     unsafe类       </span><br></pre></td></tr></table></figure>
<h3 id="6go的常用基础数据类型和java的基础数据类型对比"><a class="markdownIt-Anchor" href="#6go的常用基础数据类型和java的基础数据类型对比">#</a> 6.Go 的常用基础数据类型和 Java 的基础数据类型对比</h3>
<h4 id="1go中的常用基础数据类型有"><a class="markdownIt-Anchor" href="#1go中的常用基础数据类型有">#</a> 1).go 中的常用基础数据类型有：</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1.布尔型：关键字【bool】： true   false</span><br><span class="line">2.有符号整形：头一位是代表正负</span><br><span class="line">            int   默认整形   4或8字节         		  32位或64位     </span><br><span class="line">            int8             1字节                     8位</span><br><span class="line">            int16            2字节                     16位</span><br><span class="line">            int32            4字节                     32位</span><br><span class="line">            in64             8字节                     64位</span><br><span class="line">       		【int是32还是64位取决于操作系统的位数，现在电脑一般都是64位的了，所以一般都是64位】</span><br><span class="line">3.无符号整形</span><br><span class="line">            uint             4或8字节          	 32位或64位</span><br><span class="line">            uint8             1字节                     8位</span><br><span class="line">            uint16            2字节                     16位</span><br><span class="line">            uint32            4字节                     32位</span><br><span class="line">            uint64            8字节                     64位</span><br><span class="line">4.浮点型</span><br><span class="line">            注：go语言没有float类型，只有float32和float64。</span><br><span class="line">            float32           32位浮点数  </span><br><span class="line">            float64           64位浮点数</span><br><span class="line">5.字符串</span><br><span class="line">            string</span><br><span class="line">6. byte     等同uint8，只是类似于一个别名的东西</span><br><span class="line">   rune     等同int32	 只是一个别名，强调表示编码概念对应的数字</span><br></pre></td></tr></table></figure>
<h4 id="2go中派生数据类型有"><a class="markdownIt-Anchor" href="#2go中派生数据类型有">#</a> 2).go 中派生数据类型有：</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">注:这里简单列举一下</span><br><span class="line">指针  	Pointer</span><br><span class="line">数组  	Array[]</span><br><span class="line">结构体 	struct</span><br><span class="line">进程管道： channel </span><br><span class="line">函数 		 func</span><br><span class="line">切片  	slice</span><br><span class="line">接口 		interface</span><br><span class="line">哈希 		 map</span><br><span class="line">123456789</span><br></pre></td></tr></table></figure>
<h4 id="3java中的基础数据类型"><a class="markdownIt-Anchor" href="#3java中的基础数据类型">#</a> 3).Java 中的基础数据类型</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">byte</span><br><span class="line"></span><br><span class="line">short</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line"></span><br><span class="line">long</span><br><span class="line"></span><br><span class="line">float</span><br><span class="line"></span><br><span class="line">double</span><br><span class="line"></span><br><span class="line">boolean</span><br><span class="line"></span><br><span class="line">char</span><br></pre></td></tr></table></figure>
<h3 id="7go和java的变量对比"><a class="markdownIt-Anchor" href="#7go和java的变量对比">#</a> 7.Go 和 Java 的变量对比</h3>
<h4 id="1go的变量"><a class="markdownIt-Anchor" href="#1go的变量">#</a> 1).go 的变量</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">   <span class="comment">//包含print函数</span></span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//var  变量名  变量类型 = 变量值</span></span><br><span class="line">   <span class="keyword">var</span> name <span class="type">string</span> = <span class="string">&quot;li_ming&quot;</span></span><br><span class="line">   <span class="comment">//方法内部可以直接使用 【 变量名 := 变量值 】 赋值，方法外不可以</span></span><br><span class="line">   name2:=<span class="string">&quot;xiao_hong&quot;</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;name = &quot;</span>,name)</span><br><span class="line">   fmt.Println(<span class="string">&quot;name2 = &quot;</span>,name2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2java的变量"><a class="markdownIt-Anchor" href="#2java的变量">#</a> 2).Java 的变量</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//变量类型  变量名 = 变量值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;li_ming&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;name =&quot;</span>+name);</span><br><span class="line">        System.out.println(<span class="string">&quot;i =&quot;</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8go和java的常量对比"><a class="markdownIt-Anchor" href="#8go和java的常量对比">#</a> 8.Go 和 Java 的常量对比</h3>
<h4 id="1go的常量"><a class="markdownIt-Anchor" href="#1go的常量">#</a> 1).go 的常量</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">go中的常量和java中的常量含义有一个本质的区别：</span><br><span class="line">go中的常量是指在编译期间就能确定的量(数据)，</span><br><span class="line">而java中的常量是指被赋值一次后就不能修改的量(数据)。</span><br><span class="line">所以两者不一样，因为Java中的常量也是JVM跑起来后赋值的，只不过不允许更改；</span><br><span class="line">go的常量在编译后就确实是什么数值了。</span><br><span class="line">12345</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">   //包含print函数</span><br><span class="line">   &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line">   //const  常量名  常量类型 = 常量值   显示推断类型</span><br><span class="line">   const name string = &quot;const_li_ming&quot;</span><br><span class="line">   //隐式推断类型</span><br><span class="line">   const name2 =&quot;const_xiao_hong&quot;</span><br><span class="line">   fmt.Println(&quot;name = &quot;,name)</span><br><span class="line">   fmt.Println(&quot;name2 = &quot;,name2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2java的常量"><a class="markdownIt-Anchor" href="#2java的常量">#</a> 2).Java 的常量</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">    <span class="comment">//【访问修饰符】 【静态修饰符】final修饰符   常量类型   常量名 =  常量值；</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;A&quot;</span>;    <span class="comment">//一般设置为static静态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;tag= &quot;</span>+TAG);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9go与java的赋值对比"><a class="markdownIt-Anchor" href="#9go与java的赋值对比">#</a> 9.Go 与 Java 的赋值对比</h3>
<h4 id="1go的赋值"><a class="markdownIt-Anchor" href="#1go的赋值">#</a> 1).go 的赋值</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">Go方法内的赋值符号可以用  := ,也可以用 =,方法外只能用 = 。</span><br><span class="line">例如:</span><br><span class="line">12</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">   //包含print函数</span><br><span class="line">   &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//方法外只能用 = 赋值</span><br><span class="line">var my_name  string = &quot;my_name&quot;</span><br><span class="line">var my_name2 = &quot;my_name2&quot;</span><br><span class="line">//my_name3:=&quot;my_name3&quot;    不在方法内，错误</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   fmt.Println(&quot;name = &quot;,my_name)</span><br><span class="line">   fmt.Println(&quot;name2 = &quot;,my_name2)</span><br><span class="line">&#125;</span><br><span class="line">12345678910111213141516</span><br><span class="line">Go支持多变量同时赋值：</span><br><span class="line">1</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">   //包含print函数</span><br><span class="line">   &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   //多变量同时赋值</span><br><span class="line">   var name,name2 = &quot;li_ming&quot;,&quot;xiao_hong&quot;</span><br><span class="line">   fmt.Println(&quot;name = &quot;,name)</span><br><span class="line">   fmt.Println(&quot;name2 = &quot;,name2)</span><br><span class="line">&#125;</span><br><span class="line">12345678910111213</span><br><span class="line">Go的丢弃赋值</span><br><span class="line">1</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">   //包含print函数</span><br><span class="line">   &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   //丢弃赋值    把 1和2丢弃 只取3</span><br><span class="line">   //在必须一次取两个以上的值的场景下，又不想要其中一个值的时候使用，比如从map中取key,value</span><br><span class="line">   var _,_,num = 1,2,3</span><br><span class="line">   fmt.Println(&quot;num = &quot;,num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2java的赋值"><a class="markdownIt-Anchor" href="#2java的赋值">#</a> 2).java 的赋值</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//直接用 = 赋值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;li_ming&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;name =&quot;</span>+name);</span><br><span class="line">        System.out.println(<span class="string">&quot;i =&quot;</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10go与java的注释"><a class="markdownIt-Anchor" href="#10go与java的注释">#</a> 10.Go 与 Java 的注释</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Go中的注释写法和Java中的基本一样。</span><br><span class="line">例如：</span><br><span class="line">//单行注释,两者相同</span><br><span class="line">/*</span><br><span class="line">    Go的多行注释</span><br><span class="line">*/</span><br><span class="line">/**</span><br><span class="line">	Java多行注释</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h3 id="11go和java的访问权限设置区别"><a class="markdownIt-Anchor" href="#11go和java的访问权限设置区别">#</a> 11.Go 和 Java 的访问权限设置区别</h3>
<p>首先我们来回忆一下，Java 的权限访问修饰符有哪些？</p>
<p>public 全局可见</p>
<p>protected 继承相关的类可见</p>
<p>default 同包可见</p>
<p>private 私有的，本类可见</p>
<p>关于 Java 中的访问权限修饰符，是用于修饰变量，方法，类的，被修饰的对象被不同的访问权限修饰符修饰后，其它程序代码要想访问它，必须在规定的访问范围内才可以，比如同包，同类，父子类，全局均可访问。</p>
<p>那么，Go 中的访问权限设置又有什么区别呢？</p>
<p>要理解这个问题，首先我们要来看一下一个 Go 程序的程序文件组织结构是什么样子的？</p>
<p>一个可运行的编译后的 Go 程序，必须有一个入口，程序从入口开始执行，这个入口必须是 main 包，并且从 main 包的 main 函数开始执行。</p>
<p>但是，为了开发的效率和管理开发任务的协调简单化，对于代码质量的可复用，可扩展等特性的要求，我们一般采用面向对象的，文件分模块式的开发。</p>
<p>比如，我是一个游戏程序，我的 main 函数启动后，首先要启动 UI 界面，那么关于 UI 界面相关的代码我们一般会专门分出一个模块去开发，然后这个模块有很多个程序文件，这里关于 UI 模块比如有 3 个文件，a.go,b.go,c.go，那么我们在实际当中会建一个以 ui 为名的包文件夹，然后把 a.go,b.go,c.go 全部放到 ui 这个包文件夹下，然后因为这个包没有 main 包，没有 main 函数，所以它打出来的一个程序文件就是以.a 结尾的工具包，类似于 Java 中的 jar 包，工具包文件名为 ui.a。</p>
<p>参考如下：</p>
<p>----com.add.mygame.ui</p>
<p>------------------------------------a.go</p>
<p>------------------------------------b.go</p>
<p>------------------------------------c.go</p>
<p>a.go 文件如下示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//这里的ui，也就是package后面的名称尽量和包文件夹的名称一致，不一致也可以</span><br><span class="line">package ui</span><br><span class="line"></span><br><span class="line">//相关方法和业务</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line">//启动游戏UI</span><br><span class="line">func StartGameUI() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意一个点，在程序中的 package 后面的 ui 包名可以和文件夹 com.mashibing.mygame.ui 中最后一层的 ui 文件夹名称不一致，</p>
<p>我们一般按规范写是要求写一致的，不一致时的区别如下：</p>
<p>我们把 ui.a 打包完毕后，我们就可以在别的程序中用 import 导入这个包模块 ，然后使用其中的内容了。</p>
<p>上面两个 ui 不同之处在于，在我们 import 的代码后面，需要写的模块名称是在 ${gopath}/src/ 下的文件夹名，也就是 com.mashibing.mygame.ui 中的 ui。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//游戏主程序</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">//这里的ui是com.mashibing.mygame.ui的最后一层文件夹名</span><br><span class="line">import &quot;ui&quot;</span><br><span class="line"></span><br><span class="line">//相关方法和业务</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	//这里的ui不是文件夹名，而是之前a.go程序中package后面写的包名</span><br><span class="line">	ui.StartGameUI()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/97e67873761b49d1a5db9164693282dc.png#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/2dd9e1a2ffac44fbb18253a2738a4199.png#pic_center" alt="在这里插入图片描述"></p>
<p>接下来进入主题，我们的 go 语言关于访问修饰符的是指的限制什么权限，以及如何实现？</p>
<p>我们之前可以看出来，实战中的 go 程序是有一个 main 程序 import 很多其它包模块，每个模块实现对应的功能，最后统一在 main 程序中组合来完成整个软件程序，那么有一些其它模块的函数和变量，我只想在本程序文件中调用，不想被其它程序 import 能调用到，如何实现？</p>
<p>import 后是否能调用对应包中的对象 (变量，结构体，函数之类的) 就是 go 关于访问权限的定义，import 后，可以访问，说明是开启了访问权限，不可以访问，是说明关闭了其它程序访问的权限。</p>
<p>在 go 中，为了遵循实现简洁，快速的原则，用默认的规范来规定访问权限设置。</p>
<p>默认规范是：某种类型（包括变量，结构体，函数，类型等）的名称定义首字母大写就是在其它包可以访问，首字母非大写，就是只能在自己的程序中访问。</p>
<p>这样我们就能理解为什么导入 fmt 包后，他的 PrintF 函数的首字母 P 是大写的。</p>
<p>参照如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package ui</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   //这里的P是大写</span><br><span class="line">   //所有调用别的包下的函数，都是首字母大写</span><br><span class="line">   fmt.Printf(&quot;aa&quot;)</span><br><span class="line">&#125;</span><br><span class="line">//这里的Person的首字母P也是表示外部程序导入该包后可以使用此Person类</span><br><span class="line">type Person struct&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//这里的D同上</span><br><span class="line">var Data string = &quot;li_ming&quot;</span><br></pre></td></tr></table></figure>
<h3 id="12go与java程序文件的后缀名对比"><a class="markdownIt-Anchor" href="#12go与java程序文件的后缀名对比">#</a> 12.Go 与 Java 程序文件的后缀名对比</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Java的编译文件是.class结尾,多个.class打成的一个可执行文件是.jar结尾,.jar不能直接在windows和linux上执行,得用java命令在JVM中执行。</span><br><span class="line"></span><br><span class="line">Go语言的程序文件后缀为.go,有main包main函数的,.go文件打包成二进制对应操作系统的可执行程序,如windows上的.exe结尾的可执行程序。</span><br><span class="line"></span><br><span class="line">Java的类库会以.jar结尾，Go语言非main包没有main函数的程序编译打包会打成一个类库，以.a结尾,也就是说Go语言的类库以.a结尾。</span><br><span class="line"></span><br><span class="line">Go的类库如下:</span><br><span class="line">            包名.a     </span><br><span class="line">            my_util.a</span><br><span class="line">注：my_util是最顶层文件夹名，里面包含着一个个程序文件。</span><br><span class="line">12345678910</span><br></pre></td></tr></table></figure>
<h3 id="13go与java选择结构的对比"><a class="markdownIt-Anchor" href="#13go与java选择结构的对比">#</a> 13.Go 与 Java 选择结构的对比</h3>
<h4 id="1if"><a class="markdownIt-Anchor" href="#1if">#</a> 1).if</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Go中的if和Java中的if使用相同，只不过是把小括号给去掉了。       </span><br></pre></td></tr></table></figure>
<p>示例 1：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">      单分支结构语法格式如下:</span></span><br><span class="line"><span class="comment">         if 条件判断 &#123;</span></span><br><span class="line"><span class="comment">            //代码块</span></span><br><span class="line"><span class="comment">         &#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> num <span class="type">int</span></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;请输入数字&quot;</span>)</span><br><span class="line">   fmt.Scan(&amp;num)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> num &gt; <span class="number">10</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;您输入的数字大于10&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">      if else分支结构语法格式如下:</span></span><br><span class="line"><span class="comment">         if 条件判断 &#123;</span></span><br><span class="line"><span class="comment">            //代码块</span></span><br><span class="line"><span class="comment">         &#125; else &#123;</span></span><br><span class="line"><span class="comment">            //代码快2</span></span><br><span class="line"><span class="comment">         &#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> num <span class="type">int</span></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;请输入数字&quot;</span>)</span><br><span class="line">   fmt.Scan(&amp;num)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> num &gt; <span class="number">10</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;您输入的数字大于10&quot;</span>)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;您输入的数字不大于10&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">      if else分支结构语法格式如下:</span></span><br><span class="line"><span class="comment">         if 条件判断 &#123;</span></span><br><span class="line"><span class="comment">            //代码块</span></span><br><span class="line"><span class="comment">         &#125; else if 条件判断&#123;</span></span><br><span class="line"><span class="comment">            //代码块2</span></span><br><span class="line"><span class="comment">         &#125; else &#123;</span></span><br><span class="line"><span class="comment">            //代码块3</span></span><br><span class="line"><span class="comment">         &#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> num <span class="type">int</span></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;请输入数字&quot;</span>)</span><br><span class="line">   fmt.Scan(&amp;num)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> num &gt; <span class="number">10</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;您输入的数字大于10&quot;</span>)</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> num == <span class="number">10</span>&#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;您输入的数字等于10&quot;</span>)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;您输入的数字小于10&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2switch"><a class="markdownIt-Anchor" href="#2switch">#</a> 2).switch</h4>
<p>示例 1：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a = <span class="string">&quot;li_ming&quot;</span></span><br><span class="line">   <span class="keyword">switch</span> a &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&quot;li_ming&quot;</span>:</span><br><span class="line">      fmt.Println(<span class="string">&quot;Hello!LiMing&quot;</span>)</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&quot;xiao_hong&quot;</span>:</span><br><span class="line">      fmt.Println(<span class="string">&quot;Hello!XiaoHong&quot;</span>)</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">      fmt.Println(<span class="string">&quot;No!&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例 2：一分支多值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	</span><br><span class="line">   <span class="keyword">var</span> name = <span class="string">&quot;li_ming&quot;</span></span><br><span class="line">   <span class="keyword">var</span> name2 = <span class="string">&quot;xiao_hong&quot;</span></span><br><span class="line">   <span class="keyword">switch</span> name &#123;</span><br><span class="line">   <span class="comment">//li_ming或xiao_hong 均进入此</span></span><br><span class="line">   <span class="keyword">case</span> <span class="string">&quot;li_ming&quot;</span>, <span class="string">&quot;xiao_hong&quot;</span>:</span><br><span class="line">      fmt.Println(<span class="string">&quot;li_ming and xiao_hong&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">switch</span> name2 &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&quot;li_ming&quot;</span>, <span class="string">&quot;xiao_hong&quot;</span>:</span><br><span class="line">      fmt.Println(<span class="string">&quot;li_ming and xiao_hong&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;g</span><br></pre></td></tr></table></figure>
<p>示例 3：switch 表达式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> num <span class="type">int</span> = <span class="number">11</span></span><br><span class="line">   <span class="keyword">switch</span>&#123;</span><br><span class="line">      <span class="keyword">case</span> num &gt; <span class="number">10</span> &amp;&amp; num &lt; <span class="number">20</span>:</span><br><span class="line">         fmt.Println(num)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例 4：fallthrough 下面的 case 全部执行</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> num = <span class="number">11</span></span><br><span class="line">   <span class="keyword">switch</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> num == <span class="number">11</span>:</span><br><span class="line">      fmt.Println(<span class="string">&quot;==11&quot;</span>)</span><br><span class="line">      <span class="keyword">fallthrough</span></span><br><span class="line">   <span class="keyword">case</span> num &lt; <span class="number">10</span>:</span><br><span class="line">      fmt.Println(<span class="string">&quot;&lt;12&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="14go与java循环结构的对比"><a class="markdownIt-Anchor" href="#14go与java循环结构的对比">#</a> 14.Go 与 Java 循环结构的对比</h3>
<h4 id="1for循环"><a class="markdownIt-Anchor" href="#1for循环">#</a> 1).for 循环</h4>
<p>示例 1：省略小括号</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">      fmt.Println(i)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例 2：和 while 相同，break,continue 同 java</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   i := <span class="number">0</span></span><br><span class="line">   <span class="comment">//省略另外两项，相当于java中的while</span></span><br><span class="line">   <span class="keyword">for</span> i &lt; <span class="number">3</span> &#123;</span><br><span class="line">      i++</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//break用法相同</span></span><br><span class="line">   <span class="keyword">for</span> i == <span class="number">3</span> &#123;</span><br><span class="line">      fmt.Println(i)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例 3：死循环，三项均省略</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例 4：嵌套循环和 java 也一样，不演示了</p>
<p>示例 5： range 循环</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> data [<span class="number">10</span>]<span class="type">int</span> = [<span class="number">10</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;</span><br><span class="line">   <span class="keyword">for</span>  i, num := <span class="keyword">range</span> data &#123;</span><br><span class="line">      fmt.Println(i,num)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2goto"><a class="markdownIt-Anchor" href="#2goto">#</a> 2).goto</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//goto可以用在任何地方，但是不能跨函数使用</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;start&quot;</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//go to的作用是跳转，中间的语句不执行，无条件跳转</span></span><br><span class="line">   <span class="keyword">goto</span> my_location <span class="comment">//goto是关键字， my_location可以自定义，他叫标签</span></span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">&quot;over&quot;</span>)</span><br><span class="line">   my_location:</span><br><span class="line">   fmt.Println(<span class="string">&quot;location&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="15go与java的数组对比"><a class="markdownIt-Anchor" href="#15go与java的数组对比">#</a> 15.Go 与 Java 的数组对比</h3>
<p>1）go 的一维数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var 数组名 [数组长度]数组类型  = [数组长度]数组类型&#123;元素1，元素2...&#125;</span><br></pre></td></tr></table></figure>
<p>示例 1：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">//全局</span></span><br><span class="line"><span class="keyword">var</span> my_arr [<span class="number">6</span>]<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> my_arr_1 [<span class="number">3</span>]<span class="type">int</span> = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//方法内：</span></span><br><span class="line">   this_arr := [<span class="number">2</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">   fmt.Println(my_arr)</span><br><span class="line">   fmt.Println(my_arr_1)</span><br><span class="line">   fmt.Println(this_arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2）二维数组</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">//全局</span></span><br><span class="line"><span class="keyword">var</span> my_arr [<span class="number">4</span>][<span class="number">6</span>]<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> my_arr_1 [<span class="number">2</span>][<span class="number">3</span>]<span class="type">int</span> = [...][<span class="number">3</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//方法内：</span></span><br><span class="line">   this_arr := [<span class="number">2</span>][<span class="number">3</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>&#125;&#125;</span><br><span class="line">   <span class="comment">// 第 2 纬度不能用 &quot;...&quot;。</span></span><br><span class="line">   this_arr2 := [...][<span class="number">2</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">3</span>&#125;&#125;</span><br><span class="line">   fmt.Println(my_arr)</span><br><span class="line">   fmt.Println(my_arr_1)</span><br><span class="line">   fmt.Println(this_arr)</span><br><span class="line">   fmt.Println(this_arr2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="16go有指针概念java没有指针概念"><a class="markdownIt-Anchor" href="#16go有指针概念java没有指针概念">#</a> 16.Go 有指针概念，Java 没有指针概念</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Go中有指针的概念，Java中没有指针的概念。</span><br><span class="line">指针简单的说就是存储一个【变量地址】的【变量】。</span><br><span class="line">12</span><br><span class="line">Go中使用指针的方法</span><br><span class="line">//*+变量类型 = 对应变量类型的指针类型，&amp;+变量名 = 获取变量引用地址    </span><br><span class="line">var  指针变量名 *指针变量类型 = &amp;变量名  </span><br><span class="line">例如：</span><br><span class="line">var my_point *int = &amp;num</span><br><span class="line">//通过&amp;+指针变量 = 修改原来的变量真实值</span><br><span class="line">&amp;指针变量名 = 修改的变量值</span><br><span class="line">例如：</span><br><span class="line">&amp;my_point = 100;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 声明实际变量</span></span><br><span class="line">	<span class="keyword">var</span> name <span class="type">string</span>=<span class="string">&quot;li_ming&quot;</span></span><br><span class="line">	<span class="comment">// 声明指针变量</span></span><br><span class="line">	<span class="keyword">var</span> name_point *<span class="type">string</span></span><br><span class="line">	<span class="comment">// 指针变量的存储地址</span></span><br><span class="line">	name_point = &amp;name</span><br><span class="line"></span><br><span class="line">	<span class="comment">//直接访问变量地址</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;name 变量的地址是:&quot;</span>, &amp;name  )</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指针变量的存储地址</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;name_point变量储存的指针地址:&quot;</span>, name_point )</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用指针访问值</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;*name_point 变量的值:&quot;</span>, *name_point )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name 变量的地址是: 0x10ae40f0</span><br><span class="line">name_point变量储存的指针地址: 0x10ae40f0</span><br><span class="line">*name_point 变量的值: li_ming</span><br></pre></td></tr></table></figure>
<h3 id="17go语言的中newmake和java中的new对象有什么区别"><a class="markdownIt-Anchor" href="#17go语言的中newmake和java中的new对象有什么区别">#</a> 17.Go 语言的中 new,make 和 Java 中的 new 对象有什么区别？</h3>
<p>首先，Java 中的 new 关键字代表创建关于某一个类的一个新的对象。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); </span><br></pre></td></tr></table></figure>
<p>Go 中的创建一个 struct 结构体的对象，是不需要用 new 关键字的，参考【20】中有代码示例讲解如何创建结构体对象。</p>
<p>Go 中 new 的概念是和内存相关的，我们可以通过 new 来为基础数据类型申请一块内存地址空间，然后把这个把这个内存地址空间赋值给</p>
<p>一个指针变量上。（new 主要就是为基础数据类型申请内存空间的，当我们需要一个基础数据类型的指针变量，并且在初始化这个基础指针变量时，不能确定他的初始值，此时我们才需要用 new 去内存中申请一块空间，并把这空间绑定到对应的指针上，之后可以用该指针为这块内存空间写值。new 关键字在实际开发中很少使用，和 java 很多处用 new 的情况大不相同）</p>
<p>参考如下示例代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> num *<span class="type">int</span></span><br><span class="line">   <span class="comment">//此处num是nil</span></span><br><span class="line">   fmt.Println(num)</span><br><span class="line">   <span class="comment">//此处会报空指针异常，因为num为nil,没有申请内存空间，所以不能为nil赋值</span></span><br><span class="line">   *num = <span class="number">1</span></span><br><span class="line">   fmt.Println(*num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改为如下代码即可：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//在内存中申请一块地址，并把内存地址存入num</span></span><br><span class="line">   <span class="keyword">var</span> num = <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">   <span class="comment">//此处num的值是申请出来的内存空间地址值，一个十六进制的数字</span></span><br><span class="line">   fmt.Println(num)</span><br><span class="line">   <span class="comment">//正常</span></span><br><span class="line">   *num = <span class="number">1</span></span><br><span class="line">   fmt.Println(*num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们来看一个 go 中的 make 是做什么用的？</p>
<p>go 中的 make 是用来创建 slice (切片)，map (映射表)，chan (线程通信管道) 这三个类型的对象的，返回的就是对应类型的对象，他的作用就相当于 Java 中 new 一个 ArrayList，new 一个 HashMap 时候的 new 的作用，只不过是 go 语法规定用 make 来创建 slice (切片)，map (映射表)，chan (线程通信管道)。</p>
<p>示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//make只能为map,channel,slice申请分配内存，只有这三种，没有第四种</span></span><br><span class="line">   <span class="comment">//所有通过make创建的这三种类型都是引用类型，传递参数时虽然是引用值传递，</span></span><br><span class="line">   <span class="comment">//但是对方法内引用变量参数的修改可以影响到外部的引用变量</span></span><br><span class="line">   <span class="comment">//1.通过make创建map对象  如下代码类似于Java中 Map&lt;String,Integer&gt; myMap = new HashMap&lt;&gt;();</span></span><br><span class="line">   <span class="comment">//在这里make就是申请分配map的内存，和java中创建map的new一样</span></span><br><span class="line">   myMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">   myMap[<span class="string">&quot;li_ming&quot;</span>] = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.通过make创建channel,make函数内可以有一个参数，也可以有两个参数，有两个参数时第二个参数</span></span><br><span class="line">   <span class="comment">//为通道的缓存队列的长度</span></span><br><span class="line">   <span class="comment">//2.1) 只有一个参数，通道的缓存队列长度此时为0，也就是无缓存。</span></span><br><span class="line">   <span class="comment">//创建一个传输int类型数据的通道</span></span><br><span class="line">   myChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">   fmt.Println(myChan)</span><br><span class="line">   <span class="comment">//2.2) 有两个参数，第二个参数2代表此时代表缓存队列的长度为2</span></span><br><span class="line">   <span class="comment">//创建一个传输int类型数据的通道,缓存为2</span></span><br><span class="line">   mychan2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">2</span>)</span><br><span class="line">   fmt.Println(mychan2)</span><br><span class="line">   <span class="comment">//此处暂时不做通道缓存队列数多少有何区别的讲解</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.通过make创建slice切片</span></span><br><span class="line">   <span class="comment">//有两种方式，一种是两个参数，一种是三个参数</span></span><br><span class="line">   <span class="comment">//我们只有在创建一个空的切片时才会使用make</span></span><br><span class="line">   <span class="comment">//如果通过一个已有的数组创建切片往往是下面的形式</span></span><br><span class="line">   <span class="comment">//创建一个底层数组</span></span><br><span class="line">   myArr := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">   <span class="comment">//如果通过一个数组创建切片，往往是用 原始数组变量名[切片起始位置:切片结束位置] 创建一个切片</span></span><br><span class="line">   mySlice1 := myArr[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">   fmt.Println(mySlice1)</span><br><span class="line">   <span class="comment">//我们如果是想创建一个空的slice,则用make创建切片</span></span><br><span class="line">   <span class="comment">//如下形式 make(int[],num1,num2)</span></span><br><span class="line">   <span class="comment">//num1 = 切片的长度(默认分配内存空间的元素个数)</span></span><br><span class="line">   <span class="comment">//num2 = 切片的容量(解释：底层数组的长度/切片的容量，超过底层数组长度append新元素时会创建一个新的底层数组，</span></span><br><span class="line">   <span class="comment">//不超过则会使用原来的底层数组)</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//代表底层数组的长度是4,默认给底层数组的前两个元素分配内存空间</span></span><br><span class="line">   <span class="comment">//切片指向前两个元素的地址，如果append新元素，在元素数小于4时都会</span></span><br><span class="line">   <span class="comment">//在原来的底层数组的最后一个元素新分配空间和赋值，</span></span><br><span class="line">   <span class="comment">//append超过4个元素时，因为原数组大小不可变，也也存储不下了，</span></span><br><span class="line">   <span class="comment">//所以会新创建一个新的底层数组，切片指向新的底层数组</span></span><br><span class="line">   mySliceEmpty := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">   fmt.Println(mySliceEmpty)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//两个参数，代表切片的长度和切片的容量(底层数组长度)均为第二个参数那个值</span></span><br><span class="line">   mySliceEmpty2 := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">5</span>)</span><br><span class="line">   fmt.Println(mySliceEmpty2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="18go相关的数据容器和java的集合框架对比"><a class="markdownIt-Anchor" href="#18go相关的数据容器和java的集合框架对比">#</a> 18.Go 相关的数据容器和 Java 的集合框架对比</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Go中有的数据结构：数组，切片，map，双向链表，环形链表，堆</span><br><span class="line">Go自己的类库中没有set,没有集合(List)，但是第三方库有实现。</span><br><span class="line">Java中有： Map,Set,List,Queue,Stack,数组</span><br><span class="line">Java中没有切片的概念。</span><br><span class="line">Go中的数组打印格式是[1,2,3,4,5] </span><br><span class="line">Go中的切片打印格式是[[1,2,3]]</span><br><span class="line">Go中切片的概念：切片是数组的一个子集，就是数组截取某一段。</span><br><span class="line">Go的map和Java的map大致相同</span><br></pre></td></tr></table></figure>
<h3 id="19go中的函数go的方法和java中的方法对比"><a class="markdownIt-Anchor" href="#19go中的函数go的方法和java中的方法对比">#</a> 19.Go 中的函数，Go 的方法和 Java 中的方法对比</h3>
<h4 id="1go中的函数定义"><a class="markdownIt-Anchor" href="#1go中的函数定义">#</a> 1).Go 中的函数定义</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Go中返回值可以有多个，不像Java中多个值得封装到实体或map返回</span><br><span class="line">//注：【】内的返回值可不写，无返回值直接把返回值部分全部去掉即可。</span><br><span class="line">func 函数名(变量1 变量类型，变量2 变量2类型...)【(返回值1 类型1，返回值2 类型2...)】  &#123;        //注意：这个方法的右中括号必须和func写在同一行才行，否则报错，不能按c语言中的换行写</span><br><span class="line">123</span><br></pre></td></tr></table></figure>
<p>示例 1：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//定义局部变量</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">100</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="type">int</span> = <span class="number">200</span></span><br><span class="line">   <span class="keyword">var</span> result <span class="type">int</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//调用函数并返回最大值</span></span><br><span class="line">   result = max(a, b)</span><br><span class="line"></span><br><span class="line">   fmt.Println( <span class="string">&quot;最大值是 :&quot;</span>, result )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数返回两个数的最大值 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(num1, num2 <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> result <span class="type">int</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (num1 &gt; num2) &#123;</span><br><span class="line">      result = num1</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = num2</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例 2：返回多个值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a, b := swap(<span class="string">&quot;li_ming&quot;</span>, <span class="string">&quot;xiao_hong&quot;</span>)</span><br><span class="line">   fmt.Println(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">string</span>) &#123;</span><br><span class="line">   <span class="comment">//返回多个值</span></span><br><span class="line">   <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意点：函数的参数：基础类型是按值传递，复杂类型是按引用传递</p>
<p>示例 3： 函数的参数：变长参数传递</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	manyArgs(<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>)</span><br><span class="line">	manyArgs(<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;5&quot;</span>)</span><br><span class="line">	dataStr := []<span class="type">string</span>&#123;<span class="string">&quot;11&quot;</span>,<span class="string">&quot;11&quot;</span>,<span class="string">&quot;11&quot;</span>&#125;</span><br><span class="line">	<span class="comment">//传数组也可以，加三个点</span></span><br><span class="line">	manyArgs(<span class="number">1</span>,<span class="number">2</span>,dataStr...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可变参数必须放在最后面</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">manyArgs</span><span class="params">(a <span class="type">int</span>,b <span class="type">int</span> ,str ...<span class="type">string</span> )</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> i,s := <span class="keyword">range</span> str &#123;</span><br><span class="line">		fmt.Println(i,s)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意点：函数的返回值：如果有返回值，返回值的类型必须写，返回值得变量名根据情况可写可不写。</p>
<p>示例 4： defer：推迟执行 (类似于 java 中的 finally)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   testMyFunc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testDefer1</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;print defer1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testDefer2</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;print defer2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testMyFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//defer会在方法返回前执行，有点像java中的finally</span></span><br><span class="line">   <span class="comment">//defer写在任意位置均可，多个defer的话按照逆序依次执行</span></span><br><span class="line">   <span class="keyword">defer</span> testDefer2()</span><br><span class="line">   <span class="keyword">defer</span> testDefer1()</span><br><span class="line">   fmt.Println(<span class="string">&quot;print my func&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例 5 ：丢弃返回值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//方式一丢弃：丢弃num1和str</span></span><br><span class="line">   _,num2,_:= testFun(<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;3&quot;</span>);</span><br><span class="line">   fmt.Println(num2)</span><br><span class="line">   <span class="comment">//方式二丢弃：</span></span><br><span class="line">   _,num3,_:= testFun(<span class="number">1</span>,<span class="number">3</span>,<span class="string">&quot;4&quot;</span>);</span><br><span class="line">   fmt.Println(num3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testFun</span><span class="params">(num1,num2 <span class="type">int</span>,str <span class="type">string</span>)</span></span> (n1 <span class="type">int</span>,n2 <span class="type">int</span>,s1 <span class="type">string</span>)&#123;</span><br><span class="line">   n1 = num1</span><br><span class="line">   n2 = num2</span><br><span class="line">   s1 = str</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testFun2</span><span class="params">(num1,num2 <span class="type">int</span>,str <span class="type">string</span>)</span></span> (<span class="type">int</span>,<span class="type">int</span>,<span class="type">string</span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> num1,num2,str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2java中的方法定义"><a class="markdownIt-Anchor" href="#2java中的方法定义">#</a> 2).Java 中的方法定义</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符   返回值类型   方法名(参数1类型  参数1，参数2类型 参数2...) &#123;</span><br><span class="line"></span><br><span class="line">      return 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Integer <span class="title function_">doSomething</span><span class="params">(String name,Integer age)</span> &#123;</span><br><span class="line">   </span><br><span class="line">		<span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="20go的内置函数和java的默认导入包javalang"><a class="markdownIt-Anchor" href="#20go的内置函数和java的默认导入包javalang">#</a> 20.Go 的内置函数和 Java 的默认导入包 java.lang.*</h3>
<p>为了在 Java 中快速开发，Java 语言的创造者把一些常用的类和接口都放到到 java.lang 包下，lang 包下的特点就是不用写 import 语句导入包就可以用里面的程序代码。</p>
<p>Go 中也有类似的功能，叫做 Go 的内置函数，Go 的内置函数是指不用导入任何包，直接就可以通过函数名进行调用的函数。</p>
<p>Go 中的内置函数有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">close          关闭channel</span><br><span class="line"></span><br><span class="line">len            求长度</span><br><span class="line"></span><br><span class="line">make	      创建slice,map,chan对象</span><br><span class="line"></span><br><span class="line">append	      追加元素到切片(slice)中</span><br><span class="line"> </span><br><span class="line">panic         抛出异常，终止程序</span><br><span class="line"></span><br><span class="line">recover       尝试恢复异常，必须写在defer相关的代码块中</span><br></pre></td></tr></table></figure>
<p>参考示例代码 1：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   array := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">   str := <span class="string">&quot;myName&quot;</span></span><br><span class="line">   <span class="comment">//获取字符串长度</span></span><br><span class="line">   fmt.Println(<span class="built_in">len</span>(str))</span><br><span class="line">   <span class="comment">//获取数组长度</span></span><br><span class="line">   fmt.Println(<span class="built_in">len</span>(array))</span><br><span class="line">   <span class="comment">//获取切片长度</span></span><br><span class="line">   fmt.Println(<span class="built_in">len</span>(array[<span class="number">1</span>:]))</span><br><span class="line"></span><br><span class="line">   <span class="comment">//make创建channel示例</span></span><br><span class="line">   intChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">1</span>)</span><br><span class="line">   <span class="comment">//make创建map示例</span></span><br><span class="line">   myMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">   <span class="comment">//make创建切片</span></span><br><span class="line">   mySlice := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">5</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">   fmt.Println(intChan)</span><br><span class="line">   fmt.Println(myMap)</span><br><span class="line">   fmt.Println(mySlice)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//关闭管道</span></span><br><span class="line">   <span class="built_in">close</span>(intChan)</span><br><span class="line">   <span class="comment">//为切片添加元素</span></span><br><span class="line">   array2 := <span class="built_in">append</span>(array[:],<span class="number">6</span>)</span><br><span class="line">   <span class="comment">//输出</span></span><br><span class="line">   fmt.Println(array2)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//new案例</span></span><br><span class="line">   num := <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">   fmt.Println(num)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考示例代码 2：panic 和 recover 的使用</p>
<p>他们用于抛出异常和尝试捕获恢复异常</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 刚刚打开某资源</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		err := <span class="built_in">recover</span>()</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		fmt.Println(<span class="string">&quot;释放资源..&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">&quot;抛出异常&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="number">2</span><span class="string">&quot;)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">func func3() &#123;</span></span><br><span class="line"><span class="string">	fmt.Println(&quot;</span><span class="number">3</span><span class="string">&quot;)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">func main() &#123;</span></span><br><span class="line"><span class="string">	func1()</span></span><br><span class="line"><span class="string">	func2()</span></span><br><span class="line"><span class="string">	func3()</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>Java 中的 java.lang 包下具体有什么在这里就不赘述了，请参考 JavaAPI 文档：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JavaAPI文档导航：https://www.oracle.com/cn/java/technologies/java-se-api-doc.html</span><br></pre></td></tr></table></figure>
<h3 id="21go的标准格式化输出库fmt和java的输出打印库对比"><a class="markdownIt-Anchor" href="#21go的标准格式化输出库fmt和java的输出打印库对比">#</a> 21.Go 的标准格式化输出库 fmt 和 java 的输出打印库对比</h3>
<p>Java 的标准输出流工具类是 java.lang 包下的 System 类，具体是其静态成员变量 PrintStream 类。</p>
<p>他有静态三个成员变量:</p>
<p>分别是 PrintStream 类型的 out,in,err</p>
<p>我们常见 System.out.println (), 实际上调用的就是 PrintStream 类对象的 println 方法。</p>
<hr>
<p>Go 中的格式化输出输入库是 fmt 模块。</p>
<p>fmt 在 Go 中提供了输入和输出的功能，类型 Java 中的 Scanner 和 PrintStream (println)。</p>
<p>它的使用方法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Print:   原样输出到控制台，不做格式控制。</span><br><span class="line">Println: 输出到控制台并换行</span><br><span class="line">Printf : 格式化输出(按特定标识符指定格式替换)</span><br><span class="line">Sprintf：格式化字符串并把字符串返回，不输出，有点类似于Java中的拼接字符串然后返回。</span><br><span class="line">Fprintf：来格式化并输出到 io.Writers 而不是 os.Stdout</span><br></pre></td></tr></table></figure>
<p>详细占位符号如下：</p>
<p>代码示例如下：</p>
<h3 id="22go的面向对象相关知识"><a class="markdownIt-Anchor" href="#22go的面向对象相关知识">#</a> 22.Go 的面向对象相关知识</h3>
<h4 id="1封装属性结构体"><a class="markdownIt-Anchor" href="#1封装属性结构体">#</a> 1. 封装属性 (结构体)</h4>
<p>Go 中有一个数据类型是 Struct, 它在面向对象的概念中相当于 Java 的类，可以封装属性和封装方法，首先看封装属性如下示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">   name <span class="type">string</span></span><br><span class="line">   age <span class="type">int</span></span><br><span class="line">   sex <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//示例1：</span></span><br><span class="line">   <span class="keyword">var</span> l1 People</span><br><span class="line">   l1.name = <span class="string">&quot;li_ming&quot;</span></span><br><span class="line">   l1.age = <span class="number">22</span></span><br><span class="line">   l1.sex = <span class="literal">false</span></span><br><span class="line">   <span class="comment">//li_ming</span></span><br><span class="line">   fmt.Println(l1.name)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//示例2</span></span><br><span class="line">   <span class="keyword">var</span> l2 *People = <span class="built_in">new</span>(People)</span><br><span class="line">   l2.name = <span class="string">&quot;xiao_hong&quot;</span></span><br><span class="line">   l2.age = <span class="number">33</span></span><br><span class="line">   l2.sex = <span class="literal">true</span></span><br><span class="line">   <span class="comment">//xiao_hong xiao_hong</span></span><br><span class="line">   fmt.Println(l2.name,(*l2).name)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//示例3:</span></span><br><span class="line">   <span class="keyword">var</span> l3 *People = &amp;People&#123; name:<span class="string">&quot;li_Ming&quot;</span>,age:<span class="number">25</span>,sex:<span class="literal">true</span>&#125;</span><br><span class="line">   <span class="comment">//li_Ming  li_Ming</span></span><br><span class="line">   fmt.Println(l3.name,(*l3).name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2封装方法方法接收器"><a class="markdownIt-Anchor" href="#2封装方法方法接收器">#</a> 2. 封装方法 (方法接收器)</h4>
<p>如果想为某个 Struct 类型添加一个方法，参考如下说明和代码：</p>
<p>go 的方法和 Java 中的方法对比，go 的函数和 go 方法的不同</p>
<p>Go 中的函数是不需要用结构体的对象来调用的，可以直接调用</p>
<p>Go 中的方法是必须用一个具体的结构体对象来调用的，有点像 Java 的某个类的对象调用其方法</p>
<p>我们可以把指定的函数绑定到对应的结构体上，使该函数成为这个结构体的方法，然后这个结构体的对象就可以通过。来调用这个方法了</p>
<p>绑定的形式是：在 func 和方法名之间写一个 (当前对象变量名 当前结构体类型)，这个叫方法的接受器，其中当前对象的变量名就是当前结构体调用该方法的对象的引用，相当于 java 中的 this 对象。</p>
<p>参考如下示例为 Student 学生添加一个 learn 学习的方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span>  &#123;</span><br><span class="line">   num <span class="type">int</span> <span class="comment">//学号</span></span><br><span class="line">   name <span class="type">string</span> <span class="comment">//姓名</span></span><br><span class="line">   class <span class="type">int</span>  <span class="comment">//班级</span></span><br><span class="line">   sex  <span class="type">bool</span>  <span class="comment">//性别</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给Student添加一个方法</span></span><br><span class="line"><span class="comment">//这里的(stu Student)中的stu相当于java方法中的this对象</span></span><br><span class="line"><span class="comment">//stu是一个方法的接收器，接收是哪个对象调用了当方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu Student)</span></span> learn() &#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;%s学生正在学习&quot;</span>,stu.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   stu := Student&#123;<span class="number">1</span>,<span class="string">&quot;li_ming&quot;</span>,<span class="number">10</span>,<span class="literal">true</span>&#125;</span><br><span class="line">   stu.learn()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法的接收器也可以是指针类型的</p>
<p>参考如下案例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span>  &#123;</span><br><span class="line">   num <span class="type">int</span> <span class="comment">//学号</span></span><br><span class="line">   name <span class="type">string</span> <span class="comment">//姓名</span></span><br><span class="line">   class <span class="type">int</span>  <span class="comment">//班级</span></span><br><span class="line">   sex  <span class="type">bool</span>  <span class="comment">//性别</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里方法的接收器也可以是指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu *Student)</span></span> learn() &#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;%s学生正在学习&quot;</span>,stu.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//指针类型</span></span><br><span class="line">   stu := &amp;Student&#123;<span class="number">1</span>,<span class="string">&quot;li_ming&quot;</span>,<span class="number">10</span>,<span class="literal">true</span>&#125;</span><br><span class="line">   stu.learn()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意有一种情况，当一个对象为 nil 空时，它调用方法时，接收器接受的对于自身的引用也是 nil，需要我们做一些健壮性的不为 nil 才做的判断处理。</p>
<h4 id="3go的继承结构体嵌入"><a class="markdownIt-Anchor" href="#3go的继承结构体嵌入">#</a> 3.Go 的继承 (结构体嵌入)</h4>
<p>Go 中可以用嵌入结构体实现类似于继承的功能：</p>
<p>参考如下代码示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑</span></span><br><span class="line"><span class="keyword">type</span> Computer <span class="keyword">struct</span> &#123;</span><br><span class="line">	screen <span class="type">string</span> <span class="comment">//电脑屏幕</span></span><br><span class="line">	keyboard <span class="type">string</span> <span class="comment">//键盘</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cp Computer)</span></span> compute(num1,num2 <span class="type">int</span>) <span class="type">int</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//笔记本电脑</span></span><br><span class="line"><span class="keyword">type</span> NoteBookComputer <span class="keyword">struct</span>&#123;</span><br><span class="line">	Computer</span><br><span class="line">	wireless_network_adapter <span class="type">string</span> <span class="comment">//无线网卡</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> cp1 NoteBookComputer = NoteBookComputer&#123;&#125;</span><br><span class="line">	cp1.screen = <span class="string">&quot;高清屏&quot;</span></span><br><span class="line">	cp1.keyboard = <span class="string">&quot;防水键盘&quot;</span></span><br><span class="line">	cp1.wireless_network_adapter = <span class="string">&quot;新一代无线网卡&quot;</span></span><br><span class="line">	fmt.Println(cp1)</span><br><span class="line">	fmt.Println(cp1.compute(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，Go 中可以嵌入多个结构体，但是多个结构体不能有相同的方法，如果有参数和方法名完全相同的方法，在编译的时候就会报错。所以 Go 不存在嵌入多个结构体后，被嵌入的几个结构体有相同的方法，最后不知道选择执行哪个方法的情况，多个结构体方法相同时，直接编译就会报错。</p>
<p>参考如下示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   man := Man&#123;&#125;</span><br><span class="line">   fmt.Println(man)</span><br><span class="line">   <span class="comment">//下面的代码编译会报错</span></span><br><span class="line">   <span class="comment">//man.doEat()</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Man <span class="keyword">struct</span> &#123;</span><br><span class="line">   FatherA</span><br><span class="line">   FatherB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p FatherA)</span></span>  doEat() &#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;FatherA eat&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t FatherB)</span></span>  doEat() &#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;FatherB eat&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FatherB <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FatherA <span class="keyword">struct</span>  &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4go的多态接口"><a class="markdownIt-Anchor" href="#4go的多态接口">#</a> 4.Go 的多态 (接口)</h4>
<p>接下来我们讲 Go 中如何通过父类接口指向具体实现类对象，实现多态：</p>
<p>go 语言中的接口是非侵入式接口。</p>
<p>java 语言中的接口是侵入式接口。</p>
<p>侵入式接口是指需要显示的在类中写明实现哪些接口。</p>
<p>非侵入式接口是指不要显示的在类中写明要实现哪些接口，只需要方法名同名，参数一致即可。</p>
<p>参考如下代码示例：接口与多态</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//动物接口</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">interface</span>&#123;</span><br><span class="line">   eat()     <span class="comment">//吃饭接口方法</span></span><br><span class="line">   sleep()       <span class="comment">//睡觉接口方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//小猫</span></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//小狗</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//小猫吃方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cat Cat)</span></span> eat() &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;小猫在吃饭&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//小猫睡方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cat Cat)</span></span> sleep()&#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;小猫在睡觉&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//小狗在吃饭</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dog Dog)</span></span> eat()&#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;小狗在吃饭&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//小狗在睡觉</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dog Dog)</span></span> sleep()&#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;小狗在睡觉&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> cat Animal = Cat&#123;&#125;</span><br><span class="line">   <span class="keyword">var</span> dog Animal = Dog&#123;&#125;</span><br><span class="line">   cat.eat()</span><br><span class="line">   cat.sleep()</span><br><span class="line">   dog.eat()</span><br><span class="line">   dog.sleep()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口可以内嵌接口</p>
<p>参考如下代码示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="comment">//内嵌接口</span></span><br><span class="line"><span class="comment">//学习接口，内嵌听和看学习接口</span></span><br><span class="line"><span class="keyword">type</span> Learn <span class="keyword">interface</span> &#123;</span><br><span class="line">   LearnByHear</span><br><span class="line">   LearnByLook</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过听学习接口</span></span><br><span class="line"><span class="keyword">type</span> LearnByHear <span class="keyword">interface</span> &#123;</span><br><span class="line">   hear()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过看学习</span></span><br><span class="line"><span class="keyword">type</span> LearnByLook <span class="keyword">interface</span> &#123;</span><br><span class="line">   look()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id=""><a class="markdownIt-Anchor" href="#">#</a> </h3>
<h3 id="23go语言中线程的实现和java语言中线程的实现"><a class="markdownIt-Anchor" href="#23go语言中线程的实现和java语言中线程的实现">#</a> 23.Go 语言中线程的实现和 Java 语言中线程的实现</h3>
<p>go 中的线程相关的概念是 Goroutines (并发)，是使用 go 关键字开启。</p>
<p>Java 中的线程是通过 Thread 类开启的。</p>
<p>在 go 语言中，一个线程就是一个 Goroutines，主函数就是（主） main Goroutines。</p>
<p>使用 go 语句来开启一个新的 Goroutines</p>
<p>比如：</p>
<p>普通方法执行</p>
<p>myFunction()</p>
<p>开启一个 Goroutines 来执行方法</p>
<p>go myFunction()</p>
<p>java 中是</p>
<p>new Thread(()-&gt;{</p>
<p>// 新线程逻辑代码</p>
<p>}).start();</p>
<p>参考下面的代码示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//并发开启新线程goroutine测试</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunction</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;Hello!!!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//并发执行方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goroutineTestFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;Hello!!! Start Goroutine!!!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   myFunction()</span></span><br><span class="line"><span class="comment">   //go goroutineTestFunc()</span></span><br><span class="line"><span class="comment">   //此时因为主线程有时候结束的快，goroutineTestFunc方法得不到输出，由此可以看出是开启了新的线程。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="comment">//打开第二段执行</span></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   go goroutineTestFunc()</span></span><br><span class="line"><span class="comment">   time.Sleep(10*time.Second)//睡一段时间  10秒</span></span><br><span class="line"><span class="comment">   myFunction()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程间的通信：</p>
<p>java 线程间通信有很多种方式：</p>
<p>比如最原始的 wait/notify</p>
<p>到使用 juc 下高并发线程同步容器，Go 和 Java 关于 Socket 编程的对比同步队列</p>
<p>到 CountDownLatch 等一系列工具类</p>
<p>…</p>
<p>甚至是分布式系统不同机器之间的消息中间件，单机的 disruptor 等等。</p>
<p>Go 语言不同，线程间主要的通信方式是 Channel。</p>
<p>Channel 是实现 go 语言多个线程（goroutines）之间通信的一个机制。</p>
<p>Channel 是一个线程间传输数据的管道，创建 Channel 必须声明管道内的数据类型是什么</p>
<p>下面我们创建一个传输 int 类型数据的 Channel</p>
<p>代码示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">   fmt.Println(ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>channel 是引用类型，函数传参数时是引用传递而不是值拷贝的传递。</p>
<p>channel 的空值和别的应用类型一样是 nil。</p>
<p>== 可以比较两个 Channel 之间传输的数据类型是否相等。</p>
<p>channel 是一个管道，他可以收数据和发数据。</p>
<p>具体参照下面代码示例:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//channel发送数据和接受数据用 &lt;-表示,是发送还是接受取决于chan在  &lt;-左边还是右边</span></span><br><span class="line"><span class="comment">//创建一个传输字符串数据类型的管道</span></span><br><span class="line"><span class="keyword">var</span>  chanStr  = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;main goroutine print Hello &quot;</span>)</span><br><span class="line">   <span class="comment">//默认channel是没有缓存的，阻塞的，也就是说，发送端发送后直到接受端接受到才会施放阻塞往下面走。</span></span><br><span class="line">   <span class="comment">//同样接收端如果先开启，直到接收到数据才会停止阻塞往下走</span></span><br><span class="line">   <span class="comment">//开启新线程发送数据</span></span><br><span class="line">   <span class="keyword">go</span> startNewGoroutineOne()</span><br><span class="line">   <span class="comment">//从管道中接收读取数据</span></span><br><span class="line">   <span class="keyword">go</span> startNewGoroutineTwo()</span><br><span class="line">   <span class="comment">//主线程等待，要不直接结束了</span></span><br><span class="line">   time.Sleep(<span class="number">100</span>*time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startNewGoroutineOne</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;send channel print Hello &quot;</span>)</span><br><span class="line">   <span class="comment">//管道发送数据</span></span><br><span class="line">   chanStr &lt;- <span class="string">&quot;Hello!!!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startNewGoroutineTwo</span><span class="params">()</span></span>&#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;receive channel print Hello &quot;</span>)</span><br><span class="line">   strVar := &lt;-chanStr</span><br><span class="line">   fmt.Println(strVar)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无缓存的 channel 可以起到一个多线程间线程数据同步锁安全的作用。</p>
<p>缓存的 channel 创建方式是</p>
<p>make (chan string, 缓存个数)</p>
<p>缓存个数是指直到多个数据没有消费或者接受后才进行阻塞。</p>
<p>类似于 java 中的 synchronized 和 lock</p>
<p>可以保证多线程并发下的数据一致性问题。</p>
<p>首先我们看一个线程不安全的代码示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//多线程并发下的不安全问题</span></span><br><span class="line"><span class="comment">//金额</span></span><br><span class="line"><span class="keyword">var</span> moneyA <span class="type">int</span> =<span class="number">1000</span></span><br><span class="line"><span class="comment">//添加金额</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subtractMoney</span><span class="params">(subMoney <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   time.Sleep(<span class="number">3</span>*time.Second)</span><br><span class="line">   moneyA-=subMoney</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询金额</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMoney</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> moneyA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//添加查询金额</span></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(getMoney()&gt;<span class="number">200</span>) &#123;</span><br><span class="line">         subtractMoney(<span class="number">200</span>)</span><br><span class="line">         fmt.Printf(<span class="string">&quot;200元扣款成功，剩下：%d元\n&quot;</span>,getMoney())</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="comment">//添加查询金额</span></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(getMoney()&gt;<span class="number">900</span>) &#123;</span><br><span class="line">         subtractMoney(<span class="number">900</span>)</span><br><span class="line">         fmt.Printf(<span class="string">&quot;900元扣款成功，剩下：%d元\n&quot;</span>,getMoney())</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="comment">//正常逻辑，只够扣款一单，可以多线程环境下结果钱扣多了</span></span><br><span class="line">   time.Sleep(<span class="number">5</span>*time.Second)</span><br><span class="line">   fmt.Println(getMoney())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缓存为 1 的 channel 可以作为锁使用：</p>
<p>示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//多线程并发下使用channel改造</span></span><br><span class="line"><span class="comment">//金额</span></span><br><span class="line"><span class="keyword">var</span> moneyA  = <span class="number">1000</span></span><br><span class="line"><span class="comment">//减少金额管道</span></span><br><span class="line"><span class="keyword">var</span> synchLock = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加金额</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subtractMoney</span><span class="params">(subMoney <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   time.Sleep(<span class="number">3</span>*time.Second)</span><br><span class="line">   moneyA-=subMoney</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询金额</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMoney</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> moneyA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//添加查询金额</span></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      synchLock&lt;<span class="number">-10</span></span><br><span class="line">      <span class="keyword">if</span>(getMoney()&gt;<span class="number">200</span>) &#123;</span><br><span class="line">         subtractMoney(<span class="number">200</span>)</span><br><span class="line">         fmt.Printf(<span class="string">&quot;200元扣款成功，剩下：%d元\n&quot;</span>,getMoney())</span><br><span class="line">      &#125;</span><br><span class="line">      &lt;-synchLock</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="comment">//添加查询金额</span></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      synchLock&lt;<span class="number">-10</span></span><br><span class="line">      <span class="keyword">if</span>(getMoney()&gt;<span class="number">900</span>) &#123;</span><br><span class="line">         subtractMoney(<span class="number">900</span>)</span><br><span class="line">         fmt.Printf(<span class="string">&quot;900元扣款成功，剩下：%d元\n&quot;</span>,getMoney())</span><br><span class="line">      &#125;</span><br><span class="line">      synchLock&lt;<span class="number">-10</span></span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="comment">//这样类似于java中的Lock锁，不会扣多</span></span><br><span class="line">   time.Sleep(<span class="number">5</span>*time.Second)</span><br><span class="line">   fmt.Println(getMoney())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>go 也有互斥锁</p>
<p>类似于 java 中的 Lock 接口</p>
<p>参考如下示例代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;sync&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//多线程并发下使用channel改造</span></span><br><span class="line"><span class="comment">//金额</span></span><br><span class="line"><span class="keyword">var</span> moneyA  = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lock sync.Mutex;</span><br><span class="line"><span class="comment">//添加金额</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subtractMoney</span><span class="params">(subMoney <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   lock.Lock()</span><br><span class="line">   time.Sleep(<span class="number">3</span>*time.Second)</span><br><span class="line">   moneyA-=subMoney</span><br><span class="line">   lock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询金额</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMoney</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   lock.Lock()</span><br><span class="line">   result := moneyA</span><br><span class="line">   lock.Unlock()</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//添加查询金额</span></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(getMoney()&gt;<span class="number">200</span>) &#123;</span><br><span class="line">         subtractMoney(<span class="number">200</span>)</span><br><span class="line">         fmt.Printf(<span class="string">&quot;200元扣款成功，剩下：%d元\n&quot;</span>,getMoney())</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">         fmt.Println(<span class="string">&quot;余额不足，无法扣款&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="comment">//添加查询金额</span></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(getMoney()&gt;<span class="number">900</span>) &#123;</span><br><span class="line">         subtractMoney(<span class="number">900</span>)</span><br><span class="line">         fmt.Printf(<span class="string">&quot;900元扣款成功，剩下：%d元\n&quot;</span>,getMoney())</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">         fmt.Println(<span class="string">&quot;余额不足，无法扣款&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="comment">//正常</span></span><br><span class="line">   time.Sleep(<span class="number">5</span>*time.Second)</span><br><span class="line">   fmt.Println(getMoney())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="24go中的反射与java中的反射对比"><a class="markdownIt-Anchor" href="#24go中的反射与java中的反射对比">#</a> 24.Go 中的反射与 Java 中的反射对比</h3>
<p>整体概述：反射是一个通用的概念，是指在程序运行期间获取到变量或者对象，结构体的元信息，比如类型信息，并且能够取出其中变量的值，调用对应的方法。</p>
<p>首先我们先来回顾一下 Java 语言用到反射的场景有哪些？</p>
<p>1. 比如说我们的方法参数不能确定是什么类型，是 Object 类型，我们就可以通过反射在运行期间获取其真实的类型，然后做对应的逻辑处理。</p>
<p>2. 比如动态代理，我们需要在程序运行时，动态的加载一个类，创建一个类，使用一个类。</p>
<p>3. 比如在想要强行破解获取程序中被 private 的成员。</p>
<p>4.Java 的各种框架中用的非常多，框架中用反射来判断用户自定义的类是什么类型，然后做区别处理。</p>
<p>Go 中的反射大概也是相同的，比如，go 中有一个类型 interface,interface 类型相当于 Java 中的 Object 类，当以 interface 作为参数类型时，可以给这个参数传递任意类型的变量。</p>
<p>例如示例 1：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   testAllType(<span class="number">1</span>);</span><br><span class="line">   testAllType(<span class="string">&quot;Go&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//interface&#123;&#125;代表任意类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testAllType</span> <span class="params">(data <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">   fmt.Println(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么第一种应用场景就出现了，当我们在 go 中想实现一个函数 / 方法，这个函数 / 方法的参数类型在编写程序的时候不能确认，在运行时会有各种不同的类型传入这个通用的函数 / 方法中，我们需要对不同类型的参数做不同的处理，那么我们就得能获取到参数是什么类型的，然后根据这个类型信息做业务逻辑判断。</p>
<p>反射我们需要调用 reflect 包模块，使用 reflect.typeOf () 可以获取参数的类型信息对象，再根据类型信息对象的 kind 方法，获取到具体类型，详细参考下面代码。</p>
<p>例如示例 2：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   handleType(<span class="number">1</span>)</span><br><span class="line">   handleType(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleType</span><span class="params">(data <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">   <span class="comment">//获取类型对象</span></span><br><span class="line">   d := reflect.TypeOf(data)</span><br><span class="line">   <span class="comment">//kind方法是获取类型</span></span><br><span class="line">   fmt.Println(d.Kind())</span><br><span class="line">   <span class="keyword">switch</span> d.Kind() &#123;</span><br><span class="line">      <span class="keyword">case</span> reflect.Invalid:</span><br><span class="line">         <span class="comment">//无效类型逻辑处理</span></span><br><span class="line">         fmt.Println(<span class="string">&quot;无效类型&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> reflect.Int,reflect.Int8,reflect.Int16,reflect.Int32,reflect.Int64:</span><br><span class="line">         fmt.Println(<span class="string">&quot;整形&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> reflect.Bool:</span><br><span class="line">         fmt.Println(<span class="string">&quot;bool类型&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line">因为传入进来的都是<span class="keyword">interface</span>类型，所以我们需要用的时候要区分类型，然后取出其中真正类型的值。</span><br></pre></td></tr></table></figure>
<p>反射取出值得方法就是先通过 reflect.ValueOf () 获取参数值对象，然后再通过不同的具体方法获取到值对象，比如 int 和 bool</p>
<p>示例 3：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	handleValue(<span class="number">1</span>)</span><br><span class="line">	handleValue(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleValue</span><span class="params">(data <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="comment">//获取类型对象</span></span><br><span class="line">	d := reflect.ValueOf(data)</span><br><span class="line">	<span class="comment">//kind方法是获取类型</span></span><br><span class="line">	fmt.Println(d.Kind())</span><br><span class="line">	<span class="keyword">switch</span> d.Kind() &#123;</span><br><span class="line">		<span class="keyword">case</span> reflect.Invalid:</span><br><span class="line">			<span class="comment">//无效类型逻辑处理</span></span><br><span class="line">			fmt.Println(<span class="string">&quot;无效类型&quot;</span>)</span><br><span class="line">		<span class="keyword">case</span> reflect.Int,reflect.Int8,reflect.Int16,reflect.Int32,reflect.Int64:</span><br><span class="line">			<span class="comment">//取出值</span></span><br><span class="line">			<span class="keyword">var</span> myNum = d.Int()</span><br><span class="line">			fmt.Println(myNum)</span><br><span class="line">		<span class="keyword">case</span> reflect.Bool:</span><br><span class="line">			<span class="comment">//取出bool值</span></span><br><span class="line">			<span class="keyword">var</span> myBool = d.Bool()</span><br><span class="line">			fmt.Println(myBool)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构体中的属性和方法怎么获取呢？</p>
<p>获取结构体属性的个数是先 ValueOf 获取结构体值对象 v 后，用 v.NumField () 获取该结构体有几个属性，通过 v.Field (i) 来获取对应位置的属性的元类型。</p>
<p>示例代码 4：</p>
<p>后续反射还有几个 api 和代码示例和具体应用场景，正在补。。。</p>
<h3 id="25变量作用域的区别"><a class="markdownIt-Anchor" href="#25变量作用域的区别">#</a> 25. 变量作用域的区别</h3>
<p>Go 语言的变量作用域和 Java 中的一样，遵循最近原则，逐渐往外层找。</p>
<p>这个比较简单，就不做过多赘述了。</p>
<h3 id="26go语言和java语言字符串操作的区别"><a class="markdownIt-Anchor" href="#26go语言和java语言字符串操作的区别">#</a> 26.Go 语言和 Java 语言字符串操作的区别</h3>
<h3 id="27go语言和java语言io操作的区别"><a class="markdownIt-Anchor" href="#27go语言和java语言io操作的区别">#</a> 27.Go 语言和 Java 语言 IO 操作的区别</h3>
<h3 id="28go语言中有匿名函数有闭包java中没有高阶函数用法"><a class="markdownIt-Anchor" href="#28go语言中有匿名函数有闭包java中没有高阶函数用法">#</a> 28.Go 语言中有匿名函数，有闭包，Java 中没有 (高阶函数用法)</h3>
<p>函数也是一种类型，它可以作为一个参数进行传递，也可以作为一个返回值传递。</p>
<p>Go 中可以定义一个匿名函数，并把这个函数赋值给一个变量</p>
<p>示例 1： 匿名函数赋值给变量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个匿名函数并赋值给myFun变量</span></span><br><span class="line"><span class="keyword">var</span> myFun = <span class="function"><span class="keyword">func</span><span class="params">(x,y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> x+y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//调用myFun</span></span><br><span class="line">   fmt.Println(myFun(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<p>Go 的函数内部是无法再声明一个有名字的函数的，Go 的函数内部只能声明匿名函数。</p>
<p>示例 2：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   myFunc3()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFun1</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/*此处报错，函数内部不能声明带有名称的函数</span></span><br><span class="line"><span class="comment">   func myFunc2() &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc3</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//函数内部可以声明一个匿名函数，并把这个匿名函数赋值给f变量</span></span><br><span class="line">   <span class="keyword">var</span> f = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Hi,boy!&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//调用f</span></span><br><span class="line">   f()</span><br><span class="line">   <span class="comment">//如果不想赋值给变量，那就必须在最后加上(),表示立即执行</span></span><br><span class="line">   <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Hello,girl!&quot;</span>)</span><br><span class="line">   &#125;()<span class="comment">//有参数可以写在这个小括号中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hi,boy!</span><br><span class="line">Hello,girl!</span><br></pre></td></tr></table></figure>
<p>Go 中有闭包的功能。(闭包是一个通用的编程概念，一些语言有，一些没有，javascript 中就有这个概念，Java 中没有)</p>
<p>闭包，通俗易懂的讲，就是你有一个 A 函数，A 函数有一个 a 参数，然后在 A 函数内部再定义或者调用或者写一个 B 函数，这个 B 函数叫做闭包函数。B 函数内部的代码可以访问它外部的 A 函数的 a 参数，正常 A 函数调用返回完毕，a 参数就不能用了，可是闭包函数 B 函数仍然可以访问这个 a 参数，B 函数能不受 A 函数的调用生命周期限制可以随时访问其中的 a 参数，这个能访问的状态叫做已经做了闭包，闭包闭的是把 a 参数封闭到了 B 函数中，不受 A 函数的限制。</p>
<p>也就是说，我们用程序实现一个闭包的功能，实质上就是写一个让外层的函数参数或者函数内变量封闭绑定到内层函数的功能。</p>
<p>接下来我们看代码示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我们来看看实现闭包</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> f = f1(<span class="number">100</span>)</span><br><span class="line">   f(<span class="number">100</span>) <span class="comment">//print 200</span></span><br><span class="line">   f(<span class="number">100</span>) <span class="comment">//print 300</span></span><br><span class="line">   f(<span class="number">100</span>) <span class="comment">//print 400</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">   <span class="comment">//此时即使f1函数执行完毕，x也不会消失</span></span><br><span class="line">   <span class="comment">//x在func(y int)这个函数内一直存在并且叠加，</span></span><br><span class="line">   <span class="comment">//这里把x的值封闭到func(y int)这个返回函数中，使其函数一直能使用x的值</span></span><br><span class="line">   <span class="comment">//就叫做闭包，把x变量封闭到fun(y int)这个函数包内。</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(y <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">      x+=y</span><br><span class="line">      fmt.Printf(<span class="string">&quot;x=%d\n&quot;</span>,x)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x=200</span><br><span class="line">x=300</span><br><span class="line">x=400</span><br></pre></td></tr></table></figure>
<p>做下闭包的总结，如何实现一个闭包：</p>
<p>1. 定义一个 A 函数，此函数返回一个匿名函数。（定义一个返回匿名函数的 A 函数）</p>
<p>2. 把在 A 函数的 b 参数或 A 函数代码块中的 b 变量，放入匿名函数中，进行操作。</p>
<p>3. 这样我们调用 A 函数返回一个函数，这个函数不断的调用就可以一直使用之前 b 参数，b 变量，并且 b 值不会刷新，有点像在匿名函数外部自定义了一个 b 的成员变量（成员变量取自 Java 中类的相关概念）</p>
<h3 id="29go中的map和java中的hashmap"><a class="markdownIt-Anchor" href="#29go中的map和java中的hashmap">#</a> 29.Go 中的 map 和 Java 中的 HashMap</h3>
<p>Go 中的 map 也是一个存储 key-value，键值对的这么一种数据结构。</p>
<p>我们来看下如何使用：</p>
<p>如何创建一个 map?(map 是引用类型，默认值是 nil，必须用 make 为其创建才能使用)</p>
<p>创建一个 map 必须要用 make，否则会是 nil</p>
<p>格式为: make (map [key 类型] value 类型) (下面有代码示例)</p>
<p>往 Go 中的 map 赋值添加元素用 【 map 变量名称 [key] = value 】 的方式</p>
<p>示例 1：创建 map 以及添加元素</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//创建一个map必须要用make，否则会是nil</span></span><br><span class="line">   <span class="comment">//格式为:  make(map[key类型]value类型)</span></span><br><span class="line">   <span class="comment">//Java中:   Map&lt;String,Integer&gt; myMap = new HashMap&lt;&gt;();</span></span><br><span class="line">   myMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">   <span class="comment">//往Go中的map赋值添加元素用 【 map变量名称[key] = value 】 的方式</span></span><br><span class="line">   <span class="comment">//区别于Java中的: myMap.put(&quot;li_age&quot;,20);</span></span><br><span class="line">   myMap[<span class="string">&quot;li_age&quot;</span>] = <span class="number">20</span></span><br><span class="line">   myMap[<span class="string">&quot;hong_age&quot;</span>] = <span class="number">30</span></span><br><span class="line">   <span class="comment">//打印一下map</span></span><br><span class="line">   fmt.Println(myMap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们从 map 中取值得格式为： 【 mapValue := map 变量名 [key]】</p>
<p>当我们填写的 key 在 map 中找不到时返回对应的 value 默认值，int 是 0，引用类型是 nil</p>
<p>当我们的 key 取不到对应的值，而 value 的类型是一个 int 类型，我们如何判断这个 0 是实际值还是默认值呢</p>
<p>此时我们需要同时取两个值</p>
<p>通过 map 的 key 取出两个值，第二个参数为 bool 类型，false 为该值不存在，true 为成功取到值</p>
<p>参考下面：</p>
<p>示例 2：从 map 中取值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//创建一个map必须要用make，否则会是nil</span></span><br><span class="line">   <span class="comment">//格式为:  make(map[key类型]value类型)</span></span><br><span class="line">   <span class="comment">//Java中:   Map&lt;String,Integer&gt; myMap = new HashMap&lt;&gt;();</span></span><br><span class="line">   myMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">   <span class="comment">//往Go中的map赋值添加元素用 【 map变量名称[key] = value 】 的方式</span></span><br><span class="line">   <span class="comment">//区别于Java中的: myMap.put(&quot;li_age&quot;,20);</span></span><br><span class="line">   myMap[<span class="string">&quot;li_age&quot;</span>] = <span class="number">20</span></span><br><span class="line">   myMap[<span class="string">&quot;hong_age&quot;</span>] = <span class="number">30</span></span><br><span class="line">   <span class="comment">//打印一下map</span></span><br><span class="line">   fmt.Println(myMap)</span><br><span class="line">   <span class="comment">//不存在的值</span></span><br><span class="line">   fmt.Println(myMap[<span class="string">&quot;no&quot;</span>])</span><br><span class="line"></span><br><span class="line">   <span class="comment">//当我们的key取不到对应的值，而value的类型是一个int类型，我们如何判断这个0是实际值还是默认值呢</span></span><br><span class="line">   <span class="comment">//此时我们需要同时取两个值</span></span><br><span class="line">   <span class="comment">//通过map的key取出两个值，第二个参数为bool类型，false为该值不存在，true为成功取到值</span></span><br><span class="line">   value,existsValue := myMap[<span class="string">&quot;no&quot;</span>]</span><br><span class="line">   <span class="keyword">if</span> !existsValue &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;此值不存在&quot;</span>)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;value = %d&quot;</span>,value)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Go 中因为返回值可以是两个，所以的 map 遍历很简单，不像 java 还得弄一个 Iterator 对象再逐个获取，它一次两个都能取出来，用 for 搭配 range 即可实现。</p>
<p>示例 3：遍历</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   myMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">   myMap[<span class="string">&quot;num1&quot;</span>] = <span class="number">1</span></span><br><span class="line">   myMap[<span class="string">&quot;num2&quot;</span>] = <span class="number">2</span></span><br><span class="line">   myMap[<span class="string">&quot;num3&quot;</span>] = <span class="number">3</span></span><br><span class="line">   myMap[<span class="string">&quot;num4&quot;</span>] = <span class="number">4</span></span><br><span class="line">   myMap[<span class="string">&quot;num5&quot;</span>] = <span class="number">5</span></span><br><span class="line">   myMap[<span class="string">&quot;num6&quot;</span>] = <span class="number">6</span></span><br><span class="line">   <span class="comment">//遍历key,value</span></span><br><span class="line">   <span class="keyword">for</span> key,value := <span class="keyword">range</span> myMap &#123;</span><br><span class="line">      fmt.Println(key,value)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//写一个参数的时候只取key</span></span><br><span class="line">   <span class="keyword">for</span> key := <span class="keyword">range</span> myMap &#123;</span><br><span class="line">      fmt.Println(key)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果只想取value，就需要用到之前的_标识符进行占位丢弃</span></span><br><span class="line">   <span class="keyword">for</span> _,value := <span class="keyword">range</span> myMap &#123;</span><br><span class="line">      fmt.Println(value)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除函数：用内置函数 delete 删除</p>
<p>示例 4：删除 map 元素</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   myMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">   myMap[<span class="string">&quot;num1&quot;</span>] = <span class="number">1</span></span><br><span class="line">   myMap[<span class="string">&quot;num2&quot;</span>] = <span class="number">2</span></span><br><span class="line">   myMap[<span class="string">&quot;num3&quot;</span>] = <span class="number">3</span></span><br><span class="line">   myMap[<span class="string">&quot;num4&quot;</span>] = <span class="number">4</span></span><br><span class="line">   myMap[<span class="string">&quot;num5&quot;</span>] = <span class="number">5</span></span><br><span class="line">   myMap[<span class="string">&quot;num6&quot;</span>] = <span class="number">6</span></span><br><span class="line">   <span class="comment">//第二个参数为删除的key</span></span><br><span class="line">   <span class="built_in">delete</span>(myMap,<span class="string">&quot;num6&quot;</span>)</span><br><span class="line">   <span class="comment">//此时已经没有值了，默认值为0</span></span><br><span class="line">   fmt.Println(myMap[<span class="string">&quot;num6&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Java 中有一些复杂的 Map 类型，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Map&lt;String,Object&gt;&gt; data = new HashMap&lt;&gt;();</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>实际上，在 Go 语言中，也有复杂的类型，我们举几个代码示例</p>
<p>示例 5：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//由map组成的切片</span></span><br><span class="line">   <span class="comment">//第一部分 make[] 声明切片</span></span><br><span class="line">   <span class="comment">//第二部分 map[string]int  声明该切片内部装的单个类型是map</span></span><br><span class="line">   <span class="comment">//第三部分 参数 5 表示该切片的长度和容量都是5</span></span><br><span class="line">   <span class="comment">//长度是用索引能取到第几个元素，索引不能超过长度-1，分配长度后都是默认值，int是0，引用类型是nil</span></span><br><span class="line">   <span class="comment">//容量至少比长度大，能索引到几个+未来可添加元素个数(目前没有任何东西，看不见)= 切片容量</span></span><br><span class="line">   <span class="comment">//make([]切片类型,切片长度，切片容量)</span></span><br><span class="line">   <span class="comment">//make([]切片类型,切片长度和容量等同)</span></span><br><span class="line">   slice := <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>,<span class="number">5</span>,<span class="number">10</span>)</span><br><span class="line">   slice0 := <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>,<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line">   <span class="comment">//我们看看打印的东西</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;slice=&quot;</span>,slice)</span><br><span class="line">   fmt.Println(<span class="string">&quot;slice=0&quot;</span>,slice0)</span><br><span class="line"></span><br><span class="line">   <span class="comment">///*   先看这段</span></span><br><span class="line">   <span class="comment">//因为有5个长度，所以初始化了5个map，但是map没有通过make申请内容空间，所以报错nil map</span></span><br><span class="line">   <span class="comment">//slice[0][&quot;age&quot;] = 10;//报错</span></span><br><span class="line">   <span class="comment">//下面不报错</span></span><br><span class="line">   slice[<span class="number">0</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>,<span class="number">10</span>)</span><br><span class="line">   slice[<span class="number">0</span>][<span class="string">&quot;age&quot;</span>] = <span class="number">19</span></span><br><span class="line">   fmt.Println(slice[<span class="number">0</span>][<span class="string">&quot;age&quot;</span>])</span><br><span class="line">   <span class="comment">//*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slice= [map[] map[] map[] map[] map[]]</span><br><span class="line">slice=0 []</span><br><span class="line">19</span><br><span class="line">123</span><br></pre></td></tr></table></figure>
<p>接下来继续看代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//由map组成的切片</span></span><br><span class="line">   <span class="comment">//第一部分 make[] 声明切片</span></span><br><span class="line">   <span class="comment">//第二部分 map[string]int  声明该切片内部装的单个类型是map</span></span><br><span class="line">   <span class="comment">//第三部分 参数 5 表示该切片的长度和容量都是5</span></span><br><span class="line">   <span class="comment">//长度是用索引能取到第几个元素，索引不能超过长度-1，分配长度后都是默认值，int是0，引用类型是nil</span></span><br><span class="line">   <span class="comment">//append元素到切片时，是添加到最末尾的位置，当元素未超过容量时，都是用的同一个底层数组</span></span><br><span class="line">   <span class="comment">//超过容量时会返回一个新的数组</span></span><br><span class="line">   <span class="comment">//make([]切片类型,切片长度，切片容量)</span></span><br><span class="line">   <span class="comment">//make([]切片类型,切片长度和容量等同)</span></span><br><span class="line">   slice := <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>,<span class="number">5</span>,<span class="number">10</span>)</span><br><span class="line">   slice0 := <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>,<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line">   <span class="comment">//我们看看打印的东西</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;slice=&quot;</span>,slice)</span><br><span class="line">   fmt.Println(<span class="string">&quot;slice=0&quot;</span>,slice0)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*   先看这段</span></span><br><span class="line"><span class="comment">   //因为有5个长度，所以初始化了5个map，但是map没有通过make申请内容空间，所以报错nil map</span></span><br><span class="line"><span class="comment">   //slice[0][&quot;age&quot;] = 10;//报错</span></span><br><span class="line"><span class="comment">   //下面不报错</span></span><br><span class="line"><span class="comment">   slice[0] = make(map[string]int,10)</span></span><br><span class="line"><span class="comment">   slice[0][&quot;age&quot;] = 19</span></span><br><span class="line"><span class="comment">   fmt.Println(slice[0][&quot;age&quot;])</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic: assignment to entry in nil map</span><br></pre></td></tr></table></figure>
<p>看下面这个报错：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//由map组成的切片</span></span><br><span class="line">   <span class="comment">//第一部分 make[] 声明切片</span></span><br><span class="line">   <span class="comment">//第二部分 map[string]int  声明该切片内部装的单个类型是map</span></span><br><span class="line">   <span class="comment">//第三部分 参数 5 表示该切片的长度和容量都是5</span></span><br><span class="line">   <span class="comment">//长度是用索引能取到第几个元素，索引不能超过长度-1，分配长度后都是默认值，int是0，引用类型是nil</span></span><br><span class="line">   <span class="comment">//append元素到切片时，是添加到最末尾的位置，当元素未超过容量时，都是用的同一个底层数组</span></span><br><span class="line">   <span class="comment">//超过容量时会返回一个新的数组</span></span><br><span class="line">   <span class="comment">//make([]切片类型,切片长度，切片容量)</span></span><br><span class="line">   <span class="comment">//make([]切片类型,切片长度和容量等同)</span></span><br><span class="line">   slice := <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>,<span class="number">5</span>,<span class="number">10</span>)</span><br><span class="line">   slice0 := <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>,<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line">   <span class="comment">//我们看看打印的东西</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;slice=&quot;</span>,slice)</span><br><span class="line">   fmt.Println(<span class="string">&quot;slice=0&quot;</span>,slice0)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*   先看这段</span></span><br><span class="line"><span class="comment">   //因为有5个长度，所以初始化了5个map，但是map没有通过make申请内容空间，所以报错nil map</span></span><br><span class="line"><span class="comment">   //slice[0][&quot;age&quot;] = 10;//报错</span></span><br><span class="line"><span class="comment">   //下面不报错</span></span><br><span class="line"><span class="comment">   slice[0] = make(map[string]int,10)</span></span><br><span class="line"><span class="comment">   slice[0][&quot;age&quot;] = 19</span></span><br><span class="line"><span class="comment">   fmt.Println(slice[0][&quot;age&quot;])</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="comment">///*</span></span><br><span class="line">   <span class="comment">//因为初始化了0个长度，所以索引取不到值，报index out of range</span></span><br><span class="line">   slice0[<span class="number">0</span>][<span class="string">&quot;age&quot;</span>] = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice= [mappanic: runtime error: index out of range</span><br></pre></td></tr></table></figure>
<p>接下来我们看一个：类似于 Java 中常用的 map 类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//类似于Java中的Map&lt;String,HashMap&lt;String,Object&gt;&gt;</span></span><br><span class="line">   <span class="keyword">var</span> myMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;,<span class="number">10</span>)</span><br><span class="line">   fmt.Println(myMap)</span><br><span class="line">   <span class="comment">//记得make</span></span><br><span class="line">   myMap[<span class="string">&quot;li_ming_id_123&quot;</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;,<span class="number">5</span>)</span><br><span class="line">   myMap[<span class="string">&quot;li_ming_id_123&quot;</span>][<span class="string">&quot;school&quot;</span>] = <span class="string">&quot;清华大学&quot;</span></span><br><span class="line"></span><br><span class="line">   fmt.Println(myMap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map[]</span><br><span class="line">map[li_ming_id_123:map[school:清华大学]]</span><br></pre></td></tr></table></figure>
<h3 id="30go中的time时间包模块和java中的时间api使用区别"><a class="markdownIt-Anchor" href="#30go中的time时间包模块和java中的时间api使用区别">#</a> 30.Go 中的 time 时间包模块和 Java 中的时间 API 使用区别</h3>
<p>Go 中关于时间处理的操作在 time 包中</p>
<p>1. 基本获取时间信息</p>
<p>参考如下代码示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//获取当前时间</span></span><br><span class="line">   now := time.Now()</span><br><span class="line">   <span class="comment">//获取当前年份</span></span><br><span class="line">   year := now.Year()</span><br><span class="line">   <span class="comment">//获取当前月份</span></span><br><span class="line">   month := now.Month()</span><br><span class="line">   <span class="comment">//获取当前 日期</span></span><br><span class="line">   day := now.Day()</span><br><span class="line">   <span class="comment">//获取当前小时</span></span><br><span class="line">   hour := now.Hour()</span><br><span class="line">   <span class="comment">//获取当前分钟</span></span><br><span class="line">   min := now.Minute()</span><br><span class="line">   <span class="comment">//获取当前秒</span></span><br><span class="line">   second :=now.Second()</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取当前时间戳，和其它编程语言一样，自1970年算起</span></span><br><span class="line">   timestamp := now.Unix()</span><br><span class="line">   <span class="comment">//纳秒时间戳</span></span><br><span class="line">   ntimestamp := now.UnixNano()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">&quot;year=&quot;</span>,year)</span><br><span class="line">   fmt.Println(<span class="string">&quot;month=&quot;</span>,month)</span><br><span class="line">   fmt.Println(<span class="string">&quot;day=&quot;</span>,day)</span><br><span class="line">   fmt.Println(<span class="string">&quot;hour=&quot;</span>,hour)</span><br><span class="line">   fmt.Println(<span class="string">&quot;min=&quot;</span>,min)</span><br><span class="line">   fmt.Println(<span class="string">&quot;second=&quot;</span>,second)</span><br><span class="line">   fmt.Println(<span class="string">&quot;timestamp=&quot;</span>,timestamp)</span><br><span class="line">   fmt.Println(<span class="string">&quot;ntimestamp=&quot;</span>,ntimestamp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2. 格式化时间</p>
<p>Go 的时间格式化和其它语言不太一样，它比较特殊，取了 go 的出生日期作为参数标准</p>
<p>参考如下代码示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//获取当前时间</span></span><br><span class="line">   now := time.Now()</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2006-01-02 15:04:05这个数值是一个标准写死的，只要改格式符号即可</span></span><br><span class="line">   fmt.Println(now.Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))</span><br><span class="line">   fmt.Println(now.Format(<span class="string">&quot;2006/01/02 15:04:05&quot;</span>))</span><br><span class="line">   fmt.Println(now.Format(<span class="string">&quot;2006/01/02&quot;</span>))<span class="comment">//年月日</span></span><br><span class="line">   fmt.Println(now.Format(<span class="string">&quot;15:04:05&quot;</span>))<span class="comment">//时分秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="31go和java关于socket编程的对比"><a class="markdownIt-Anchor" href="#31go和java关于socket编程的对比">#</a> 31.Go 和 Java 关于 Socket 编程的对比</h3>
<h3 id="32聊聊go语言如何连接mysql数据库"><a class="markdownIt-Anchor" href="#32聊聊go语言如何连接mysql数据库">#</a> 32. 聊聊 Go 语言如何连接 Mysql 数据库</h3>
<h3 id="33聊聊go语言如何使用redis"><a class="markdownIt-Anchor" href="#33聊聊go语言如何使用redis">#</a> 33. 聊聊 Go 语言如何使用 Redis</h3>
<h3 id="34go中的依赖管理module对比java的maven"><a class="markdownIt-Anchor" href="#34go中的依赖管理module对比java的maven">#</a> 34.Go 中的依赖管理–Module, 对比 Java 的 maven</h3>
<h3 id="35go的协程高并发支持与java的区别"><a class="markdownIt-Anchor" href="#35go的协程高并发支持与java的区别">#</a> 35.Go 的协程高并发支持与 Java 的区别</h3>
<h3 id="36go的性能调优和java的性能调优"><a class="markdownIt-Anchor" href="#36go的性能调优和java的性能调优">#</a> 36.Go 的性能调优和 Java 的性能调优</h3>
<h3 id="37go的测试api与java的单元测试"><a class="markdownIt-Anchor" href="#37go的测试api与java的单元测试">#</a> 37.Go 的测试 API 与 Java 的单元测试</h3>
<h3 id="38自定义类型type"><a class="markdownIt-Anchor" href="#38自定义类型type">#</a> 38. 自定义类型 Type</h3>
<h3 id="39go的参数值传递与引用传递"><a class="markdownIt-Anchor" href="#39go的参数值传递与引用传递">#</a> 39.Go 的参数值传递与引用传递</h3>
<p>接下来我们讲一下 Go 中的参数传递原理。</p>
<p>关于参数传递是一个什么概念呢，参数传递相关的知识是在研究当调用一个函数时，把外部的一个变量传入函数内，在函数内修改这个参数是否会对外部的参数变量的值有影响。参数传递用在的一个地方是函数的参数传递。（还有方法的接收器参数传递）</p>
<p>比如李明今天没有写作业，到了学校后匆匆忙忙的找小红要作业本 (小红的作业本为方法调用处传入的参数)，想要抄一抄补上，所以李明有一个抄作业的任务 (抄作业的任务为函数)，那么他有两个选择可以完成抄作业的任务。</p>
<p>第一个是直接拿过来小红的作业本开始抄，这在函数中叫做引用传递，因为如果小明抄的时候不小心桌子上的水打翻了，弄湿了小红的作业本，小红的作业本就真湿了，没法交了。</p>
<p>第二个是用打印机把小红的作业打印一份，然后拿着打印的那份抄，这叫做值传递，也就是说我拷贝一份值来用，那么我在抄作业 (任务函数内) 无论怎么弄湿小红的作业本，小红真正的自己的作业本也不受到影响。</p>
<p>在编程语言的函数中，如果是值传递，则是一个拷贝，在方法内部修改该参数值无法对其本身造成影响，如果是引用传递的概念，则可以改变其对象本身的值。</p>
<p>在 Go 语言中只有值传递，也是是说，无论如何 Go 的参数传递的都是一个拷贝。</p>
<p>重点来了：</p>
<p>Go 中的值传递有两种类型，如下：</p>
<p>1. 第一种值传递是具体的类型对象值传递，可能是 int,string,struct 之类的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在此时，如果我们要自定义一个struct类型，传入参数中，可能遇到一个坑，因为是值传递，所以会拷贝一个struct对象，如果这个对象占内存比较大，而且这个函数调用频繁，会大量的拷贝消耗性能资源。</span><br></pre></td></tr></table></figure>
<p>2. 第二种传递是叫指针参数类型的值传递，此时参数是一个指针类型，到具体的方法中，我们的参数也要用指针类型的参数接受，但是此时 Go 语言的内部做了一个黑箱操作。</p>
<p>举例 (下面还有完整可执行代码示例，先文字和伪代码举例)：</p>
<p>我们有一个类型为 Boy 的结构体，还有一个方法 Mod</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func Mod(b  *Boy)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 Mod 方法的参数是一个指针类型的 Boy 对象，</p>
<p>我们要调用的时候应该这样传参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var boy = Boy&#123;&#125; </span><br><span class="line">//用&amp;取boy对象的指针地址，然后传入Mod方法</span><br><span class="line">Mod(&amp;boy)</span><br></pre></td></tr></table></figure>
<p>我们看看下面的代码示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Boy 结构体</span></span><br><span class="line"><span class="keyword">type</span> Boy <span class="keyword">struct</span> &#123;</span><br><span class="line">   name <span class="type">string</span></span><br><span class="line">   age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Mod</span><span class="params">(b *Boy)</span></span> &#123;</span><br><span class="line">   <span class="comment">//这个是获取调用方法传入的参数的地址值</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;b的值(之前boy的地址)是%p\n&quot;</span>,b)</span><br><span class="line">   <span class="comment">//这个是获取本函数中 b这个指针变量的地址</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;b这个指针自己的地址是=%p\n&quot;</span>,&amp;b)</span><br><span class="line">   <span class="comment">//打印值</span></span><br><span class="line">   <span class="comment">//这里自动转换使指针可以直接点出来属性</span></span><br><span class="line">   fmt.Println(b.name,b.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    boy := Boy&#123;<span class="string">&quot;li_ming&quot;</span>,<span class="number">20</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;main函数中的boy地址是:%p\n&quot;</span>,&amp;boy)</span><br><span class="line">    <span class="comment">//将boy的地址 放入Mod函数的参数中</span></span><br><span class="line">    Mod(&amp;boy)</span><br><span class="line">    <span class="comment">//注意！！！下面有黑箱操作：</span></span><br><span class="line">    <span class="comment">/* //在&amp;boy并放入Mod传递的过程中实际上做了如下黑箱操作</span></span><br><span class="line"><span class="comment">    b := new(Boy)   //创建一个名为b的类型为Boy的指针变量</span></span><br><span class="line"><span class="comment">    b = &amp;boy      //把boy的地址存入b这个指针变量内</span></span><br><span class="line"><span class="comment">    //接着把b放入func Mod(b *Boy)的参数中，然后，开始执行Mod方法。</span></span><br><span class="line"><span class="comment">    fmt.Println(b.name,b.age)</span></span><br><span class="line"><span class="comment">    fmt.Printf(&quot;b的地址是:%p\n&quot;,&amp;b)</span></span><br><span class="line"><span class="comment">    fmt.Printf(&quot;b的值是:%p\n&quot;,b)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    //输出结果</span></span><br><span class="line"><span class="comment">    //main函数中的boy地址是:0x10aec0c0</span></span><br><span class="line"><span class="comment">    //li_ming 20</span></span><br><span class="line"><span class="comment">    //b的地址是:0x10ae40f8</span></span><br><span class="line"><span class="comment">    //b的值是:0x10aec0c0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*//以下代码无用，是指为了加深理解new，可以试试输出结果</span></span><br><span class="line"><span class="comment">    boy2 := new(Boy)</span></span><br><span class="line"><span class="comment">    fmt.Printf(&quot;main函数中new的boy2地址是:%p\n&quot;,boy2)</span></span><br><span class="line"><span class="comment">    boy2.name = &quot;xiaohong&quot;</span></span><br><span class="line"><span class="comment">    boy2.age = 18</span></span><br><span class="line"><span class="comment">    Mod(boy2)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，Go 中的参数传递所有的都是值传递，</p>
<p>只不过值传递中，值可以是指针类型，是创建了一个新的指针存储原来参数 (这个参数是原对象的地址) 的值。</p>
<p>所以你用原对象的地址改它的属性，是有点类似于引用类型传递的效果的。</p>
<p>为啥说指针类型也是值传递，因为他还是创建了一个新的指针对象，值传递就是拷贝，拷贝就得创建对象，只不过这个新的指针变量存储的值是原来的参数对象的地址。</p>
<p>最后总结一下：</p>
<p>1.Go 的参数传递都是值传递。</p>
<p>2. 指针类型的值传递可以改变原来对象的值。</p>
<p>3.make 和 new 从底层原理上创建的所有对象都是指针对象，所以 make 和 new 创建出来的 slice,map,chan 或者其它任何对象都是指针传递，改变值后都可以使原来的对象属性发生变化。</p>
<h3 id="40结构体转json"><a class="markdownIt-Anchor" href="#40结构体转json">#</a> 40. 结构体转 JSON</h3>
<h3 id="41go如何搭建http-server"><a class="markdownIt-Anchor" href="#41go如何搭建http-server">#</a> 41.Go 如何搭建 HTTP-Server</h3>
<h3 id="42go如何搭建http-client"><a class="markdownIt-Anchor" href="#42go如何搭建http-client">#</a> 42.Go 如何搭建 HTTP-Client</h3>
<h3 id="43go如何设置使用的cpu个数"><a class="markdownIt-Anchor" href="#43go如何设置使用的cpu个数">#</a> 43.Go 如何设置使用的 CPU 个数</h3>
<p>Go 语言天生支持高并发，其中一个体现就是如果你的 Go 程序不设置并发时使用的最大 cpu 核数的话，在高并发情况下 Go 会自动把所有 CPU 都用上，跑满。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">拓展阅读：</span><br><span class="line">我们简单理解一下cpu（懂得可以跳过）</span><br><span class="line">    举例：比如有一个专门做财务的公司(计算机)，他们的赚钱业务很简单(计算机工作)，就是帮别人做算术题(计算机工作的具体任务)，加减乘除之类的算术题，现在公司有4个员工(物理意义上的4个cpu核数)，有4本算数书(4个进程)，每本书有10道题(线程)，一共有40道算术题要算(40个线程任务)，于是4个人一起干活，在同一时间，有4道算术题被计算，最后大致上每个人算了10道算数题。</span><br><span class="line">    第二天，有8本算术书(8个进程)，他们为了快速完成任务，规定一人(每个人是一个物理cpu核数)管2本算数书(单物理cpu内部实际上是管理的两个不同的算数书，也就是相当于有两个不同的逻辑cpu)，为的就是如果第一本做烦了可以换着做第2本，混合着做，最后都做完就可以。</span><br><span class="line"></span><br><span class="line">    cpu是进行最终二进制计算的核心计算器，cpu核数是有两个概念，一个是真实世界的物理硬件核数，比如4核cpu,就是有4个物理硬件内核，然而我们在生产环境的linux服务器上top的时候，出现的cpu个数实际上是逻辑cpu数，有可能linux服务器只有4核物理cpu,可是每个物理cpu分为两个逻辑cpu，这个时候我们在linux上top看的时候就是有8个cpu信息行数据。</span><br></pre></td></tr></table></figure>
<p>我们回顾一下 Java，Java 运行时我们一般管理的都是线程数，而所有的 java 线程均在 JVM 这个虚拟机进程中，于是在高并发情况下，当 cpu 资源充足时，我们需要根据 cpu 的逻辑核数来确定我们的线程池线程数 (在高并发环境下一定要设置优化线程数啊！！！线程池就能设置线程数！！！)，比如我们是 4 个物理 cpu, 每个双核逻辑，一共逻辑八核 cpu, 此时，比如我们要做并发定时任务，这台服务器没有其它程序，8 个 cpu 全都给我们自己用，那么我们的线程数最少也要设置成 8，再细化，我们得根据程序执行的任务分别在 cpu 计算 (正常处理程序业务逻辑) 的耗时和 cpuIO 耗时（IO 耗时比如查 mysql 数据库数据），假如我们定时跑批任务一个任务计算用时 0.2 秒，查数据库 0.8 秒 (自己可以写程序监测)，那么可以参考如下公式：</p>
<p>总任务耗时 /cpu 耗时 = 多少个线程 (每个逻辑 cpu)</p>
<p>我们算出每个逻辑 cpu 要跑多少个线程后再乘以逻辑 cpu 的个数，就能算出来了</p>
<p>如下：</p>
<p>(0.2+0.8)/0.2=5 个线程 (每个逻辑 cpu)</p>
<p>5*8 = 40</p>
<p>于是我们在线程池的时候应该这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService fixedThreadPool = Executors.newFixedThreadPool(40);</span><br></pre></td></tr></table></figure>
<p>至于公式为什么要这么写，是因为 IO 操作的时候，cpu 是空闲的，也就是说，0.8 秒数据库操作的时候，cpu 都是空闲的，那么我们就多开几个线程让 cpu 在这 0.8 秒的时候工作，开几个呢，要等 0.8 秒，一个任务 cpu 要计算 0.2 秒，0.8/0.2=4 (个)，可是这个逻辑 cpu 还有一个主线程在那 0.8 秒上等着结果呢，所以是 4+1=5（个）线程。</p>
<p>上述我们回顾了 Java 中的线程数和 CPU 核数相关，接下来我们来看 Go 语言。</p>
<p>我们下面来仔细讲讲 Go 中的 goroutine (实际是协程)，是如何天然的支持高并发的，它与 Java 中的线程 Thread 又有什么区别，为什么它比线程能更好的支持高并发。</p>
<h3 id="44初始化结构体匿名结构体结构体指针再讲"><a class="markdownIt-Anchor" href="#44初始化结构体匿名结构体结构体指针再讲">#</a> 44. 初始化结构体，匿名结构体，结构体指针 (再讲)</h3>
<h3 id="45方法中的值接收和指针接收的区别方法进阶细节讲解"><a class="markdownIt-Anchor" href="#45方法中的值接收和指针接收的区别方法进阶细节讲解">#</a> 45. 方法中的值接收和指针接收的区别 (方法进阶细节讲解)</h3>
<p>我们之前讲了如果给一个类型绑定上一个接受者，就可以为这个类型添加一个这个类型独有的函数，只有这个类型对象自己能调用的函数，这个特殊的函数叫方法。</p>
<p>现在，我们讲一下方法关于传递接受者（自身引用）的进阶玩法。</p>
<p>Go 语言中的参数传递</p>
<h3 id="46基于包模块的init函数"><a class="markdownIt-Anchor" href="#46基于包模块的init函数">#</a> 46. 基于包模块的 Init 函数</h3>
<h3 id="47go-语言中的初始化依赖项"><a class="markdownIt-Anchor" href="#47go-语言中的初始化依赖项">#</a> 47.Go 语言中的初始化依赖项</h3>
<h3 id="48slice相关知识点"><a class="markdownIt-Anchor" href="#48slice相关知识点">#</a> 48.slice 相关知识点</h3>
<p>slice 的中文意思是切片。</p>
<p>要想理解切片，我们首先要理解数组。</p>
<p>数组是一个长度不能变化的容器，存储同一数据类型的数据。</p>
<p>比如：int 数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,4,5,6]</span><br></pre></td></tr></table></figure>
<p>切片是对数组中一截，一小段，一个子集的地址的截取，切片存储的是它指向的底层数组中的一小截数据的地址，切片中不存数据，创建切片也不会把数组中的数据 copy 一份，切片只是存储着数组中一部分连续的数据的地址，切片的每一个元素实际上都指向具体的数组的中一个元素。</p>
<p>切片内部包含三个元素：</p>
<p>1. 底层数组（它指向的是哪一个数组）</p>
<p>我们要理解底层数组是什么，先举例：</p>
<p>[1,2,3] 这是一个 int 数组，其中元素 1 的地址是 0x0001, 元素 2 的地址是 0x0002，元素 3 的地址是 0x0003。</p>
<p>那么如果我们创建一个通过数组 [1,2,3] 创建一个切片 x。</p>
<p>这个 x 里面存储的并不是拷贝的另外一份新的 [1,2,3]。</p>
<p>切片 x 实际上是这样子的：</p>
<p>[0x0001,0x0002,0x0003]</p>
<p>当我们取出 x [0] 的时候，它操作的实际上是 0x0001 这个地址的元素，而这个地址实际上就是数组 [1,2,3] 中的 1 的地址。</p>
<p>也就是说，当我们修改了数组 [1,2,3] 中的 1 后，比如 0x0001 = 5 , 切片 x 中的 0 元素的取值自动也不一样了，因为 0x0001 地址上存储的 值已经被改成 5 了，而 x [0] 实际上还是 0x0001, 所以此时取出 x [0], 得到的就是 5。</p>
<p>切片存储的每一个元素实际上是它指向的底层数组的每一个元素的地址。</p>
<p>也就是说切片是一个引用类型，它不存储元素，不拷贝元素，它存储数组元素的引用，通过修改切片会修改原来数组的值。</p>
<p>2. 切片的长度</p>
<p>这个切片中有有几个元素，指向了数组中的几个连续的元素。</p>
<p>3. 切片的容量</p>
<p>从切片在底层数组的起始下标 (切片的首个元素) 到底层数组的最后一个元素，一共有几个元素，切片的容量就是几。</p>
<p>例如：(下面先用伪代码示例，后面有具体可执行代码)</p>
<p>原数组：a = [1,2,3,4,5,6,7,8]</p>
<p>切片: b = a [2:5] 从数组 a 的下标为 2 的开始，也就是具体数值是 3 开始，截取到下标为 5，下标为 5 的是 6，因为切片截取是左开右闭，所以切片中包括下标为 2 的数值 3，不包含下标为 5 的数值 6。</p>
<p>切片存储的地址指向的数据是：[3,4,5]</p>
<p>因为 3，4，5 有三个数，所以切片的长度是 3。</p>
<p>因为从切片的起始元素 3 到底层数组的末尾元素 8 之间有 6 个元素，所以切片的容量是 6。</p>
<p>修改切片实际上是修改切片指向的底层数组中的值。</p>
<h3 id="49go中类似于函数指针的功能"><a class="markdownIt-Anchor" href="#49go中类似于函数指针的功能">#</a> 49.Go 中类似于函数指针的功能</h3>
<p>Go 中要实现函数指针非常简单。</p>
<p>因为 Go 中的函数也是一种类型。</p>
<p>所以我们只要声明一个变量，把某一个函数赋值给这个变量，就能实现函数指针的效果。</p>
<p>如下代码示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//加法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myAddFun</span><span class="params">(x,y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> x+y</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//减法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mySubFun</span><span class="params">(x,y <span class="type">int</span> )</span></span> <span class="type">int</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> x-y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数变量(类似于函数指针)</span></span><br><span class="line"><span class="keyword">var</span> myPointFun <span class="function"><span class="keyword">func</span><span class="params">(x,y <span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//加法函数赋值给该函数变量，相当于函数指针指向加法函数</span></span><br><span class="line">   myPointFun = myAddFun</span><br><span class="line">   fmt.Printf(<span class="string">&quot;a+b = %d\n&quot;</span>,myPointFun(<span class="number">10</span>,<span class="number">20</span>))</span><br><span class="line">   <span class="comment">//减法函数赋值给该函数变量，相当于函数指针指向减法函数</span></span><br><span class="line">   myPointFun = mySubFun</span><br><span class="line">   fmt.Printf(<span class="string">&quot;a-b = %d\n&quot;</span>,myPointFun(<span class="number">100</span>,<span class="number">50</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a+b = 30</span><br><span class="line">a-b = 50</span><br><span class="line">12</span><br></pre></td></tr></table></figure>
<h3 id="50go有没有注解"><a class="markdownIt-Anchor" href="#50go有没有注解">#</a> 50.Go 有没有注解</h3>
<p>原生的 Go 语言的 SDK 是不支持注解功能的，但是有一些其它的第三方机构为了实现自己的某些功能需求编写了一些自定义的注解。</p>
<h3 id="51go不能做大数据相关的开发"><a class="markdownIt-Anchor" href="#51go不能做大数据相关的开发">#</a> 51.Go 不能做大数据相关的开发</h3>
<p>因为大数据的一些底层都是 Java 开发的，用 Java 实现接口开发功能非常方便快捷，对于 Go 语言的支持包比较少，另外就是一些算法库像 numpy,pandas 和一些机器学习，深度学习算法库 Python 支持的比较好，对于 Go 的支持很不好。</p>
<h3 id="52go没有泛型"><a class="markdownIt-Anchor" href="#52go没有泛型">#</a> 52.Go 没有泛型</h3>
<p>Go 中不支持泛型 (明确)</p>
<h3 id="53go如何产生随机数随机数和种子"><a class="markdownIt-Anchor" href="#53go如何产生随机数随机数和种子">#</a> 53.Go 如何产生随机数 (随机数和种子)</h3>
<h3 id="54go如何打类似于java-jar那种依赖包a的工具依赖包有了module后不用这个了"><a class="markdownIt-Anchor" href="#54go如何打类似于java-jar那种依赖包a的工具依赖包有了module后不用这个了">#</a> 54.Go 如何打类似于 (java jar 那种依赖包).a 的工具依赖包 (有了 Module 后不用这个了)</h3>
<p>Go 中也有很多通过命令来完成辅助开发的工具，就像 Java 中 jdk 中的 java javac javap 等指令那种命令工具。</p>
<p>比如有 go build xxx 命令，go clean xxx 命令， go run xxx 命令…</p>
<p>Java 中打 jar 包可以通过 IDEA 集成开发环境图形界面化直接打包，也可以使用 jar 命令在命令行操作中 (使用不同的参数) 进行打包。</p>
<p>与 java jar 命令打包对应的 Go 的命令是 go install, 这个 go install 也类似于 maven 中的 install, 它会把打成的.a 后缀名结尾的工具包文件</p>
<p>放入 ${GOPATH} /pkg 下。</p>
<p>具体使用如下示例：</p>
<p>注意：使用 go install 之前必须在操作系统的环境变量中定义 ${GOPATH} 这个环境变量</p>
<p>1. 查看我们当前的操作系统中环境变量有没有定义 GOPATH。</p>
<p>2. 查看 ${GOPATH} 目录下是否有 src,pkg,bin 目录，并且保证我们的代码是在 src 下的。</p>
<p>3. 打开一个命令行窗口，比如 windows 是 cmd 打开一个 dos 窗口。</p>
<p>4. 我们在最开始之前已经把 go 的安装包下的包含 Go 操作指令的 bin 目录配置在了 PATH 环境变量中，所以此时我们可以不用管目录直接使用 go install 命令。</p>
<ol>
<li>例如目录结构如下：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.mashibing.gotest</span><br></pre></td></tr></table></figure>
<p>-------------------------mygopackge</p>
<p>MyUtil.go</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">记住一点，此时MyUtil中不能是main包，也不能有main函数，否则打不出来.a结尾的依赖包。</span><br></pre></td></tr></table></figure>
<p>此时编写执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go  install com/mashibing/gotest/mygopackge</span><br></pre></td></tr></table></figure>
<p>此指令运行时，首先会去找 ${GOPATH} 目录</p>
<p>然后把后面的 com/mashibing/gotest/mygopackge 拼接上去</p>
<p>也就是 ${GOPATH}/com/mashibing/gotest/mygopackge</p>
<p>然后会把 ${GOPATH}/com/mashibing/gotest/mygopackge 下的所有.go 文件，比如 MyUtil.go 全部打包压缩进 mygopackge.a 文件</p>
<p>最后会把 mygopackage.a 放入 G O P A T H /p k g / {GOPATH}/pkg/<em>GOP<strong>A</strong>T**H</em>/<em>p<strong>k</strong>g</em>/{标示操作系统的一个名字 (这个不重要)}/com/mashibing/gotest/ 下。</p>
<p>最终.a 文件存储的结构是这样的：</p>
<p>${GOPATH}/pkg/com/mashibing/gotest/mygopackge.a</p>
<h3 id="55go中的依赖管理module使用"><a class="markdownIt-Anchor" href="#55go中的依赖管理module使用">#</a> 55.Go 中的依赖管理 Module 使用</h3>
<h4 id="1什么是gomodulego中module和包的区别"><a class="markdownIt-Anchor" href="#1什么是gomodulego中module和包的区别">#</a> 1. 什么是 GoModule?(Go 中 Module 和包的区别？)</h4>
<p>首先我们要理解一下 Go 的 Module 是一个什么概念？</p>
<p>我先简单的说一下，Go 中的 Module 是 GoSDK1.11 后提出的一个新的类似于包的机制，叫做模块，在 1.13 版本后成熟使用，GoSDK 中 Module 功能是和相当于一个包的增强版，一个模块类型的项目在根目录下必须有一个 go.mod 文件，这个模块项目内部可以有很多个不同的包，每个包下有不同的代码，我们下载依赖的时候是把这个模块下载下来 (模块以压缩包 (比如 zip) 的形式存储在 G O P A T H /p k g /m o d /c a c h e / 下，源码文件也会在 {GOPATH}/pkg/mod/cache/ 下，源码文件也会在<em> GOP<strong>A</strong>T**H</em>/<em>p<strong>k</strong>g</em>/<em>m<strong>o</strong>d</em>/<em>c<strong>a</strong>c<strong>h</strong>e</em> / 下，源码文件也会在 {GOPATH}/pkg/mod/ 下)。</p>
<p>我们导入模块的时候只需要引入一次，使用模块中不同的包的时候可以通过 import 模块下不同的包名，来引入不同包的功能。</p>
<p>比如下面的结构</p>
<p>-----------com.mashibing.module</p>
<p>-----------------------package1</p>
<p>--------------test1.go</p>
<p>------------------------package2</p>
<p>-------------test2.go</p>
<p>然后我们只需要在 go.mod 中引入这一个模块，就能在 import 的时候任意引入 package1 或 package2。</p>
<h4 id="2为什么要使用gomodule"><a class="markdownIt-Anchor" href="#2为什么要使用gomodule">#</a> 2. 为什么要使用 GoModule?</h4>
<h5 id="1团队协作开发中对于包的版本号的管理"><a class="markdownIt-Anchor" href="#1团队协作开发中对于包的版本号的管理">#</a> 1). 团队协作开发中对于包的版本号的管理</h5>
<p>在没有 Module 之前，我们都是把自己写的 Go 程序打成包，然后别的程序引用的话引入这个包。</p>
<p>可是在开发中这些包的版本有个明显的不能管理的问题。</p>
<p>比如我怎么知道这个包是今天开发的最新版还是明天开发的，我在团队协同开发中怎么把别人写的最新版本的包更新到我的项目中。</p>
<h5 id="2便于开发中的依赖包管理"><a class="markdownIt-Anchor" href="#2便于开发中的依赖包管理">#</a> 2）便于开发中的依赖包管理</h5>
<p>其次，我们在开发中下载了别人的项目，怎么快速的观察有哪些依赖包，如何快速的把所有依赖包从仓库中下载下来，都是一个问题，</p>
<p>这两个问题就可以通过观察项目根目录下的 go.mod 文件的依赖模块列表和执行 go mod download 命令快速从第三方模块仓库中下载依赖包来完成。</p>
<h5 id="3隔离管理不同类别的项目"><a class="markdownIt-Anchor" href="#3隔离管理不同类别的项目">#</a> 3). 隔离管理不同类别的项目</h5>
<p>有了 Module 后，我们可以把我们自己的项目和系统的项目隔离管理，我们的项目不用必须放在 ${GOPATH}/src 下了</p>
<h4 id="3哪些项目能使用gomodule"><a class="markdownIt-Anchor" href="#3哪些项目能使用gomodule">#</a> 3. 哪些项目能使用 GoModule?</h4>
<p>一个 GoModule 项目要想引入其它依赖模块，需要在根目录下的 go.mod 中添加对应的依赖模块地址。</p>
<p>注意：！！！重点来了！！！</p>
<p>GoModule 只能引用同样是 Module 类型的项目，经常用于引用内部自己的项目。</p>
<p>像 maven 仓库一样引用开源模块的依赖也是一个特别常用的场景。</p>
<p>不过我们需要修改代理地址访问国内的第三方 GoModule 提供商。</p>
<p><a target="_blank" rel="noopener" href="https://goproxy.cn/%E6%98%AF%E4%B8%80%E4%B8%AA%E5%9B%BD%E5%86%85%E7%9A%84%E5%8F%AF%E8%AE%BF%E9%97%AE%E7%9A%84GoModule%E4%BE%9D%E8%B5%96%E4%BB%93%E5%BA%93%EF%BC%8C%E7%B1%BB%E4%BC%BC%E4%BA%8EJava%E4%B8%ADmaven%E4%B8%AD%E5%A4%AE%E4%BB%93%E5%BA%93%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%82">https://goproxy.cn/ 是一个国内的可访问的 GoModule 依赖仓库，类似于 Java 中 maven 中央仓库的概念。</a></p>
<h4 id="4gomodule的版本问题"><a class="markdownIt-Anchor" href="#4gomodule的版本问题">#</a> 4.GoModule 的版本问题？</h4>
<p>我们使用 Go module 之前，首先要保证我们的 Go SDK 是在 1.13 以及以上版本。(Go1.11 以上就可以使用 Module, 但是需要设置一些开启等，1.13 后默认开启)</p>
<p>因为在 1.13 版本上官方正式推荐使用，成为稳定版了。</p>
<p>Go 也有代码仓库，比如可以使用 github 作为 go 项目的代码仓库，Go 语言本身就提供了一个指令 go get 来从指定的仓库中</p>
<p>拉取依赖包和代码，不过 go get 这个指令在开启模块功能和关闭模块功能下用法不一样，下面有开启模块下的用法。</p>
<h4 id="5gomodule和java中maven的区别"><a class="markdownIt-Anchor" href="#5gomodule和java中maven的区别">#</a> 5.GoModule 和 Java 中 Maven 的区别？</h4>
<p>Go 中的 Module 和 Java 中的 Maven 不同：</p>
<p>首先，Module 是官方的 SDK 包自带的，它并非像 maven 一样还得安装 maven 插件之类的。</p>
<p>关于中央依赖仓库，Go 和 Java 中的概念是类似的，都是国内的第三方提供的。</p>
<h4 id="6如何开启gomodulego111module"><a class="markdownIt-Anchor" href="#6如何开启gomodulego111module">#</a> 6. 如何开启 GoModule?(GO111MODULE)</h4>
<p>具体我们如何使用 Module 呢？</p>
<p>我们首先要检查我们的 GoSDK 版本是 1.11 还是 1.13 之上。</p>
<p>如果是 1.11 的话我们需要设置一个操作系统的中的环境变量，用于开启 Module 功能，这个是否开启的环境变量名是 GO111MODULE，</p>
<p>他有三种状态：</p>
<p>第一个是 on 开启状态，在此状态开启下项目不会再去 ${GOPATH} 下寻找依赖包。</p>
<p>第二个是 off 不开启 Module 功能，在此状态下项目会去 ${GOPATH} 下寻找依赖包。</p>
<p>第三个是 auto 自动检测状态，在此状态下会判断项目是否在 G O P A T H /s r c 外，如果在外面，会判断项目根目录下是否有 g o . m o d 文件，如果均有则开启 M o d u l e 功能，如果缺任何一个则会从 {GOPATH}/src 外，如果在外面，会判断项目根目录下是否有 go.mod 文件，如果均有则开启 Module 功能，如果缺任何一个则会从<em> GOP<strong>A</strong>T**H</em>/<em>src</em> 外，如果在外面，会判断项目根目录下是否有<em> g**o</em>.<em>m<strong>o</strong>d</em> 文件，如果均有则开启<em> M<strong>o</strong>d<strong>u</strong>l**e</em> 功能，如果缺任何一个则会从 {GOPATH} 下寻找依赖包。</p>
<p>GoSDK1.13 版本后 GO111MODULE 的默认值是 auto，所以 1.13 版本后不用修改该变量。</p>
<p>注意：在使用模块的时候， <code>GOPATH</code>  是无意义的，不过它还是会把下载的依赖储存在  <code>$&#123;GOPATH&#125;/src/mod</code>  中，也会把  <code>go install</code>  的结果放在  <code>$&#123;GOPATH&#125;/bin</code>  中。</p>
<p>windows</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set GO111MODULE=on</span><br></pre></td></tr></table></figure>
<p>linux</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export GO111MODULE=on</span><br></pre></td></tr></table></figure>
<h4 id="7gomodule的真实使用场景1"><a class="markdownIt-Anchor" href="#7gomodule的真实使用场景1">#</a> 7.GoModule 的真实使用场景 1：</h4>
<p>接下来我们代入具体的使用场景：</p>
<p>今天，小明要接手一个新的 Go 项目，他通过 GoLand 中的 git 工具，从公司的 git 仓库中下载了一个 Go 的项目。(下载到他电脑的非 ${GOPATH}/src 目录，比如下载到他电脑的任意一个自己的工作空间)</p>
<p>此时他要做的是：</p>
<p>1). 先打开项目根目录下的 go.mod 文件看看里面依赖了什么工具包。(这个就是随便了解一下项目)</p>
<p>2).Go 的中央模块仓库是 Go 的官网提供的，在国外是 https://proxy.golang.org 这个地址，可是在国内无法访问。</p>
<p>我们在国内需要使用如下的中央模块仓库地址：<a target="_blank" rel="noopener" href="https://goproxy.cn">https://goproxy.cn</a></p>
<p>我们 Go 中的 SDK 默认是去找国外的中央模块仓库的，如何修改成国内的呢？</p>
<p>我们知道，所有的下载拉取行为脚本实际上是从 go download 这个脚本代码中实现的，而在这个脚本中的源码实现里，肯定有一个代码是写的是取出操作系统中的一个环境变量，这个环境变量存储着一个地址，这个地址代表了去哪个中央模块仓库拉取。</p>
<p>在 GoSDK 中的默认实现里，这个操作系统的环境变量叫做 GOPROXY，在脚本中为其赋予了一个默认值，就是国外的 proxy.golang.org 这个值。</p>
<p>我们要想修改，只需要在当前电脑修改该环境变量的值即可：</p>
<p>(注意，这个变量值不带 https, 这只是一个变量，程序会自动拼接 https)</p>
<p>windows</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set GOPROXY=goproxy.cn</span><br></pre></td></tr></table></figure>
<p>linux</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export GOPROXY=goproxy.cn</span><br></pre></td></tr></table></figure>
<p>3). 切换到项目的根目录，也就是有 go.mod 的那层目录，打开命令行窗口。</p>
<p>执行 download 指令 (下载模块项目到 ${GOPATH}/pkg/mod 下)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go  mod  download</span><br></pre></td></tr></table></figure>
<p>4). 如果不报错，代表已经下载好了，可以使用了，此时在项目根目录会生成一个 go.sum 文件。</p>
<p>一会再讲解 sum 文件。</p>
<p>5). 此时可以进行开发了。</p>
<h4 id="8gomodule的真实使用场景2"><a class="markdownIt-Anchor" href="#8gomodule的真实使用场景2">#</a> 8.GoModule 的真实使用场景 2：</h4>
<p>场景 2：我们如何用命令创建一个 Module 的项目，(开发工具也能手动创建)。</p>
<p>切换到项目根目录，执行如下指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go  mod init 模块名(模块名可不写)</span><br></pre></td></tr></table></figure>
<p>然后会在根目录下生成一个 go.mod 文件</p>
<p>我们看看这个 go.mod 文件长啥样？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 刚才init指令后的模块名参数被写在module后了</span><br><span class="line">module 模块名</span><br><span class="line">//表示使用GoSDK的哪个版本</span><br><span class="line">go 1.14</span><br></pre></td></tr></table></figure>
<p>修改 go.mod 文件中的依赖即可。</p>
<p>我们有两种方式下载和更新依赖：</p>
<p>1. 修改 go.mod 文件，然后执行 go mod down 把模块依赖下载到自己 ${GOPATH}/pkg/mod 下，这里面装的是所有下载的 module 缓存依赖文件，其中有 zip 的包，也有源码，在一个项目文件夹下的不同文件夹下放着，还有版本号文件夹区分，每个版本都是一个文件夹。</p>
<p>2. 直接在命令行使用 go get package@version 更新或者下载依赖模块，升级或者降级模块的版本。(这里是开启模块后的 go get 指令用法)</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get  github.com/gin-contrib/sessions@v0.0.1</span><br></pre></td></tr></table></figure>
<p>这个指令执行过后，会自动修改 go.mod 中的文件内容，不需要我们手动修改 go.mod 文件中的内容。</p>
<h4 id="9gomod文件详解"><a class="markdownIt-Anchor" href="#9gomod文件详解">#</a> 9.go.mod 文件详解</h4>
<p>接下来我们讲讲核心配置文件 go.mod</p>
<p>go.mod 内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//表示本项目的module模块名称是什么,别的模块依赖此模块的时候写这个名字</span><br><span class="line">module test</span><br><span class="line">//表示使用GoSDK的哪个版本</span><br><span class="line">go 1.14</span><br><span class="line">//require中声明的是需要依赖的包和包版本号</span><br><span class="line">require (</span><br><span class="line">	//格式如下： 需要import导入的模块名  版本号</span><br><span class="line">	//		   需要import导入的模块名2  版本号2	</span><br><span class="line">	//			...					...</span><br><span class="line">    github.com/gin-contrib/sessions v0.0.1</span><br><span class="line">    github.com/gin-contrib/sse v0.1.0 // indirect</span><br><span class="line">    github.com/gin-gonic/gin v1.4.0</span><br><span class="line">    github.com/go-redis/redis v6.15.6+incompatible</span><br><span class="line">    github.com/go-sql-driver/mysql v1.4.1</span><br><span class="line">    github.com/golang/protobuf v1.3.2 // indirect</span><br><span class="line">    github.com/jinzhu/gorm v1.9.11</span><br><span class="line">    github.com/json-iterator/go v1.1.7 // indirect</span><br><span class="line">    github.com/kr/pretty v0.1.0 // indirect</span><br><span class="line">    github.com/mattn/go-isatty v0.0.10 // indirect</span><br><span class="line">    github.com/sirupsen/logrus v1.2.0</span><br><span class="line">    github.com/ugorji/go v1.1.7 // indirect</span><br><span class="line">)</span><br><span class="line">//replace写法如下，表示如果项目中有引入前面的依赖模块，改为引用=&gt;后面的依赖模块，</span><br><span class="line">//可以用于golang的国外地址访问改为指向国内的github地址,当然你在上面require直接写github就不用在这里repalce了</span><br><span class="line">replace (</span><br><span class="line">	golang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a =&gt; github.com/golang/crypto v0.0.0-20190313024323-a1f597ede03a</span><br><span class="line">)</span><br><span class="line">//忽略依赖模块，表示在该项目中无论如何都使用不了该依赖模块，可以用于限制使用某个有bug版本的模块</span><br><span class="line">exclude(</span><br><span class="line">    github.com/ugorji/go v1.1.7 </span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>注：go.mod 提供了 module, require、replace 和 exclude 四个命令</p>
<p>module 语句指定包的名字（路径）<br>
require 语句指定的依赖项模块<br>
 replace 语句可以替换依赖项模块<br>
 exclude 语句可以忽略依赖项模块</p>
<p><a target="_blank" rel="noopener" href="http://xn--github-9o7i2021c.com/ugorji/go">上面 github.com/ugorji/go</a> v1.1.7 //indirect 有 indirect 和非 indirect</p>
<p>indirect 代表此模块是间接引用的，中间隔了几个项目</p>
<p>这个不用特殊写，可以注释写便于识别和开发</p>
<h4 id="10gomodule有哪些命令如何使用"><a class="markdownIt-Anchor" href="#10gomodule有哪些命令如何使用">#</a> 10.GoModule 有哪些命令？如何使用？</h4>
<p>Go 有如下关于 Module 的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//go mod   命令：</span><br><span class="line">download  //下载依赖模块到$&#123;GOPATH&#125;/pkg/mod</span><br><span class="line">edit      //一系列参数指令用于操作go.mod文件，参数太多，具体下面有例子</span><br><span class="line">graph     //输出显示每一个模块依赖了哪些模块</span><br><span class="line">init      //在一个非module项目的根目录下创建一个go.mod文件使其变为一个module管理的项目</span><br><span class="line">tidy      //根据项目实际使用的依赖包修改(删除和添加)go.mod中的文本内容</span><br><span class="line">vendor    //在项目根目录创建一个vender文件夹 然后把$&#123;GOPATH&#125;/pkg/mod下载的本项目需要的依赖模块拷贝到本项目的vender目录下</span><br><span class="line">verify    //校验$&#123;GOPATH&#125;/pkg/mod中的依赖模块下载到本地后是否被修改或者篡改过</span><br><span class="line">why       //一个说明文档的功能，用于说明一些包之间的为什么要这么依赖。(没啥用)</span><br></pre></td></tr></table></figure>
<h5 id="0-init和download"><a class="markdownIt-Anchor" href="#0-init和download">#</a> 0). init 和 download</h5>
<p>我们之前在案例中讲了 init,download 指令，这里不再赘述</p>
<h5 id="1go-mod-edit"><a class="markdownIt-Anchor" href="#1go-mod-edit">#</a> 1).go mod edit</h5>
<p>是指在命令行用指令通过不同的参数修改 go.mod 文件，这个指令必须得写参数才能正确执行，不能空执行 go mod edit</p>
<p>参数 1 ：-fmt</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -fmt</span><br></pre></td></tr></table></figure>
<p>格式化 go.mod 文件，只是格式规范一下，不做其它任何内容上的修改。</p>
<p>其它任何 edit 指令执行完毕后都会自动执行 - fmt 格式化操作。</p>
<p>这个使用场景就是我们如果不想做任何操作，就想试试 edit 指令，就只需要跟上 - fmt 就行，因为单独不加任何参数</p>
<p>只有 go mod edit 后面不跟参数是无法执行的。</p>
<p>我们如何升级降级依赖模块的版本，或者说添加新的依赖和移除旧的依赖呢</p>
<p>参数 2： -require=path@version /-droprequire=path flags</p>
<p>添加一个依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod  edit -require=github.com/gin-contrib/sessions@v0.0.1</span><br></pre></td></tr></table></figure>
<p>删除一个依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -droprequire=github.com/gin-contrib/sessions@v0.0.1</span><br></pre></td></tr></table></figure>
<p>这两个和 go get package@version 功能差不多，但是官方文档更推荐使用 go get 来完成添加和修改依赖（go get 后的 package 和上面的 path 一个含义，都是模块全路径名）</p>
<p>参数 3：-exclude=path@version and -dropexclude=path@version</p>
<p>排除某个版本某个模块的使用，必须有该模块才可以写这个进行排除。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -exclude=github.com/gin-contrib/sessions@v0.0.1</span><br></pre></td></tr></table></figure>
<p>删除排除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -dropexclude=github.com/gin-contrib/sessions@v0.0.1</span><br></pre></td></tr></table></figure>
<p>简单来说，执行这两个是为了我们在开发中避免使用到不应该使用的包</p>
<p>… 还有好几个，基本很少用，省略了</p>
<h5 id="2go-mod-graph"><a class="markdownIt-Anchor" href="#2go-mod-graph">#</a> 2).go mod graph</h5>
<p>命令用法： 输出每一个模块依赖了哪些模块 无参数，直接使用 ，在项目根目录下命令行执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod graph</span><br></pre></td></tr></table></figure>
<p>比如：</p>
<p>模块 1 依赖了模块 a</p>
<p>模块 1 依赖了模块 b</p>
<p>模块 1 依赖了模块 c</p>
<p>模块 2 依赖了模块 x</p>
<p>模块 2 依赖了模块 z</p>
<p>如下是具体例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">C:\$&#123;GOPAHT&#125;\file\project&gt;go mod graph</span><br><span class="line">file\project github.com/edgexfoundry/go-mod-bootstrap@v0.0.35</span><br><span class="line">github.com/edgexfoundry/go-mod-bootstrap@v0.0.35 github.com/BurntSushi/toml@v0.3.1</span><br><span class="line">github.com/edgexfoundry/go-mod-bootstrap@v0.0.35 github.com/edgexfoundry/go-mod-configuration@v0.0.3</span><br><span class="line">github.com/edgexfoundry/go-mod-bootstrap@v0.0.35 github.com/edgexfoundry/go-mod-core-contracts@v0.1.34</span><br><span class="line">github.com/edgexfoundry/go-mod-bootstrap@v0.0.35 github.com/edgexfoundry/go-mod-registry@v0.1.17</span><br><span class="line">github.com/edgexfoundry/go-mod-bootstrap@v0.0.35 github.com/edgexfoundry/go-mod-secrets@v0.0.17</span><br><span class="line">github.com/edgexfoundry/go-mod-bootstrap@v0.0.35 github.com/gorilla/mux@v1.7.1</span><br><span class="line">github.com/edgexfoundry/go-mod-bootstrap@v0.0.35 github.com/pelletier/go-toml@v1.2.0</span><br><span class="line">github.com/edgexfoundry/go-mod-bootstrap@v0.0.35 github.com/stretchr/testify@v1.5.1</span><br><span class="line">github.com/edgexfoundry/go-mod-bootstrap@v0.0.35 gopkg.in/yaml.v2@v2.2.8</span><br><span class="line">github.com/edgexfoundry/go-mod-configuration@v0.0.3 github.com/cenkalti/backoff@v2.2.1+incompatible</span><br><span class="line">github.com/edgexfoundry/go-mod-configuration@v0.0.3 github.com/hashicorp/consul/api@v1.1.0</span><br></pre></td></tr></table></figure>
<h5 id="3go-mod-tidy"><a class="markdownIt-Anchor" href="#3go-mod-tidy">#</a> 3).go mod tidy</h5>
<p>根据实际项目使用到的依赖模块，在 go.mod 中添加或者删除文本引用</p>
<p>有一个参数可选项 -v 输出在 go.mod 文件中删除的引用模块信息</p>
<p>比如我们项目用到一个模块，go.mod 中没写，执行后 go.mod 中就会添加上该模块的文本引用。</p>
<p>如果我们在 go.mod 中引用了一个模块，检测在真实项目中并没有使用，则会在 go.mod 中删除该文本引用。</p>
<p>使用如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go  mod  tidy -v</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unused github.com/edgexfoundry/go-mod-bootstrap</span><br></pre></td></tr></table></figure>
<p>输出表示检测项目没有使用到该模块，然后从 go.mod 中把该包的引用文字给删除了。</p>
<h5 id="4go-mod-vender"><a class="markdownIt-Anchor" href="#4go-mod-vender">#</a> 4).go mod vender</h5>
<p>该指令会在项目中建立一个 vender 目录，然后把 ${GOPATG}/pkg/mod 中下载的依赖拷贝到项目的 vender 目录中，方便管理和方便在 idea 中引用依赖。 -v 参数可以在控制台输出相关的结果信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod vender -v </span><br></pre></td></tr></table></figure>
<h5 id="5go-mod-verify"><a class="markdownIt-Anchor" href="#5go-mod-verify">#</a> 5).go mod verify</h5>
<p>验证下载到 ${GOPATH}/pkg/mod 中的依赖模块有没有被修改或者篡改。</p>
<p>结果会输出是否被修改过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod verify</span><br></pre></td></tr></table></figure>
<p>比如输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all modules verified</span><br></pre></td></tr></table></figure>
<p>这个是所有模块已经验证，代表没有被修改，如果被修改，会提示哪些被修改。</p>
<h5 id="6go-mod-why"><a class="markdownIt-Anchor" href="#6go-mod-why">#</a> 6).go mod why</h5>
<p>这个没啥用，说白了就是一个解释文档，输入参数和依赖他说明哪些包为啥要依赖这些包，不用看它，用处不大。</p>
<h4 id="11gosum详细讲解"><a class="markdownIt-Anchor" href="#11gosum详细讲解">#</a> 11.go.sum 详细讲解</h4>
<h5 id="1gosum什么时候会更新或者新建生成"><a class="markdownIt-Anchor" href="#1gosum什么时候会更新或者新建生成">#</a> 1).go.sum 什么时候会更新或者新建生成？</h5>
<p>当我们通过 go mod download 下载完依赖模块或者 go get package@version 更新了依赖包的时候</p>
<p>，会检查根目录下有没有一个叫 go.sum 的文件，没有的话则创建一个并写入内容，有的话会更新 go.sum 中的内容。</p>
<h5 id="2gosum是用来做什么的"><a class="markdownIt-Anchor" href="#2gosum是用来做什么的">#</a> 2).go.sum 是用来做什么的？</h5>
<p>go.sum 的作用是用来校验你下载的依赖模块是否是官方仓库提供的，对应的正确的版本的，并且中途没有被黑客篡改的。</p>
<p>go.sum 主要是起安全作用和保证依赖的版本肯定是官方的提供的那个版本，版本确认具体是确认你下载的那个模块版本里面的代码的和官方提供的模块的那个版本的代码完全相同，一字不差。</p>
<p>通过 go.sum 保证安全性是很有必要的，因为如果你的电脑被黑客攻击了，黑客可以截取你对外发送的文件，也可以修改发送给你的文件，那么就会产生一个问题：</p>
<p>本来的路径应该是这样的： 第三方模块依赖库 ------------&gt; 你的电脑</p>
<p>结果中间有黑客会变成这样:</p>
<p>第三方模块依赖库 --------&gt; 黑客修改了依赖库中的代码，植入病毒代码，并重新打成模块发送给你 ---------&gt; 你以为是官方的版本</p>
<p>结果黑客就把病毒代码植入到了你的项目中，你的项目就不安全了，面临着数据全部泄露的风险。</p>
<h5 id="3gosum是如何实现校验机制的它包含什么内容"><a class="markdownIt-Anchor" href="#3gosum是如何实现校验机制的它包含什么内容">#</a> 3).go.sum 是如何实现校验机制的？它包含什么内容？</h5>
<p>说到校验安全机制，有一种常规的玩法就是使用不可逆加密算法，不可逆加密算法是指将 a 文本通过算法加密成 b 文本后，b 文本永远也不能反着计算出 a 文本。</p>
<p>不可加密算法的具体是怎么应用的呢？它是如何起作用的？</p>
<p>我们在这里先讲一个不可逆的加密算法 SHA-256 算法。</p>
<p>SHA-256 算法的功能就是将一个任意长度的字符串转换成一个固定长度为 64 的字符串，比如:</p>
<p>4e07408562bedb8b60ce05c1decfe3ad16b72230967de01f640b7e4729b49fce</p>
<p>这里从 4e07 代表四个字符串，按此算，这个加密后的字符串为 64 个。</p>
<p>为什么是 64 个呢？</p>
<p>因为 64 个字符串每两个字符为一组，比如 4e 是一组，07 是一组，也就是说有 32 组，每一组是一个十六进制的数值，一个十六进制的数值也就是两个字符用计算机中的 8 个字节内存空间存储，也就是一个十六进制的数字，有两个字符串，占 8 个字节，一个字节等同 8 位 (bit)(位只能存储 0 和 1 两个值)，也就是说:</p>
<p>32（32 个十六进制数，每个十六进制数用两个字符表示）*8 字节 = 256 位。</p>
<p>仔细看名字，SHA 代表是算法的加密方式类型，256 代表的是他这个是 256 位的版本。</p>
<p>具体原理实现是 SHA 内部定义了一系列固定数值的表，然后加密的时候无论是需要加密多少文字，它都按照一定的规则从需要加密的文字中按一定规则抽取其中的缩略一部分，然后拿缩略的一部分和 SHA 内部的固定数值表进行固定的 hash 映射和算术操作，这个 hash 映射和算术操作的顺序是固定写死的，公共数据表是写死的，这个写死的顺序和公共数据表就是这个算法的具体内容本质。</p>
<p>这样的话，因为抽取的是缩略的内容，所以我们可以把输出结果固定在 64 个字符，256 位。</p>
<p>因为是缩略的内容， 所以我们不可能通过缩略的内容反推出完整的结果。</p>
<p>但是，相同的文本按照这个算法加密出来的 64 个字符肯定是相同的，同时，只要改变原需要加密文本的一个字符，也会造成加密出来的 64 个字符大不相同。</p>
<p>我们用 SHA-256 通常是这么用的：</p>
<p>A 方 要 发送信息给 B 方</p>
<p>B 方 要确定信息是 A 方发送的，没有经过篡改</p>
<p>此时 A 和 B 同时约定一个密码字符串，比如 abc。</p>
<p>这个 abc 只有 A 方和 B 方知道。</p>
<p>A 方把 需要传输的文本拼接上 abc，然后通过 SHA-256 加密算出一个值，把原文本和算出的值全部发送给 B。</p>
<p>B 方 拿出原文本，拼接上 abc，进行 SHA256 计算，看看结果是否和传输过来的 A 传输的值一样，如果一样，代表中间没有被篡改。</p>
<p>为什么呢？</p>
<p>因为如果有一个黑客 C 想要篡改，他就得同时篡改原文本和算出的签名值。</p>
<p>可是 C 不知道密码是 abc，它也就不能把 abc 拼接到原文后，所以它算出来的签名和 B 算出来的签名肯定不一致。</p>
<p>所以 B 如果自己算出的签名值与接收到的签名值不一致，B 就知道不是 A 发过来的，就能校验发送端的源头是否是官方安全的了。</p>
<hr>
<p>接下来我们讲一下 go.sum 的验证机制。</p>
<p>首先说下 go.sum 中存储的内容，这个文件存储的每一行都是如下格式</p>
<p>模块名 版本号 hash 签名值</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">github.com/google/uuid v1.1.1 h1:Gkbcsh/GbpXz7lPftLA3P6TYMwjCLYm83jiFQZF/3gY=   </span><br><span class="line"></span><br><span class="line">github.com/google/uuid v1.1.1/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=</span><br></pre></td></tr></table></figure>
<p>这里的 hash 签名值是拿当前模块当前版本号内的所有代码字符串计算出来的一个值，就是通过上面讲解的 SHA-256 计算的。</p>
<p>所以哪怕是这个模块中的代码有一个字变了，计算出来的 hash 值也不相同。</p>
<p>第三方模块库在每发布一个新的模块版本后，会按照 SHA-256 计算出对应版本的 hash 值，然后提供给外部获取用于检验安全性。</p>
<p>当我们 go mod download 和 go get package@version 后 会更新 go.mod 中的模块路径和版本。</p>
<p>然后会更新或者创建根目录下 go.sum 文件中的模块名 版本号 和 hash 值。</p>
<p>在 go.sum 中的 hash 值是在下载和更新依赖包的时候，同时获取官方提供的版本号得来的。</p>
<p>也就是说，基本上 go.sum 中的文件都是从官网（外国）（中国是第三方模块仓库）上获得的正品版本号，这个版本号是仓库方自己算的，你只是获取到了存储到你自己的 go.sum 中。</p>
<p>具体如何获取版本号有个小知识点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go module机制在下载和更新依赖的时候会取出操作系统中名为`GOSUMDB`的环境变量中的值，这个服务器地址值代表了从哪个第三方仓库获取对应的正品版本号。</span><br></pre></td></tr></table></figure>
<p>重点来了，当你在 go build 打包创建 go 项目的时候，go build 的内部指令会去拿你本地的模块文件进行 SHA-256 计算，然后拿到一个计算出来的结果值，之后它会拿此值和 go.sum 中的正确的从官网拉取的值进行对比，如果不一样，说明这个模块包不是官方发布的，也就是你本地的模块包和官方发布的模块包中的代码肯定有差异。</p>
<h2 id="四专门详解go并发编程相关知识"><a class="markdownIt-Anchor" href="#四专门详解go并发编程相关知识">#</a> 四。专门详解 Go 并发编程相关知识</h2>
<h3 id="1go为什么天然支持高并发纤程比线程的优势是什么"><a class="markdownIt-Anchor" href="#1go为什么天然支持高并发纤程比线程的优势是什么">#</a> 1.Go 为什么天然支持高并发，纤程比线程的优势是什么？</h3>
<p>Go 语言在设计的时候就考虑了充分利用计算机的多核处理器，具体表现为，Go 中开启一个并发的任务以操作系统的线程资源调度为单位的，而是 Go 的创造者们自己写了一套管理多个任务的机制，在这个机制下，每一个并发的任务线程叫做纤程，这个纤程的作用等同一个线程，也是并发执行的，只不过纤程是在应用程序管理的，懂底层的可以讲是在用户态的一个线程，而 Java 中调度的线程是属于操作系统，也就是操作系统内核态的线程。</p>
<p>用户态的纤程归属于用户编写的软件管理和调度，优点是可以根据情况灵活实现堆栈的内存分配，最优化其中的运行资源配置。</p>
<p>内核态的线程归属于操作系统调度和管理，他底层是有 windows 或者 linux 操作系统底层的代码管理的，那么他就不灵活，每个线程分配的资源可能造成浪费，创建的线程数肯定也有一定的限制。</p>
<p>Go 的创造可以为自己的语言和任务灵活配置资源，Linux 和 windows 操作系统的代码是通用的，总不能为你这个语言修改源代码把。</p>
<p>在实际程序运行中，一个操作系统的内核态线程可能管理着好几个甚至数十个纤程 (根据实际情况和设置不同而不同)，所以省去了线程时间片上下文切换的时间。</p>
<p>同时因为内部机制灵活，所以执行效率高，占用内存也少。</p>
<p>这就是 Go 语言的并发优势的核心所在。</p>
<h3 id="2并发和并行的区别"><a class="markdownIt-Anchor" href="#2并发和并行的区别">#</a> 2. 并发和并行的区别？</h3>
<p>并发是指的一个角色在一段时间内通过来回切换处理了多个任务。</p>
<p>并行是指两个或者多个角色同时处理自己的任务。</p>
<p>举例：</p>
<p>并发：在一个小时内，你写了 10 分钟语文作业，又写了 10 分钟数学，之后又写了 10 分中英语作业，然后再从语文 10 分钟，数学 10 分钟，英文 10 分钟又来一次。</p>
<p>这个叫做你并发的写语文数学英语作业。</p>
<p>你一个一段时间（一个小时内）通过切换（一会写数学，一会写语文。。。），处理了多个任务（写了三门课的作业）</p>
<p>并行：你和小明同时写自己的作业。你们俩同时运行的状态叫做并行运作状态，强调的是你们两个人同时在处理任务 (做作业)。</p>
<p>你和小明 (两个以上的角色) 同时写作业 (处理自己的任务)。</p>
<p>在计算机中，比如有 4 个 cpu，4 个 cpu 同时工作，叫做这 4 个 cpu 并行执行任务，每个 cpu 通过时间片机制上下文切换处理 100 个小任务，叫做每个 cpu 并发的处理 100 个任务。</p>
<h3 id="3go是如何用channel进行协程间数据通信数据同步的"><a class="markdownIt-Anchor" href="#3go是如何用channel进行协程间数据通信数据同步的">#</a> 3.Go 是如何用 Channel 进行协程间数据通信数据同步的？</h3>
<p>go 中的线程相关的概念是 Goroutines (并发)，是使用 go 关键字开启。</p>
<p>Java 中的线程是通过 Thread 类开启的。</p>
<p>在 go 语言中，一个线程就是一个 Goroutines，主函数就是（主） main Goroutines。</p>
<p>使用 go 语句来开启一个新的 Goroutines</p>
<p>比如：</p>
<p>普通方法执行</p>
<p>myFunction()</p>
<p>开启一个 Goroutines 来执行方法</p>
<p>go myFunction()</p>
<p>java 中是</p>
<p>new Thread(()-&gt;{</p>
<p>// 新线程逻辑代码</p>
<p>}).start();</p>
<p>参考下面的代码示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//并发开启新线程goroutine测试</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunction</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;Hello!!!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//并发执行方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goroutineTestFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;Hello!!! Start Goroutine!!!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   myFunction()</span></span><br><span class="line"><span class="comment">   //go goroutineTestFunc()</span></span><br><span class="line"><span class="comment">   //此时因为主线程有时候结束的快，goroutineTestFunc方法得不到输出，由此可以看出是开启了新的线程。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="comment">//打开第二段执行</span></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   go goroutineTestFunc()</span></span><br><span class="line"><span class="comment">   time.Sleep(10*time.Second)//睡一段时间  10秒</span></span><br><span class="line"><span class="comment">   myFunction()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程间的通信：</p>
<p>java 线程间通信有很多种方式：</p>
<p>比如最原始的 wait/notify</p>
<p>到使用 juc 下高并发线程同步容器，同步队列</p>
<p>到 CountDownLatch 等一系列工具类</p>
<p>…</p>
<p>甚至是分布式系统不同机器之间的消息中间件，单机的 disruptor 等等。</p>
<p>Go 语言不同，线程间主要的通信方式是 Channel。</p>
<p>Channel 是实现 go 语言多个线程（goroutines）之间通信的一个机制。</p>
<p>Channel 是一个线程间传输数据的管道，创建 Channel 必须声明管道内的数据类型是什么</p>
<p>下面我们创建一个传输 int 类型数据的 Channel</p>
<p>代码示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">   fmt.Println(ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>channel 是引用类型，函数传参数时是引用传递而不是值拷贝的传递。</p>
<p>channel 的空值和别的应用类型一样是 nil。</p>
<p>== 可以比较两个 Channel 之间传输的数据类型是否相等。</p>
<p>channel 是一个管道，他可以收数据和发数据。</p>
<p>具体参照下面代码示例:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//channel发送数据和接受数据用 &lt;-表示,是发送还是接受取决于chan在  &lt;-左边还是右边</span></span><br><span class="line"><span class="comment">//创建一个传输字符串数据类型的管道</span></span><br><span class="line"><span class="keyword">var</span>  chanStr  = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;main goroutine print Hello &quot;</span>)</span><br><span class="line">   <span class="comment">//默认channel是没有缓存的，阻塞的，也就是说，发送端发送后直到接受端接受到才会施放阻塞往下面走。</span></span><br><span class="line">   <span class="comment">//同样接收端如果先开启，直到接收到数据才会停止阻塞往下走</span></span><br><span class="line">   <span class="comment">//开启新线程发送数据</span></span><br><span class="line">   <span class="keyword">go</span> startNewGoroutineOne()</span><br><span class="line">   <span class="comment">//从管道中接收读取数据</span></span><br><span class="line">   <span class="keyword">go</span> startNewGoroutineTwo()</span><br><span class="line">   <span class="comment">//主线程等待，要不直接结束了</span></span><br><span class="line">   time.Sleep(<span class="number">100</span>*time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startNewGoroutineOne</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;send channel print Hello &quot;</span>)</span><br><span class="line">   <span class="comment">//管道发送数据</span></span><br><span class="line">   chanStr &lt;- <span class="string">&quot;Hello!!!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startNewGoroutineTwo</span><span class="params">()</span></span>&#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;receive channel print Hello &quot;</span>)</span><br><span class="line">   strVar := &lt;-chanStr</span><br><span class="line">   fmt.Println(strVar)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无缓存的 channel 可以起到一个多线程间线程数据同步锁安全的作用。</p>
<p>缓存的 channel 创建方式是</p>
<p>make (chan string, 缓存个数)</p>
<p>缓存个数是指直到多个数据没有消费或者接受后才进行阻塞。</p>
<p>类似于 java 中的 synchronized 和 lock</p>
<p>可以保证多线程并发下的数据一致性问题。</p>
<p>首先我们看一个线程不安全的代码示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//多线程并发下的不安全问题</span></span><br><span class="line"><span class="comment">//金额</span></span><br><span class="line"><span class="keyword">var</span> moneyA <span class="type">int</span> =<span class="number">1000</span></span><br><span class="line"><span class="comment">//添加金额</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subtractMoney</span><span class="params">(subMoney <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   time.Sleep(<span class="number">3</span>*time.Second)</span><br><span class="line">   moneyA-=subMoney</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询金额</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMoney</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> moneyA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//添加查询金额</span></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(getMoney()&gt;<span class="number">200</span>) &#123;</span><br><span class="line">         subtractMoney(<span class="number">200</span>)</span><br><span class="line">         fmt.Printf(<span class="string">&quot;200元扣款成功，剩下：%d元\n&quot;</span>,getMoney())</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="comment">//添加查询金额</span></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(getMoney()&gt;<span class="number">900</span>) &#123;</span><br><span class="line">         subtractMoney(<span class="number">900</span>)</span><br><span class="line">         fmt.Printf(<span class="string">&quot;900元扣款成功，剩下：%d元\n&quot;</span>,getMoney())</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="comment">//正常逻辑，只够扣款一单，可以多线程环境下结果钱扣多了</span></span><br><span class="line">   time.Sleep(<span class="number">5</span>*time.Second)</span><br><span class="line">   fmt.Println(getMoney())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缓存为 1 的 channel 可以作为锁使用：</p>
<p>示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//多线程并发下使用channel改造</span></span><br><span class="line"><span class="comment">//金额</span></span><br><span class="line"><span class="keyword">var</span> moneyA  = <span class="number">1000</span></span><br><span class="line"><span class="comment">//减少金额管道</span></span><br><span class="line"><span class="keyword">var</span> synchLock = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加金额</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subtractMoney</span><span class="params">(subMoney <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   time.Sleep(<span class="number">3</span>*time.Second)</span><br><span class="line">   moneyA-=subMoney</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询金额</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMoney</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> moneyA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//添加查询金额</span></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      synchLock&lt;<span class="number">-10</span></span><br><span class="line">      <span class="keyword">if</span>(getMoney()&gt;<span class="number">200</span>) &#123;</span><br><span class="line">         subtractMoney(<span class="number">200</span>)</span><br><span class="line">         fmt.Printf(<span class="string">&quot;200元扣款成功，剩下：%d元\n&quot;</span>,getMoney())</span><br><span class="line">      &#125;</span><br><span class="line">      &lt;-synchLock</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="comment">//添加查询金额</span></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      synchLock&lt;<span class="number">-10</span></span><br><span class="line">      <span class="keyword">if</span>(getMoney()&gt;<span class="number">900</span>) &#123;</span><br><span class="line">         subtractMoney(<span class="number">900</span>)</span><br><span class="line">         fmt.Printf(<span class="string">&quot;900元扣款成功，剩下：%d元\n&quot;</span>,getMoney())</span><br><span class="line">      &#125;</span><br><span class="line">      synchLock&lt;<span class="number">-10</span></span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="comment">//这样类似于java中的Lock锁，不会扣多</span></span><br><span class="line">   time.Sleep(<span class="number">5</span>*time.Second)</span><br><span class="line">   fmt.Println(getMoney())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4go中的goroutine使用和gmp模型"><a class="markdownIt-Anchor" href="#4go中的goroutine使用和gmp模型">#</a> 4.Go 中的 Goroutine 使用和 GMP 模型？</h3>
<p>Go 中的线程 (实际是纤程) goroutine 的底层管理和调度是在 runtime 包中自己实现的，其中遵循了 GMP 模型。</p>
<p>G 就是一个 goroutine，包括它自身的一些元信息。</p>
<p>M 是指操作系统内核态的线程的一个虚拟表示，一个 M 就是操作系统内核态的一个线程。</p>
<p>P 是一个组列表，P 管理着多个 goroutines,P 还有一些用于组管理的元数据信息。</p>
<h3 id="5go的select怎么用"><a class="markdownIt-Anchor" href="#5go的select怎么用">#</a> 5.Go 的 select 怎么用？</h3>
<p>Go 中的 select 是专门用于支持更好的使用管道 (channel) 的。</p>
<p>我们之前虽然讲了能从管道中读取数据，但是这有一个缺陷，就是我们在一个 Goroutine 中不能同时处理读取多个 channel，因为在一个 Goroutine 中，一个 channel 阻塞后就无法继续运行了，所以无法在一个 Goroutine 处理多个 channel, 而 select 很好的解决了这个问题。</p>
<p>select 相当于 Java 中 Netty 框架的多路复用器的功能。</p>
<p>举例代码示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//创建一个缓存为1的chan</span></span><br><span class="line">   myChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">1</span>)</span><br><span class="line">   <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++&#123;</span><br><span class="line">      <span class="comment">//select 的用法是，从上到下依次判断case 是否可执行，如果可执行，则执行完毕跳出select,如果不能执行，尝试下一个执行</span></span><br><span class="line">      <span class="comment">//这里的可执行是指的不阻塞，也就是说，select从上到下开始挑选一个不阻塞的case执行，执行完毕后跳出，</span></span><br><span class="line">      <span class="comment">//如果所有case都阻塞，则执行default</span></span><br><span class="line">      <span class="comment">//如下输出结果，i=奇数的时候走case   myChan&lt;-i:，把奇数放入mychan</span></span><br><span class="line">      <span class="comment">//走偶数的时候因为myChan中有数据了，则把上一个奇数打印出来。</span></span><br><span class="line">      <span class="comment">//所以结果是 1  3  5  7  ...</span></span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span>  data := &lt;-myChan:</span><br><span class="line">               fmt.Println(data)</span><br><span class="line">            <span class="keyword">case</span>   myChan&lt;-i:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">               fmt.Println(<span class="string">&quot;default !!!&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6go中的互斥锁类似于java中的reentrantlock"><a class="markdownIt-Anchor" href="#6go中的互斥锁类似于java中的reentrantlock">#</a> 6.Go 中的互斥锁 (类似于 Java 中的 ReentrantLock)</h3>
<p>先按线程不安全的数据错误的代码示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">var</span> num <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wait sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wait.Add(<span class="number">5</span>)</span><br><span class="line">	<span class="keyword">go</span> myAdd()</span><br><span class="line">	<span class="keyword">go</span> myAdd()</span><br><span class="line">	<span class="keyword">go</span> myAdd()</span><br><span class="line">	<span class="keyword">go</span> myAdd()</span><br><span class="line">	<span class="keyword">go</span> myAdd()</span><br><span class="line">	wait.Wait()</span><br><span class="line">	<span class="comment">//预期值等于5万，可是因为线程不安全错误，小于5万</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;num = %d\n&quot;</span>,num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span>  <span class="title">myAdd</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wait.Done()</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span> ;i&lt;<span class="number">10000</span>;i++ &#123;</span><br><span class="line">		num+=<span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num = 38626  </span><br></pre></td></tr></table></figure>
<p>互斥锁示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">var</span> num <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wait sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   wait.Add(<span class="number">5</span>)</span><br><span class="line">   <span class="keyword">go</span> myAdd()</span><br><span class="line">   <span class="keyword">go</span> myAdd()</span><br><span class="line">   <span class="keyword">go</span> myAdd()</span><br><span class="line">   <span class="keyword">go</span> myAdd()</span><br><span class="line">   <span class="keyword">go</span> myAdd()</span><br><span class="line">   wait.Wait()</span><br><span class="line">   <span class="comment">//预期值等于5万，可是因为线程不安全错误，小于5万</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;num = %d\n&quot;</span>,num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span>  <span class="title">myAdd</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> wait.Done()</span><br><span class="line">   <span class="keyword">for</span> i:=<span class="number">0</span> ;i&lt;<span class="number">10000</span>;i++ &#123;</span><br><span class="line">      lock.Lock()</span><br><span class="line">      num+=<span class="number">1</span></span><br><span class="line">      lock.Unlock()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7go中的读写锁类似于java中的reentrantreadwritelock"><a class="markdownIt-Anchor" href="#7go中的读写锁类似于java中的reentrantreadwritelock">#</a> 7.Go 中的读写锁 (类似于 Java 中的 ReentrantReadWriteLock)</h3>
<p>读写锁用于读多写少的情况，多个线程并发读不上锁，写的时候才上锁互斥</p>
<p>读写锁示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;sync&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//金额</span></span><br><span class="line"><span class="keyword">var</span> moneyA  = <span class="number">1000</span></span><br><span class="line"><span class="comment">//读写锁</span></span><br><span class="line"><span class="keyword">var</span> rwLock sync.RWMutex;</span><br><span class="line"><span class="keyword">var</span> wait sync.WaitGroup</span><br><span class="line"><span class="comment">//添加金额</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subtractMoney</span><span class="params">(subMoney <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   rwLock.Lock()</span><br><span class="line">   time.Sleep(<span class="number">3</span>*time.Second)</span><br><span class="line">   moneyA-=subMoney</span><br><span class="line">   rwLock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询金额</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMoney</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   rwLock.RLock()</span><br><span class="line">   result := moneyA</span><br><span class="line">   rwLock.RUnlock()</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   wait.Add(<span class="number">2</span>)</span><br><span class="line">   <span class="comment">//添加查询金额</span></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">defer</span> wait.Done()</span><br><span class="line">      <span class="keyword">if</span>(getMoney()&gt;<span class="number">200</span>) &#123;</span><br><span class="line">         subtractMoney(<span class="number">200</span>)</span><br><span class="line">         fmt.Printf(<span class="string">&quot;200元扣款成功，剩下：%d元\n&quot;</span>,getMoney())</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">         fmt.Println(<span class="string">&quot;余额不足，无法扣款&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="comment">//添加查询金额</span></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">defer</span> wait.Done()</span><br><span class="line">      <span class="keyword">if</span>(getMoney()&gt;<span class="number">900</span>) &#123;</span><br><span class="line">         subtractMoney(<span class="number">900</span>)</span><br><span class="line">         fmt.Printf(<span class="string">&quot;900元扣款成功，剩下：%d元\n&quot;</span>,getMoney())</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">         fmt.Println(<span class="string">&quot;余额不足，无法扣款&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">   wait.Wait()</span><br><span class="line">   fmt.Println(getMoney())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8go中的并发安全map类似于currenthashmap"><a class="markdownIt-Anchor" href="#8go中的并发安全map类似于currenthashmap">#</a> 8.Go 中的并发安全 Map (类似于 CurrentHashMap)</h3>
<p>Go 中自己通过 make 创建的 map 不是线程安全的，具体体现在多线程添加值和修改值下会报如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fatal error : concurrent map writes</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>这个错类似于 java 中多线程读写线程不安全的容器时报的错。</p>
<p>Go 为了解决这个问题，专门给我们提供了一个并发安全的 map，这个并发安全的 map 不用通过 make 创建，拿来即可用，并且他提供了一些不同于普通 map 的操作方法。</p>
<p>参考如下代码示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个sync包下的线程安全map对象</span></span><br><span class="line"><span class="keyword">var</span> myConcurrentMap = sync.Map&#123;&#125;</span><br><span class="line"><span class="comment">//遍历数据用的</span></span><br><span class="line"><span class="keyword">var</span> myRangeMap = sync.Map&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//存储数据</span></span><br><span class="line">   myConcurrentMap.Store(<span class="number">1</span>,<span class="string">&quot;li_ming&quot;</span>)</span><br><span class="line">   <span class="comment">//取出数据</span></span><br><span class="line">   name,ok := myConcurrentMap.Load(<span class="number">1</span>)</span><br><span class="line">   <span class="keyword">if</span>(!ok) &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;不存在&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//打印值  li_ming</span></span><br><span class="line">   fmt.Println(name)</span><br><span class="line">   <span class="comment">//该key有值,则ok为true,返回它原来存在的值，不做任何操作；该key无值，则执行添加操作，ok为false,返回新添加的值</span></span><br><span class="line">   name2, ok2 := myConcurrentMap.LoadOrStore(<span class="number">1</span>,<span class="string">&quot;xiao_hong&quot;</span>)</span><br><span class="line">   <span class="comment">//因为key=1存在，所以打印是   li_ming true</span></span><br><span class="line">   fmt.Println(name2,ok2)</span><br><span class="line">   name3, ok3 := myConcurrentMap.LoadOrStore(<span class="number">2</span>,<span class="string">&quot;xiao_hong&quot;</span>)</span><br><span class="line">   <span class="comment">//因为key=2不存在，所以打印是   xiao_hong false</span></span><br><span class="line">   fmt.Println(name3,ok3)</span><br><span class="line">   <span class="comment">//标记删除值</span></span><br><span class="line">   myConcurrentMap.Delete(<span class="number">1</span>)</span><br><span class="line">   <span class="comment">//取出数据</span></span><br><span class="line">   <span class="comment">//name4,ok4 := myConcurrentMap.Load(1)</span></span><br><span class="line">   <span class="comment">//if(!ok4) &#123;</span></span><br><span class="line">   <span class="comment">// fmt.Println(&quot;name4=不存在&quot;)</span></span><br><span class="line">   <span class="comment">// return</span></span><br><span class="line">   <span class="comment">//&#125;</span></span><br><span class="line">   <span class="comment">//fmt.Println(name4)</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//遍历数据</span></span><br><span class="line">   rangeFunc()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rangeFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">   myRangeMap.Store(<span class="number">1</span>,<span class="string">&quot;xiao_ming&quot;</span>)</span><br><span class="line">   myRangeMap.Store(<span class="number">2</span>,<span class="string">&quot;xiao_li&quot;</span>)</span><br><span class="line">   myRangeMap.Store(<span class="number">3</span>,<span class="string">&quot;xiao_ke&quot;</span>)</span><br><span class="line">   myRangeMap.Store(<span class="number">4</span>,<span class="string">&quot;xiao_lei&quot;</span>)</span><br><span class="line"></span><br><span class="line">   myRangeMap.Range(<span class="function"><span class="keyword">func</span><span class="params">(k, v <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;data_key_value = :&quot;</span>,k,v)</span><br><span class="line">      <span class="comment">//return true代表继续遍历下一个，return false代表结束遍历操作</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9go中的atomicxxx原子操作类类似于java中的atocmicinteger之类的"><a class="markdownIt-Anchor" href="#9go中的atomicxxx原子操作类类似于java中的atocmicinteger之类的">#</a> 9.Go 中的 AtomicXXX 原子操作类 (类似于 Java 中的 AtocmicInteger 之类的)</h3>
<p>Go 中的 atomic 包里面的功能和 Java 中的 Atomic 一样，原子操作类，原理也是 cas, 甚至提供了 cas 的 api 函数，这里不做过多讲解，</p>
<p>简单举一个代码示例，因为方法太多，详细的请参考 api 文档中的 atomic 包：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//简单举例</span></span><br><span class="line">   <span class="keyword">var</span> num <span class="type">int64</span> = <span class="number">20</span></span><br><span class="line">   atomic.AddInt64(&amp;num,<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10go中的waitgroup类似于java中的countdownlatch"><a class="markdownIt-Anchor" href="#10go中的waitgroup类似于java中的countdownlatch">#</a> 10.Go 中的 WaitGroup (类似于 Java 中的 CountDownLatch)</h3>
<p>现在让我们看一个需求，比如我们开启三个并发任务，然后三个并发任务执行处理完毕后我们才让主线程继续往下面走。</p>
<p>这时候肯定不能用睡眠了，因为不知道睡眠多长时间。</p>
<p>这是 Go 中的 sync 包提供了一个 WaitGroup 的工具，他基本上和 Java 中的 CountDownLatch 的功能一致。</p>
<p>接下来让我们看代码示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;sync&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取类似于CountDownLatch的对象</span></span><br><span class="line"><span class="keyword">var</span> wait sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//设置计数器任务为3，当3个任务全部done后，wait.Wait()才会松开阻塞</span></span><br><span class="line">   wait.Add(<span class="number">3</span>)</span><br><span class="line">   <span class="keyword">go</span> myFun1()</span><br><span class="line">   <span class="keyword">go</span> myFun2()</span><br><span class="line">   <span class="keyword">go</span> myFun3()</span><br><span class="line">   <span class="comment">//阻塞</span></span><br><span class="line">   wait.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span>  <span class="title">myFun1</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//计数器减1</span></span><br><span class="line">   <span class="keyword">defer</span> wait.Done()</span><br><span class="line">   <span class="comment">//睡眠五秒</span></span><br><span class="line">   time.Sleep(time.Second*<span class="number">5</span>)</span><br><span class="line">   fmt.Println(<span class="string">&quot;fun1执行完毕&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFun2</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//计数器减1</span></span><br><span class="line">   <span class="keyword">defer</span> wait.Done()</span><br><span class="line">   <span class="comment">//睡眠五秒</span></span><br><span class="line">   time.Sleep(time.Second*<span class="number">5</span>)</span><br><span class="line">   fmt.Println(<span class="string">&quot;fun2执行完毕&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFun3</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//计数器减1</span></span><br><span class="line">   <span class="keyword">defer</span> wait.Done()</span><br><span class="line">   <span class="comment">//睡眠五秒</span></span><br><span class="line">   time.Sleep(time.Second*<span class="number">5</span>)</span><br><span class="line">   fmt.Println(<span class="string">&quot;fun3执行完毕&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">码如下：</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`go</span></span><br><span class="line"><span class="string">package main</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">import (</span></span><br><span class="line"><span class="string">   &quot;fmt&quot;</span></span><br><span class="line"><span class="string">   &quot;sync&quot;</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//全局变量</span></span><br><span class="line"><span class="string">var num int</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">var wait sync.WaitGroup</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">var lock sync.Mutex</span></span><br><span class="line"><span class="string">func main() &#123;</span></span><br><span class="line"><span class="string">   wait.Add(5)</span></span><br><span class="line"><span class="string">   go myAdd()</span></span><br><span class="line"><span class="string">   go myAdd()</span></span><br><span class="line"><span class="string">   go myAdd()</span></span><br><span class="line"><span class="string">   go myAdd()</span></span><br><span class="line"><span class="string">   go myAdd()</span></span><br><span class="line"><span class="string">   wait.Wait()</span></span><br><span class="line"><span class="string">   //预期值等于5万，可是因为线程不安全错误，小于5万</span></span><br><span class="line"><span class="string">   fmt.Printf(&quot;num = %d\n&quot;,num)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">func  myAdd() &#123;</span></span><br><span class="line"><span class="string">   defer wait.Done()</span></span><br><span class="line"><span class="string">   for i:=0 ;i&lt;10000;i++ &#123;</span></span><br><span class="line"><span class="string">      lock.Lock()</span></span><br><span class="line"><span class="string">      num+=1</span></span><br><span class="line"><span class="string">      lock.Unlock()</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="7go中的读写锁类似于java中的reentrantreadwritelock-2"><a class="markdownIt-Anchor" href="#7go中的读写锁类似于java中的reentrantreadwritelock-2">#</a> 7.Go 中的读写锁 (类似于 Java 中的 ReentrantReadWriteLock)</h3>
<p>读写锁用于读多写少的情况，多个线程并发读不上锁，写的时候才上锁互斥</p>
<p>读写锁示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;sync&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//金额</span></span><br><span class="line"><span class="keyword">var</span> moneyA  = <span class="number">1000</span></span><br><span class="line"><span class="comment">//读写锁</span></span><br><span class="line"><span class="keyword">var</span> rwLock sync.RWMutex;</span><br><span class="line"><span class="keyword">var</span> wait sync.WaitGroup</span><br><span class="line"><span class="comment">//添加金额</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subtractMoney</span><span class="params">(subMoney <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   rwLock.Lock()</span><br><span class="line">   time.Sleep(<span class="number">3</span>*time.Second)</span><br><span class="line">   moneyA-=subMoney</span><br><span class="line">   rwLock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询金额</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMoney</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   rwLock.RLock()</span><br><span class="line">   result := moneyA</span><br><span class="line">   rwLock.RUnlock()</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   wait.Add(<span class="number">2</span>)</span><br><span class="line">   <span class="comment">//添加查询金额</span></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">defer</span> wait.Done()</span><br><span class="line">      <span class="keyword">if</span>(getMoney()&gt;<span class="number">200</span>) &#123;</span><br><span class="line">         subtractMoney(<span class="number">200</span>)</span><br><span class="line">         fmt.Printf(<span class="string">&quot;200元扣款成功，剩下：%d元\n&quot;</span>,getMoney())</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">         fmt.Println(<span class="string">&quot;余额不足，无法扣款&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="comment">//添加查询金额</span></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">defer</span> wait.Done()</span><br><span class="line">      <span class="keyword">if</span>(getMoney()&gt;<span class="number">900</span>) &#123;</span><br><span class="line">         subtractMoney(<span class="number">900</span>)</span><br><span class="line">         fmt.Printf(<span class="string">&quot;900元扣款成功，剩下：%d元\n&quot;</span>,getMoney())</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">         fmt.Println(<span class="string">&quot;余额不足，无法扣款&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">   wait.Wait()</span><br><span class="line">   fmt.Println(getMoney())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8go中的并发安全map类似于currenthashmap-2"><a class="markdownIt-Anchor" href="#8go中的并发安全map类似于currenthashmap-2">#</a> 8.Go 中的并发安全 Map (类似于 CurrentHashMap)</h3>
<p>Go 中自己通过 make 创建的 map 不是线程安全的，具体体现在多线程添加值和修改值下会报如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error : concurrent map writes</span><br></pre></td></tr></table></figure>
<p>这个错类似于 java 中多线程读写线程不安全的容器时报的错。</p>
<p>Go 为了解决这个问题，专门给我们提供了一个并发安全的 map，这个并发安全的 map 不用通过 make 创建，拿来即可用，并且他提供了一些不同于普通 map 的操作方法。</p>
<p>参考如下代码示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个sync包下的线程安全map对象</span></span><br><span class="line"><span class="keyword">var</span> myConcurrentMap = sync.Map&#123;&#125;</span><br><span class="line"><span class="comment">//遍历数据用的</span></span><br><span class="line"><span class="keyword">var</span> myRangeMap = sync.Map&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//存储数据</span></span><br><span class="line">   myConcurrentMap.Store(<span class="number">1</span>,<span class="string">&quot;li_ming&quot;</span>)</span><br><span class="line">   <span class="comment">//取出数据</span></span><br><span class="line">   name,ok := myConcurrentMap.Load(<span class="number">1</span>)</span><br><span class="line">   <span class="keyword">if</span>(!ok) &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;不存在&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//打印值  li_ming</span></span><br><span class="line">   fmt.Println(name)</span><br><span class="line">   <span class="comment">//该key有值,则ok为true,返回它原来存在的值，不做任何操作；该key无值，则执行添加操作，ok为false,返回新添加的值</span></span><br><span class="line">   name2, ok2 := myConcurrentMap.LoadOrStore(<span class="number">1</span>,<span class="string">&quot;xiao_hong&quot;</span>)</span><br><span class="line">   <span class="comment">//因为key=1存在，所以打印是   li_ming true</span></span><br><span class="line">   fmt.Println(name2,ok2)</span><br><span class="line">   name3, ok3 := myConcurrentMap.LoadOrStore(<span class="number">2</span>,<span class="string">&quot;xiao_hong&quot;</span>)</span><br><span class="line">   <span class="comment">//因为key=2不存在，所以打印是   xiao_hong false</span></span><br><span class="line">   fmt.Println(name3,ok3)</span><br><span class="line">   <span class="comment">//标记删除值</span></span><br><span class="line">   myConcurrentMap.Delete(<span class="number">1</span>)</span><br><span class="line">   <span class="comment">//取出数据</span></span><br><span class="line">   <span class="comment">//name4,ok4 := myConcurrentMap.Load(1)</span></span><br><span class="line">   <span class="comment">//if(!ok4) &#123;</span></span><br><span class="line">   <span class="comment">// fmt.Println(&quot;name4=不存在&quot;)</span></span><br><span class="line">   <span class="comment">// return</span></span><br><span class="line">   <span class="comment">//&#125;</span></span><br><span class="line">   <span class="comment">//fmt.Println(name4)</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//遍历数据</span></span><br><span class="line">   rangeFunc()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rangeFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">   myRangeMap.Store(<span class="number">1</span>,<span class="string">&quot;xiao_ming&quot;</span>)</span><br><span class="line">   myRangeMap.Store(<span class="number">2</span>,<span class="string">&quot;xiao_li&quot;</span>)</span><br><span class="line">   myRangeMap.Store(<span class="number">3</span>,<span class="string">&quot;xiao_ke&quot;</span>)</span><br><span class="line">   myRangeMap.Store(<span class="number">4</span>,<span class="string">&quot;xiao_lei&quot;</span>)</span><br><span class="line"></span><br><span class="line">   myRangeMap.Range(<span class="function"><span class="keyword">func</span><span class="params">(k, v <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;data_key_value = :&quot;</span>,k,v)</span><br><span class="line">      <span class="comment">//return true代表继续遍历下一个，return false代表结束遍历操作</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9go中的atomicxxx原子操作类类似于java中的atocmicinteger之类的-2"><a class="markdownIt-Anchor" href="#9go中的atomicxxx原子操作类类似于java中的atocmicinteger之类的-2">#</a> 9.Go 中的 AtomicXXX 原子操作类 (类似于 Java 中的 AtocmicInteger 之类的)</h3>
<p>Go 中的 atomic 包里面的功能和 Java 中的 Atomic 一样，原子操作类，原理也是 cas, 甚至提供了 cas 的 api 函数，这里不做过多讲解，</p>
<p>简单举一个代码示例，因为方法太多，详细的请参考 api 文档中的 atomic 包：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//简单举例</span></span><br><span class="line">   <span class="keyword">var</span> num <span class="type">int64</span> = <span class="number">20</span></span><br><span class="line">   atomic.AddInt64(&amp;num,<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10go中的waitgroup类似于java中的countdownlatch-2"><a class="markdownIt-Anchor" href="#10go中的waitgroup类似于java中的countdownlatch-2">#</a> 10.Go 中的 WaitGroup (类似于 Java 中的 CountDownLatch)</h3>
<p>现在让我们看一个需求，比如我们开启三个并发任务，然后三个并发任务执行处理完毕后我们才让主线程继续往下面走。</p>
<p>这时候肯定不能用睡眠了，因为不知道睡眠多长时间。</p>
<p>这是 Go 中的 sync 包提供了一个 WaitGroup 的工具，他基本上和 Java 中的 CountDownLatch 的功能一致。</p>
<p>接下来让我们看代码示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;sync&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取类似于CountDownLatch的对象</span></span><br><span class="line"><span class="keyword">var</span> wait sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//设置计数器任务为3，当3个任务全部done后，wait.Wait()才会松开阻塞</span></span><br><span class="line">   wait.Add(<span class="number">3</span>)</span><br><span class="line">   <span class="keyword">go</span> myFun1()</span><br><span class="line">   <span class="keyword">go</span> myFun2()</span><br><span class="line">   <span class="keyword">go</span> myFun3()</span><br><span class="line">   <span class="comment">//阻塞</span></span><br><span class="line">   wait.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span>  <span class="title">myFun1</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//计数器减1</span></span><br><span class="line">   <span class="keyword">defer</span> wait.Done()</span><br><span class="line">   <span class="comment">//睡眠五秒</span></span><br><span class="line">   time.Sleep(time.Second*<span class="number">5</span>)</span><br><span class="line">   fmt.Println(<span class="string">&quot;fun1执行完毕&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFun2</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//计数器减1</span></span><br><span class="line">   <span class="keyword">defer</span> wait.Done()</span><br><span class="line">   <span class="comment">//睡眠五秒</span></span><br><span class="line">   time.Sleep(time.Second*<span class="number">5</span>)</span><br><span class="line">   fmt.Println(<span class="string">&quot;fun2执行完毕&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFun3</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//计数器减1</span></span><br><span class="line">   <span class="keyword">defer</span> wait.Done()</span><br><span class="line">   <span class="comment">//睡眠五秒</span></span><br><span class="line">   time.Sleep(time.Second*<span class="number">5</span>)</span><br><span class="line">   fmt.Println(<span class="string">&quot;fun3执行完毕&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关于我"><a class="markdownIt-Anchor" href="#关于我">#</a> 关于我</h2>
<p>Brath 是一个热爱技术的 Java 程序猿，公众号「InterviewCoder」定期分享有趣有料的精品原创文章！</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png" alt="InterviewCoder"></p>
<p>非常感谢各位人才能看到这里，原创不易，文章如果有帮助可以关注、点赞、分享或评论，这都是对我的莫大支持！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-04-20T06:02:20.191Z" title="2023-4-20 14:02:20">2023-04-20</time>发表</span><span class="level-item"><time dateTime="2023-04-20T06:01:26.646Z" title="2023-4-20 14:01:26">2023-04-20</time>更新</span><span class="level-item">2 小时读完 (大约14373个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/04/20/%E3%80%90Go%E3%80%91Go%E8%AF%AD%E8%A8%80%E8%B6%85%E5%85%A8%E8%AF%A6%E8%A7%A3(%E5%85%A5%E9%97%A8%E7%BA%A7)/">Go语言超全详解（入门级）</a></p><div class="content"><p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png" alt="InterviewCoder"></p>
<h1 id="go语言超全详解入门级"><a class="markdownIt-Anchor" href="#go语言超全详解入门级">#</a> Go 语言超全详解（入门级）</h1>
<h3 id="文章目录"><a class="markdownIt-Anchor" href="#文章目录">#</a> 文章目录</h3>
<ul>
<li><a href="#1_Go_6">1. Go 语言的出现</a></li>
<li><a href="#2_gohello_world_12">2. go 版本的 hello world</a></li>
<li><a href="#3__36">3. 数据类型</a></li>
<li>
<ul>
<li><a href="#30__48">3.0 定义变量</a></li>
<li>
<ul>
<li><a href="#301__61">3.0.1 如果变量没有初始化</a></li>
<li><a href="#302__70">3.0.2 如果变量没有指定类型</a></li>
<li><a href="#303___82">3.0.3 := 符号</a></li>
<li><a href="#304__94">3.0.4 多变量声明</a></li>
<li><a href="#305__121">3.0.5 匿名变量</a></li>
<li><a href="#306__141">3.0.6 变量作用域</a></li>
</ul>
</li>
<li><a href="#31__150">3.1 基本类型</a></li>
<li><a href="#32__164">3.2 指针</a></li>
<li>
<ul>
<li><a href="#321__169">3.2.1 指针声明和初始化</a></li>
<li><a href="#322__188">3.2.2 空指针</a></li>
</ul>
</li>
<li><a href="#33__193">3.3 数组</a></li>
<li>
<ul>
<li><a href="#331__196">3.3.1 声明数组</a></li>
<li><a href="#332__208">3.3.2 初始化数组</a></li>
<li><a href="#333_go_219">3.3.3 go 中的数组名意义</a></li>
<li><a href="#334__225">3.3.4 数组指针</a></li>
</ul>
</li>
<li><a href="#34__243">3.4 结构体</a></li>
<li>
<ul>
<li><a href="#341__246">3.4.1 声明结构体</a></li>
<li><a href="#342__265">3.4.2 访问结构体成员</a></li>
<li><a href="#343__285">3.4.3 结构体指针</a></li>
</ul>
</li>
<li><a href="#35__297">3.5 字符串</a></li>
<li>
<ul>
<li><a href="#351__301">3.5.1 字符串定义和初始化</a></li>
<li><a href="#352_UTF8_317">3.5.2 字符串 UTF8 编码</a></li>
<li><a href="#353__343">3.5.3 字符串的强制类型转换</a></li>
</ul>
</li>
<li><a href="#36_slice_354">3.6 slice</a></li>
<li>
<ul>
<li><a href="#361_slice_359">3.6.1 slice 定义</a></li>
<li><a href="#362__381">3.6.2 添加元素</a></li>
<li><a href="#363__428">3.6.3 删除元素</a></li>
</ul>
</li>
<li><a href="#37__491">3.7 函数</a></li>
<li>
<ul>
<li><a href="#371__493">3.7.1 函数分类</a></li>
<li><a href="#372__521">3.7.2 函数声明和定义</a></li>
<li><a href="#373__538">3.7.3 函数传参</a></li>
<li><a href="#374__559">3.7.4 函数返回值</a></li>
<li><a href="#375__610">3.7.5 递归调用</a></li>
</ul>
</li>
<li><a href="#38__628">3.8 方法</a></li>
<li><a href="#39__673">3.9 接口</a></li>
<li>
<ul>
<li><a href="#391__674">3.9.1 什么是接口</a></li>
<li><a href="#392__684">3.9.2 结构体类型</a></li>
<li><a href="#393__738">3.9.3 具体类型向接口类型赋值</a></li>
<li><a href="#394__749">3.9.4 获取接口类型数据的具体类型信息</a></li>
</ul>
</li>
<li><a href="#310_channel_754">3.10 channel</a></li>
<li>
<ul>
<li><a href="#3101__755">3.10.1 相关结构体定义</a></li>
<li><a href="#3102_channel_794">3.10.2 阻塞式读写 channel 操作</a></li>
<li><a href="#3103_channel_826">3.10.3 非阻塞式读写 channel 操作</a></li>
</ul>
</li>
<li><a href="#311_map_855">3.11 map</a></li>
<li>
<ul>
<li><a href="#3111__944">3.11.1 插入数据</a></li>
<li><a href="#3112__957">3.11.2 删除数据</a></li>
<li><a href="#3113__966">3.11.3 查找数据</a></li>
<li><a href="#3114__980">3.11.4 扩容</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4__1012">4. 常用语句及关键字</a></li>
<li>
<ul>
<li><a href="#41__1014">4.1 条件语句</a></li>
<li><a href="#42__1078">4.2 循环语句</a></li>
<li>
<ul>
<li><a href="#421__1079">4.2.1 循环处理语句</a></li>
<li><a href="#421__1095">4.2.1 循环控制语句</a></li>
</ul>
</li>
<li><a href="#43__1200">4.3 关键字</a></li>
</ul>
</li>
</ul>
<hr>
<h1 id="1-go语言的出现"><a class="markdownIt-Anchor" href="#1-go语言的出现">#</a> 1. Go 语言的出现</h1>
<p>在具体学习 go 语言的基础语法之前，我们来了解一下 go 语言出现的时机及其特点。</p>
<p>Go 语言最初由 Google 公司的 Robert Griesemer、Ken Thompson 和 Rob Pike 三个大牛于 2007 年开始设计发明，他们最终的目标是设计一种<strong>适应网络和多核时代的 C 语言</strong>。所以 Go 语言很多时候被描述为 “类 C 语言”，或者是 “21 世纪的 C 语言”，当然从各种角度看，Go 语言确实是从 C 语言继承了相似的表达式语法、控制流结构、基础数据类型、调用参数传值、指针等诸多编程思想。但是 Go 语言更是对 C 语言最彻底的一次扬弃，它舍弃了 C 语言中灵活但是危险的指针运算，还重新设计了 C 语言中部分不太合理运算符的优先级，并在很多细微的地方都做了必要的打磨和改变。</p>
<h1 id="2-go版本的hello-world"><a class="markdownIt-Anchor" href="#2-go版本的hello-world">#</a> 2. go 版本的 hello world</h1>
<p>在这一部分我们只是使用 “hello world” 的程序来向大家介绍一下 go 语言的所编写的程序的基本组成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import <span class="string">&quot;fmt&quot;</span></span><br><span class="line">func <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 终端输出hello world</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<p>和 C 语言相似，go 语言的基本组成有：</p>
<ul>
<li>包声明，编写源文件时，必须在非注释的第一行指明这个文件属于哪个包，如 <code>package main</code> 。</li>
<li>引入包，其实就是告诉 Go 编译器这个程序需要使用的包，如 <code>import &quot;fmt&quot;</code>  其实就是引入了 fmt 包。</li>
<li>函数，和 c 语言相同，即是一个可以实现某一个功能的函数体，每一个可执行程序中必须拥有一个 main 函数。</li>
<li>变量，Go 语言变量名由字母、数字、下划线组成，其中首个字符不能为数字。</li>
<li>语句 / 表达式，在 Go 程序中，一行代表一个语句结束。每个语句不需要像 C 家族中的其它语言一样以分号；结尾，因为这些工作都将由 Go 编译器自动完成。</li>
<li>注释，和 c 语言中的注释方式相同，可以在任何地方使用以 // 开头的单行注释。以 /* 开头，并以 */ 结尾来进行多行注释，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。</li>
</ul>
<blockquote>
<p>需要注意的是：<strong>标识符</strong>是用来命名变量、类型等程序实体。一个标识符实际上就是一个或是多个字母和数字、下划线_组成的序列，但是第一个字符必须是字母或下划线而不能是数字。</p>
<ol>
<li>当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；</li>
<li>标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected）。</li>
</ol>
</blockquote>
<h1 id="3-数据类型"><a class="markdownIt-Anchor" href="#3-数据类型">#</a> 3. 数据类型</h1>
<p>在 Go 编程语言中，数据类型用于声明函数和变量。</p>
<p>数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。具体分类如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>详解</th>
</tr>
</thead>
<tbody>
<tr>
<td>布尔型</td>
<td>布尔型的值只可以是常量 true 或者 false。</td>
</tr>
<tr>
<td>数字类型</td>
<td>整型 int 和浮点型 float。Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。</td>
</tr>
<tr>
<td>字符串类型</td>
<td>字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。</td>
</tr>
<tr>
<td>派生类型</td>
<td>(a) 指针类型（Pointer）(b) 数组类型 © 结构化类型 (struct)(d) Channel 类型 (e) 函数类型 (f) 切片类型 (g) 接口类型（interface）(h) Map 类型</td>
</tr>
</tbody>
</table>
<h2 id="30-定义变量"><a class="markdownIt-Anchor" href="#30-定义变量">#</a> 3.0 定义变量</h2>
<p>声明变量的一般形式是使用 var 关键字，具体格式为： <code>var identifier typename</code> 。如下的代码中我们定义了一个类型为 int 的变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="type">int</span> = <span class="number">27</span></span><br><span class="line">	fmt.Println(a);</span><br><span class="line">&#125; </span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<h3 id="301-如果变量没有初始化"><a class="markdownIt-Anchor" href="#301-如果变量没有初始化">#</a> 3.0.1 如果变量没有初始化</h3>
<p>在 go 语言中定义了一个变量，指定变量类型，如果没有初始化，则变量默认为零值。<strong>零值就是变量没有做初始化时系统默认设置的值</strong>。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>零值</th>
</tr>
</thead>
<tbody>
<tr>
<td>数值类型</td>
<td>0</td>
</tr>
<tr>
<td>布尔类型</td>
<td>false</td>
</tr>
<tr>
<td>字符串</td>
<td>“”（空字符串）</td>
</tr>
</tbody>
</table>
<h3 id="302-如果变量没有指定类型"><a class="markdownIt-Anchor" href="#302-如果变量没有指定类型">#</a> 3.0.2 如果变量没有指定类型</h3>
<p>在 go 语言中如果没有指定变量类型，可以通过变量的初始值来判断变量类型。如下代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> d = <span class="literal">true</span></span><br><span class="line">    fmt.Println(d)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<h3 id="303-符号"><a class="markdownIt-Anchor" href="#303-符号">#</a> 3.0.3 := 符号</h3>
<p>当我们定义一个变量后又使用该符号初始化变量，就会产生编译错误，因为该符号其实是一个声明语句。</p>
<p>使用格式： <code>typename := value</code></p>
<p>也就是说 <code>intVal := 1</code>  相等于：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intVal <span class="type">int</span> </span><br><span class="line">intVal =<span class="number">1</span> </span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>
<h3 id="304-多变量声明"><a class="markdownIt-Anchor" href="#304-多变量声明">#</a> 3.0.4 多变量声明</h3>
<p>可以同时声明多个类型相同的变量（非全局变量），如下图所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x, y <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> c, d <span class="type">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">g, h := <span class="number">123</span>, <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<p>关于全局变量的声明如下：<br>
 <code>var ( vname1 v_type1 vname2 v_type2 )</code> <br>
 具体举例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ( </span><br><span class="line">    a <span class="type">int</span></span><br><span class="line">    b <span class="type">bool</span></span><br><span class="line">)</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<h3 id="305-匿名变量"><a class="markdownIt-Anchor" href="#305-匿名变量">#</a> 3.0.5 匿名变量</h3>
<p>匿名变量的特点是一个下画线 <code>_</code> ，这本身就是一个特殊的标识符，被称为空白标识符。它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值<strong>不能在后续的代码中使用</strong>，也不可以使用这个标识符作为变量对其它变量进行赋值或运算。</p>
<p>使用匿名变量时，只需要在<strong>变量声明的地方</strong>使用下画线替换即可。</p>
<p>示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">GetData</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>, <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a, _ := GetData()</span><br><span class="line">        _, b := GetData()</span><br><span class="line">        fmt.Println(a, b)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是匿名变量不占用内存空间，不会分配内存。匿名变量与匿名变量之间也不会因为多次声明而无法使用。</p>
<h3 id="306-变量作用域"><a class="markdownIt-Anchor" href="#306-变量作用域">#</a> 3.0.6 变量作用域</h3>
<p>作用域指的是已声明的标识符所表示的常量、类型、函数或者包在源代码中的作用范围，在此我们主要看一下 go 中变量的作用域，根据变量定义位置的不同，可以分为一下三个类型：</p>
<ol>
<li>函数内定义的变量为<strong>局部变量</strong>，这种局部变量的作用域只在函数体内，函数的参数和返回值变量都属于局部变量。这种变量在存在于函数被调用时，销毁于函数调用结束后。</li>
<li>函数外定义的变量为<strong>全局变量</strong>，全局变量只需要在一个源文件中定义，就可以在所有源文件中使用，甚至可以使用 import 引入外部包来使用。全局变量声明必须<strong>以 var 关键字开头</strong>，如果想要在<strong>外部包中使用</strong>全局变量的<strong>首字母必须大写</strong>。</li>
<li>函数定义中的变量成为<strong>形式参数</strong>，定义函数时函数名后面括号中的变量叫做形式参数（简称形参）。形式参数只在函数调用时才会生效，函数调用结束后就会被销毁，在函数未被调用时，函数的形参并不占用实际的存储单元，也没有实际值。<strong>形式参数会作为函数的局部变量来使用</strong>。</li>
</ol>
<h2 id="31-基本类型"><a class="markdownIt-Anchor" href="#31-基本类型">#</a> 3.1 基本类型</h2>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>uint8 / uint16 / uint32 / uint64</td>
<td>无符号 8 / 16 / 32 / 64 位整型</td>
</tr>
<tr>
<td>int8 / int16 / int32 / int64</td>
<td>有符号 8 / 16 / 32 / 64 位整型</td>
</tr>
<tr>
<td>float32 / float64</td>
<td>IEEE-754 32 / 64 位浮点型数</td>
</tr>
<tr>
<td>complex64 / complex128</td>
<td>32 / 64 位实数和虚数</td>
</tr>
<tr>
<td>byte</td>
<td>类似 uint8</td>
</tr>
<tr>
<td>rune</td>
<td>类似 int32</td>
</tr>
<tr>
<td>uintptr</td>
<td>无符号整型，用于存放一个指针</td>
</tr>
</tbody>
</table>
<p>以上就是 go 语言基本的数据类型，有了数据类型，我们就可以使用这些类型来定义变量，Go 语言变量名由字母、数字、下划线组成，其中首个字符不能为数字。</p>
<h2 id="32-指针"><a class="markdownIt-Anchor" href="#32-指针">#</a> 3.2 指针</h2>
<p>与 C 相同，Go 语言让程序员决定何时使用指针。变量其实是一种使用方便的占位符，用于引用计算机内存地址。Go 语言中的的取地址符是 <code>&amp;</code> ，放到一个变量前使用就会返回相应变量的内存地址。</p>
<p>指针变量其实就是用于存放某一个对象的内存地址。</p>
<h3 id="321-指针声明和初始化"><a class="markdownIt-Anchor" href="#321-指针声明和初始化">#</a> 3.2.1 指针声明和初始化</h3>
<p>和基础类型数据相同，在使用指针变量之前我们首先需要申明指针，声明格式如下： <code>var var_name *var-type</code> ，其中的 var-type 为指针类型，var_name 为指针变量名，* 号用于指定变量是作为一个指针。</p>
<p>代码举例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ip *<span class="type">int</span>        <span class="comment">/* 指向整型*/</span></span><br><span class="line"><span class="keyword">var</span> fp *<span class="type">float32</span>    <span class="comment">/* 指向浮点型 */</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>指针的初始化就是取出相对应的变量地址对指针进行赋值，具体如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">var</span> a <span class="type">int</span>= <span class="number">20</span>   <span class="comment">/* 声明实际变量 */</span></span><br><span class="line">   <span class="keyword">var</span> ip *<span class="type">int</span>        <span class="comment">/* 声明指针变量 */</span></span><br><span class="line"></span><br><span class="line">   ip = &amp;a  <span class="comment">/* 指针变量的存储地址 */</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<h3 id="322-空指针"><a class="markdownIt-Anchor" href="#322-空指针">#</a> 3.2.2 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%A9%BA%E6%8C%87%E9%92%88&amp;spm=1001.2101.3001.7020">空指针</a></h3>
<p>当一个指针被定义后<strong>没有分配到任何变量</strong>时，它的值为 <strong>nil</strong>，也称为空指针。它概念上和其它语言的 null、NULL 一样，都指代零值或空值。</p>
<h2 id="33-数组"><a class="markdownIt-Anchor" href="#33-数组">#</a> 3.3 数组</h2>
<p>和 c 语言相同，Go 语言也提供了数组类型的数据结构，数组是具有<strong>相同唯一类型</strong>的一组已编号且<strong>长度固定</strong>的数据项序列，这种类型可以是任意的原始类型例如整型、字符串或者自定义类型。</p>
<h3 id="331-声明数组"><a class="markdownIt-Anchor" href="#331-声明数组">#</a> 3.3.1 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%A3%B0%E6%98%8E%E6%95%B0%E7%BB%84&amp;spm=1001.2101.3001.7020">声明数组</a></h3>
<p>Go 语言数组声明需要指定元素类型及元素个数，语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var variable_name [SIZE] variable_type</span><br></pre></td></tr></table></figure>
<p>以上就可以定一个一维数组，我们举例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> balance [<span class="number">10</span>] <span class="type">float32</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="332-初始化数组"><a class="markdownIt-Anchor" href="#332-初始化数组">#</a> 3.3.2 初始化数组</h3>
<p>数组的初始化方式有不止一种方式，我们列举如下：</p>
<ol>
<li>直接进行初始化： <code>var balance = [5]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;</code></li>
<li>通过字面量在声明数组的同时快速初始化数组： <code>balance := [5]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;</code></li>
<li>数组长度不确定，编译器通过元素个数自行推断数组长度，在 [ ] 中填入 <code>...</code> ，举例如下： <code>var balance = [...]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;</code>  和 <code>balance := [...]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;</code></li>
<li>数组长度确定，指定下标进行部分初始化： <code>balanced := [5]float32(1:2.0, 3:7.0)</code></li>
</ol>
<blockquote>
<p>注意：</p>
<ul>
<li>初始化数组中 {} 中的元素个数不能大于 [] 中的数字。<br>
如果忽略 [] 中的数字不设置数组大小，Go 语言会根据元素的个数来设置数组的大小。</li>
</ul>
</blockquote>
<h3 id="333-go中的数组名意义"><a class="markdownIt-Anchor" href="#333-go中的数组名意义">#</a> 3.3.3 go 中的数组名意义</h3>
<p>在 c 语言中我们知道数组名在本质上是数组中第一个元素的地址，而在 go 语言中，数组名仅仅表示整个数组，是一个完整的值，一个数组变量即是表示整个数组。</p>
<p>所以在 go 中一个数组变量被赋值或者被传递的时候实际上就会复制整个数组。如果数组比较大的话，这种复制往往会占有很大的开销。所以为了避免这种开销，往往需要传递一个指向数组的指针，这个数组指针并不是数组。关于数组指针具体在指针的部分深入的了解。</p>
<h3 id="334-数组指针"><a class="markdownIt-Anchor" href="#334-数组指针">#</a> 3.3.4 数组指针</h3>
<p>通过数组和指针的知识我们就可以定义一个数组指针，代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// a 是一个数组</span></span><br><span class="line"><span class="keyword">var</span> b = &amp;a                <span class="comment">// b 是指向数组的指针</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>数组指针除了可以防止数组作为参数传递的时候浪费空间，还可以利用其和 <code>for range</code>  来遍历数组，具体代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> b &#123;     <span class="comment">// 通过数组指针迭代数组的元素</span></span><br><span class="line">    fmt.Println(i, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<p>具体关于 go 语言的循环语句我们在后文中再进行详细介绍。</p>
<h2 id="34-结构体"><a class="markdownIt-Anchor" href="#34-结构体">#</a> 3.4 结构体</h2>
<p>通过上述数组的学习，我们就可以直接定义多个同类型的变量，但这往往也是一种限制，只能存储同一种类型的数据，而我们在结构体中就可以定义多个不同的数据类型。</p>
<h3 id="341-声明结构体"><a class="markdownIt-Anchor" href="#341-声明结构体">#</a> 3.4.1 声明结构体</h3>
<p>在声明结构体之前我们首先需要定义一个结构体类型，这需要使用 type 和 struct，type 用于设定结构体的名称，struct 用于定义一个新的数据类型。具体结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> struct_variable_type <span class="keyword">struct</span> &#123;</span><br><span class="line">   member definition</span><br><span class="line">   member definition</span><br><span class="line">   ...</span><br><span class="line">   member definition</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<p>定义好了结构体类型，我们就可以使用该结构体声明这样一个结构体变量，语法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">variable_name := structure_variable_type &#123;value1, value2...valuen&#125;</span><br><span class="line"></span><br><span class="line">variable_name := structure_variable_type &#123; key1: value1, key2: value2..., keyn: valuen&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<h3 id="342-访问结构体成员"><a class="markdownIt-Anchor" href="#342-访问结构体成员">#</a> 3.4.2 访问结构体成员</h3>
<p>如果要访问结构体成员，需要使用点号  <code>.</code>  操作符，格式为： <code>结构体变量名.成员名</code> 。举例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Books <span class="keyword">struct</span> &#123;</span><br><span class="line">   title <span class="type">string</span></span><br><span class="line">   author <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> book1 Books</span><br><span class="line">	Book1.title = <span class="string">&quot;Go 语言入门&quot;</span></span><br><span class="line">	Book1.author = <span class="string">&quot;mars.hao&quot;</span>	</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>
<h3 id="343-结构体指针"><a class="markdownIt-Anchor" href="#343-结构体指针">#</a> 3.4.3 结构体指针</h3>
<p>关于结构体指针的定义和申明同样可以套用前文中讲到的指针的相关定义，从而使用一个指针变量存放一个结构体变量的地址。</p>
<p>定义一个结构体变量的语法： <code>var struct_pointer *Books</code> 。</p>
<p>这种指针变量的初始化和上文指针部分的初始化方式相同 <code>struct_pointer = &amp;Book1</code> ，但是和 c 语言中有所不同，使用结构体指针访问结构体成员仍然使用 <code>.</code>  操作符。格式如下： <code>struct_pointer.title</code></p>
<h2 id="35-字符串"><a class="markdownIt-Anchor" href="#35-字符串">#</a> 3.5 字符串</h2>
<p>一个字符串是一个<strong>不可改变</strong>的字节序列，字符串通常是用来包含人类可读的文本数据。和数组不同的是，字符串的元素不可修改，是一个只读的<strong>字节数组</strong>。每个字符串的长度虽然也是固定的，但是字符串的长度并不是字符串类型的一部分。</p>
<h3 id="351-字符串定义和初始化"><a class="markdownIt-Anchor" href="#351-字符串定义和初始化">#</a> 3.5.1 字符串定义和初始化</h3>
<p>Go 语言字符串的底层结构在 reflect.StringHeader 中定义，具体如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="type">uintptr</span></span><br><span class="line">    Len  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<p>也就是说字符串结构由两个信息组成：第一个是字符串指向的底层字节数组，第二个是字符串的字节的长度。</p>
<p>字符串其实是一个结构体，因此字符串的赋值操作也就是 reflect.StringHeader 结构体的复制过程，并不会涉及底层字节数组的复制，所以我们也可以将字符串数组看作一个结构体数组。</p>
<p>字符串和数组类似，内置的 len 函数返回字符串的长度。</p>
<h3 id="352-字符串utf8编码"><a class="markdownIt-Anchor" href="#352-字符串utf8编码">#</a> 3.5.2 字符串 UTF8 编码</h3>
<p>根据 Go 语言规范，Go 语言的源文件都是采用<strong> UTF8</strong> 编码。因此，Go 源文件中出现的字符串面值常量一般也是 UTF8 编码的（对于转义字符，则没有这个限制）。提到 Go 字符串时，我们一般都会假设字符串对应的是一个合法的 UTF8 编码的字符序列。</p>
<p>Go 语言的字符串中可以存放任意的二进制字节序列，而且即使是 UTF8 字符序列也可能会遇到坏的编码。如果遇到一个<strong>错误的 UTF8 编码输入</strong>，将生成一个<strong>特别的 Unicode 字符</strong>‘\uFFFD’，这个字符在不同的软件中的显示效果可能不太一样，在印刷中这个符号通常是一个黑色六角形或钻石形状，里面包含一个白色的问号‘ ’。</p>
<p>下面的字符串中，我们故意损坏了第一字符的第二和第三字节，因此第一字符将会打印为 “”，第二和第三字节则被忽略；后面的 “abc” 依然可以正常解码打印（<strong>错误编码不会向后扩散是 UTF8 编码的优秀特性之一</strong>）。代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;\xe4\x00\x00\xe7\x95\x8cabc&quot;</span>) <span class="comment">//  界abc</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>不过在 for range 迭代这个含有损坏的 UTF8 字符串时，第一字符的第二和第三字节依然会被单独迭代到，不过此时迭代的值是损坏后的 0：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0 65533  // \uFFFD, 对应  </span></span><br><span class="line"><span class="comment">// 1 0      // 空字符</span></span><br><span class="line"><span class="comment">// 2 0      // 空字符</span></span><br><span class="line"><span class="comment">// 3 30028  // 界</span></span><br><span class="line"><span class="comment">// 6 97     // a</span></span><br><span class="line"><span class="comment">// 7 98     // b</span></span><br><span class="line"><span class="comment">// 8 99     // c</span></span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>
<h3 id="353-字符串的强制类型转换"><a class="markdownIt-Anchor" href="#353-字符串的强制类型转换">#</a> 3.5.3 字符串的强制类型转换</h3>
<p>在上文中我们知道源代码往往会采用 UTF8 编码，如果不想解码 UTF8 字符串，想直接遍历原始的字节码：</p>
<ol>
<li>可以将字符串强制转为 [] byte 字节序列后再行遍历（这里的转换一般不会产生运行时开销）：</li>
<li>采用传统的下标方式遍历字符串的字节数组</li>
</ol>
<p>除此以外，字符串相关的强制类型转换主要<strong>涉及到 [] byte 和 [] rune 两种类型</strong>。每个转换都可能隐含<strong>重新分配内存</strong>的代价，最坏的情况下它们的运算时间复杂度都是 O (n)。</p>
<p>不过字符串和 [] rune 的转换要更为特殊一些，因为一般这种强制类型转换要求两个类型的底层内存结构要尽量一致，显然它们底层对应的 [] byte 和 [] int32 类型是完全不同的内部布局，因此这种转换可能隐含重新分配内存的操作。</p>
<h2 id="36-slice"><a class="markdownIt-Anchor" href="#36-slice">#</a> 3.6 slice</h2>
<p>简单地说，切片就是一种简化版的<strong>动态数组</strong>。因为动态数组的<strong>长度不固定</strong>，切片的长度自然也就不能是类型的组成部分了。数组虽然有适用它们的地方，但是数组的类型和操作都不够灵活，而切片则使用得相当广泛。</p>
<p>切片高效操作的要点是要降低内存分配的次数，尽量保证 append 操作（在后续的插入和删除操作中都涉及到这个函数）不会超出 cap 的容量，降低触发内存分配的次数和每次分配内存大小。</p>
<h3 id="361-slice定义"><a class="markdownIt-Anchor" href="#361-slice定义">#</a> 3.6.1 slice 定义</h3>
<p>我们先看看切片的结构定义，reflect.SliceHeader：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="type">uintptr</span>   <span class="comment">// 指向底层的的数组指针</span></span><br><span class="line">    Len  <span class="type">int</span>	   <span class="comment">// 切片长度</span></span><br><span class="line">    Cap  <span class="type">int</span>	   <span class="comment">// 切片最大长度</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>
<p>和数组一样，内置的 len 函数返回切片中有效元素的长度，内置的 cap 函数返回切片容量大小，容量必须大于或等于切片的长度。</p>
<p>切片可以和<strong> nil</strong> 进行比较，只有当切片<strong>底层数据指针为空时</strong>切片本身为 nil，这时候<strong>切片的长度和容量信息将是无效的</strong>。如果有切片的底层数据指针为空，但是长度和容量不为 0 的情况，那么说明切片本身已经被损坏了</p>
<p>只要是<strong>切片的底层</strong>数据指针、长度和容量<strong>没有发生变化</strong>的话，对切片的遍历、元素的读取和修改都和数组是一样的。在对切片本身赋值或参数传递时，和数组指针的操作方式类似，只是复制切片头信息（reflect.SliceHeader），并不会复制底层的数据。对于类型，和数组的最大不同是，切片的类型和长度信息无关，只要是相同类型元素构成的切片均对应相同的切片类型。</p>
<p>当我们想定义声明一个切片时可以如下：</p>
<p>在对切片本身赋值或参数传递时，和数组指针的操作方式类似，只是复制切片头信息・（reflect.SliceHeader），并不会复制底层的数据。对于类型，和数组的最大不同是，切片的类型和长度信息无关，<strong>只要是相同类型元素构成的切片均对应相同的切片类型</strong>。</p>
<h3 id="362-添加元素"><a class="markdownIt-Anchor" href="#362-添加元素">#</a> 3.6.2 添加元素</h3>
<p><code>append()</code>  ：内置的泛型函数，可以向切片中增加元素。</p>
<ol>
<li>在切片尾部追加 N 个元素</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="type">int</span></span><br><span class="line">a = <span class="built_in">append</span>(a, <span class="number">1</span>)               <span class="comment">// 追加1个元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)         <span class="comment">// 追加多个元素, 手写解包方式</span></span><br><span class="line">a = <span class="built_in">append</span>(a, []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;...) <span class="comment">// 追加一个切片, 切片需要解包</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：尾部添加在容量不足的条件下需要重新分配内存，可能导致巨大的内存分配和复制数据代价。即使容量足够，依然需要用 append 函数的返回值来更新切片本身，因为新切片的长度已经发生了变化。</p>
</blockquote>
<ol>
<li>在切片开头位置添加元素</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">a = <span class="built_in">append</span>([]<span class="type">int</span>&#123;<span class="number">0</span>&#125;, a...)        <span class="comment">// 在开头位置添加1个元素</span></span><br><span class="line">a = <span class="built_in">append</span>([]<span class="type">int</span>&#123;<span class="number">-3</span>,<span class="number">-2</span>,<span class="number">-1</span>&#125;, a...) <span class="comment">// 在开头添加1个切片</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：在开头一般都会导致内存的重新分配，而且会导致已有的元素全部复制 1 次。因此，从切片的开头添加元素的性能一般要比从尾部追加元素的性能差很多。</p>
</blockquote>
<ol>
<li>append 链式操作</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="type">int</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:i], <span class="built_in">append</span>([]<span class="type">int</span>&#123;x&#125;, a[i:]...)...)     <span class="comment">// 在第i个位置插入x</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:i], <span class="built_in">append</span>([]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, a[i:]...)...) <span class="comment">// 在第i个位置插入切片</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>每个添加操作中的第二个 append 调用都会创建一个<strong>临时切片</strong>，并将 a [i:] 的内容复制到新创建的切片中，然后将临时创建的切片再追加到 a [:i]。</p>
</blockquote>
<ol>
<li>append 和 copy 组合</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">append</span>(a, <span class="number">0</span>)     <span class="comment">// 切片扩展1个空间</span></span><br><span class="line"><span class="built_in">copy</span>(a[i+<span class="number">1</span>:], a[i:]) <span class="comment">// a[i:]向后移动1个位置</span></span><br><span class="line">a[i] = x             <span class="comment">// 设置新添加的元素</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>第三个操作中会创建一个临时对象，我们可以借用 copy 函数避免这个操作，这种方式操作语句虽然冗长了一点，但是相比前面的方法，可以减少中间创建的临时切片。</p>
</blockquote>
<h3 id="363-删除元素"><a class="markdownIt-Anchor" href="#363-删除元素">#</a> 3.6.3 删除元素</h3>
<p>根据要删除元素的位置有三种情况：</p>
<ol>
<li>从开头位置删除；</li>
</ol>
<ul>
<li>直接移动数据指针，代码如下：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ...&#125;</span><br><span class="line">a = a[<span class="number">1</span>:]                       <span class="comment">// 删除开头1个元素</span></span><br><span class="line">a = a[N:]                       <span class="comment">// 删除开头N个元素</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<ul>
<li>将后面的数据向开头移动，使用<strong> append 原地完成</strong>（所谓原地完成是指在原有的切片数据对应的内存区间内完成，不会导致内存空间结构的变化）</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ...&#125;</span><br><span class="line">a = <span class="built_in">append</span>(a[:<span class="number">0</span>], a[<span class="number">1</span>:]...) <span class="comment">// 删除开头1个元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:<span class="number">0</span>], a[N:]...) <span class="comment">// 删除开头N个元素</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用 copy 将后续数据向前移动，代码如下：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">a = a[:<span class="built_in">copy</span>(a, a[<span class="number">1</span>:])] <span class="comment">// 删除开头1个元素</span></span><br><span class="line">a = a[:<span class="built_in">copy</span>(a, a[N:])] <span class="comment">// 删除开头N个元素</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<ol>
<li>从中间位置删除；<br>
对于删除中间的元素，需要对剩余的元素进行一次整体挪动，同样可以用 append 或 copy 原地完成：</li>
</ol>
<ul>
<li>append 删除操作如下：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ...&#125;</span><br><span class="line">a = <span class="built_in">append</span>(a[:i], a[i+<span class="number">1</span>], ...)</span><br><span class="line">a = <span class="built_in">append</span>(a[:i], a[i+N:], ...)</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<ul>
<li>copy 删除操作如下：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">a = a[:<span class="built_in">copy</span>(a[:i], a[i+<span class="number">1</span>:])] <span class="comment">// 删除中间1个元素</span></span><br><span class="line">a = a[:<span class="built_in">copy</span>(a[:i], a[i+N:])] <span class="comment">// 删除中间N个元素</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<ol>
<li>从尾部删除。</li>
</ol>
<p>代码如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ...&#125;</span><br><span class="line"></span><br><span class="line">a = a[:<span class="built_in">len</span>(a)<span class="number">-1</span>]   <span class="comment">// 删除尾部1个元素</span></span><br><span class="line">a = a[:<span class="built_in">len</span>(a)-N]   <span class="comment">// 删除尾部N个元素</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>删除切片尾部的元素是最快的</p>
</blockquote>
<h2 id="37-函数"><a class="markdownIt-Anchor" href="#37-函数">#</a> 3.7 函数</h2>
<p>为完成某一功能的程序指令 (语句) 的集合，称为函数。</p>
<h3 id="371-函数分类"><a class="markdownIt-Anchor" href="#371-函数分类">#</a> 3.7.1 函数分类</h3>
<p>在 Go 语言中，函数是第一类对象，我们可以将函数保持到变量中。函数主要有<strong>具名</strong>和<strong>匿名</strong>之分，包级函数一般都是具名函数，具名函数是匿名函数的一种特例，当匿名函数引用了外部作用域中的变量时就成了<strong>闭包函数</strong>，闭包函数是函数式编程语言的核心。</p>
<p>举例代码如下：</p>
<ol>
<li>具名函数：就和 c 语言中的普通函数意义相同，具有函数名、返回值以及函数参数的函数。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<ol>
<li>匿名函数：指不需要定义函数名的一种函数实现方式，它由一个不带函数名的函数声明和函数体组成。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Add = <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>解释几个名词如下：</p>
<ol>
<li>闭包函数：返回为函数对象，不仅仅是一个函数对象，在该函数外还包裹了一层作用域，这使得，该函数无论在何处调用，优先使用自己外层包裹的作用域。</li>
<li>一级对象：支持闭包的多数语言都将函数作为第一级对象，就是说函数可以存储到变量中作为参数传递给其他函数，最重要的是能够被函数动态创建和返回。</li>
<li>包：go 的每一个文件都是属于一个包的，也就是说 go 是以包的形式来管理文件和项目目录结构的。</li>
</ol>
</blockquote>
<h3 id="372-函数声明和定义"><a class="markdownIt-Anchor" href="#372-函数声明和定义">#</a> 3.7.2 函数声明和定义</h3>
<p>Go 语言函数定义格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fuction_name</span><span class="params">([parameter list])</span></span>[<span class="keyword">return</span> types]&#123;</span><br><span class="line">	函数体</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th></th>
<th>解析</th>
</tr>
</thead>
<tbody>
<tr>
<td>func</td>
<td>函数由 func 开始声明</td>
</tr>
<tr>
<td>function_name</td>
<td>函数名称</td>
</tr>
<tr>
<td>parameter list</td>
<td>参数列表</td>
</tr>
<tr>
<td>return_types</td>
<td>返回类型</td>
</tr>
<tr>
<td>函数体</td>
<td>函数定义的代码集合</td>
</tr>
</tbody>
</table>
<h3 id="373-函数传参"><a class="markdownIt-Anchor" href="#373-函数传参">#</a> 3.7.3 函数传参</h3>
<blockquote>
<p>Go 语言中的函数可以有多个参数和多个返回值，参数和返回值都是以传值的方式和被调用者交换数据。在语法上，函数还支持可变数量的参数，<strong>可变数量的参数必须是最后出现的参数</strong>，可变数量的参数其实是一个切片类型的参数。</p>
</blockquote>
<p>当可变参数是一个<strong>空接口类型</strong>时，调用者是否解包可变参数会导致不同的结果，我们解释一下解包的含义，代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	Print(a...)   <span class="comment">// 解包</span></span><br><span class="line">	Print(a)	  <span class="comment">// 未解包</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">(a ...<span class="type">int</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	fmt.Println(a...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>
<p>以上当传入参数为 <code>a...</code>  时即是对切片 a 进行了解包，此时其实相当于直接调用 <code>Print(1,2,3)</code> 。当传入参数直接为  <code>a</code>  时等价于直接调用 <code>Print([]int&#123;&#125;&#123;1,2,3&#125;)</code></p>
<h3 id="374-函数返回值"><a class="markdownIt-Anchor" href="#374-函数返回值">#</a> 3.7.4 函数返回值</h3>
<blockquote>
<p>不仅函数的参数可以有名字，也可以给函数的返回值命名。</p>
</blockquote>
<p>举例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Find</span><span class="params">(m <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, key <span class="type">int</span>)</span></span>(value <span class="type">int</span>, ok <span class="type">bool</span>) &#123;</span><br><span class="line">	value,ok = m[key]</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<p>如果返回值命名了，可以通过名字来修改返回值，也可以通过 defer 语句在 return 语句之后修改返回值，举例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mian</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span> ; i&lt;<span class="number">3</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="built_in">println</span>(i) &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数最终的输出为：</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>
<p>以上代码中如果没有 defer 其实返回值就是 <code>0,1,2</code> ，但 defer 语句会在函数 return 之后才会执行，也就是或只有以上函数在执行结束 return 之后才会执行 defer 语句，而该函数 return 时的 <code>i</code>  值将会达到 3，所以最终的 defer 语句执行 printlin 的输出都是 3。</p>
<p>defer 语句延迟执行的其实是一个匿名函数，因为这个匿名函数捕获了外部函数的局部变量 v，这种函数我们一般叫闭包。闭包对捕获的外部变量并不是传值方式访问，而是以<strong>引用</strong>的方式访问。</p>
<p>这种方式往往会带来一些问题，修复方法为在每一轮迭代中都为 defer 函数提供一个独有的变量，修改代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        i := i <span class="comment">// 定义一个循环体内局部变量i</span></span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123; <span class="built_in">println</span>(i) &#125; ()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="comment">// 通过函数传入i</span></span><br><span class="line">        <span class="comment">// defer 语句会马上对调用参数求值</span></span><br><span class="line">        <span class="comment">// 不再捕获，而是直接传值</span></span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span>&#123; <span class="built_in">println</span>(i) &#125; (i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>
<h3 id="375-递归调用"><a class="markdownIt-Anchor" href="#375-递归调用">#</a> 3.7.5 递归调用</h3>
<p>Go 语言中，函数还可以直接或间接地调用自己，也就是支持递归调用。Go 语言函数的递归调用<strong>深度逻辑上没有限制</strong>，函数调用的栈是<strong>不会出现溢出错误</strong>的，因为 Go 语言运行时会根据需要动态地调整函数栈的大小。这部分的知识将会涉及 goroutint 和动态栈的相关知识，我们将会在之后的博文中向大家解释。</p>
<p>它的语法和 c 很相似，格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recursion</span><span class="params">()</span></span> &#123;</span><br><span class="line">   recursion() <span class="comment">/* 函数调用自身 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   recursion()</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>
<h2 id="38-方法"><a class="markdownIt-Anchor" href="#38-方法">#</a> 3.8 方法</h2>
<p>方法一般是面向对象编程 (OOP) 的一个特性，在 C++ 语言中方法对应一个类对象的成员函数，是关联到具体对象上的虚表中的。但是 Go 语言的方法却是<strong>关联到类型</strong>的，这样可以在<strong>编译阶段完成方法的静态绑定</strong>。一个面向对象的程序会用方法来表达其属性对应的操作，这样使用这个对象的用户就不需要直接去操作对象，而是借助方法来做这些事情。</p>
<p>实现 C 语言中的一组函数如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件对象</span></span><br><span class="line"><span class="keyword">type</span> File <span class="keyword">struct</span> &#123;</span><br><span class="line">    fd <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="type">string</span>)</span></span> (f *File, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CloseFile</span><span class="params">(f *File)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读文件数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(f *File, offset <span class="type">int64</span>, data []<span class="type">byte</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819</span></span><br></pre></td></tr></table></figure>
<p>以上的三个函数都是普通的函数，需要占用包级空间中的名字资源。不过 CloseFile 和 ReadFile 函数只是针对 File 类型对象的操作，这时候我们更希望这类函数和操作对象的类型紧密绑定在一起。</p>
<p>所以在 go 语言中我们修改如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> CloseFile() <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读文件数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> ReadFile(offset <span class="type">int64</span>, data []<span class="type">byte</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>
<p>将 CloseFile 和 ReadFile 函数的第一个参数移动到函数名的开头，这两个函数就成了<strong> File 类型</strong>独有的方法了（而不是 File 对象方法）</p>
<p>从代码角度看虽然只是一个小的改动，但是从编程哲学角度来看，Go 语言已经是进入面向对象语言的行列了。我们可以给任何自定义类型添加一个或多个方法。每种类型对应的方法必须和类型的定义在同一个包中，因此是无法给 int 这类内置类型添加方法的（因为方法的定义和类型的定义不在一个包中）。对于给定的类型，每个方法的名字必须是唯一的，同时方法和函数一样也不支持重载。</p>
<h2 id="39-接口"><a class="markdownIt-Anchor" href="#39-接口">#</a> 3.9 接口</h2>
<h3 id="391-什么是接口"><a class="markdownIt-Anchor" href="#391-什么是接口">#</a> 3.9.1 什么是接口</h3>
<p>Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。</p>
<p>Go 的接口类型是对其它类型行为的抽象和概括；因为接口类型<strong>不会和特定的实现细节绑定在一起</strong>，通过这种抽象的方式我们可以让对象更加灵活和更具有适应能力。很多面向对象的语言都有相似的接口概念，但 Go 语言中接口类型的独特之处在于它是满足隐式实现的鸭子类型。</p>
<p>所谓<strong>鸭子类型</strong>说的是：只要走起路来像鸭子、叫起来也像鸭子，那么就可以把它当作鸭子。Go 语言中的面向对象就是如此，如果一个对象只要看起来像是某种接口类型的实现，那么它就可以作为该接口类型使用。</p>
<p>就比如说在 c 语言中，使用 printf 在终端输出的时候只能输出有限类型的几个变量，而在 go 中可以使用 fmt.Printf，实际上是 fmt.Fprintf 向任意自定义的输出流对象打印，甚至可以打印到网络甚至是压缩文件，同时打印的数据不限于语言内置的基础类型，任意隐士满足 fmt.Stringer 接口的对象都可以打印，不满足 fmt.Stringer 接口的依然可以通过反射的技术打印。</p>
<h3 id="392-结构体类型"><a class="markdownIt-Anchor" href="#392-结构体类型">#</a> 3.9.2 结构体类型</h3>
<p>interface 实际上就是一个结构体，包含两个成员。其中一个成员是指向具体数据的指针，另一个成员中包含了类型信息。空接口和带方法的接口略有不同，下面分别是空接口的数据结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Eface</span><br><span class="line">&#123;</span><br><span class="line">    Type*    <span class="keyword">type</span>;</span><br><span class="line">    void*    data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>
<p>其中的 Type 指的是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uintptr</span> size;</span><br><span class="line">    <span class="type">uint32</span> hash;</span><br><span class="line">    <span class="type">uint8</span> _unused;</span><br><span class="line">    <span class="type">uint8</span> align;</span><br><span class="line">    <span class="type">uint8</span> fieldAlign;</span><br><span class="line">    <span class="type">uint8</span> kind;</span><br><span class="line">    Alg *alg;</span><br><span class="line">    void *gc;</span><br><span class="line">    String *<span class="type">string</span>;</span><br><span class="line">    UncommonType *x;</span><br><span class="line">    Type *ptrto;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>
<p>和带方法的接口使用的数据结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Iface</span><br><span class="line">&#123;</span><br><span class="line">    Itab*    tab;</span><br><span class="line">    void*    data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>
<p>其中的 Iface 指的是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span>    Itab</span><br><span class="line">&#123;</span><br><span class="line">    InterfaceType*    inter;</span><br><span class="line">    Type*    <span class="keyword">type</span>;</span><br><span class="line">    Itab*    link;</span><br><span class="line">    <span class="type">int32</span>    bad;</span><br><span class="line">    <span class="type">int32</span>    unused;</span><br><span class="line">    void    (*fun[])(void);   <span class="comment">// 方法表</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>
<h3 id="393-具体类型向接口类型赋值"><a class="markdownIt-Anchor" href="#393-具体类型向接口类型赋值">#</a> 3.9.3 具体类型向接口类型赋值</h3>
<p>将一个具体类型数据赋值给 interface 这样的抽象类型，需要进行类型转换。这个转换过程中涉及哪些操作呢？</p>
<p>如果转换为空接口，返回一个 Eface，将 Eface 中的 data 指针指向原型数据，type 指针会指向数据的 Type 结构体。</p>
<p>如果将其转化为带方法的 interface，需要进行一次检测，该类型必须实现 interface 中声明的所有方法才可以进行转换，这个检测将会在编译过程中进行。检测过程具体实现式通过比较具体类型的方法表和接口类型的方法表来进行的。</p>
<ul>
<li>具体类型方法表：Type 的 UncommonType 中有一个方法表，某个具体类型实现的所有方法都会被收集到这张表中。</li>
<li>接口类型方法表：Iface 的 Itab 的 InterfaceType 中也有一张方法表，这张方法表中是接口所声明的方法。Iface 中的 Itab 的 func 域也是一张方法表，这张表中的每一项就是一个函数指针，也就是只有实现没有声明。</li>
</ul>
<p>这两处方法表都是排序过的，只需要一遍顺序扫描进行比较，应该可以知道 Type 中否实现了接口中声明的所有方法。最后还会将 Type 方法表中的函数指针，拷贝到 Itab 的 fun 字段中。Iface 中的 Itab 的 func 域也是一张方法表，这张表中的每一项就是一个函数指针，也就是只有实现没有声明。</p>
<h3 id="394-获取接口类型数据的具体类型信息"><a class="markdownIt-Anchor" href="#394-获取接口类型数据的具体类型信息">#</a> 3.9.4 获取接口类型数据的具体类型信息</h3>
<p>接口类型转换为具体类型 (也就是反射，reflect)，也涉及到了类型转换。reflect 包中的 TypeOf 和 ValueOf 函数来得到接口变量的 Type 和 Value。</p>
<h2 id="310-channel"><a class="markdownIt-Anchor" href="#310-channel">#</a> 3.10 channel</h2>
<h3 id="3101-相关结构体定义"><a class="markdownIt-Anchor" href="#3101-相关结构体定义">#</a> 3.10.1 相关结构体定义</h3>
<p>go 中的 channel 是可以被存储在变量中，可以作为参数传递给函数，也可以作为函数返回值返回，我们先来看一下 channel 的结构体定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span>    Hchan</span><br><span class="line">&#123;</span><br><span class="line">    uintgo    qcount;            <span class="comment">// 队列q中的总数据数量</span></span><br><span class="line">    uintgo    dataqsize;        <span class="comment">// 环形队列q的数据大小</span></span><br><span class="line">    <span class="type">uint16</span>    elemsize;			<span class="comment">// 当前队列的使用量</span></span><br><span class="line">    <span class="type">bool</span>    closed;				</span><br><span class="line">    <span class="type">uint8</span>    elemalign;</span><br><span class="line">    Alg*    elemalg;        <span class="comment">// interface for element type</span></span><br><span class="line">    uintgo    sendx;            <span class="comment">// 发送index</span></span><br><span class="line">    uintgo    recvx;            <span class="comment">// 接收index</span></span><br><span class="line">    WaitQ    recvq;            <span class="comment">// 因recv而阻塞的等待队列</span></span><br><span class="line">    WaitQ    sendq;            <span class="comment">// 因send而阻塞的等待队列</span></span><br><span class="line">    Lock;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>
<p>Hchan 结构体中的核心部分是存放 channel 数据的环形队列，相关数据的作用已经在其后做出了备注。在该结构体中没有存放数据的域，如果是带缓冲区的 chan，则缓冲区数据实际上是紧接着 Hchan 结构体中分配的。</p>
<p>另一个重要部分就是 recvq 和 sendq 两个链表，一个是因读这个通道而导致阻塞的 goroutine，另一个是因为写这个通道而阻塞的 goroutine。如果一个 goroutine 阻塞于 channel 了，那么它就被挂在 recvq 或 sendq 中。WaitQ 是链表的定义，包含一个头结点和一个尾结点，该链表中中存放的成员是一个 sudoG 结构体变量，具体定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span>    SudoG</span><br><span class="line">&#123;</span><br><span class="line">    G*    g;        <span class="comment">// g and selgen constitute</span></span><br><span class="line">    <span class="type">uint32</span>    selgen;        <span class="comment">// a weak pointer to g</span></span><br><span class="line">    SudoG*    link;</span><br><span class="line">    <span class="type">int64</span>    releasetime;</span><br><span class="line">    <span class="type">byte</span>*    elem;        <span class="comment">// data element</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>
<p>该结构体中最主要的是 g 和 elem。elem 用于存储 goroutine 的数据。读通道时，数据会从 Hchan 的队列中拷贝到 SudoG 的 elem 域。写通道时，数据则是由 SudoG 的 elem 域拷贝到 Hchan 的队列中。</p>
<p>Hchan 结构如下：<br>
<img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/ddf2855d06234305a122bea469d0adaa.png" alt="在这里插入图片描述"></p>
<h3 id="3102-阻塞式读写channel操作"><a class="markdownIt-Anchor" href="#3102-阻塞式读写channel操作">#</a> 3.10.2 阻塞式读写 channel 操作</h3>
<p>写操作代码如下，其中的 c 就是 channel，v 指的是数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c &lt;- v</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>事实上基本的阻塞模式写 channel 操作在底层运行时库中对应的是一个 runtime.chansend 函数。具体如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void runtime·chansend(ChanType *t, Hchan *c, byte *ep, bool *pres, void *pc)</span><br></pre></td></tr></table></figure>
<p>其中的 ep 指的是变量 v 的地址，这里的传值约定是调用者负责分配好 ep 的空间，仅需要简单的取变量地址就好了，pres 是在 select 中的通道操作中使用的。</p>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/22fb68eff45145c89f2f64d51b3e556f.png" alt="在这里插入图片描述"></p>
<p>阻塞模式读操作的核心函数有两种包装如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool)</span><br></pre></td></tr></table></figure>
<p>以及</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected)</span><br></pre></td></tr></table></figure>
<p>这两种的区别主要在于返回值是否会返回一个 bool 类型值，该值只是用于判断 channel 是否能读取出数据。</p>
<p>读写操作的以上阻塞的过程类似，故而不再做出说明，我们补充三个细节：</p>
<ul>
<li>以上我们都强调是阻塞式的读写操作，其实相对应的也有<strong>非阻塞的</strong>读写操作，使用过 select-case 来进行调用的。</li>
<li>空通道，指的是将一个 channel 赋值为 nil，或者调用后不适用 make 进行初始化。读写空通道是永远阻塞的。</li>
<li>关闭的通道，永远不会阻塞，会返回一个通道数据类型的零值。首先将 closed 置为 1，第二步收集读等待队列 recvq 的所有 sg，每个 sg 的 elem 都设为类型零值，第三步收集写等待队列 sendq 的所有 sg，每个 sg 的 elem 都设为 nil，最后唤醒所有收集的 sg。</li>
</ul>
<h3 id="3103-非阻塞式读写channel操作"><a class="markdownIt-Anchor" href="#3103-非阻塞式读写channel操作">#</a> 3.10.3 非阻塞式读写 channel 操作</h3>
<p>如上文所说，非阻塞式其实就是使用 select-case 来实现，在编译时将会被编译为 if-else。</p>
<p>如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v = &lt;-c:</span><br><span class="line">        ...foo</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">        ...bar</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<p>就会被编译为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> selectnbrecv(&amp;v, c) &#123;</span><br><span class="line">        ...foo</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...bar</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>
<p>至于其中的 selectnbrecv 相关的函数简单地调 runtime.chanrecv 函数，设置了一个参数，告诉 runtime.chanrecv 函数，当不能完成操作时不要阻塞，而是返回失败。</p>
<p>但是 select 中的 case 的执行顺序是随机的，而不像 switch 中的 case 那样一条一条的顺序执行。让每一个 select 都对应一个 Select 结构体。在 Select 数据结构中有个 Scase 数组，记录下了每一个 case，而 Scase 中包含了 Hchan。然后 pollorder 数组将元素随机排列，这样就可以将 Scase 乱序了。</p>
<h2 id="311-map"><a class="markdownIt-Anchor" href="#311-map">#</a> 3.11 map</h2>
<p>map 表的底层原理是哈希表，其结构体定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">    Key  *Type <span class="comment">// Key type</span></span><br><span class="line">    Elem *Type <span class="comment">// Val (elem) type</span></span><br><span class="line"></span><br><span class="line">    Bucket *Type <span class="comment">// 哈希桶</span></span><br><span class="line">    Hmap   *Type <span class="comment">// 底层使用的哈希表元信息</span></span><br><span class="line">    Hiter  *Type <span class="comment">// 用于遍历哈希表的迭代器</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>
<p>其中的 Hmap 的具体化数据结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go.</span></span><br><span class="line">    <span class="comment">// Make sure this stays in sync with the compiler&#x27;s definition.</span></span><br><span class="line">    count     <span class="type">int</span> <span class="comment">// map目前的元素数目</span></span><br><span class="line">    flags     <span class="type">uint8</span> <span class="comment">// map状态（正在被遍历/正在被写入）</span></span><br><span class="line">    B         <span class="type">uint8</span>  <span class="comment">// 哈希桶数目以2为底的对数（哈希桶的数目都是 2 的整数次幂，用位运算来计算取余运算的值, 即 N mod M = N &amp; (M-1))）</span></span><br><span class="line">    noverflow <span class="type">uint16</span> <span class="comment">//溢出桶的数目, 这个数值不是恒定精确的, 当其 B&gt;=16 时为近似值</span></span><br><span class="line">    hash0     <span class="type">uint32</span> <span class="comment">// 随机哈希种子</span></span><br><span class="line"></span><br><span class="line">    buckets    unsafe.Pointer <span class="comment">// 指向当前哈希桶的指针</span></span><br><span class="line">    oldbuckets unsafe.Pointer <span class="comment">// 扩容时指向旧桶的指针</span></span><br><span class="line">    nevacuate  <span class="type">uintptr</span>        <span class="comment">// 桶进行调整时指示的搬迁进度</span></span><br><span class="line"></span><br><span class="line">    extra *mapextra <span class="comment">// 表征溢出桶的变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>
<p>以上 hmap 基本都是涉及到了哈希桶和溢出桶，我们首先看一下它的数据结构，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    topbits  [<span class="number">8</span>]<span class="type">uint8</span>    <span class="comment">// 键哈希值的高8位</span></span><br><span class="line">    keys     [<span class="number">8</span>]keytype  <span class="comment">// 哈希桶中所有键</span></span><br><span class="line">    elems    [<span class="number">8</span>]elemtype	<span class="comment">// 哈希桶中所有值</span></span><br><span class="line">    <span class="comment">//pad      uintptr(新的 go 版本已经移除了该字段, 我未具体了解此处的 change detail, 之前设置该字段是为了在 nacl/amd64p32 上的内存对齐)</span></span><br><span class="line">    overflow <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>
<p>我们会发现哈希桶 bmap 一般指定其能保存 8 个键值对，如果多于 8 个键值对，就会申请新的 buckets，并将其于之前的 buckets 链接在一起。</p>
<p>其中的联系如图所示：<br>
<img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/13c1b9f9899d48b08c32b76ef4037a17.png" alt="在这里插入图片描述"></p>
<p>在具体插入时，首先会根据 key 值采用相应的 hash 算法计算对应的哈希值，将哈希值的低 8 位作为 Hmap 结构体中 buckets 数组的索引，找到 key 值所对应的 bucket，将哈希值的高 8 位催出在 bucket 的 tophash 中。</p>
<p>特点如下：</p>
<ul>
<li>map 是<strong>无序的</strong>（原因为无序写入以及扩容导致的元素顺序发生变化），每次打印出来的 map 都会不一样，它不能通过 index 获取，而必须通过 key 获取</li>
<li>map 的<strong>长度是不固定</strong>的，也就是和 slice 一样，也是一种引用类型</li>
<li>内置的 len 函数同样适用于 map，返回 map 拥有的 key 的数量</li>
<li>map 的 key 可以是所有可比较的类型，如布尔型、整数型、浮点型、复杂型、字符串型…… 也可以键。</li>
</ul>
<p>如下方式即可进行初始化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">map</span>[keytype]valuetype</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>类型名</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>map 表名字</td>
</tr>
<tr>
<td>keytype</td>
<td>键类型</td>
</tr>
<tr>
<td>valuetype</td>
<td>键对应的值的类型</td>
</tr>
</tbody>
</table>
<p>除此以外还可以使用 make 进行初始化，代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map_variable = <span class="built_in">make</span>(<span class="keyword">map</span>[key_data_type]value_data_type)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>我们还可以使用初始值进行初始化，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;hunter&quot;</span>:<span class="number">12</span>,<span class="string">&quot;tony&quot;</span>:<span class="number">10</span>&#125;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="3111-插入数据"><a class="markdownIt-Anchor" href="#3111-插入数据">#</a> 3.11.1 插入数据</h3>
<p>map 的数据插入代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map_variable[<span class="string">&quot;mars&quot;</span>] = <span class="number">27</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>插入过程如下：</p>
<ol>
<li>根据 key 值计算出哈希值</li>
<li>取哈希值低位和 hmap.B 取模确定 bucket 位置</li>
<li>查找该 key 是否已经存在，如果存在则直接更新值</li>
<li>如果没有找到 key，则将这一对 key-value 插入</li>
</ol>
<h3 id="3112-删除数据"><a class="markdownIt-Anchor" href="#3112-删除数据">#</a> 3.11.2 删除数据</h3>
<p><strong>delete(map, key)</strong> 函数用于删除集合的元素，参数为 map 和其对应的 key。删除函数不返回任何值。相关代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   countryCapitalMap := <span class="keyword">map</span>[<span class="type">string</span>] <span class="type">string</span> &#123;<span class="string">&quot;France&quot;</span>:<span class="string">&quot;Paris&quot;</span>,<span class="string">&quot;Italy&quot;</span>:<span class="string">&quot;Rome&quot;</span>,<span class="string">&quot;Japan&quot;</span>:<span class="string">&quot;Tokyo&quot;</span>,<span class="string">&quot;India&quot;</span>:<span class="string">&quot;New Delhi&quot;</span>&#125;</span><br><span class="line">   <span class="comment">/* 删除元素 */</span></span><br><span class="line">   <span class="built_in">delete</span>(countryCapitalMap,<span class="string">&quot;France&quot;</span>);</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<h3 id="3113-查找数据"><a class="markdownIt-Anchor" href="#3113-查找数据">#</a> 3.11.3 查找数据</h3>
<p>通过 key 获取 map 中对应的 value 值。语法为： <code>map[key] </code> . 但是当 key 如果不存在的时候，我们会得到该 value 值类型的默认值，比如 string 类型得到空字符串，int 类型得到 0。但是程序不会报错。</p>
<p>所以我们可以使用<strong> ok-idiom</strong> 获取值，如下： <code>value, ok := map[key] </code> ，其中的 value 是返回值，ok 是一个 bool 值，可知道 key/value 是否存在。</p>
<p>在 map 表中的查找过程如下：</p>
<ol>
<li>查找或者操作 map 时，首先 key 经过 hash 函数生成 hash 值</li>
<li>通过哈希值的低 8 位来判断当前数据属于哪个桶</li>
<li>找到桶之后，通过哈希值的高八位与 bucket 存储的高位哈希值循环比对</li>
<li>如果相同就比较刚才找到的底层数组的 key 值，如果 key 相同，取出 value</li>
<li>如果高八位 hash 值在此 bucket 没有，或者有，但是 key 不相同，就去链表中下一个溢出 bucket 中查找，直到查找到链表的末尾</li>
<li>如果查找不到，也不会返回空值，而是返回相应类型的 0 值。</li>
</ol>
<h3 id="3114-扩容"><a class="markdownIt-Anchor" href="#3114-扩容">#</a> 3.11.4 扩容</h3>
<p>哈希表就是以空间换时间，访问速度是直接跟填充因子相关的，所以当哈希表太满之后就需要进行扩容。</p>
<p>如果扩容前的哈希表大小为 2B 扩容之后的大小为 2 (B+1)，每次扩容都变为<strong>原来大小的两倍</strong>，哈希表大小始终为 2 的指数倍，则有 (hash mod 2B) 等价于 (hash &amp; (2B-1))。这样可以简化运算，避免了取余操作。</p>
<blockquote>
<p>触发扩容的条件？</p>
</blockquote>
<ol>
<li>负载因子 (负载因子 = 键数量 /bucket 数量) &gt; 6.5 时，也即平均每个 bucket 存储的键值对达到 6.5 个。</li>
<li>溢出桶（overflow）数量 &gt; 2^15 时，也即 overflow 数量超过 32768 时。</li>
</ol>
<blockquote>
<p>什么是增量扩容呢？</p>
</blockquote>
<p>如果负载因子 &gt; 6.5 时，进行增量扩容。这时会新建一个桶（bucket），新的 bucket 长度是原来的 2 倍，然后旧桶数据搬迁到新桶。每个旧桶的键值对都会分流到两个新桶中</p>
<p>主要是缩短 map 容器的响应时间。假如我们直接将 map 用作某个响应实时性要求非常高的 web 应用存储，如果不采用增量扩容，当 map 里面存储的元素很多之后，扩容时系统就会卡往，导致较长一段时间内无法响应请求。不过增量扩容本质上还是将总的扩容时间分摊到了每一次哈希操作上面。</p>
<blockquote>
<p>什么是等量扩容？它的触发条件是什么？进行等量扩容后的优势是什么？</p>
</blockquote>
<p>等量扩容，就是创建和旧桶数目一样多的新桶，然后把原来的键值对迁移到新桶中，重新做一遍类似增量扩容的搬迁动作。</p>
<p>触发条件：负载因子没超标，溢出桶较多。这个较多的评判标准为：</p>
<ul>
<li>如果常规桶数目不大于 2^15，那么使用的溢出桶数目超过常规桶就算是多了；</li>
<li>如果常规桶数目大于 215，那么使用溢出桶数目一旦超过 215 就算多了。</li>
</ul>
<p>这样做的目的是把松散的键值对重新排列一次，能够存储的更加紧凑，进而减少溢出桶的使用，以使 bucket 的使用率更高，进而保证更快的存取。</p>
<h1 id="4-常用语句及关键字"><a class="markdownIt-Anchor" href="#4-常用语句及关键字">#</a> 4. 常用语句及关键字</h1>
<p>接下来我们了解一下关于 go 语言语句的基本内容。</p>
<h2 id="41-条件语句"><a class="markdownIt-Anchor" href="#41-条件语句">#</a> 4.1 条件语句</h2>
<p>和 c 语言类似，相关的条件语句如下表所示：</p>
<table>
<thead>
<tr>
<th>语句</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>if 语句</td>
<td>if 语句 由一个布尔表达式后紧跟一个或多个语句组成。</td>
</tr>
<tr>
<td>if…else 语句</td>
<td>if 语句 后可以使用可选的 else 语句，else 语句中的表达式在布尔表达式为 false 时执行。</td>
</tr>
<tr>
<td>switch 语句</td>
<td>switch 语句用于基于不同条件执行不同动作。</td>
</tr>
<tr>
<td>select 语句</td>
<td>select 语句类似于 switch 语句，但是 select 会随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。</td>
</tr>
</tbody>
</table>
<ul>
<li>if 语句<br>
语法如下：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 布尔表达式 &#123;</span><br><span class="line">   <span class="comment">/* 在布尔表达式为 true 时执行 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<ul>
<li>if-else 语句</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 布尔表达式 &#123;</span><br><span class="line">   <span class="comment">/* 在布尔表达式为 true 时执行 */</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">/* 在布尔表达式为 false 时执行 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>
<ul>
<li>switch 语句<br>
其中的变量 <code>v</code>  可以是任何类型， <code>val1</code>  和 <code>val2</code>  可以是同类型的任意值，类型不局限为常量或者整数，或者最终结果为相同类型的表达式。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> v &#123;</span><br><span class="line">    <span class="keyword">case</span> val1:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> val2:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>
<ul>
<li>select 语句<br>
 select 是 Go 中的一个控制结构，类似于用于通信的 switch 语句。每个 case 必须是一个<strong>通信操作</strong>，要么是发送要么是接收。它将会随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。一个默认的子句应该总是可运行的。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> communication clause  :</span><br><span class="line">       statement(s);      </span><br><span class="line">    <span class="keyword">case</span> communication clause  :</span><br><span class="line">       statement(s);</span><br><span class="line">    <span class="comment">/* 你可以定义任意数量的 case */</span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">/* 可选 */</span></span><br><span class="line">       statement(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
<ul>
<li>每个 case 必须都是一个通信</li>
<li>所有 channel 表达式都会被求值，所有被发送的表达式都会被求值</li>
<li>如果任意某一个通信都可以，它就执行，其他就忽略</li>
<li>如果有多个 case 都可以运行，select 就会随机挑选一个来执行。</li>
<li>如果没有一个 case 可以被运行：如果有 default 子句，就执行 default 子句，select 将被阻塞，直到某个通信可以运行，从而避免饥饿问题。</li>
</ul>
</blockquote>
<h2 id="42-循环语句"><a class="markdownIt-Anchor" href="#42-循环语句">#</a> 4.2 循环语句</h2>
<h3 id="421-循环处理语句"><a class="markdownIt-Anchor" href="#421-循环处理语句">#</a> 4.2.1 循环处理语句</h3>
<p>go 中时使用 for 实现循环的，共有三种形式：</p>
<table>
<thead>
<tr>
<th></th>
<th>语法</th>
</tr>
</thead>
<tbody>
<tr>
<td>和 c 语言中的 for 相同</td>
<td>for init; condition; post {}</td>
</tr>
<tr>
<td>和 c 语言中的 while 相同</td>
<td>for condition{}</td>
</tr>
<tr>
<td>和 c 语言中的 <code>for(;;)</code>  相同</td>
<td>for{}</td>
</tr>
</tbody>
</table>
<p>除此以外，for 循环还可以直接使用<strong> range</strong> 对 slice、map、数组以及字符串等进行迭代循环，格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> oldmap &#123;</span><br><span class="line">	newmap[key] = value</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<h3 id="421-循环控制语句"><a class="markdownIt-Anchor" href="#421-循环控制语句">#</a> 4.2.1 循环控制语句</h3>
<table>
<thead>
<tr>
<th>控制语句</th>
<th>详解</th>
</tr>
</thead>
<tbody>
<tr>
<td>break</td>
<td>中断跳出循环或者 switch 语句</td>
</tr>
<tr>
<td>continue</td>
<td>跳过当前循环的剩余语句，然后继续下一轮循环</td>
</tr>
<tr>
<td>goto 语句</td>
<td>将控制转移到被标记的语句</td>
</tr>
</tbody>
</table>
<ol>
<li>break<br>
break 主要用于循环语句跳出循环，和 c 语言中的使用方式是相同的。且在多重循环的时候还可以使用 label 标出想要 break 的循环。<br>
实例代码如下：</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> a&lt;<span class="number">5</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, a)</span><br><span class="line">	a++</span><br><span class="line">	<span class="keyword">if</span> a==<span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>
<ol>
<li>continue<br>
Go 语言的 continue 语句 有点像 break 语句。但是 continue 不是跳出循环，而是跳过当前循环执行下一次循环语句。在多重循环中，可以用标号 label 标出想 continue 的循环。<br>
实例代码如下：</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 不使用标记</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;---- continue ---- &quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;i: %d\n&quot;</span>, i)</span><br><span class="line">            <span class="keyword">for</span> i2 := <span class="number">11</span>; i2 &lt;= <span class="number">13</span>; i2++ &#123;</span><br><span class="line">                fmt.Printf(<span class="string">&quot;i2: %d\n&quot;</span>, i2)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">i: 1</span></span><br><span class="line"><span class="comment">i2: 11</span></span><br><span class="line"><span class="comment">i2: 12</span></span><br><span class="line"><span class="comment">i2: 13</span></span><br><span class="line"><span class="comment">i: 2</span></span><br><span class="line"><span class="comment">i2: 11</span></span><br><span class="line"><span class="comment">i2: 12</span></span><br><span class="line"><span class="comment">i2: 13</span></span><br><span class="line"><span class="comment">i: 3</span></span><br><span class="line"><span class="comment">i2: 11</span></span><br><span class="line"><span class="comment">i2: 12</span></span><br><span class="line"><span class="comment">i2: 13</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用标记</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;---- continue label ----&quot;</span>)</span><br><span class="line">    re:</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;i: %d&quot;</span>, i)</span><br><span class="line">                <span class="keyword">for</span> i2 := <span class="number">11</span>; i2 &lt;= <span class="number">13</span>; i2++ &#123;</span><br><span class="line">                    fmt.Printf(<span class="string">&quot;i2: %d\n&quot;</span>, i2)</span><br><span class="line">                    <span class="keyword">continue</span> re</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">i: 1</span></span><br><span class="line"><span class="comment">i2: 11</span></span><br><span class="line"><span class="comment">i: 2</span></span><br><span class="line"><span class="comment">i2: 11</span></span><br><span class="line"><span class="comment">i: 3</span></span><br><span class="line"><span class="comment">i2: 11</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435363738394041424344</span></span><br></pre></td></tr></table></figure>
<ol>
<li>goto<br>
goto 语句主要是无条件转移到过程中<strong>指定的行</strong>。goto 语句通常和条件语句配合使用，可用来实现条件转移、构成循环以及跳出循环体等功能。但是并不主张使用 goto 语句，以免造成程序流程混乱。<br>
示例代码如下：</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">0</span></span><br><span class="line">LOOP: <span class="keyword">for</span> a&lt;<span class="number">5</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a == <span class="number">2</span> &#123;</span><br><span class="line">		a = a+<span class="number">1</span></span><br><span class="line">		<span class="keyword">goto</span> LOOP</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, a)</span><br><span class="line">	a++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="number">123456789101112131415161718</span></span><br></pre></td></tr></table></figure>
<p>以上代码中的 LOOP 就是一个标签，当运行到 goto 语句的时候，此时执行流就会跳转到 LOOP 标志的哪一行上。</p>
<h2 id="43-关键字"><a class="markdownIt-Anchor" href="#43-关键字">#</a> 4.3 关键字</h2>
<p>我们这一部分直接列表供大家了解 go 中的关键字如下：</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>import</td>
<td>导入相应的包文件</td>
</tr>
<tr>
<td>package</td>
<td>创建包文件，用于标记该文件归属哪个包</td>
</tr>
<tr>
<td>chan</td>
<td>channal，通道</td>
</tr>
<tr>
<td>var</td>
<td>变量控制，用于简短声明定义变量（:= 符号只能在函数内部使用，不能全局使用）</td>
</tr>
<tr>
<td>const</td>
<td>常量声明，任何时候 const 和 var 都可以同时出现</td>
</tr>
<tr>
<td>func</td>
<td>定义函数和方法</td>
</tr>
<tr>
<td>interface</td>
<td>接口，是一种具有一组方法的类型，这些方法定义了 interface 的行为</td>
</tr>
<tr>
<td>map</td>
<td>哈希表</td>
</tr>
<tr>
<td>struct</td>
<td>定义结构体</td>
</tr>
<tr>
<td>type</td>
<td>声明类型，取别名</td>
</tr>
<tr>
<td>for</td>
<td>for 是 go 中唯一的循环结构，上文中已经介绍过它的用法</td>
</tr>
<tr>
<td>break</td>
<td>中止，跳出循环</td>
</tr>
<tr>
<td>continue</td>
<td>继续下一轮循环</td>
</tr>
<tr>
<td>select</td>
<td>选择流程，可以同时等待多个通道操作</td>
</tr>
<tr>
<td>switch</td>
<td>多分枝选择，上文中已经详细介绍过它的用法</td>
</tr>
<tr>
<td>case</td>
<td>和 switch 配套使用</td>
</tr>
<tr>
<td>default</td>
<td>用于选择结构的默认选型</td>
</tr>
<tr>
<td>defer</td>
<td>用于资源释放，会在函数返回之前进行调用</td>
</tr>
<tr>
<td>if</td>
<td>分支选择</td>
</tr>
<tr>
<td>else</td>
<td>和 if 配套使用</td>
</tr>
<tr>
<td>go</td>
<td>通过 <code>go func()</code>  来开启一个 goroutine</td>
</tr>
<tr>
<td>goto</td>
<td>跳转至标志点的代码块，不推荐使用</td>
</tr>
<tr>
<td>fallthrouth</td>
<td></td>
</tr>
<tr>
<td>range</td>
<td>用于遍历 slice 类型数据</td>
</tr>
<tr>
<td>return</td>
<td>用于标注函数返回值</td>
</tr>
</tbody>
</table>
<h2 id="关于我"><a class="markdownIt-Anchor" href="#关于我">#</a> 关于我</h2>
<p>Brath 是一个热爱技术的 Java 程序猿，公众号「InterviewCoder」定期分享有趣有料的精品原创文章！</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png" alt="InterviewCoder"></p>
<p>非常感谢各位人才能看到这里，原创不易，文章如果有帮助可以关注、点赞、分享或评论，这都是对我的莫大支持！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-04-20T06:02:20.187Z" title="2023-4-20 14:02:20">2023-04-20</time>发表</span><span class="level-item"><time dateTime="2023-04-20T06:01:26.623Z" title="2023-4-20 14:01:26">2023-04-20</time>更新</span><span class="level-item">10 分钟读完 (大约1531个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/04/20/%E3%80%90Gmail%E3%80%91%E5%9B%BD%E5%86%85%E6%80%8E%E4%B9%88%E6%B3%A8%E5%86%8CGmail%E9%82%AE%E7%AE%B1%EF%BC%9F/">【Gmail】国内怎么注册Gmail邮箱？</a></p><div class="content"><h1 id="gmail国内怎么注册gmail邮箱"><a class="markdownIt-Anchor" href="#gmail国内怎么注册gmail邮箱">#</a> 【Gmail】国内怎么注册 Gmail 邮箱？</h1>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png" alt="InterviewCoder"></p>
<p>​		谷歌邮箱（Gmail）是在国际上使用最为频繁的邮箱，不管我们是用来收发邮件，还是用来注册国外的网站，大多数情况下都离不开谷歌邮箱。甚至，不少网站都直接支持谷歌邮箱登录，这就是为什么，国内很多网友想要注册 Gmail 谷歌邮箱的原因。</p>
<p>​		但是，大部分网友都无法自己完整注册，今天来做一篇完整的谷歌邮箱注册教程，非常详细，一步一步照做即可！</p>
<p>​	<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/4817a9d47027589.jpg" alt="img"></p>
<h2 id="谷歌邮箱怎么注册"><a class="markdownIt-Anchor" href="#谷歌邮箱怎么注册">#</a> 谷歌邮箱怎么注册？</h2>
<h4 id="注册前准备"><a class="markdownIt-Anchor" href="#注册前准备">#</a> 注册前准备</h4>
<p>1、手机号码一个（没有注册过谷歌邮箱的手机号码）</p>
<p>2、加速器（魔法）（国内使用谷歌，必须要加速器才行哦，加速器需自备，不然你会连谷歌邮箱官网都无法进入）</p>
<h4 id="谷歌gmail邮箱注册教程"><a class="markdownIt-Anchor" href="#谷歌gmail邮箱注册教程">#</a> 谷歌 Gmail 邮箱注册教程</h4>
<p>1、我们使用浏览器打开谷歌邮箱官网（<a target="_blank" rel="noopener" href="http://gmail.google.com">gmail.google.com</a>），进入谷歌邮箱的登录主页，我们点击左下方的创建账号按钮，选择个人用途。</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/image-20230420135757242.png" alt="image-20230420135757242"></p>
<p>2、在进入的界面我们不要着急填写资料，我们先修改语言，点击左下方的简体中文。</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/c81e728d9d4c2f6-30.jpg" alt="img"></p>
<p>3、这个时候，会弹出国家语言列表，我们选择 “English（United States）”。</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/eccbc87e4b5ce2f-25.jpg" alt="img"></p>
<p>4、这个时候，界面会变成英语。我们在填写个人信息，如下图填写。填好过后，我们要记住账号和密码信息哦，后面登录要用的。</p>
<p><a target="_blank" rel="noopener" href="https://blog.aftss.cn/wp-content/uploads/2022/09/a87ff679a2f3e71-20.jpg"><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/a87ff679a2f3e71-20.jpg" alt="img"></a></p>
<p>5、这个时候，会跳转到手机号码验证页面，我们选择中国 + 86，填写自己的手机号，点击 Next。如果顺利，你会进入下一步，填写验证码。如果你的加速器美国 IP 质量不行，这里就会提示你 “此电话号码无法用于验证”。遇到这个提示，建议，切换一个优质美国 IP，在操作。</p>
<p><a target="_blank" rel="noopener" href="https://blog.aftss.cn/wp-content/uploads/2022/09/e4da3b7fbbce234-21.jpg"><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/e4da3b7fbbce234-21.jpg" alt="img"></a></p>
<p>6、输入手机收到的验证码，点击 “verify”。</p>
<p><a target="_blank" rel="noopener" href="https://blog.aftss.cn/wp-content/uploads/2022/09/1679091c5a880fa-18.jpg"><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/1679091c5a880fa-18.jpg" alt="img"></a></p>
<p>7、这个界面，我们只需要填写出生日期即可，别的可不填。出生日期，大家一定要选择成年的年龄哦，别乱填，填好点 next。</p>
<p><a target="_blank" rel="noopener" href="https://blog.aftss.cn/wp-content/uploads/2022/09/8f14e45fceea167-16.jpg"><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/8f14e45fceea167-16.jpg" alt="img"></a></p>
<p>8、来到这个界面，我们不用管，直接点击 skip。</p>
<p><a target="_blank" rel="noopener" href="https://blog.aftss.cn/wp-content/uploads/2022/09/c9f0f895fb98ab9-11.jpg"><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/c9f0f895fb98ab9-11.jpg" alt="img"></a></p>
<p>9、隐私条款确认，我们点击 I agree。</p>
<p><a target="_blank" rel="noopener" href="https://blog.aftss.cn/wp-content/uploads/2022/09/45c48cce2e2d7fb-7.jpg"><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/45c48cce2e2d7fb-7.jpg" alt="img"></a></p>
<p>这个时候，你会发现，账号注册成功了，并且，页面会直接跳转到谷歌邮箱的界面。</p>
<h2 id="注册失败原因汇总"><a class="markdownIt-Anchor" href="#注册失败原因汇总">#</a> 注册失败原因汇总</h2>
<p>其实注册流程并不复杂，很简单，也就只需要几步。可是，国内的网友注册，总是无法注册成功。这里，把最容易导致注册失败的原因，给大家汇总一下，自己操作的时候就要注意了！</p>
<h3 id="1-手机号码注册过"><a class="markdownIt-Anchor" href="#1-手机号码注册过">#</a> 1、手机号码注册过</h3>
<p>你用来注册谷歌邮箱的手机号码，你自己之前注册过谷歌邮箱，再次注册有可能会出现无法注册的情况。虽然，谷歌没有说明一个手机能够不能注册多个账号，但是，我们最好还是不要用注册过的手机号。</p>
<h3 id="2-加速器ip质量不行"><a class="markdownIt-Anchor" href="#2-加速器ip质量不行">#</a> 2、加速器 IP 质量不行</h3>
<p>很多网友使用的加速器，IP 地址已经被人多次用来注册过谷歌邮箱了，到你注册的时候，早就被谷歌锁定了，识别你为恶意注册。这种情况，自然无法成功注册。那么，怎么才算高质量的 IP 地址呢？我们尽量使用那些没怎么被人用过的 IP，冷僻的线路即可。</p>
<h3 id="3-语言没设置"><a class="markdownIt-Anchor" href="#3-语言没设置">#</a> 3、语言没设置</h3>
<p>大家看教程，应该知道，我注册的时候是设置了英语的。再加上使用的 IP 为美国，这样自然，谷歌会认为我是一个美国人在注册，审核机制自然就成了美区的审核机制，没那么严格，成功率会高一些。</p>
<h3 id="4-如果以上都不行那么建议使用-iphone-手机注册一下试试很大几率可以成功"><a class="markdownIt-Anchor" href="#4-如果以上都不行那么建议使用-iphone-手机注册一下试试很大几率可以成功">#</a> 4、如果以上都不行，那么建议使用 IPHONE 手机注册一下试试，很大几率可以成功！</h3>
<h2 id="关于我"><a class="markdownIt-Anchor" href="#关于我">#</a> 关于我</h2>
<p>Brath 是一个热爱技术的 <code>Java</code>  程序猿，公众号「InterviewCoder」定期分享有趣有料的精品原创文章！</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa31569d28cd4d5baa3a7168d4021f37~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png" alt="InterviewCoder"> 非常感谢各位人才能看到这里，原创不易，文章如果有帮助可以关注、点赞、分享或评论，这都是对我的莫大支持！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-04-20T06:02:20.183Z" title="2023-4-20 14:02:20">2023-04-20</time>发表</span><span class="level-item"><time dateTime="2023-04-20T06:01:26.621Z" title="2023-4-20 14:01:26">2023-04-20</time>更新</span><span class="level-item">28 分钟读完 (大约4168个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/04/20/%E3%80%90Git%E3%80%91SVN&amp;Git%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/">SVN&amp;Git使用手册</a></p><div class="content"><p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png" alt="InterviewCoder"></p>
<p>切记 代码是先更新再提交.<br>
（一）SVN 和 GIt 区别<br>
 1．基本<br>
 SVN 是集中式版本控制工具<br>
 git 是分布式版本控制工具</p>
<p>2．SVN 和 Git 优缺点<br>
 svn 优点:<br>
1. 方便管理者查看每个开发者开发进度<br>
 2. 方便对开发者进行权限控制<br>
 svn 缺点:<br>
1. 严重依赖网络环境进行版本控制<br>
 2. 中央服务器宕机，无法进行版本控制<br>
 3. 中央服务器磁盘损坏，丢失历史版本内容<br>
 Git 优点:<br>
1. 很完美的解决了 SVN 存在的缺点</p>
<p>TortoiseGit 小乌龟<br>
给当前项目提交到码云上<br>
 1. 用浏览器登录码云，在码云上创建一个仓库<br>
 2. 打开 TortoiseGit 软件<br>
 3. 新建一个文件夹改好名字 (注意是空文件夹)<br>
 4. 右键文件夹–&gt;Git 克隆…–&gt; 弹出如下图–&gt; 粘贴好 url<br>
5. 点击确定就可以了</p>
<p>6. 然后就给你自己的代码放入刚才的文件夹下，然后就点击推送等等.<br>
2．设置用户名和邮箱</p>
<p>直接设置即可。签名密钥不需要管</p>
<p>Git 使用笔记<br>
（一）概念<br>
 1．什么是版本控制</p>
<p>版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 除了项目源代码，你可以对任何类型的文件进行版本控制。</p>
<p>2．为什么要版本控制<br>
有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。<br>
许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易犯错。 有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。<br>
为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。<br>
3．集中化的版本控制系统<br>
接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？ 于是，集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）应运而生。<br>
集中化的版本控制系统都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。<br>
这么做虽然解决了本地版本控制系统无法让在不同系统上的开发者协同工作的诟病，但也还是存在下面的问题：</p>
<p>单点故障： 中央服务器宕机，则其他人无法使用；如果中心数据库磁盘损坏有没有进行备份，你将丢失所有数据。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。</p>
<p>必须联网才能工作： 受网络状况、带宽影响。</p>
<p>4．分布式版本控制系统<br>
于是分布式版本控制系统（Distributed Version Control System，简称 DVCS）面世了。 Git 就是一个典型的分布式版本控制系统。<br>
这类系统，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。<br>
分布式版本控制系统可以不用联网就可以工作，因为每个人的电脑上都是完整的版本库，当你修改了某个文件后，你只需要将自己的修改推送给别人就可以了。但是，在实际使用分布式版本控制系统的时候，很少会直接进行推送修改，而是使用一台充当 “中央服务器” 的东西。这个服务器的作用仅仅是用来方便 “交换” 大家的修改，没有它大家也一样干活，只是交换修改不方便而已。<br>
分布式版本控制系统的优势不单是不必联网这么简单，后面我们还会看到 Git 极其强大的分支管理等功能。<br>
5．Git 与其他版本管理系统的主要区别<br>
 Git 在保存和对待各种信息的时候与其它版本控制系统有很大差异，尽管操作起来的命令形式非常相近，理解这些差异将有助于防止你使用中的困惑。<br>
下面我们主要说一个关于 Git 其他版本管理系统的主要差别：对待数据的方式。<br>
Git 采用的是直接记录快照的方式，而非差异比较。我后面会详细介绍这两种方式的差别。<br>
大部分版本控制系统（CVS、Subversion、Perforce、Bazaar 等等）都是以文件变更列表的方式存储信息，这类系统将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。<br>
具体原理如下图所示，理解起来其实很简单，每个我们对提交更新一个文件之后，系统记录都会记录这个文件做了哪些更新，以增量符号 Δ(Delta) 表示。</p>
<p>我们怎样才能得到一个文件的最终版本呢？<br>
很简单，高中数学的基本知识，我们只需要将这些原文件和这些增加进行相加就行了。<br>
这种方式有什么问题呢？<br>
比如我们的增量特别特别多的话，如果我们要得到最终的文件是不是会耗费时间和性能。<br>
Git 不按照以上方式对待或保存数据。 反之，Git 更像是把数据看作是对小型文件系统的一组快照。 每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 快照流。</p>
<p>6．使用 git 原因<br>
分布式版本控制工具<br>
为什么使用 git 呢？<br>
互联网项目，业务越来越复杂，项目越来越大，使用 SVN 版本控制不太好使了。<br>
从 git 目标，看 git 的优势 速度快、分布式、有能力管理大型项目</p>
<p>7．工作流程以及流程图</p>
<p>在工作目录中修改文件。<br>
暂存文件，将文件的快照放入暂存区域。<br>
提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。<br>
8．程序员工作流程<br>
项目经理：1 创建项目 2 项目添加本地暂存态 3 项目提交到本地 4 建立远程连接 5 推送代码到远程服务器<br>
程序员 A：1 克隆代码到本地 2 编写代码，将代码添加本地暂存态 3 代码提交本地 4 推送代码到服务器<br>
程序员 B：1 克隆代码到本地 2 编写代码，将代码添加本地暂存态 3 代码提交本地 4 推送代码到服务器 5 更新其他程序员提交的代码<br>
 9．git 三种状态</p>
<p>已提交（committed）：数据已经安全的保存在本地数据库中。</p>
<p>已修改（modified）：已修改表示修改了文件，但还没保存到数据库中。</p>
<p>已暂存（staged）：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</p>
<p>由此引入 Git 项目的三个工作区域的概念：Git 仓库 (.git directoty) 、工作目录 (Working Directory) 以及 暂存区域 (Staging Area) 。</p>
<p>（二）Git 分支<br>
 1．分支概念</p>
<p>几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。在很多版本控制系统中，这是个昂贵的过程，常常需要创建一个源代码目录的完整副本，对大型项目来说会花费很长时间。</p>
<p>有人把 Git 的分支模型称为 “必杀技特性”，而正是因为它，将 Git 从版本控制系统家族里区分出来。Git 有何特别之处呢？Git 的分支可谓是难以置信的轻量级，它的新建操作几乎可以在瞬间完成，并且在不同分支间切换起来也差不多一样快。和许多其他版本控制系统不同，Git 鼓励在工作流程中频繁使用分支与合并，哪怕一天之内进行许多次都没有关系。理解分支的概念并熟练运用后，你才会意识到为什么 Git 是一个如此强大而独特的工具，并从此真正改变你的开发方式。<br>
2．分支需求<br>
现在让我们来看一个简单的分支与合并的例子，实际工作中大体也会用到这样的工作流<br>
程：</p>
<p>开发某个网站。<br>
为实现某个新的需求，创建一个分支。<br>
在这个分支上开展工作。<br>
假设此时，你突然接到一个电话说有个很严重的问题需要紧急修补，那么可以按照下面的方<br>
式处理：<br>
返回到原先已经发布到生产服务器上的分支。<br>
为这次紧急修补建立一个新分支。<br>
测试通过后，将此修补分支合并，再推送到生产服务器上。<br>
切换到之前实现新需求的分支，继续工作。<br>
（三）git 指令<br>
 1．创建 git 目录<br>
 git init</p>
<p>创建 git 目录:<br>
 该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。(参见 Git 内部原理 来了解更多关于到底 .git 文件夹中包含了哪些文件的信息。)<br>
 2．克隆仓库<br>
 git clone [url]<br>
 克隆仓库的命令格式是 git clone [url] 。比如，要克隆 Git 的可链接库 libgit2，可以用下面的命令<br>
 $ git clone <a target="_blank" rel="noopener" href="https://github.com/libgit2/libgit2">https://github.com/libgit2/libgit2</a></p>
<p>这会在当前目录下创建一个名为 “libgit2” 的目录，并在这个目录下初始化一个 .git 文件夹，从远程仓库拉取下所有数据放入 .git 文件夹，然后从中读取最新版本的文件的拷贝。如果你进入到这个新建的 libgit2 文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。如果你想在克隆远程仓库的时<br>
候，自定义本地仓库的名字，你可以使用如下命令<br>
 $ git clone <a target="_blank" rel="noopener" href="https://github.com/libgit2/libgit2">https://github.com/libgit2/libgit2</a> mylibgit<br>
 这将执行与上一个命令相同的操作，不过在本地创建的仓库名字变为 mylibgit<br>
3．查看文件状态<br>
 git status<br>
 要查看哪些文件处于什么状态，可以用 git status 命令。如果在克隆仓库后立即使用此命令，会看到类似这<br>
样的输出.</p>
<p>跟踪新文件</p>
<p>（四）使用<br>
 1．安装 git</p>
<p><a target="_blank" rel="noopener" href="http://note.youdao.com/noteshare?id=448878ab8bdba693717f8967e6aa6a4f">http://note.youdao.com/noteshare?id=448878ab8bdba693717f8967e6aa6a4f</a></p>
<p>2．将项目上传到码云上</p>
<p>如果账户已经配置好，git 客户端也安装好，在将要上传的文件中，右键打开 Git Bash Here, 按如下步骤即可：<br>
1.git init<br>
2.git remote add origin “你的码云项目地址（ssh 或 https）”<br>
 开始提交项目<br>
 3.git pull origin master 如果密码报错看下面<br>
 4.git touch init .txt  // 如果已经存在更改的文件，则操作这一步，否则跳过即可<br>
 5.git add .<br>
6.git commit -m “第一次提交（提交信息）”<br>
7.git push origin master<br>
 如出现错误 hint: Updates were rejected because the tip of your current branch is behind<br>
hint: its remote counterpart. Integrate the remote changes (e.g.<br>
hint: ‘git pull …’) before pushing again.<br>
hint: See the ‘Note about fast-forwards’ in ‘git push --help’ for details.<br>
 可执行此操作继续，git push -u origin master -f  强制命令会覆盖别人分支，慎用</p>
<p>密码报错在这里进行修改</p>
<p>3．用 git 从 github 上下载代码</p>
<p>新建一个文件夹，放你需要下载的东西。右键点击 “Git Bash Here”</p>
<p>此时会弹出 git 的命令窗口</p>
<p>3、输入  git clone + 下载地址，回车即可。如   git clone <a target="_blank" rel="noopener" href="https://github.comxxx.git">https://github.comxxx.git</a><br>
 等待下载</p>
<p>下载好之后，文件夹里就会出现相应的项目啦～</p>
<p>（五）GitGUI 操作<br>
 1．使用 gui 上传代码到码云上<br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33867131/article/details/80831491"> https://blog.csdn.net/qq_33867131/article/details/80831491</a></p>
<p>SVN 的基本使用<br>
（一）基本简介<br>
开源的版本控制系统，可以用来保存代码，同步代码，也可以保存图片文档电影什么的.<br>
 主要作用就是可以随时进行代码同步。但是会存在一些问题，会有一些解决方案<br>
（二）服务端创建仓库<br>
 1．搭建仓库，添加用户</p>
<p><a target="_blank" rel="noopener" href="http://note.youdao.com/noteshare?id=549663e56580a3643bbcc9104c357226">http://note.youdao.com/noteshare?id=549663e56580a3643bbcc9104c357226</a></p>
<p>2．分配权限</p>
<p>创建好用户后，用户还是不能访问我们的仓库，接下来我们要给用户分个组（如果想让用户不进组也能访问仓库，可以直接给单个用户权限</p>
<p>3．给代码放到 svn 上面</p>
<p>然后复制仓库地址</p>
<p>在你要上传的项目右键</p>
<p>然后点击确定</p>
<p>（三）错误解决<br>
 1．代码错乱问题<br>
去查看日志，下载正确的时间段的代码，然后再创建新的仓库，放那个代码，原来的仓库就删除掉就可以了.</p>
<p>2．No appropriate protocol<br>
 公司的 SVN 协议从 svn 协议变更到 https 协议，结果 IDEA 的 SVN 报 No appropriate protocol，查询资料，最终解决方案是：<br>
Go to Preferences &gt; Version Control &gt; SubVersion &gt; Enable Interactive Mode<br>
3．versionControl 里面找不到 subversion 选项<br>
去安装 svnToolBox 插件 即可解决</p>
<h2 id="关于我"><a class="markdownIt-Anchor" href="#关于我">#</a> 关于我</h2>
<p>Brath 是一个热爱技术的 Java 程序猿，公众号「InterviewCoder」定期分享有趣有料的精品原创文章！</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png" alt="InterviewCoder"></p>
<p>非常感谢各位人才能看到这里，原创不易，文章如果有帮助可以关注、点赞、分享或评论，这都是对我的莫大支持！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-04-20T06:02:20.179Z" title="2023-4-20 14:02:20">2023-04-20</time>发表</span><span class="level-item"><time dateTime="2023-04-20T06:01:26.615Z" title="2023-4-20 14:01:26">2023-04-20</time>更新</span><span class="level-item">3 分钟读完 (大约480个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/04/20/%E3%80%90Git%E3%80%91Github%E8%AE%BF%E9%97%AE%E5%8A%A0%E9%80%9F/">Github访问加速方法</a></p><div class="content"><p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png" alt="InterviewCoder"></p>
<h2 id="1-获取延迟最小ip地址"><a class="markdownIt-Anchor" href="#1-获取延迟最小ip地址">#</a> 1. 获取延迟最小 IP 地址</h2>
<p>首先，打开</p>
<p><a target="_blank" rel="noopener" href="http://tool.chinaz.com/dns?type=1&amp;host=github.com&amp;ip=">http://tool.chinaz.com/dns?type=1&amp;host=github.com&amp;ip=</a></p>
<p>查询 Github 的地址，选择延迟最小的</p>
<p><img src="E:%5Cmd%E5%9B%BE%E7%89%87%5C1640222585966.png" alt="1640222585966"></p>
<h2 id="2-修改系统hosts文件"><a class="markdownIt-Anchor" href="#2-修改系统hosts文件">#</a> <strong>2. 修改系统 Hosts 文件</strong></h2>
<p>接着，打开系统 hosts 文件 (需管理员权限)。<br>
路径：C:\Windows\System32\drivers\etc</p>
<blockquote>
<p>mac 或者其他 linux 系统的话，是 /etc 下的 hosts 文件，需要切入到 root 用户修改</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># Copyright (c) 1993-2009 Microsoft Corp. </span><br><span class="line"># </span><br><span class="line"># This is a sample HOSTS file used by Microsoft TCP/IP for Windows. </span><br><span class="line"># </span><br><span class="line"># This file contains the mappings of IP addresses to host names. Each </span><br><span class="line"># entry should be kept on an individual line. The IP address should </span><br><span class="line"># be placed in the first column followed by the corresponding host name. </span><br><span class="line"># The IP address and the host name should be separated by at least one </span><br><span class="line"># space. </span><br><span class="line"># </span><br><span class="line"># Additionally, comments (such as these) may be inserted on individual </span><br><span class="line"># lines or following the machine name denoted by a &#x27;#&#x27; symbol. </span><br><span class="line"># </span><br><span class="line"># For example: </span><br><span class="line"># </span><br><span class="line">#      102.54.94.97     rhino.acme.com          # source server </span><br><span class="line">#       38.25.63.10     x.acme.com              # x client host </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># localhost name resolution is handled within DNS itself. </span><br><span class="line">#   127.0.0.1       localhost </span><br><span class="line">#   ::1             localhost </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">52.192.72.89    github.com</span><br></pre></td></tr></table></figure>
<p>并在末尾添加记录并保存。(需管理员权限，注意 IP 地址与域名间需留有空格)</p>
<h2 id="3-刷新系统dns缓存"><a class="markdownIt-Anchor" href="#3-刷新系统dns缓存">#</a> <strong>3. 刷新系统 DNS 缓存</strong></h2>
<p>最后，Windows+X 打开系统命令行（管理员身份）或 powershell</p>
<p>运行 ipconfig /flushdns 手动刷新系统 DNS 缓存。</p>
<blockquote>
<p>mac 系统修改完 hosts 文件，保存并退出就可以了。不要要多一步刷新操作.<br>
centos 系统执行 /etc/init.d/network restart 命令 使得 hosts 生效</p>
</blockquote>
<h2 id="关于我"><a class="markdownIt-Anchor" href="#关于我">#</a> 关于我</h2>
<p>Brath 是一个热爱技术的 Java 程序猿，公众号「InterviewCoder」定期分享有趣有料的精品原创文章！</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png" alt="InterviewCoder"></p>
<p>非常感谢各位人才能看到这里，原创不易，文章如果有帮助可以关注、点赞、分享或评论，这都是对我的莫大支持！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-04-20T06:02:20.175Z" title="2023-4-20 14:02:20">2023-04-20</time>发表</span><span class="level-item"><time dateTime="2023-04-20T06:01:26.607Z" title="2023-4-20 14:01:26">2023-04-20</time>更新</span><span class="level-item">4 分钟读完 (大约592个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/04/20/%E3%80%90Flutter%E3%80%91%E8%A7%A3%E5%86%B3%E5%8D%87%E7%BA%A7Flutter3.0%E5%90%8E%E5%87%BA%E7%8E%B0%E8%AD%A6%E5%91%8AOperand%20of%20null-aware%20operation%20%E2%80%98!%E2%80%98%20has%20type%20%E2%80%98WidgetsBinding%E2%80%98%20which%20excludes%20null/">【Flutter】解决升级Flutter3.0后出现警告Operand of null-aware operation ‘!‘ has type ‘WidgetsBinding‘ which excludes null</a></p><div class="content"><p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png" alt="InterviewCoder"></p>
<h1 id="flutter解决升级flutter30后出现警告operand-of-null-aware-operation-has-type-widgetsbinding-which-excludes-null"><a class="markdownIt-Anchor" href="#flutter解决升级flutter30后出现警告operand-of-null-aware-operation-has-type-widgetsbinding-which-excludes-null">#</a> 【Flutter】解决升级 Flutter3.0 后出现警告 Operand of null-aware operation ‘!‘ has type ‘WidgetsBinding‘ which excludes null</h1>
<h1 id="出现场景"><a class="markdownIt-Anchor" href="#出现场景">#</a> 出现场景</h1>
<p>将<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Flutter&amp;spm=1001.2101.3001.7020"> Flutter</a> SDK 升级到 3.0，运行时报以下警告。<br>
虽然不影响程序的运行，但是看着很烦。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lib/stress_test/stress_test_page.dart:120:22: Warning: Operand of null-aware operation <span class="string">&#x27;!&#x27;</span> has <span class="built_in">type</span> <span class="string">&#x27;WidgetsBinding&#x27;</span> <span class="built_in">which</span> excludes null.</span><br><span class="line"> - <span class="string">&#x27;WidgetsBinding&#x27;</span> is from <span class="string">&#x27;package:flutter/src/widgets/binding.dart&#x27;</span> (<span class="string">&#x27;../../develop_env/flutter_3.0/packages/flutter/lib/src/widgets/binding.dart&#x27;</span>).</span><br><span class="line">      WidgetsBinding.instance!.addPostFrameCallback((timeStamp) &#123;</span><br><span class="line">                     ^</span><br></pre></td></tr></table></figure>
<h1 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案">#</a> 解决方案</h1>
<p>这是因为在 Flutter 3.0 中，binding 的 instance 是不可为空的，所以不需要使用 <code>!</code> 。</p>
<p>下面有 2 种情况。</p>
<h2 id="三方依赖库"><a class="markdownIt-Anchor" href="#三方依赖库">#</a> 三方依赖库</h2>
<p>如果是依赖的库要使用到了 Binding.instance，去 pub 上看看库的新版本有没有兼容 3.0。如果有就升级库的版本。</p>
<p>比如我的项目用到了 getx 4.6.1，是 Flutter 3.0 出来之前的版本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">../../develop_env/flutter_3.0/.pub-cache/hosted/pub.flutter-io.cn/get-4.6.1/lib/get_state_manager/src/simple/get_controllers.dart:96:20: Warning: Operand of null-aware operation <span class="string">&#x27;!&#x27;</span> has <span class="built_in">type</span> <span class="string">&#x27;WidgetsBinding&#x27;</span> <span class="built_in">which</span> excludes null.</span><br><span class="line"> - <span class="string">&#x27;WidgetsBinding&#x27;</span> is from <span class="string">&#x27;package:flutter/src/widgets/binding.dart&#x27;</span> (<span class="string">&#x27;../../develop_env/flutter_3.0/packages/flutter/lib/src/widgets/binding.dart&#x27;</span>).</span><br><span class="line">    WidgetsBinding.instance!.removeObserver(this);</span><br><span class="line">                   ^</span><br></pre></td></tr></table></figure>
<p>去 pub 上查看更新记录 (changelog)，可以看到 4.6.2 兼容了 Flutter 3.0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[4.6.5] #</span><br><span class="line">Fix pub dev score</span><br><span class="line"></span><br><span class="line">[4.6.4] </span><br><span class="line">Added backward compatibility with flutter 2.</span><br><span class="line"></span><br><span class="line">[4.6.3] </span><br><span class="line">Fix SDK constraints</span><br><span class="line"></span><br><span class="line">[4.6.2] </span><br><span class="line">Added compatibility with flutter 3.0</span><br><span class="line"></span><br><span class="line">[4.6.1] </span><br><span class="line">Fix GetConnect on Flutter web</span><br></pre></td></tr></table></figure>
<p>所以我们只需要将 get 的版本更改为 4.6.2 或以上即可。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="comment"># get: ^4.6.1</span></span><br><span class="line">  <span class="attr">get:</span> <span class="string">^4.6.2</span></span><br></pre></td></tr></table></figure>
<h2 id="本地代码"><a class="markdownIt-Anchor" href="#本地代码">#</a> 本地代码</h2>
<p>如果是项目中有用到 Binding.instance，可以使用<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=dart&amp;spm=1001.2101.3001.7020"> dart</a> 命令 <code>dart fix --apply</code>  自动修复，这样就会自动把 instance 后面的 <code>!</code>  去掉。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">adodeMacBook-Pro:fusion_pro wangyang$ dart fix --apply</span><br><span class="line">Computing fixes <span class="keyword">in</span> fusion_pro... 105.4s</span><br><span class="line">Applying fixes...                      0.0s</span><br><span class="line"></span><br><span class="line">lib/pages/splash_page.dart</span><br><span class="line">  UNNECESSARY_NON_NULL_ASSERTION • 1 fix</span><br><span class="line"></span><br><span class="line">lib/stress_test/stress_test_page.dart</span><br><span class="line">  UNNECESSARY_NON_NULL_ASSERTION • 1 fix</span><br><span class="line"></span><br><span class="line">2 fixes made <span class="keyword">in</span> 2 files.</span><br></pre></td></tr></table></figure>
<h2 id="关于我"><a class="markdownIt-Anchor" href="#关于我">#</a> 关于我</h2>
<p>Brath 是一个热爱技术的 Java 程序猿，公众号「InterviewCoder」定期分享有趣有料的精品原创文章！</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png" alt="InterviewCoder"></p>
<p>非常感谢各位人才能看到这里，原创不易，文章如果有帮助可以关注、点赞、分享或评论，这都是对我的莫大支持！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-04-20T06:02:20.172Z" title="2023-4-20 14:02:20">2023-04-20</time>发表</span><span class="level-item"><time dateTime="2023-04-20T06:01:26.585Z" title="2023-4-20 14:01:26">2023-04-20</time>更新</span><span class="level-item">13 分钟读完 (大约1894个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/04/20/%E3%80%90Flutter%E3%80%91Flutter%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%A1%86%E6%9E%B6%EF%BC%9ABloc%E7%9A%84%E8%AE%A1%E6%95%B0%E5%99%A8%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B/">【Flutter】Flutter状态管理框架：Bloc的计数器应用示例</a></p><div class="content"><p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png" alt="InterviewCoder"></p>
<h1 id="flutterflutter状态管理框架bloc的计数器应用示例"><a class="markdownIt-Anchor" href="#flutterflutter状态管理框架bloc的计数器应用示例">#</a> 【Flutter】Flutter 状态管理框架：Bloc 的计数器应用示例</h1>
<h1 id="flutter-计数器教程"><a class="markdownIt-Anchor" href="#flutter-计数器教程">#</a> <a target="_blank" rel="noopener" href="https://bloclibrary.dev/#/zh-cn/fluttercountertutorial?id=flutter-%E8%AE%A1%E6%95%B0%E5%99%A8%E6%95%99%E7%A8%8B">Flutter 计数器教程</a></h1>
<p><img src="https://img.shields.io/badge/level-beginner-green.svg" alt="beginner"></p>
<blockquote>
<p>在下面的教程中，我们会使用 Flutter 和 Bloc 库来开发一个计数器应用。</p>
</blockquote>
<p><img src="https://bloclibrary.dev/assets/gifs/flutter_counter.gif" alt="demo"></p>
<h2 id="核心要点"><a class="markdownIt-Anchor" href="#核心要点">#</a> <a target="_blank" rel="noopener" href="https://bloclibrary.dev/#/zh-cn/fluttercountertutorial?id=%E6%A0%B8%E5%BF%83%E8%A6%81%E7%82%B9">核心要点</a></h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://bloclibrary.dev/#/coreconcepts?id=blocobserver">BlocObserver</a>：用于观察 Bloc 内状态变化的 Widget。</li>
<li><a target="_blank" rel="noopener" href="https://bloclibrary.dev/#/flutterbloccoreconcepts?id=blocprovider">BlocProvider</a>：为它的 children 提供 Bloc 的 Widget。</li>
<li><a target="_blank" rel="noopener" href="https://bloclibrary.dev/#/flutterbloccoreconcepts?id=blocbuilder">BlocBuilder</a>：根据新的 state 来绘制对应 Widget 的 Widget。</li>
<li>用 Cubit 替代 Bloc。<a target="_blank" rel="noopener" href="https://bloclibrary.dev/#/coreconcepts?id=cubit-vs-bloc">两者有何不同？</a></li>
<li>通过 <a target="_blank" rel="noopener" href="https://bloclibrary.dev/#/migration?id=%E2%9D%97contextbloc-and-contextrepository-are-deprecated-in-favor-of-contextread-and-contextwatch">context.read</a> 来触发 Event⚡。</li>
</ul>
<h2 id="新建项目和配置文件yaml"><a class="markdownIt-Anchor" href="#新建项目和配置文件yaml">#</a> <a target="_blank" rel="noopener" href="https://bloclibrary.dev/#/zh-cn/fluttercountertutorial?id=%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%92%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6yaml">新建项目和配置文件 yaml</a></h2>
<p>我们先新建一个全新的 flutter 应用</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter create flutter_counter</span><br></pre></td></tr></table></figure>
<p>将下面代码复制粘贴到  <code>pubspec.yaml</code>  文件中</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">flutter_counter</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">A</span> <span class="string">new</span> <span class="string">Flutter</span> <span class="string">project.</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">1.0</span><span class="number">.0</span><span class="string">+1</span></span><br><span class="line"><span class="attr">publish_to:</span> <span class="string">none</span></span><br><span class="line"></span><br><span class="line"><span class="attr">environment:</span></span><br><span class="line">  <span class="attr">sdk:</span> <span class="string">&quot;&gt;=2.19.0 &lt;3.0.0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="attr">bloc:</span> <span class="string">^8.1.0</span></span><br><span class="line">  <span class="attr">flutter:</span></span><br><span class="line">    <span class="attr">sdk:</span> <span class="string">flutter</span></span><br><span class="line">  <span class="attr">flutter_bloc:</span> <span class="string">^8.1.1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dev_dependencies:</span></span><br><span class="line">  <span class="attr">bloc_test:</span> <span class="string">^9.1.0</span></span><br><span class="line">  <span class="attr">flutter_test:</span></span><br><span class="line">    <span class="attr">sdk:</span> <span class="string">flutter</span></span><br><span class="line">  <span class="attr">integration_test:</span></span><br><span class="line">    <span class="attr">sdk:</span> <span class="string">flutter</span></span><br><span class="line">  <span class="attr">mocktail:</span> <span class="string">^0.3.0</span></span><br><span class="line">  <span class="attr">very_good_analysis:</span> <span class="string">^3.1.0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">flutter:</span></span><br><span class="line">  <span class="attr">uses-material-design:</span> <span class="literal">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>安装依赖包 package</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter packages get</span><br></pre></td></tr></table></figure>
<h2 id="项目架构"><a class="markdownIt-Anchor" href="#项目架构">#</a> <a target="_blank" rel="noopener" href="https://bloclibrary.dev/#/zh-cn/fluttercountertutorial?id=%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84">项目架构</a></h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">├── lib</span><br><span class="line">│   ├── app.dart</span><br><span class="line">│   ├── counter</span><br><span class="line">│   │   ├── counter.dart</span><br><span class="line">│   │   ├── cubit</span><br><span class="line">│   │   │   └── counter_cubit.dart</span><br><span class="line">│   │   └── view</span><br><span class="line">│   │       ├── counter_page.dart</span><br><span class="line">│   │       └── counter_view.dart</span><br><span class="line">│   ├── counter_observer.dart</span><br><span class="line">│   └── main.dart</span><br><span class="line">├── pubspec.lock</span><br><span class="line">├── pubspec.yaml</span><br></pre></td></tr></table></figure>
<p>这个应用中我们使用的是功能驱动（feature-driven）的项目结构。这种项目结构可以让我们通过一个个独立的功能来扩展项目。在当前项目中，我们只需要做一个功能（也就是计数器），但是在将来我们可以通过加入更多功能来实现一个复杂的应用。</p>
<h2 id="blocobserver"><a class="markdownIt-Anchor" href="#blocobserver">#</a> <a target="_blank" rel="noopener" href="https://bloclibrary.dev/#/zh-cn/fluttercountertutorial?id=blocobserver">BlocObserver</a></h2>
<p>首先，我们需要了解如何创建一个 <code>BlocObserver</code>  ， 它将帮助我们观察应用中所有的状态变化.</p>
<p>创建文件  <code>lib/counter_observer.dart</code> :</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:bloc/bloc.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">&#123;@template counter<span class="emphasis">_observer&#125;</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="emphasis">[BlocObserver] for the counter application which</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="emphasis">observes all state changes.</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="emphasis">&#123;@endtemplate&#125;</span></span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterObserver</span> <span class="keyword">extends</span> <span class="title">BlocObserver</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown"><span class="emphasis">&#123;@macro counter_</span>observer&#125;</span></span></span><br><span class="line">  <span class="keyword">const</span> CounterObserver();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> onChange(BlocBase&lt;<span class="built_in">dynamic</span>&gt; bloc, Change&lt;<span class="built_in">dynamic</span>&gt; change) &#123;</span><br><span class="line">    <span class="keyword">super</span>.onChange(bloc, change);</span><br><span class="line">    <span class="comment">// ignore: avoid_print</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;<span class="subst">$&#123;bloc.runtimeType&#125;</span> <span class="subst">$change</span>&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这个文件中，我们只重写了  <code>onChange</code> ，用来查看所有产生的状态（state）变化</p>
<p><strong>注意</strong>:  <code>onChange</code>  在  <code>Bloc</code>  和  <code>Cubit</code>  中发挥的作用是相同的。</p>
<h2 id="maindart"><a class="markdownIt-Anchor" href="#maindart">#</a> <a target="_blank" rel="noopener" href="https://bloclibrary.dev/#/zh-cn/fluttercountertutorial?id=maindart">main.dart</a></h2>
<p>接下来，用下面的代码替换 <code>main.dart</code>  里面的内容:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:bloc/bloc.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/widgets.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter_counter/app.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter_counter/counter_observer.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  Bloc.observer = <span class="keyword">const</span> CounterObserver();</span><br><span class="line">  runApp(<span class="keyword">const</span> CounterApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们初始化了之前创建的  <code>CounterObserver</code>  并且通过  <code>runApp</code>  调用我们即将创建的 <code>CounterApp</code> 。</p>
<h2 id="counter-app"><a class="markdownIt-Anchor" href="#counter-app">#</a> <a target="_blank" rel="noopener" href="https://bloclibrary.dev/#/zh-cn/fluttercountertutorial?id=counter-app">Counter App</a></h2>
<p>创建  <code>lib/app.dart</code> :</p>
<p><code>CounterApp</code>  是一个 <code>home</code>  是 <code>CounterPage</code>  的 <code>MaterialApp</code> 。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter_counter/counter/counter.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">&#123;@template counter<span class="emphasis">_app&#125;</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="emphasis">A [MaterialApp] which sets the `home` to [CounterPage].</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="emphasis">&#123;@endtemplate&#125;</span></span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterApp</span> <span class="keyword">extends</span> <span class="title">MaterialApp</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown"><span class="emphasis">&#123;@macro counter_</span>app&#125;</span></span></span><br><span class="line">  <span class="keyword">const</span> CounterApp(&#123;<span class="keyword">super</span>.key&#125;) : <span class="keyword">super</span>(home: <span class="keyword">const</span> CounterPage());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>:  <code>CounterApp</code>  扩展（extends) 自 <code>MaterialApp</code> ，所以在这里它是一个 <code>MaterialApp</code> 。 在大多数的情况下，我们会创建一个 <code>StatelessWidget</code>  或者  <code>StatefulWidget</code>  实例，并且通过 <code>build</code>  来绘制 Widget。但是现在我们并不需要绘制任何 Widget，所以我们直接从 <code>MaterialApp</code>  进行扩展（extends)，这样更简单。</p>
<p>接下来，让我们来看下  <code>CounterPage</code> !</p>
<h2 id="counter-page"><a class="markdownIt-Anchor" href="#counter-page">#</a> <a target="_blank" rel="noopener" href="https://bloclibrary.dev/#/zh-cn/fluttercountertutorial?id=counter-page">Counter Page</a></h2>
<p>创建  <code>lib/counter/view/counter_page.dart</code> :</p>
<p><code>CounterPage</code>  是用来创建一个  <code>CounterCubit</code>  实例 (也就是接下来我们要创建的类的实例) 并把它提供给  <code>CounterView</code>  使用。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter_bloc/flutter_bloc.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter_counter/counter/counter.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">&#123;@template counter<span class="emphasis">_page&#125;</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="emphasis">A [StatelessWidget] which is responsible for providing a</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="emphasis">[CounterCubit] instance to the [CounterView].</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="emphasis">&#123;@endtemplate&#125;</span></span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown"><span class="emphasis">&#123;@macro counter_</span>page&#125;</span></span></span><br><span class="line">  <span class="keyword">const</span> CounterPage(&#123;<span class="keyword">super</span>.key&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> BlocProvider(</span><br><span class="line">      create: (_) =&gt; CounterCubit(),</span><br><span class="line">      child: <span class="keyword">const</span> CounterView(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：分离（或者解耦） <code>Cubit</code>  创建部分的代码和  <code>Cubit</code>  使用部分的代码是非常重要的。这样使得代码更容易被测试或者被重复使用。</p>
<h2 id="counter-cubit"><a class="markdownIt-Anchor" href="#counter-cubit">#</a> <a target="_blank" rel="noopener" href="https://bloclibrary.dev/#/zh-cn/fluttercountertutorial?id=counter-cubit">Counter Cubit</a></h2>
<p>创建  <code>lib/counter/cubit/counter_cubit.dart</code> :</p>
<p><code>CounterCubit</code>  类将提供两种方法:</p>
<ul>
<li><code>increment</code> : 给当前状态（state）加 1</li>
<li><code>decrement</code> : 给当前状态（state）减 1</li>
</ul>
<p>设置  <code>CounterCubit</code>  状态的数据类型为  <code>int</code> ， 初始值是  <code>0</code> 。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:bloc/bloc.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">&#123;@template counter<span class="emphasis">_cubit&#125;</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="emphasis">A [Cubit] which manages an [int] as its state.</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="emphasis">&#123;@endtemplate&#125;</span></span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterCubit</span> <span class="keyword">extends</span> <span class="title">Cubit</span>&lt;<span class="title">int</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown"><span class="emphasis">&#123;@macro counter_</span>cubit&#125;</span></span></span><br><span class="line">  CounterCubit() : <span class="keyword">super</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Add 1 to the current state.</span></span></span><br><span class="line">  <span class="keyword">void</span> increment() =&gt; emit(state + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Subtract 1 from the current state.</span></span></span><br><span class="line">  <span class="keyword">void</span> decrement() =&gt; emit(state - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>小贴士</strong>：可以使用 <a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=FelixAngelov.bloc">VSCode Extension</a> 或者 <a target="_blank" rel="noopener" href="https://plugins.jetbrains.com/plugin/12129-bloc">IntelliJ Plugin</a> 自动创建新的 Cubit。</p>
<p>接下来我们来写 <code>CounterView</code> ，它将使用 state 并且和 <code>CounterCubit</code>  交互。</p>
<h2 id="counter-view"><a class="markdownIt-Anchor" href="#counter-view">#</a> <a target="_blank" rel="noopener" href="https://bloclibrary.dev/#/zh-cn/fluttercountertutorial?id=counter-view">Counter View</a></h2>
<p>创建  <code>lib/counter/view/counter_view.dart</code> :</p>
<p><code>CounterView</code>  是用来绘制计数器上的数字以及两个用于增加和减少数字的 FloatingActionButtons。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter_bloc/flutter_bloc.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter_counter/counter/counter.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">&#123;@template counter<span class="emphasis">_view&#125;</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="emphasis">A [StatelessWidget] which reacts to the provided</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="emphasis">[CounterCubit] state and notifies it in response to user input.</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="emphasis">&#123;@endtemplate&#125;</span></span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterView</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown"><span class="emphasis">&#123;@macro counter_</span>view&#125;</span></span></span><br><span class="line">  <span class="keyword">const</span> CounterView(&#123;<span class="keyword">super</span>.key&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> textTheme = Theme.of(context).textTheme;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(title: <span class="keyword">const</span> Text(<span class="string">&#x27;Counter&#x27;</span>)),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: BlocBuilder&lt;CounterCubit, <span class="built_in">int</span>&gt;(</span><br><span class="line">          builder: (context, state) &#123;</span><br><span class="line">            <span class="keyword">return</span> Text(<span class="string">&#x27;<span class="subst">$state</span>&#x27;</span>, style: textTheme.displayMedium);</span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: Column(</span><br><span class="line">        mainAxisAlignment: MainAxisAlignment.end,</span><br><span class="line">        crossAxisAlignment: CrossAxisAlignment.end,</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          FloatingActionButton(</span><br><span class="line">            key: <span class="keyword">const</span> Key(<span class="string">&#x27;counterView_increment_floatingActionButton&#x27;</span>),</span><br><span class="line">            child: <span class="keyword">const</span> Icon(Icons.add),</span><br><span class="line">            onPressed: () =&gt; context.read&lt;CounterCubit&gt;().increment(),</span><br><span class="line">          ),</span><br><span class="line">          <span class="keyword">const</span> SizedBox(height: <span class="number">8</span>),</span><br><span class="line">          FloatingActionButton(</span><br><span class="line">            key: <span class="keyword">const</span> Key(<span class="string">&#x27;counterView_decrement_floatingActionButton&#x27;</span>),</span><br><span class="line">            child: <span class="keyword">const</span> Icon(Icons.remove),</span><br><span class="line">            onPressed: () =&gt; context.read&lt;CounterCubit&gt;().decrement(),</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>用 <code>BlocBuilder</code>  把  <code>Text</code>  包起来，这样每一次 <code>CounterCubit</code>  状态变化的时候里面的文字就会更新。 另外，使用 <code>context.read&lt;CounterCubit&gt;()</code>  来接入 <code>CounterCubit</code>  实例。</p>
<p><strong>注意</strong>：只有  <code>Text</code>  需要被  <code>BlocBuilder</code>  包起来，因为这是唯一一个会随着  <code>CounterCubit</code>  状态（state) 变化而变化的组件。请不要包裹任何不随状态（state) 改变而改变的 Widget， 从而避免绘制不必要的组件。</p>
<h2 id="barrel"><a class="markdownIt-Anchor" href="#barrel">#</a> <a target="_blank" rel="noopener" href="https://bloclibrary.dev/#/zh-cn/fluttercountertutorial?id=barrel">Barrel</a></h2>
<p>创建  <code>lib/counter/counter.dart</code> :</p>
<p>加入  <code>counter.dart</code>  用来导出所有有关计数器的公共接口。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="string">&#x27;cubit/counter_cubit.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="string">&#x27;view/view.dart&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>大功告成！我们已经将表现层（presentation layer）从数据逻辑层（business logic layer）中分离出来。 <code>CounterView</code>  不会知道用户点击按钮的时候发生了什么，它只是通知了  <code>CounterCubit</code> 。 而且，  <code>CounterCubit</code>  不会知道状态（也就是计数器的值）是什么， 它只是根据被调用的方法来发出新的状态。</p>
<p>最后，通过执行  <code>flutter run</code>  让我们在真实设备或者模拟器上运行它。</p>
<h2 id="关于我"><a class="markdownIt-Anchor" href="#关于我">#</a> 关于我</h2>
<p>Brath 是一个热爱技术的 Java 程序猿，公众号「InterviewCoder」定期分享有趣有料的精品原创文章！</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png" alt="InterviewCoder"></p>
<p>非常感谢各位人才能看到这里，原创不易，文章如果有帮助可以关注、点赞、分享或评论，这都是对我的莫大支持！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-04-20T06:02:20.168Z" title="2023-4-20 14:02:20">2023-04-20</time>发表</span><span class="level-item"><time dateTime="2023-04-20T06:01:26.595Z" title="2023-4-20 14:01:26">2023-04-20</time>更新</span><span class="level-item">2 分钟读完 (大约319个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/04/20/%E3%80%90Flutter%E3%80%91Flutter%E9%87%8D%E5%A4%8D%E8%BF%9B%E5%85%A5%E9%A1%B5%E9%9D%A2GIF%E4%B8%8D%E5%8A%A0%E8%BD%BD%E9%97%AE%E9%A2%98/">Flutter下加载本地资源GIF，怎么做到每次进入页面都会出现动画效果？</a></p><div class="content"><p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png" alt="InterviewCoder"></p>
<p>1. 问题：Flutter 加载 GIF 之后，只有第一次进入页面才会执行动画，接下来都不会执行了<br>
 2. 原因：因为 Flutter 的图片缓存机制，在第一次加载图片后，会将图片缓存下来，所以再次访问，你看见的还是上次的已经执行完毕的动画<br>
 3. 解决：在 dispose 中把 imageCache 用 clear 方法清理掉</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> asset = <span class="string">&quot;images/401.gif&quot;</span>;</span><br><span class="line">Widget img = Image.asset(<span class="string">&quot;images/401.gif&quot;</span>,key: UniqueKey(),);</span><br><span class="line"></span><br><span class="line"> <span class="meta">@override</span></span><br><span class="line"> <span class="keyword">void</span> initState() &#123;</span><br><span class="line">   <span class="keyword">super</span>.initState();</span><br><span class="line">     <span class="comment">//初始化</span></span><br><span class="line">   toast();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@override</span></span><br><span class="line"> <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">   <span class="keyword">super</span>.dispose();</span><br><span class="line">     <span class="comment">//清理缓存</span></span><br><span class="line">	imageCache!.clear();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span> toast() &#123;</span><br><span class="line">   DialogUtils.showErrorMessage(<span class="string">&quot;401&quot;</span>,</span><br><span class="line">       gravity: ToastGravity.CENTER, toastLength: Toast.LENGTH_SHORT);</span><br><span class="line"></span><br><span class="line">   Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">3</span>), () &#123;</span><br><span class="line">     DialogUtils.showMessage(<span class="string">&quot;您没有权限访问......&quot;</span>,</span><br><span class="line">         gravity: ToastGravity.CENTER, toastLength: Toast.LENGTH_LONG);</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="关于我"><a class="markdownIt-Anchor" href="#关于我">#</a> 关于我</h2>
<p>Brath 是一个热爱技术的 Java 程序猿，公众号「InterviewCoder」定期分享有趣有料的精品原创文章！</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png" alt="InterviewCoder"></p>
<p>非常感谢各位人才能看到这里，原创不易，文章如果有帮助可以关注、点赞、分享或评论，这都是对我的莫大支持！</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/8/">上一页</a></div><div class="pagination-next"><a href="/page/10/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/8/">8</a></li><li><a class="pagination-link is-current" href="/page/9/">9</a></li><li><a class="pagination-link" href="/page/10/">10</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/13/">13</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-26T00:59:24.590Z">2023-04-26</time></p><p class="title"><a href="/2023/04/26/%E3%80%90DDD%E3%80%91DDD%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%E4%B8%8E%E4%BC%A0%E7%BB%9F%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E7%9A%84%E5%8C%BA%E5%88%AB/">【DDD】DDD分层架构与传统三层架构的区别</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-21T01:04:21.063Z">2023-04-21</time></p><p class="title"><a href="/2023/04/21/%E3%80%90NodeJS%E3%80%91Windows%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%A6%82%E4%BD%95%E5%81%9ANode%E5%A4%9A%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%EF%BC%9F/">【NodeJS】Windows环境下如何做Node多版本管理？</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-20T06:52:53.490Z">2023-04-20</time></p><p class="title"><a href="/2023/04/20/%E3%80%90HEXO%E3%80%91%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/">【HEXO】使用Hexo搭建属于自己的博客</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-20T06:02:20.463Z">2023-04-20</time></p><p class="title"><a href="/2023/04/20/%E3%80%90%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E3%80%91%E8%85%BE%E8%AE%AF%E4%BA%91%E7%94%B3%E8%AF%B7%E7%9A%84%E5%85%8D%E8%B4%B9%E8%AF%81%E4%B9%A6%E9%83%A8%E7%BD%B2%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91CDN%E5%92%8C%E4%BA%91%E7%9B%BE%E8%AF%81%E4%B9%A6%E4%B8%AD%E5%BF%83/">腾讯云申请的免费证书部署到阿里云CDN和云盾证书中心</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-20T06:02:20.459Z">2023-04-20</time></p><p class="title"><a href="/2023/04/20/%E3%80%90%E5%A4%96%E8%AE%BE%E3%80%91%E6%9C%BA%E6%A2%B0%E9%94%AE%E7%9B%98%E8%BD%B4%E4%BD%93%E6%80%8E%E4%B9%88%E9%80%89%EF%BC%9F%E4%B8%89%E6%A8%A1%E7%83%AD%E6%8F%92%E6%8B%94%E5%8E%9F%E6%9D%A5%E6%98%AF%E8%BF%99%E4%B9%88%E5%9B%9E%E4%BA%8B/">【外设】机械键盘轴体怎么选？三模热插拔原来是这么回事</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">121</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png" alt="InterviewCoder"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">InterviewCoder</p><p class="is-size-6 is-block">面试记官方公众号</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">121</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://mp.weixin.qq.com/s/jWs6lLHl5L-atXJhHc4YvA" target="_blank" rel="noopener">关注我</a></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://brath.cloud/me.png" alt="Brath"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Brath</p><p class="is-size-6 is-block">技能改变人生，知识改变命运。</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·江苏·无锡</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">121</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Guoqing815" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Guoqing815"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Gitee" href="https://gitee.com/Guoqing-Li"><i class="fab fa-gitee"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://schokolade.cn/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">泠灵(特别呜谢)</span></span><span class="level-right"><span class="level-item tag">schokolade.cn</span></span></a></li><li><a class="level is-mobile" href="https://gitee.com/Guoqing-Li" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Gitee(码云)</span></span><span class="level-right"><span class="level-item tag">gitee.com</span></span></a></li><li><a class="level is-mobile" href="https://blog.csdn.net/Brath?type=blog" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">CSDN</span></span><span class="level-right"><span class="level-item tag">blog.csdn.net</span></span></a></li><li><a class="level is-mobile" href="https://juejin.cn/user/settings/profile" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">掘金</span></span><span class="level-right"><span class="level-item tag">juejin.cn</span></span></a></li><li><a class="level is-mobile" href="https://oss.console.aliyun.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">AliCloud(阿里云)</span></span><span class="level-right"><span class="level-item tag">oss.console.aliyun.com</span></span></a></li><li><a class="level is-mobile" href="https://cloud.tencent.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">TencentCloud(腾讯云)</span></span><span class="level-right"><span class="level-item tag">cloud.tencent.com</span></span></a></li><li><a class="level is-mobile" href="https://www.zhipin.com/web/user/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">BOSS</span></span><span class="level-right"><span class="level-item tag">www.zhipin.com</span></span></a></li><li><a class="level is-mobile" href="https://www.bilibili.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bilibili(B站)</span></span><span class="level-right"><span class="level-item tag">www.bilibili.com</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://brath.cloud/me.png" alt="Brath-Blog" height="28"></a><p class="is-size-7"><span>&copy; 2023 Brath</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p><p class="is-size-7">© 2029</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>