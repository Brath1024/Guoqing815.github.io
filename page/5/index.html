<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Brath-Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Brath-Blog"><meta name="msapplication-TileImage" content="https://brath.cloud/me.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Brath-Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Brath-Blog"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="Brath-Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="Brath"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"Brath-Blog","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"Brath"},"publisher":{"@type":"Organization","name":"Brath-Blog","logo":{"@type":"ImageObject","url":"https://brath.cloud/me.png"}},"description":""}</script><link rel="icon" href="https://brath.cloud/me.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://brath.cloud/me.png" alt="Brath-Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">文章列表</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">更多</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Guoqing815"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-01-06T01:27:00.332Z" title="2023-1-6 9:27:00">2023-01-06</time>发表</span><span class="level-item"><time dateTime="2023-01-06T01:27:56.322Z" title="2023-1-6 9:27:56">2023-01-06</time>更新</span><span class="level-item">1 小时读完 (大约10473个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/06/%E3%80%90Java%E3%80%91Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0(%E5%90%90%E8%A1%80%E8%B6%85%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93)/">Java多线程学习（吐血超详细总结）</a></p><div class="content"><h1 id="java多线程学习吐血超详细总结"><a class="markdownIt-Anchor" href="#java多线程学习吐血超详细总结">#</a> Java 多线程学习（吐血超详细总结）</h1>
<p>写在前面的话：此文只能说是 java<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&amp;spm=1001.2101.3001.7020"> 多线程</a>的一个入门，其实 Java 里头线程完全可以写一本书了，但是如果最基本的你都学掌握好，又怎么能更上一个台阶呢？如果你觉得此文很简单，那推荐你看看 Java 并发包的的线程池（<a target="_blank" rel="noopener" href="http://blog.csdn.net/evankaka/article/details/51489322">Java 并发编程与技术内幕：线程池深入理解</a>），或者看这个专栏：<a target="_blank" rel="noopener" href="http://blog.csdn.net/column/details/javahhighconcurrence.html">Java 并发编程与技术内幕</a>。你将会对 Java 里头的高并发场景下的线程有更加深刻的理解。</p>
<p>目录<a target="_blank" rel="noopener" href="http://blog.csdn.net/evankaka/article/details/44153709#"> (?)</a>[<a target="_blank" rel="noopener" href="http://blog.csdn.net/evankaka/article/details/44153709#">-]</a></p>
<ol>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/evankaka/article/details/44153709#t0">一扩展 javalangThread 类</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/evankaka/article/details/44153709#t1">二实现 javalangRunnable 接口</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/evankaka/article/details/44153709#t2">三 Thread 和 Runnable 的区别</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/evankaka/article/details/44153709#t3">四线程状态转换</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/evankaka/article/details/44153709#t4">五线程调度</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/evankaka/article/details/44153709#t5">六常用函数说明</a></li>
<li>
<ol>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/evankaka/article/details/44153709#t6">使用方式</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/evankaka/article/details/44153709#t7">为什么要用 join 方法</a></li>
</ol>
</li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/evankaka/article/details/44153709#t8">七常见线程名词解释</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/evankaka/article/details/44153709#t9">八线程同步</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/evankaka/article/details/44153709#t10">九线程数据传递</a></li>
</ol>
<p>​    本文主要讲了 java 中多线程的使用方法、线程同步、线程数据传递、线程状态及相应的一些线程函数用法、概述等。在这之前，首先让我们来了解下在操作系统中进程和线程的区别：</p>
<p><strong>进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含 1–n 个线程。（进程是资源分配的最小单位）</strong></p>
<p><strong>线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器 (PC)，线程切换开销小。（线程是 cpu 调度的最小单位）</strong></p>
<p>线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。</p>
<p>多进程是指操作系统能同时运行多个任务（程序）。</p>
<p>多线程是指在同一程序中有多个顺序流在执行。</p>
<p>在<em> java</em> 中要想实现多线程，有两种手段，一种是继续<em> Thread</em> 类，另外一种是实现<em> Runable</em> 接口.(<strong>其实准确来讲，应该有三种，还有一种是实现 Callable 接口</strong>，并与 Future、线程池结合使用，此文这里不讲这个，有兴趣看这里<a target="_blank" rel="noopener" href="http://blog.csdn.net/evankaka/article/details/51610635"> Java 并发编程与技术内幕：Callable、Future、FutureTask、CompletionService</a> )</p>
<h1 id="一-扩展javalangthread类"><a class="markdownIt-Anchor" href="#一-扩展javalangthread类">#</a> 一、扩展 java.lang.Thread 类</h1>
<p>这里继承 Thread 类的方法是比较常用的一种，如果说你只是想起一条线程。没有什么其它特殊的要求，那么可以使用 Thread.（<strong>笔者推荐使用 Runable，后头会说明为什么</strong>）。下面来看一个简单的实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.multithread.learning;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Thread1</span><span class="params">(String name)</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="built_in">this</span>.name=name;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            System.out.println(name + <span class="string">&quot;运行  :  &quot;</span> + i);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                sleep((<span class="type">int</span>) Math.random() * <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                e.printStackTrace();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		Thread1 mTh1=<span class="keyword">new</span> <span class="title class_">Thread1</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		Thread1 mTh2=<span class="keyword">new</span> <span class="title class_">Thread1</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		mTh1.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		mTh2.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p>A 运行 : 0<br>
B 运行 : 0<br>
A 运行 : 1<br>
A 运行 : 2<br>
A 运行 : 3<br>
A 运行 : 4<br>
B 运行 : 1<br>
B 运行 : 2<br>
B 运行 : 3<br>
B 运行 : 4</p>
<p>再运行一下：</p>
<p>A 运行 : 0<br>
B 运行 : 0<br>
B 运行 : 1<br>
B 运行 : 2<br>
B 运行 : 3<br>
B 运行 : 4<br>
A 运行 : 1<br>
A 运行 : 2<br>
A 运行 : 3<br>
A 运行 : 4</p>
<p>说明：</p>
<p>程序启动运行 main 时候，java 虚拟机启动一个进程，主线程 main 在 main () 调用时候被创建。随着调用 MitiSay 的两个对象的 start 方法，另外两个线程也启动了，这样，整个应用就在多线程下运行。</p>
<p>注意：start () 方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行是由操作系统决定的。</p>
<p>从程序运行的结果可以发现，多线程程序是乱序执行。因此，只有乱序执行的代码才有必要设计为多线程。</p>
<p>Thread.sleep () 方法调用目的是不让当前线程独自霸占该进程所获取的 CPU 资源，以留出一定时间给其他线程执行的机会。</p>
<p>实际上所有的多线程代码执行顺序都是不确定的，每次执行的结果都是随机的。</p>
<p>但是 start 方法重复调用的话，会出现 java.lang.IllegalThreadStateException 异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Thread1 mTh1=<span class="keyword">new</span> <span class="title class_">Thread1</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread1 mTh2=mTh1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mTh1.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mTh2.start();</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p>Exception in thread “main” java.lang.IllegalThreadStateException<br>
at java.lang.Thread.start(Unknown Source)<br>
at com.multithread.learning.Main.main(Main.java:31)<br>
 A 运行 : 0<br>
A 运行 : 1<br>
A 运行 : 2<br>
A 运行 : 3<br>
A 运行 : 4</p>
<h1 id="二-实现javalangrunnable接口"><a class="markdownIt-Anchor" href="#二-实现javalangrunnable接口">#</a> 二、实现 java.lang.Runnable 接口</h1>
<p>采用 Runnable 也是非常常见的一种，我们只需要重写 run 方法即可。下面也来看个实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *<span class="doctag">@functon</span> 多线程学习</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *<span class="doctag">@author</span> 林炳文</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *<span class="doctag">@time</span> 2015.3.9</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.multithread.runnable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Thread2</span><span class="params">(String name)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">this</span>.name=name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	            System.out.println(name + <span class="string">&quot;运行  :  &quot;</span> + i);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	            	Thread.sleep((<span class="type">int</span>) Math.random() * <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	                e.printStackTrace();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Thread2</span>(<span class="string">&quot;C&quot;</span>)).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Thread2</span>(<span class="string">&quot;D&quot;</span>)).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p>C 运行 : 0<br>
D 运行 : 0<br>
D 运行 : 1<br>
C 运行 : 1<br>
D 运行 : 2<br>
C 运行 : 2<br>
D 运行 : 3<br>
C 运行 : 3<br>
D 运行 : 4<br>
C 运行 : 4</p>
<p>说明：</p>
<p>Thread2 类通过实现 Runnable 接口，使得该类有了多线程类的特征。run（）方法是多线程程序的一个约定。所有的多线程代码都在 run 方法里面。Thread 类实际上也是实现了 Runnable 接口的类。</p>
<p>在启动的多线程的时候，需要先通过 Thread 类的构造方法 Thread (Runnable target) 构造出对象，然后调用 Thread 对象的 start () 方法来运行多线程代码。</p>
<p>实际上所有的多线程代码都是通过运行 Thread 的 start () 方法来运行的。因此，不管是扩展 Thread 类还是实现 Runnable 接口来实现多线程，最终还是通过 Thread 的对象的 API 来控制线程的，熟悉 Thread 类的 API 是进行多线程编程的基础。</p>
<h1 id="三-thread和runnable的区别"><a class="markdownIt-Anchor" href="#三-thread和runnable的区别">#</a> 三、Thread 和 Runnable 的区别</h1>
<p>如果一个类继承 Thread，则不适合资源共享。但是如果实现了 Runable 接口的话，则很容易的实现资源共享。</p>
<p>** 总结：<br>
**</p>
<p><strong>实现 Runnable 接口比继承 Thread 类所具有的优势：</strong></p>
<p><strong>1）：适合多个相同的程序代码的线程去处理同一个资源</strong></p>
<p><strong>2）：可以避免 java 中的单继承的限制</strong></p>
<p><strong>3）：增加程序的健壮性，代码可以被多个线程共享，代码和数据独立</strong></p>
<p><strong>4）：线程池只能放入实现 Runable 或 callable 类线程，不能直接放入继承 Thread 的类</strong></p>
<p><strong><em>* 提醒一下大家：*</em>*<em>main*</em>*<em> 方法其实也是一个线程。在 *</em>*<em>java*</em>*<em> 中所以的线程都是同时启动的，至于什么时候，哪个先执行，完全看谁先得到 *</em>*<em>CPU*</em>*<em> 的资源。*</em></strong></p>
<p><strong>在<strong><strong> java</strong></strong> 中，每次程序运行至少启动<strong><strong> 2</strong></strong> 个线程。一个是<strong><strong> main</strong></strong> 线程，一个是垃圾收集线程。因为每当使用<strong><strong> java</strong></strong> 命令执行一个类的时候，实际上都会启动一个ＪＶＭ，每一个ｊＶＭ实习在就是在操作系统中启动了一个进程。</strong></p>
<h1 id="四-线程状态转换"><a class="markdownIt-Anchor" href="#四-线程状态转换">#</a> 四、线程状态转换</h1>
<p>下面的这个图非常重要！你如果看懂了这个图，那么对于多线程的理解将会更加深刻！</p>
<p><img src="https://img-blog.csdn.net/20150309140927553" alt="img"></p>
<p>1、新建状态（New）：新创建了一个线程对象。</p>
<p>2、就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的 start () 方法。该状态的线程位于可运行线程池中，变得可运行，等待获取 CPU 的使用权。</p>
<p>3、运行状态（Running）：就绪状态的线程获取了 CPU，执行程序代码。</p>
<p><strong>4、阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃 CPU 使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：</strong></p>
<p><strong>（一）、等待阻塞：运行的线程执行 wait () 方法，JVM 会把该线程放入等待池中。(wait 会释放持有的锁)</strong></p>
<p><strong>（二）、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线程放入锁池中。</strong></p>
<p><strong>（三）、其他阻塞：运行的线程执行 sleep () 或 join () 方法，或者发出了 I/O 请求时，JVM 会把该线程置为阻塞状态。当 sleep () 状态超时、join () 等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入就绪状态。（注意，sleep 是不会释放持有的锁）</strong></p>
<p>5、死亡状态（Dead）：线程执行完了或者因异常退出了 run () 方法，该线程结束生命周期。</p>
<h1 id="五-线程调度"><a class="markdownIt-Anchor" href="#五-线程调度">#</a> 五、线程调度</h1>
<p>线程的调度</p>
<p>1、调整线程优先级：Java 线程有优先级，优先级高的线程会获得较多的运行机会。</p>
<p>Java 线程的优先级用整数表示，取值范围是 1~10，Thread 类有以下三个静态常量：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> MAX_PRIORITY</span><br><span class="line">          线程可以具有的最高优先级，取值为<span class="number">10</span>。</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> MIN_PRIORITY</span><br><span class="line">          线程可以具有的最低优先级，取值为<span class="number">1</span>。</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> NORM_PRIORITY</span><br><span class="line">          分配给线程的默认优先级，取值为<span class="number">5</span>。</span><br></pre></td></tr></table></figure>
<p>Thread 类的 setPriority () 和 getPriority () 方法分别用来设置和获取线程的优先级。</p>
<p>每个线程都有默认的优先级。主线程的默认优先级为 Thread.NORM_PRIORITY。</p>
<p>线程的优先级有继承关系，比如 A 线程中创建了 B 线程，那么 B 将和 A 具有相同的优先级。</p>
<p>JVM 提供了 10 个线程优先级，但与常见的操作系统都不能很好的映射。如果希望程序能移植到各个操作系统中，应该仅仅使用 Thread 类有以下三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式。</p>
<p>2、线程睡眠：Thread.sleep (long millis) 方法，使线程转到阻塞状态。millis 参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep () 平台移植性好。</p>
<p>3、线程等待：Object 类中的 wait () 方法，导致当前的线程等待，直到其他线程调用此对象的 notify () 方法或 notifyAll () 唤醒方法。这个两个唤醒方法也是 Object 类中的方法，行为等价于调用 wait (0) 一样。</p>
<p>4、线程让步：Thread.yield () 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。</p>
<p>5、线程加入：join () 方法，等待其他线程终止。在当前线程中调用另一个线程的 join () 方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。</p>
<p>6、线程唤醒：Object 类中的 notify () 方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个 notifyAll ()，唤醒在此对象监视器上等待的所有线程。</p>
<p>注意：Thread 中 suspend () 和 resume () 两个方法在 JDK1.5 中已经废除，不再介绍。因为有死锁倾向。</p>
<h1 id="六-常用函数说明"><a class="markdownIt-Anchor" href="#六-常用函数说明">#</a> 六、常用函数说明</h1>
<p>**①sleep (long millis): 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）</p>
<p>②join (): 指等待 t 线程终止。**</p>
<h3 id="使用方式"><a class="markdownIt-Anchor" href="#使用方式">#</a> 使用方式。</h3>
<p>join 是 Thread 类的一个方法，启动线程后直接调用，即 join () 的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了 join () 方法后面的代码，只有等到子线程结束了才能执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AThread</span>(); t.start(); t.join();</span><br></pre></td></tr></table></figure>
<h3 id="为什么要用join方法"><a class="markdownIt-Anchor" href="#为什么要用join方法">#</a> 为什么要用 join () 方法</h3>
<p>在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到 join () 方法了。</p>
<p>不加 join。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *<span class="doctag">@functon</span> 多线程学习,join</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *<span class="doctag">@author</span> 林炳文</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *<span class="doctag">@time</span> 2015.3.9</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.multithread.join;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Thread1</span><span class="params">(String name)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    	<span class="built_in">super</span>(name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="built_in">this</span>.name=name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 线程运行开始!&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;子线程&quot;</span>+name + <span class="string">&quot;运行 : &quot;</span> + i);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                sleep((<span class="type">int</span>) Math.random() * <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                e.printStackTrace();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 线程运行结束!&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">&quot;主线程运行开始!&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		Thread1 mTh1=<span class="keyword">new</span> <span class="title class_">Thread1</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		Thread1 mTh2=<span class="keyword">new</span> <span class="title class_">Thread1</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		mTh1.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		mTh2.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		System.out.println(Thread.currentThread().getName()+ <span class="string">&quot;主线程运行结束!&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>输出结果：<br>
main 主线程运行开始！<br>
main 主线程运行结束！<br>
B 线程运行开始！<br>
 子线程 B 运行 : 0<br>
A 线程运行开始！<br>
 子线程 A 运行 : 0<br>
 子线程 B 运行 : 1<br>
 子线程 A 运行 : 1<br>
 子线程 A 运行 : 2<br>
 子线程 A 运行 : 3<br>
 子线程 A 运行 : 4<br>
A 线程运行结束！<br>
 子线程 B 运行 : 2<br>
 子线程 B 运行 : 3<br>
 子线程 B 运行 : 4<br>
B 线程运行结束！<br>
 发现主线程比子线程早结束</p>
<p>加 join</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">&quot;主线程运行开始!&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		Thread1 mTh1=<span class="keyword">new</span> <span class="title class_">Thread1</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		Thread1 mTh2=<span class="keyword">new</span> <span class="title class_">Thread1</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		mTh1.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		mTh2.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			mTh1.join();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			e.printStackTrace();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			mTh2.join();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			e.printStackTrace();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		System.out.println(Thread.currentThread().getName()+ <span class="string">&quot;主线程运行结束!&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>
main 主线程运行开始！<br>
A 线程运行开始！<br>
 子线程 A 运行 : 0<br>
B 线程运行开始！<br>
 子线程 B 运行 : 0<br>
 子线程 A 运行 : 1<br>
 子线程 B 运行 : 1<br>
 子线程 A 运行 : 2<br>
 子线程 B 运行 : 2<br>
 子线程 A 运行 : 3<br>
 子线程 B 运行 : 3<br>
 子线程 A 运行 : 4<br>
 子线程 B 运行 : 4<br>
A 线程运行结束！<br>
 主线程一定会等子线程都结束了才结束</p>
<p><strong>③yield (): 暂停当前正在执行的线程对象，并执行其他线程。</strong></p>
<p>​    Thread.yield () 方法作用是：暂停当前正在执行的线程对象，并执行其他线程。</p>
<p>​      ****yield () 应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。**** 因此，使用 yield () 的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证 yield () 达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。</p>
<p>结论：yield () 从未导致线程转到等待 / 睡眠 / 阻塞状态。在大多数情况下，yield () 将导致线程从运行状态转到可运行状态，但有可能没有效果。可看上面的图。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *@functon 多线程学习 yield</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *@author 林炳文</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *@time 2015.3.9</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">package com.multithread.yield;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadYield</span> extends Thread&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadYield</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @<span class="function">Override</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="type">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">&quot;&quot;</span> + <span class="keyword">this</span>.<span class="built_in">getName</span>() + <span class="string">&quot;-----&quot;</span> + i);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当i为30时，该线程就会把CPU时间让掉，让其他或者自己的线程执行（也就是谁先抢到谁执行）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i ==<span class="number">30</span>) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.<span class="built_in">yield</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		ThreadYield yt1 = <span class="keyword">new</span> <span class="built_in">ThreadYield</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    	ThreadYield yt2 = <span class="keyword">new</span> <span class="built_in">ThreadYield</span>(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        yt1.<span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        yt2.<span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p>第一种情况：李四（线程）当执行到 30 时会 CPU 时间让掉，这时张三（线程）抢到 CPU 时间并执行。</p>
<p>第二种情况：李四（线程）当执行到 30 时会 CPU 时间让掉，这时李四（线程）抢到 CPU 时间并执行。</p>
<p><strong>sleep () 和 yield () 的区别</strong><br>
 sleep () 和 yield () 的区别):sleep () 使当前线程进入停滞状态，所以执行 sleep () 的线程在指定的时间内肯定不会被执行；yield () 只是使当前线程重新回到可执行状态，所以执行 yield () 的线程有可能在进入到可执行状态后马上又被执行。<br>
sleep 方法使当前运行中的线程睡眼一段时间，进入不可运行状态，这段时间的长短是由程序设定的，yield 方法使当前线程让出 CPU 占有权，但让出的时间是不可设定的。实际上，yield () 方法对应了如下操作：先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把 CPU 的占有权交给此线程，否则，继续运行原来的线程。所以 yield () 方法称为 “退让”，它把运行机会让给了同等优先级的其他线程<br>
另外，sleep 方法允许较低优先级的线程获得运行机会，但 yield () 方法执行时，当前线程仍处在可运行状态，所以，不可能让出较低优先级的线程些时获得 CPU 占有权。在一个运行系统中，如果较高优先级的线程没有调用 sleep 方法，又没有受到 I\O 阻塞，那么，较低优先级线程只能等待所有较高优先级的线程运行结束，才有机会运行。</p>
<p><strong>④setPriority (): 更改线程的优先级。</strong></p>
<p>MIN_PRIORITY = 1<br>
　　  NORM_PRIORITY = 5<br>
MAX_PRIORITY = 10</p>
<p>用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread4 t1 = new Thread4(&quot;t1&quot;);</span><br><span class="line">Thread4 t2 = new Thread4(&quot;t2&quot;);</span><br><span class="line">t1.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">t2.setPriority(Thread.MIN_PRIORITY);</span><br></pre></td></tr></table></figure>
<p><strong><em>*⑤interrupt (): 不要以为它是中断某个线程！它只是线线程发送一个中断信号，让线程在无限等待时（如死锁时）能抛出抛出，从而结束线程，但是如果你吃掉了这个异常，那么 *</em>*<em> 这个线程还是不会中断的！*</em></strong></p>
<p>⑥wait()</p>
<p>Obj.wait ()，与 Obj.notify () 必须要与 synchronized (Obj) 一起使用，也就是 wait, 与 notify 是针对已经获取了 Obj 锁进行操作，从语法角度来说就是 Obj.wait (),Obj.notify 必须在 synchronized (Obj){…} 语句块内。从功能上来说 wait 就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的 notify () 唤醒该线程，才能继续获取对象锁，并继续执行。相应的 notify () 就是对对象锁的唤醒操作。但有一点需要注意的是 notify () 调用后，并不是马上就释放对象锁的，而是在相应的 synchronized (){} 语句块执行结束，自动释放锁后，JVM 会在 wait () 对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。这样就提供了在线程间同步、唤醒的操作。Thread.sleep () 与 Object.wait () 二者都可以暂停当前线程，释放 CPU 控制权，主要的区别在于 Object.wait () 在释放 CPU 同时，释放了对象锁的控制。</p>
<p>单单在概念上理解清楚了还不够，需要在实际的例子中进行测试才能更好的理解。对 Object.wait ()，Object.notify () 的应用最经典的例子，应该是三线程打印 ABC 的问题了吧，这是一道比较经典的面试题，题目要求如下：</p>
<p>建立三个线程，A 线程打印 10 次 A，B 线程打印 10 次 B,C 线程打印 10 次 C，要求线程同时运行，交替打印 10 次 ABC。这个问题用 Object 的 wait ()，notify () 就可以很方便的解决。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * wait用法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DreamSea </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2015.3.9 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.multithread.wait;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadPrinter2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object prev;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object self;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">MyThreadPrinter2</span><span class="params">(String name, Object prev, Object self)</span> &#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.name = name;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.prev = prev;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.self = self;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (prev) &#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (self) &#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    System.out.print(name);   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    count--;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    self.notify();   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    prev.wait();   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    e.printStackTrace();   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">MyThreadPrinter2</span> <span class="variable">pa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThreadPrinter2</span>(<span class="string">&quot;A&quot;</span>, c, a);   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">MyThreadPrinter2</span> <span class="variable">pb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThreadPrinter2</span>(<span class="string">&quot;B&quot;</span>, a, b);   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">MyThreadPrinter2</span> <span class="variable">pc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThreadPrinter2</span>(<span class="string">&quot;C&quot;</span>, b, c);   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(pa).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);  <span class="comment">//确保按顺序A、B、C执行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(pb).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(pc).start();   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<p>ABCABCABCABCABCABCABCABCABCABC</p>
<p>先来解释一下其整体思路，从大的方向上来讲，该问题为三线程间的同步唤醒操作，主要的目的就是 ThreadA-&gt;ThreadB-&gt;ThreadC-&gt;ThreadA 循环执行三个线程。为了控制线程执行的顺序，那么就必须要确定唤醒、等待的顺序，所以每一个线程必须同时持有两个对象锁，才能继续执行。一个对象锁是 prev，就是前一个线程所持有的对象锁。还有一个就是自身对象锁。主要的思想就是，为了控制执行的顺序，必须要先持有 prev 锁，也就前一个线程要释放自身对象锁，再去申请自身对象锁，两者兼备时打印，之后首先调用 self.notify () 释放自身对象锁，唤醒下一个等待线程，再调用 prev.wait () 释放 prev 对象锁，终止当前线程，等待循环结束后再次被唤醒。运行上述代码，可以发现三个线程循环打印 ABC，共 10 次。程序运行的主要过程就是 A 线程最先运行，持有 C,A 对象锁，后释放 A,C 锁，唤醒 B。线程 B 等待 A 锁，再申请 B 锁，后打印 B，再释放 B，A 锁，唤醒 C，线程 C 等待 B 锁，再申请 C 锁，后打印 C，再释放 C,B 锁，唤醒 A。看起来似乎没什么问题，但如果你仔细想一下，就会发现有问题，就是初始条件，三个线程按照 A,B,C 的顺序来启动，按照前面的思考，A 唤醒 B，B 唤醒 C，C 再唤醒 A。但是这种假设依赖于 JVM 中线程调度、执行的顺序。<br>
<strong>wait 和 sleep 区别<br>
共同点：</strong><br>
\1. 他们都是在多线程的环境下，都可以在程序的调用处阻塞指定的毫秒数，并返回。<br>
\2. wait () 和 sleep () 都可以通过 interrupt () 方法 打断线程的暂停状态 ，从而使线程立刻抛出 InterruptedException。<br>
如果线程 A 希望立即结束线程 B，则可以对线程 B 对应的 Thread 实例调用 interrupt 方法。如果此刻线程 B 正在 wait/sleep/join，则线程 B 会立刻抛出 InterruptedException，在 catch () {} 中直接 return 即可安全地结束线程。<br>
需要注意的是，InterruptedException 是线程自己从内部抛出的，并不是 interrupt () 方法抛出的。对某一线程调用 interrupt () 时，如果该线程正在执行普通的代码，那么该线程根本就不会抛出 InterruptedException。但是，一旦该线程进入到 wait ()/sleep ()/join () 后，就会立刻抛出 InterruptedException 。<br>
<strong>不同点：</strong><br>
\1. Thread 类的方法：sleep (),yield () 等<br>
 Object 的方法：wait () 和 notify () 等<br>
 \2. 每个对象都有一个锁来控制同步访问。Synchronized 关键字可以和对象的锁交互，来实现线程的同步。<br>
sleep 方法没有释放锁，而 wait 方法释放了锁，使得其他线程可以使用同步控制块或者方法。<br>
\3. wait，notify 和 notifyAll 只能在同步控制方法或者同步控制块里面使用，而 sleep 可以在任何地方使用<br>
所以 sleep () 和 wait () 方法的最大区别是：<br>
　　　　sleep () 睡眠时，保持对象锁，仍然占有该锁；<br>
　　　　而 wait () 睡眠时，释放对象锁。<br>
　　但是 wait () 和 sleep () 都可以通过 interrupt () 方法打断线程的暂停状态，从而使线程立刻抛出 InterruptedException（但不建议使用该方法）。<br>
<strong>sleep（）方法</strong><br>
 sleep () 使当前线程进入停滞状态（阻塞当前线程），让出 CUP 的使用、目的是不让当前线程独自霸占该进程所获的 CPU 资源，以留一定时间给其他线程执行的机会；<br>
　　 sleep () 是 Thread 类的 Static (静态) 的方法；因此他不能改变对象的机锁，所以当在一个 Synchronized 块中调用 Sleep () 方法是，线程虽然休眠了，但是对象的机锁并木有被释放，其他线程无法访问这个对象（即使睡着也持有对象锁）。<br>
　　在 sleep () 休眠时间期满后，该线程不一定会立即执行，这是因为其它线程可能正在运行而且没有被调度为放弃执行，除非此线程具有更高的优先级。<br>
<strong>wait（）方法</strong><br>
 wait () 方法是 Object 类里的方法；当一个线程执行到 wait () 方法时，它就进入到一个和该对象相关的等待池中，同时失去（释放）了对象的机锁（暂时失去机锁，wait (long timeout) 超时时间到后还需要返还对象锁）；其他线程可以访问；<br>
　　wait () 使用 notify 或者 notifyAlll 或者指定睡眠时间来唤醒当前等待池中的线程。<br>
　　wiat () 必须放在 synchronized block 中，否则会在 program runtime 时扔出”java.lang.IllegalMonitorStateException“异常。</p>
<h1 id="七-常见线程名词解释"><a class="markdownIt-Anchor" href="#七-常见线程名词解释">#</a> 七、常见线程名词解释</h1>
<p>主线程：JVM 调用程序 main () 所产生的线程。</p>
<p>当前线程：这个是容易混淆的概念。一般指通过 Thread.currentThread () 来获取的进程。</p>
<p>后台线程：指为其他线程提供服务的线程，也称为守护线程。JVM 的垃圾回收线程就是一个后台线程。 <strong>用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束</strong></p>
<p>前台线程：是指接受后台线程服务的线程，其实前台后台线程是联系在一起，就像傀儡和幕后操纵者一样的关系。傀儡是前台线程、幕后操纵者是后台线程。由前台线程创建的线程默认也是前台线程。可以通过 isDaemon () 和 setDaemon () 方法来判断和设置一个线程是否为后台线程。</p>
<p>** 线程类的一些常用方法：</p>
<p>sleep (): 强迫一个线程睡眠Ｎ毫秒。<br>
　　isAlive (): 判断一个线程是否存活。<br>
　　join (): 等待线程终止。<br>
　　activeCount (): 程序中活跃的线程数。<br>
　　enumerate (): 枚举程序中的线程。<br>
currentThread (): 得到当前线程。<br>
　　isDaemon (): 一个线程是否为守护线程。<br>
　　setDaemon (): 设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束)<br>
　　setName (): 为线程设置一个名称。<br>
　　wait (): 强迫一个线程等待。<br>
　　notify (): 通知一个线程继续运行。<br>
　　setPriority (): 设置一个线程的优先级。<br>
**</p>
<h1 id="八-线程同步"><a class="markdownIt-Anchor" href="#八-线程同步">#</a> 八、线程同步</h1>
<p>1、synchronized 关键字的作用域有二种：<br>
1）是某个对象实例内，synchronized aMethod (){} 可以防止多个线程同时访问这个对象的 synchronized 方法（如果一个对象有多个 synchronized 方法，只要一个线程访问了其中的一个 synchronized 方法，其它线程不能同时访问这个对象中任何一个 synchronized 方法）。这时，不同的对象实例的 synchronized 方法是不相干扰的。也就是说，其它线程照样可以同时访问相同类的另一个对象实例中的 synchronized 方法；<br>
2）是某个类的范围，synchronized static aStaticMethod {} 防止多个线程同时访问这个类中的 synchronized static 方法。它可以对类的所有对象实例起作用。</p>
<p>2、除了方法前用 synchronized 关键字，synchronized 关键字还可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。用法是: synchronized (this){/<em> 区块</em> /}，它的作用域是当前对象；</p>
<p>3、synchronized 关键字是不能继承的，也就是说，基类的方法 synchronized f (){} 在继承类中并不自动是 synchronized f (){}，而是变成了 f (){}。继承类需要你显式的指定它的某个方法为 synchronized 方法；</p>
<p>Java 对多线程的支持与同步机制深受大家的喜爱，似乎看起来使用了 synchronized 关键字就可以轻松地解决多线程共享数据同步问题。到底如何？――还得对 synchronized 关键字的作用进行深入了解才可定论。</p>
<p>总的说来，synchronized 关键字可以作为函数的修饰符，也可作为函数内的语句，也就是平时说的同步方法和同步语句块。如果再细的分类，synchronized 可作用于 instance 变量、object reference（对象引用）、static 函数和 class literals (类名称字面常量) 身上。</p>
<p>在进一步阐述之前，我们需要明确几点：</p>
<p>A．无论 synchronized 关键字加在方法上还是对象上，它取得的锁都是对象，而不是把一段代码或函数当作锁――而且同步方法很可能还会被其他线程的对象访问。</p>
<p>B．每个对象只有一个锁（lock）与之相关联。</p>
<p>C．实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。</p>
<p>接着来讨论 synchronized 用到不同地方对代码产生的影响：</p>
<p>假设 P1、P2 是同一个类的不同对象，这个类中定义了以下几种情况的同步块或同步方法，P1、P2 就都可以调用它们。</p>
<p>1． 把 synchronized 当作函数修饰符时，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Public <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">methodAAA</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//….</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这也就是同步方法，那这时 synchronized 锁定的是哪个对象呢？它锁定的是调用这个同步方法对象。也就是说，当一个对象 P1 在不同的线程中执行这个同步方法时，它们之间会形成互斥，达到同步的效果。但是这个对象所属的 Class 所产生的另一对象 P2 却可以任意调用这个被加了 synchronized 关键字的方法。</p>
<p>上边的示例代码等同于如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodAAA</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>)      <span class="comment">//  (1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">//…..</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(1) 处的 this 指的是什么呢？它指的就是调用这个方法的对象，如 P1。可见同步方法实质是将 synchronized 作用于 object reference。――那个拿到了 P1 对象锁的线程，才可以调用 P1 的同步方法，而对 P2 而言，P1 这个锁与它毫不相干，程序也可能在这种情形下摆脱同步机制的控制，造成数据混乱：（</p>
<p>2．同步块，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">(SomeObject so)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">              &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                     <span class="keyword">synchronized</span>(so)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">//…..</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时，锁就是 so 这个对象，谁拿到这个锁谁就可以运行它所控制的那段代码。当有一个明确的对象作为锁时，就可以这样写程序，但当没有明确的对象作为锁，只是想让一段代码同步时，可以创建一个特殊的 instance 变量（它得是一个对象）来充当锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="type">byte</span>[] lock = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>];  <span class="comment">// 特殊的instance变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Public <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="keyword">synchronized</span>(lock) &#123; <span class="comment">//… &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//…..</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：零长度的 byte 数组对象创建起来将比任何对象都经济――查看编译后的字节码：生成零长度的 byte [] 对象只需 3 条操作码，而 Object lock = new Object () 则需要 7 行操作码。</p>
<p>3．将 synchronized 作用于 static 函数，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Class Foo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodAAA</span><span class="params">()</span>   <span class="comment">// 同步的static 函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//….</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodBBB</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="keyword">synchronized</span>(Foo.class)   <span class="comment">//  class literal(类名称字面常量)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>代码中的 methodBBB () 方法是把 class literal 作为锁的情况，它和同步的 static 函数产生的效果是一样的，取得的锁很特别，是当前调用这个方法的对象所属的类（Class，而不再是由这个 Class 产生的某个具体对象了）。</p>
<p>记得在《Effective Java》一书中看到过将 Foo.class 和 P1.getClass () 用于作同步锁还不一样，不能用 P1.getClass () 来达到锁这个 Class 的目的。P1 指的是由 Foo 类产生的对象。</p>
<p>可以推断：如果一个类中定义了一个 synchronized 的 static 函数 A，也定义了一个 synchronized 的 instance 函数 B，那么这个类的同一对象 Obj 在多线程中分别访问 A 和 B 两个方法时，不会构成同步，因为它们的锁都不一样。A 方法的锁是 Obj 这个对象，而 B 的锁是 Obj 所属的那个 Class。</p>
<p><strong>总结一下：</strong></p>
<p>1、线程同步的目的是为了保护多个线程反问一个资源时对资源的破坏。<br>
2、线程同步方法是通过锁来实现，每个对象都有切仅有一个锁，这个锁与一个特定的对象关联，线程一旦获取了对象锁，其他访问该对象的线程就无法再访问该对象的其他非同步方法<br>
 3、对于静态同步方法，锁是针对这个类的，锁对象是该类的 Class 对象。静态和非静态方法的锁互不干预。一个线程获得锁，当在一个同步方法中访问另外对象上的同步方法时，会获取这两个对象锁。<br>
4、对于同步，要时刻清醒在哪个对象上同步，这是关键。<br>
5、编写线程安全的类，需要时刻注意对多个线程竞争访问资源的逻辑和安全做出正确的判断，对 “原子” 操作做出分析，并保证原子操作期间别的线程无法访问竞争资源。<br>
6、当多个线程等待一个对象锁时，没有获取到锁的线程将发生阻塞。<br>
7、死锁是线程间相互等待锁锁造成的，在实际中发生的概率非常的小。真让你写个死锁程序，不一定好使，呵呵。但是，一旦程序发生死锁，程序将死掉。</p>
<h1 id="九-线程数据传递"><a class="markdownIt-Anchor" href="#九-线程数据传递">#</a> 九、线程数据传递</h1>
<p>在传统的同步开发模式下，当我们调用一个函数时，通过这个函数的参数将数据传入，并通过这个函数的返回值来返回最终的计算结果。但在多线程的异步开发模式下，数据的传递和返回和同步开发模式有很大的区别。由于线程的运行和结束是不可预料的，因此，在传递和返回数据时就无法象函数一样通过函数参数和 return 语句来返回数据。</p>
<p>9.1、通过构造方法传递数据<br>
在创建线程时，必须要建立一个 Thread 类的或其子类的实例。因此，我们不难想到在调用 start 方法之前通过线程类的构造方法将数据传入线程。并将传入的数据使用类变量保存起来，以便线程使用 (其实就是在 run 方法中使用)。下面的代码演示了如何通过构造方法来传递数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mythread; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyThread1</span><span class="params">(String name)</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.name = name; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;hello &quot;</span> + name); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>(<span class="string">&quot;world&quot;</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">thread.start(); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>由于这种方法是在创建线程对象的同时传递数据的，因此，在线程运行之前这些数据就就已经到位了，这样就不会造成数据在线程运行后才传入的现象。如果要传递更复杂的数据，可以使用集合、类等数据结构。使用构造方法来传递数据虽然比较安全，但如果要传递的数据比较多时，就会造成很多不便。由于 Java 没有默认参数，要想实现类似默认参数的效果，就得使用重载，这样不但使构造方法本身过于复杂，又会使构造方法在数量上大增。因此，要想避免这种情况，就得通过类方法或类变量来传递数据。</p>
<p>9.2、通过变量和方法传递数据<br>
向对象中传入数据一般有两次机会，第一次机会是在建立对象时通过构造方法将数据传入，另外一次机会就是在类中定义一系列的 public 的方法或变量（也可称之为字段）。然后在建立完对象后，通过对象实例逐个赋值。下面的代码是对 MyThread1 类的改版，使用了一个 setName 方法来设置 name 变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mythread; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.name = name; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;hello &quot;</span> + name); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">MyThread2</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread2</span>(); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myThread.setName(<span class="string">&quot;world&quot;</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myThread); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">thread.start(); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>9.3、通过回调函数传递数据</p>
<p>上面讨论的两种向线程中传递数据的方法是最常用的。但这两种方法都是 main 方法中主动将数据传入线程类的。这对于线程来说，是被动接收这些数据的。然而，在有些应用中需要在线程运行的过程中动态地获取数据，如在下面代码的 run 方法中产生了 3 个随机数，然后通过 Work 类的 process 方法求这三个随机数的和，并通过 Data 类的 value 将结果返回。从这个例子可以看出，在返回 value 之前，必须要得到三个随机数。也就是说，这个 value 是无法事先就传入线程类的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mythread; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Work</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(Data data, Integer numbers)</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n : numbers) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data.value += n; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread3</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Work work; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyThread3</span><span class="params">(Work work)</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.work = work; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">java.util.<span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.util.Random(); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>(); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> random.nextInt(<span class="number">1000</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> random.nextInt(<span class="number">2000</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> random.nextInt(<span class="number">3000</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">work.process(data, n1, n2, n3); <span class="comment">// 使用回调函数 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(String.valueOf(n1) + <span class="string">&quot;+&quot;</span> + String.valueOf(n2) + <span class="string">&quot;+&quot;</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ String.valueOf(n3) + <span class="string">&quot;=&quot;</span> + data.value); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread3</span>(<span class="keyword">new</span> <span class="title class_">Work</span>()); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">thread.start(); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>好了，Java 多线程的基础知识就讲到这里了，有兴趣研究多线程的推荐直接看 java 的源码，你将会得到很大的提升！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-01-06T01:22:50.140Z" title="2023-1-6 9:22:50">2023-01-06</time>发表</span><span class="level-item"><time dateTime="2023-03-16T04:38:57.518Z" title="2023-3-16 12:38:57">2023-03-16</time>更新</span><span class="level-item">2 小时读完 (大约14226个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/06/%E3%80%90Go%E3%80%91Go%E8%AF%AD%E8%A8%80%E8%B6%85%E5%85%A8%E8%AF%A6%E8%A7%A3(%E5%85%A5%E9%97%A8%E7%BA%A7)/">Go语言超全详解（入门级）</a></p><div class="content"><h1 id="go语言超全详解入门级"><a class="markdownIt-Anchor" href="#go语言超全详解入门级">#</a> Go 语言超全详解（入门级）</h1>
<h3 id="文章目录"><a class="markdownIt-Anchor" href="#文章目录">#</a> 文章目录</h3>
<ul>
<li><a href="#1_Go_6">1. Go 语言的出现</a></li>
<li><a href="#2_gohello_world_12">2. go 版本的 hello world</a></li>
<li><a href="#3__36">3. 数据类型</a></li>
<li>
<ul>
<li><a href="#30__48">3.0 定义变量</a></li>
<li>
<ul>
<li><a href="#301__61">3.0.1 如果变量没有初始化</a></li>
<li><a href="#302__70">3.0.2 如果变量没有指定类型</a></li>
<li><a href="#303___82">3.0.3 := 符号</a></li>
<li><a href="#304__94">3.0.4 多变量声明</a></li>
<li><a href="#305__121">3.0.5 匿名变量</a></li>
<li><a href="#306__141">3.0.6 变量作用域</a></li>
</ul>
</li>
<li><a href="#31__150">3.1 基本类型</a></li>
<li><a href="#32__164">3.2 指针</a></li>
<li>
<ul>
<li><a href="#321__169">3.2.1 指针声明和初始化</a></li>
<li><a href="#322__188">3.2.2 空指针</a></li>
</ul>
</li>
<li><a href="#33__193">3.3 数组</a></li>
<li>
<ul>
<li><a href="#331__196">3.3.1 声明数组</a></li>
<li><a href="#332__208">3.3.2 初始化数组</a></li>
<li><a href="#333_go_219">3.3.3 go 中的数组名意义</a></li>
<li><a href="#334__225">3.3.4 数组指针</a></li>
</ul>
</li>
<li><a href="#34__243">3.4 结构体</a></li>
<li>
<ul>
<li><a href="#341__246">3.4.1 声明结构体</a></li>
<li><a href="#342__265">3.4.2 访问结构体成员</a></li>
<li><a href="#343__285">3.4.3 结构体指针</a></li>
</ul>
</li>
<li><a href="#35__297">3.5 字符串</a></li>
<li>
<ul>
<li><a href="#351__301">3.5.1 字符串定义和初始化</a></li>
<li><a href="#352_UTF8_317">3.5.2 字符串 UTF8 编码</a></li>
<li><a href="#353__343">3.5.3 字符串的强制类型转换</a></li>
</ul>
</li>
<li><a href="#36_slice_354">3.6 slice</a></li>
<li>
<ul>
<li><a href="#361_slice_359">3.6.1 slice 定义</a></li>
<li><a href="#362__381">3.6.2 添加元素</a></li>
<li><a href="#363__428">3.6.3 删除元素</a></li>
</ul>
</li>
<li><a href="#37__491">3.7 函数</a></li>
<li>
<ul>
<li><a href="#371__493">3.7.1 函数分类</a></li>
<li><a href="#372__521">3.7.2 函数声明和定义</a></li>
<li><a href="#373__538">3.7.3 函数传参</a></li>
<li><a href="#374__559">3.7.4 函数返回值</a></li>
<li><a href="#375__610">3.7.5 递归调用</a></li>
</ul>
</li>
<li><a href="#38__628">3.8 方法</a></li>
<li><a href="#39__673">3.9 接口</a></li>
<li>
<ul>
<li><a href="#391__674">3.9.1 什么是接口</a></li>
<li><a href="#392__684">3.9.2 结构体类型</a></li>
<li><a href="#393__738">3.9.3 具体类型向接口类型赋值</a></li>
<li><a href="#394__749">3.9.4 获取接口类型数据的具体类型信息</a></li>
</ul>
</li>
<li><a href="#310_channel_754">3.10 channel</a></li>
<li>
<ul>
<li><a href="#3101__755">3.10.1 相关结构体定义</a></li>
<li><a href="#3102_channel_794">3.10.2 阻塞式读写 channel 操作</a></li>
<li><a href="#3103_channel_826">3.10.3 非阻塞式读写 channel 操作</a></li>
</ul>
</li>
<li><a href="#311_map_855">3.11 map</a></li>
<li>
<ul>
<li><a href="#3111__944">3.11.1 插入数据</a></li>
<li><a href="#3112__957">3.11.2 删除数据</a></li>
<li><a href="#3113__966">3.11.3 查找数据</a></li>
<li><a href="#3114__980">3.11.4 扩容</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4__1012">4. 常用语句及关键字</a></li>
<li>
<ul>
<li><a href="#41__1014">4.1 条件语句</a></li>
<li><a href="#42__1078">4.2 循环语句</a></li>
<li>
<ul>
<li><a href="#421__1079">4.2.1 循环处理语句</a></li>
<li><a href="#421__1095">4.2.1 循环控制语句</a></li>
</ul>
</li>
<li><a href="#43__1200">4.3 关键字</a></li>
</ul>
</li>
</ul>
<hr>
<h1 id="1-go语言的出现"><a class="markdownIt-Anchor" href="#1-go语言的出现">#</a> 1. Go 语言的出现</h1>
<p>在具体学习 go 语言的基础语法之前，我们来了解一下 go 语言出现的时机及其特点。</p>
<p>Go 语言最初由 Google 公司的 Robert Griesemer、Ken Thompson 和 Rob Pike 三个大牛于 2007 年开始设计发明，他们最终的目标是设计一种<strong>适应网络和多核时代的 C 语言</strong>。所以 Go 语言很多时候被描述为 “类 C 语言”，或者是 “21 世纪的 C 语言”，当然从各种角度看，Go 语言确实是从 C 语言继承了相似的表达式语法、控制流结构、基础数据类型、调用参数传值、指针等诸多编程思想。但是 Go 语言更是对 C 语言最彻底的一次扬弃，它舍弃了 C 语言中灵活但是危险的指针运算，还重新设计了 C 语言中部分不太合理运算符的优先级，并在很多细微的地方都做了必要的打磨和改变。</p>
<h1 id="2-go版本的hello-world"><a class="markdownIt-Anchor" href="#2-go版本的hello-world">#</a> 2. go 版本的 hello world</h1>
<p>在这一部分我们只是使用 “hello world” 的程序来向大家介绍一下 go 语言的所编写的程序的基本组成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import <span class="string">&quot;fmt&quot;</span></span><br><span class="line">func <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 终端输出hello world</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<p>和 C 语言相似，go 语言的基本组成有：</p>
<ul>
<li>包声明，编写源文件时，必须在非注释的第一行指明这个文件属于哪个包，如 <code>package main</code> 。</li>
<li>引入包，其实就是告诉 Go 编译器这个程序需要使用的包，如 <code>import &quot;fmt&quot;</code>  其实就是引入了 fmt 包。</li>
<li>函数，和 c 语言相同，即是一个可以实现某一个功能的函数体，每一个可执行程序中必须拥有一个 main 函数。</li>
<li>变量，Go 语言变量名由字母、数字、下划线组成，其中首个字符不能为数字。</li>
<li>语句 / 表达式，在 Go 程序中，一行代表一个语句结束。每个语句不需要像 C 家族中的其它语言一样以分号；结尾，因为这些工作都将由 Go 编译器自动完成。</li>
<li>注释，和 c 语言中的注释方式相同，可以在任何地方使用以 // 开头的单行注释。以 /* 开头，并以 */ 结尾来进行多行注释，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。</li>
</ul>
<blockquote>
<p>需要注意的是：<strong>标识符</strong>是用来命名变量、类型等程序实体。一个标识符实际上就是一个或是多个字母和数字、下划线_组成的序列，但是第一个字符必须是字母或下划线而不能是数字。</p>
<ol>
<li>当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；</li>
<li>标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected）。</li>
</ol>
</blockquote>
<h1 id="3-数据类型"><a class="markdownIt-Anchor" href="#3-数据类型">#</a> 3. 数据类型</h1>
<p>在 Go 编程语言中，数据类型用于声明函数和变量。</p>
<p>数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。具体分类如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>详解</th>
</tr>
</thead>
<tbody>
<tr>
<td>布尔型</td>
<td>布尔型的值只可以是常量 true 或者 false。</td>
</tr>
<tr>
<td>数字类型</td>
<td>整型 int 和浮点型 float。Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。</td>
</tr>
<tr>
<td>字符串类型</td>
<td>字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。</td>
</tr>
<tr>
<td>派生类型</td>
<td>(a) 指针类型（Pointer）(b) 数组类型 © 结构化类型 (struct)(d) Channel 类型 (e) 函数类型 (f) 切片类型 (g) 接口类型（interface）(h) Map 类型</td>
</tr>
</tbody>
</table>
<h2 id="30-定义变量"><a class="markdownIt-Anchor" href="#30-定义变量">#</a> 3.0 定义变量</h2>
<p>声明变量的一般形式是使用 var 关键字，具体格式为： <code>var identifier typename</code> 。如下的代码中我们定义了一个类型为 int 的变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="type">int</span> = <span class="number">27</span></span><br><span class="line">	fmt.Println(a);</span><br><span class="line">&#125; </span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<h3 id="301-如果变量没有初始化"><a class="markdownIt-Anchor" href="#301-如果变量没有初始化">#</a> 3.0.1 如果变量没有初始化</h3>
<p>在 go 语言中定义了一个变量，指定变量类型，如果没有初始化，则变量默认为零值。<strong>零值就是变量没有做初始化时系统默认设置的值</strong>。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>零值</th>
</tr>
</thead>
<tbody>
<tr>
<td>数值类型</td>
<td>0</td>
</tr>
<tr>
<td>布尔类型</td>
<td>false</td>
</tr>
<tr>
<td>字符串</td>
<td>“”（空字符串）</td>
</tr>
</tbody>
</table>
<h3 id="302-如果变量没有指定类型"><a class="markdownIt-Anchor" href="#302-如果变量没有指定类型">#</a> 3.0.2 如果变量没有指定类型</h3>
<p>在 go 语言中如果没有指定变量类型，可以通过变量的初始值来判断变量类型。如下代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> d = <span class="literal">true</span></span><br><span class="line">    fmt.Println(d)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<h3 id="303-符号"><a class="markdownIt-Anchor" href="#303-符号">#</a> 3.0.3 := 符号</h3>
<p>当我们定义一个变量后又使用该符号初始化变量，就会产生编译错误，因为该符号其实是一个声明语句。</p>
<p>使用格式： <code>typename := value</code></p>
<p>也就是说 <code>intVal := 1</code>  相等于：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intVal <span class="type">int</span> </span><br><span class="line">intVal =<span class="number">1</span> </span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>
<h3 id="304-多变量声明"><a class="markdownIt-Anchor" href="#304-多变量声明">#</a> 3.0.4 多变量声明</h3>
<p>可以同时声明多个类型相同的变量（非全局变量），如下图所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x, y <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> c, d <span class="type">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">g, h := <span class="number">123</span>, <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<p>关于全局变量的声明如下：<br>
 <code>var ( vname1 v_type1 vname2 v_type2 )</code> <br>
 具体举例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ( </span><br><span class="line">    a <span class="type">int</span></span><br><span class="line">    b <span class="type">bool</span></span><br><span class="line">)</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<h3 id="305-匿名变量"><a class="markdownIt-Anchor" href="#305-匿名变量">#</a> 3.0.5 匿名变量</h3>
<p>匿名变量的特点是一个下画线 <code>_</code> ，这本身就是一个特殊的标识符，被称为空白标识符。它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值<strong>不能在后续的代码中使用</strong>，也不可以使用这个标识符作为变量对其它变量进行赋值或运算。</p>
<p>使用匿名变量时，只需要在<strong>变量声明的地方</strong>使用下画线替换即可。</p>
<p>示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">GetData</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>, <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a, _ := GetData()</span><br><span class="line">        _, b := GetData()</span><br><span class="line">        fmt.Println(a, b)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是匿名变量不占用内存空间，不会分配内存。匿名变量与匿名变量之间也不会因为多次声明而无法使用。</p>
<h3 id="306-变量作用域"><a class="markdownIt-Anchor" href="#306-变量作用域">#</a> 3.0.6 变量作用域</h3>
<p>作用域指的是已声明的标识符所表示的常量、类型、函数或者包在源代码中的作用范围，在此我们主要看一下 go 中变量的作用域，根据变量定义位置的不同，可以分为一下三个类型：</p>
<ol>
<li>函数内定义的变量为<strong>局部变量</strong>，这种局部变量的作用域只在函数体内，函数的参数和返回值变量都属于局部变量。这种变量在存在于函数被调用时，销毁于函数调用结束后。</li>
<li>函数外定义的变量为<strong>全局变量</strong>，全局变量只需要在一个源文件中定义，就可以在所有源文件中使用，甚至可以使用 import 引入外部包来使用。全局变量声明必须<strong>以 var 关键字开头</strong>，如果想要在<strong>外部包中使用</strong>全局变量的<strong>首字母必须大写</strong>。</li>
<li>函数定义中的变量成为<strong>形式参数</strong>，定义函数时函数名后面括号中的变量叫做形式参数（简称形参）。形式参数只在函数调用时才会生效，函数调用结束后就会被销毁，在函数未被调用时，函数的形参并不占用实际的存储单元，也没有实际值。<strong>形式参数会作为函数的局部变量来使用</strong>。</li>
</ol>
<h2 id="31-基本类型"><a class="markdownIt-Anchor" href="#31-基本类型">#</a> 3.1 基本类型</h2>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>uint8 / uint16 / uint32 / uint64</td>
<td>无符号 8 / 16 / 32 / 64 位整型</td>
</tr>
<tr>
<td>int8 / int16 / int32 / int64</td>
<td>有符号 8 / 16 / 32 / 64 位整型</td>
</tr>
<tr>
<td>float32 / float64</td>
<td>IEEE-754 32 / 64 位浮点型数</td>
</tr>
<tr>
<td>complex64 / complex128</td>
<td>32 / 64 位实数和虚数</td>
</tr>
<tr>
<td>byte</td>
<td>类似 uint8</td>
</tr>
<tr>
<td>rune</td>
<td>类似 int32</td>
</tr>
<tr>
<td>uintptr</td>
<td>无符号整型，用于存放一个指针</td>
</tr>
</tbody>
</table>
<p>以上就是 go 语言基本的数据类型，有了数据类型，我们就可以使用这些类型来定义变量，Go 语言变量名由字母、数字、下划线组成，其中首个字符不能为数字。</p>
<h2 id="32-指针"><a class="markdownIt-Anchor" href="#32-指针">#</a> 3.2 指针</h2>
<p>与 C 相同，Go 语言让程序员决定何时使用指针。变量其实是一种使用方便的占位符，用于引用计算机内存地址。Go 语言中的的取地址符是 <code>&amp;</code> ，放到一个变量前使用就会返回相应变量的内存地址。</p>
<p>指针变量其实就是用于存放某一个对象的内存地址。</p>
<h3 id="321-指针声明和初始化"><a class="markdownIt-Anchor" href="#321-指针声明和初始化">#</a> 3.2.1 指针声明和初始化</h3>
<p>和基础类型数据相同，在使用指针变量之前我们首先需要申明指针，声明格式如下： <code>var var_name *var-type</code> ，其中的 var-type 为指针类型，var_name 为指针变量名，* 号用于指定变量是作为一个指针。</p>
<p>代码举例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ip *<span class="type">int</span>        <span class="comment">/* 指向整型*/</span></span><br><span class="line"><span class="keyword">var</span> fp *<span class="type">float32</span>    <span class="comment">/* 指向浮点型 */</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>指针的初始化就是取出相对应的变量地址对指针进行赋值，具体如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">var</span> a <span class="type">int</span>= <span class="number">20</span>   <span class="comment">/* 声明实际变量 */</span></span><br><span class="line">   <span class="keyword">var</span> ip *<span class="type">int</span>        <span class="comment">/* 声明指针变量 */</span></span><br><span class="line"></span><br><span class="line">   ip = &amp;a  <span class="comment">/* 指针变量的存储地址 */</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<h3 id="322-空指针"><a class="markdownIt-Anchor" href="#322-空指针">#</a> 3.2.2 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%A9%BA%E6%8C%87%E9%92%88&amp;spm=1001.2101.3001.7020">空指针</a></h3>
<p>当一个指针被定义后<strong>没有分配到任何变量</strong>时，它的值为 <strong>nil</strong>，也称为空指针。它概念上和其它语言的 null、NULL 一样，都指代零值或空值。</p>
<h2 id="33-数组"><a class="markdownIt-Anchor" href="#33-数组">#</a> 3.3 数组</h2>
<p>和 c 语言相同，Go 语言也提供了数组类型的数据结构，数组是具有<strong>相同唯一类型</strong>的一组已编号且<strong>长度固定</strong>的数据项序列，这种类型可以是任意的原始类型例如整型、字符串或者自定义类型。</p>
<h3 id="331-声明数组"><a class="markdownIt-Anchor" href="#331-声明数组">#</a> 3.3.1 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%A3%B0%E6%98%8E%E6%95%B0%E7%BB%84&amp;spm=1001.2101.3001.7020">声明数组</a></h3>
<p>Go 语言数组声明需要指定元素类型及元素个数，语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var variable_name [SIZE] variable_type</span><br></pre></td></tr></table></figure>
<p>以上就可以定一个一维数组，我们举例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> balance [<span class="number">10</span>] <span class="type">float32</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="332-初始化数组"><a class="markdownIt-Anchor" href="#332-初始化数组">#</a> 3.3.2 初始化数组</h3>
<p>数组的初始化方式有不止一种方式，我们列举如下：</p>
<ol>
<li>直接进行初始化： <code>var balance = [5]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;</code></li>
<li>通过字面量在声明数组的同时快速初始化数组： <code>balance := [5]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;</code></li>
<li>数组长度不确定，编译器通过元素个数自行推断数组长度，在 [ ] 中填入 <code>...</code> ，举例如下： <code>var balance = [...]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;</code>  和 <code>balance := [...]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;</code></li>
<li>数组长度确定，指定下标进行部分初始化： <code>balanced := [5]float32(1:2.0, 3:7.0)</code></li>
</ol>
<blockquote>
<p>注意：</p>
<ul>
<li>初始化数组中 {} 中的元素个数不能大于 [] 中的数字。<br>
如果忽略 [] 中的数字不设置数组大小，Go 语言会根据元素的个数来设置数组的大小。</li>
</ul>
</blockquote>
<h3 id="333-go中的数组名意义"><a class="markdownIt-Anchor" href="#333-go中的数组名意义">#</a> 3.3.3 go 中的数组名意义</h3>
<p>在 c 语言中我们知道数组名在本质上是数组中第一个元素的地址，而在 go 语言中，数组名仅仅表示整个数组，是一个完整的值，一个数组变量即是表示整个数组。</p>
<p>所以在 go 中一个数组变量被赋值或者被传递的时候实际上就会复制整个数组。如果数组比较大的话，这种复制往往会占有很大的开销。所以为了避免这种开销，往往需要传递一个指向数组的指针，这个数组指针并不是数组。关于数组指针具体在指针的部分深入的了解。</p>
<h3 id="334-数组指针"><a class="markdownIt-Anchor" href="#334-数组指针">#</a> 3.3.4 数组指针</h3>
<p>通过数组和指针的知识我们就可以定义一个数组指针，代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// a 是一个数组</span></span><br><span class="line"><span class="keyword">var</span> b = &amp;a                <span class="comment">// b 是指向数组的指针</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>数组指针除了可以防止数组作为参数传递的时候浪费空间，还可以利用其和 <code>for range</code>  来遍历数组，具体代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> b &#123;     <span class="comment">// 通过数组指针迭代数组的元素</span></span><br><span class="line">    fmt.Println(i, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<p>具体关于 go 语言的循环语句我们在后文中再进行详细介绍。</p>
<h2 id="34-结构体"><a class="markdownIt-Anchor" href="#34-结构体">#</a> 3.4 结构体</h2>
<p>通过上述数组的学习，我们就可以直接定义多个同类型的变量，但这往往也是一种限制，只能存储同一种类型的数据，而我们在结构体中就可以定义多个不同的数据类型。</p>
<h3 id="341-声明结构体"><a class="markdownIt-Anchor" href="#341-声明结构体">#</a> 3.4.1 声明结构体</h3>
<p>在声明结构体之前我们首先需要定义一个结构体类型，这需要使用 type 和 struct，type 用于设定结构体的名称，struct 用于定义一个新的数据类型。具体结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> struct_variable_type <span class="keyword">struct</span> &#123;</span><br><span class="line">   member definition</span><br><span class="line">   member definition</span><br><span class="line">   ...</span><br><span class="line">   member definition</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<p>定义好了结构体类型，我们就可以使用该结构体声明这样一个结构体变量，语法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">variable_name := structure_variable_type &#123;value1, value2...valuen&#125;</span><br><span class="line"></span><br><span class="line">variable_name := structure_variable_type &#123; key1: value1, key2: value2..., keyn: valuen&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<h3 id="342-访问结构体成员"><a class="markdownIt-Anchor" href="#342-访问结构体成员">#</a> 3.4.2 访问结构体成员</h3>
<p>如果要访问结构体成员，需要使用点号  <code>.</code>  操作符，格式为： <code>结构体变量名.成员名</code> 。举例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Books <span class="keyword">struct</span> &#123;</span><br><span class="line">   title <span class="type">string</span></span><br><span class="line">   author <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> book1 Books</span><br><span class="line">	Book1.title = <span class="string">&quot;Go 语言入门&quot;</span></span><br><span class="line">	Book1.author = <span class="string">&quot;mars.hao&quot;</span>	</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>
<h3 id="343-结构体指针"><a class="markdownIt-Anchor" href="#343-结构体指针">#</a> 3.4.3 结构体指针</h3>
<p>关于结构体指针的定义和申明同样可以套用前文中讲到的指针的相关定义，从而使用一个指针变量存放一个结构体变量的地址。</p>
<p>定义一个结构体变量的语法： <code>var struct_pointer *Books</code> 。</p>
<p>这种指针变量的初始化和上文指针部分的初始化方式相同 <code>struct_pointer = &amp;Book1</code> ，但是和 c 语言中有所不同，使用结构体指针访问结构体成员仍然使用 <code>.</code>  操作符。格式如下： <code>struct_pointer.title</code></p>
<h2 id="35-字符串"><a class="markdownIt-Anchor" href="#35-字符串">#</a> 3.5 字符串</h2>
<p>一个字符串是一个<strong>不可改变</strong>的字节序列，字符串通常是用来包含人类可读的文本数据。和数组不同的是，字符串的元素不可修改，是一个只读的<strong>字节数组</strong>。每个字符串的长度虽然也是固定的，但是字符串的长度并不是字符串类型的一部分。</p>
<h3 id="351-字符串定义和初始化"><a class="markdownIt-Anchor" href="#351-字符串定义和初始化">#</a> 3.5.1 字符串定义和初始化</h3>
<p>Go 语言字符串的底层结构在 reflect.StringHeader 中定义，具体如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="type">uintptr</span></span><br><span class="line">    Len  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<p>也就是说字符串结构由两个信息组成：第一个是字符串指向的底层字节数组，第二个是字符串的字节的长度。</p>
<p>字符串其实是一个结构体，因此字符串的赋值操作也就是 reflect.StringHeader 结构体的复制过程，并不会涉及底层字节数组的复制，所以我们也可以将字符串数组看作一个结构体数组。</p>
<p>字符串和数组类似，内置的 len 函数返回字符串的长度。</p>
<h3 id="352-字符串utf8编码"><a class="markdownIt-Anchor" href="#352-字符串utf8编码">#</a> 3.5.2 字符串 UTF8 编码</h3>
<p>根据 Go 语言规范，Go 语言的源文件都是采用<strong> UTF8</strong> 编码。因此，Go 源文件中出现的字符串面值常量一般也是 UTF8 编码的（对于转义字符，则没有这个限制）。提到 Go 字符串时，我们一般都会假设字符串对应的是一个合法的 UTF8 编码的字符序列。</p>
<p>Go 语言的字符串中可以存放任意的二进制字节序列，而且即使是 UTF8 字符序列也可能会遇到坏的编码。如果遇到一个<strong>错误的 UTF8 编码输入</strong>，将生成一个<strong>特别的 Unicode 字符</strong>‘\uFFFD’，这个字符在不同的软件中的显示效果可能不太一样，在印刷中这个符号通常是一个黑色六角形或钻石形状，里面包含一个白色的问号‘ ’。</p>
<p>下面的字符串中，我们故意损坏了第一字符的第二和第三字节，因此第一字符将会打印为 “”，第二和第三字节则被忽略；后面的 “abc” 依然可以正常解码打印（<strong>错误编码不会向后扩散是 UTF8 编码的优秀特性之一</strong>）。代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;\xe4\x00\x00\xe7\x95\x8cabc&quot;</span>) <span class="comment">//  界abc</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>不过在 for range 迭代这个含有损坏的 UTF8 字符串时，第一字符的第二和第三字节依然会被单独迭代到，不过此时迭代的值是损坏后的 0：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0 65533  // \uFFFD, 对应  </span></span><br><span class="line"><span class="comment">// 1 0      // 空字符</span></span><br><span class="line"><span class="comment">// 2 0      // 空字符</span></span><br><span class="line"><span class="comment">// 3 30028  // 界</span></span><br><span class="line"><span class="comment">// 6 97     // a</span></span><br><span class="line"><span class="comment">// 7 98     // b</span></span><br><span class="line"><span class="comment">// 8 99     // c</span></span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>
<h3 id="353-字符串的强制类型转换"><a class="markdownIt-Anchor" href="#353-字符串的强制类型转换">#</a> 3.5.3 字符串的强制类型转换</h3>
<p>在上文中我们知道源代码往往会采用 UTF8 编码，如果不想解码 UTF8 字符串，想直接遍历原始的字节码：</p>
<ol>
<li>可以将字符串强制转为 [] byte 字节序列后再行遍历（这里的转换一般不会产生运行时开销）：</li>
<li>采用传统的下标方式遍历字符串的字节数组</li>
</ol>
<p>除此以外，字符串相关的强制类型转换主要<strong>涉及到 [] byte 和 [] rune 两种类型</strong>。每个转换都可能隐含<strong>重新分配内存</strong>的代价，最坏的情况下它们的运算时间复杂度都是 O (n)。</p>
<p>不过字符串和 [] rune 的转换要更为特殊一些，因为一般这种强制类型转换要求两个类型的底层内存结构要尽量一致，显然它们底层对应的 [] byte 和 [] int32 类型是完全不同的内部布局，因此这种转换可能隐含重新分配内存的操作。</p>
<h2 id="36-slice"><a class="markdownIt-Anchor" href="#36-slice">#</a> 3.6 slice</h2>
<p>简单地说，切片就是一种简化版的<strong>动态数组</strong>。因为动态数组的<strong>长度不固定</strong>，切片的长度自然也就不能是类型的组成部分了。数组虽然有适用它们的地方，但是数组的类型和操作都不够灵活，而切片则使用得相当广泛。</p>
<p>切片高效操作的要点是要降低内存分配的次数，尽量保证 append 操作（在后续的插入和删除操作中都涉及到这个函数）不会超出 cap 的容量，降低触发内存分配的次数和每次分配内存大小。</p>
<h3 id="361-slice定义"><a class="markdownIt-Anchor" href="#361-slice定义">#</a> 3.6.1 slice 定义</h3>
<p>我们先看看切片的结构定义，reflect.SliceHeader：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="type">uintptr</span>   <span class="comment">// 指向底层的的数组指针</span></span><br><span class="line">    Len  <span class="type">int</span>	   <span class="comment">// 切片长度</span></span><br><span class="line">    Cap  <span class="type">int</span>	   <span class="comment">// 切片最大长度</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>
<p>和数组一样，内置的 len 函数返回切片中有效元素的长度，内置的 cap 函数返回切片容量大小，容量必须大于或等于切片的长度。</p>
<p>切片可以和<strong> nil</strong> 进行比较，只有当切片<strong>底层数据指针为空时</strong>切片本身为 nil，这时候<strong>切片的长度和容量信息将是无效的</strong>。如果有切片的底层数据指针为空，但是长度和容量不为 0 的情况，那么说明切片本身已经被损坏了</p>
<p>只要是<strong>切片的底层</strong>数据指针、长度和容量<strong>没有发生变化</strong>的话，对切片的遍历、元素的读取和修改都和数组是一样的。在对切片本身赋值或参数传递时，和数组指针的操作方式类似，只是复制切片头信息（reflect.SliceHeader），并不会复制底层的数据。对于类型，和数组的最大不同是，切片的类型和长度信息无关，只要是相同类型元素构成的切片均对应相同的切片类型。</p>
<p>当我们想定义声明一个切片时可以如下：</p>
<p>在对切片本身赋值或参数传递时，和数组指针的操作方式类似，只是复制切片头信息・（reflect.SliceHeader），并不会复制底层的数据。对于类型，和数组的最大不同是，切片的类型和长度信息无关，<strong>只要是相同类型元素构成的切片均对应相同的切片类型</strong>。</p>
<h3 id="362-添加元素"><a class="markdownIt-Anchor" href="#362-添加元素">#</a> 3.6.2 添加元素</h3>
<p><code>append()</code>  ：内置的泛型函数，可以向切片中增加元素。</p>
<ol>
<li>在切片尾部追加 N 个元素</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="type">int</span></span><br><span class="line">a = <span class="built_in">append</span>(a, <span class="number">1</span>)               <span class="comment">// 追加1个元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)         <span class="comment">// 追加多个元素, 手写解包方式</span></span><br><span class="line">a = <span class="built_in">append</span>(a, []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;...) <span class="comment">// 追加一个切片, 切片需要解包</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：尾部添加在容量不足的条件下需要重新分配内存，可能导致巨大的内存分配和复制数据代价。即使容量足够，依然需要用 append 函数的返回值来更新切片本身，因为新切片的长度已经发生了变化。</p>
</blockquote>
<ol>
<li>在切片开头位置添加元素</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">a = <span class="built_in">append</span>([]<span class="type">int</span>&#123;<span class="number">0</span>&#125;, a...)        <span class="comment">// 在开头位置添加1个元素</span></span><br><span class="line">a = <span class="built_in">append</span>([]<span class="type">int</span>&#123;<span class="number">-3</span>,<span class="number">-2</span>,<span class="number">-1</span>&#125;, a...) <span class="comment">// 在开头添加1个切片</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：在开头一般都会导致内存的重新分配，而且会导致已有的元素全部复制 1 次。因此，从切片的开头添加元素的性能一般要比从尾部追加元素的性能差很多。</p>
</blockquote>
<ol>
<li>append 链式操作</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="type">int</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:i], <span class="built_in">append</span>([]<span class="type">int</span>&#123;x&#125;, a[i:]...)...)     <span class="comment">// 在第i个位置插入x</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:i], <span class="built_in">append</span>([]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, a[i:]...)...) <span class="comment">// 在第i个位置插入切片</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>每个添加操作中的第二个 append 调用都会创建一个<strong>临时切片</strong>，并将 a [i:] 的内容复制到新创建的切片中，然后将临时创建的切片再追加到 a [:i]。</p>
</blockquote>
<ol>
<li>append 和 copy 组合</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">append</span>(a, <span class="number">0</span>)     <span class="comment">// 切片扩展1个空间</span></span><br><span class="line"><span class="built_in">copy</span>(a[i+<span class="number">1</span>:], a[i:]) <span class="comment">// a[i:]向后移动1个位置</span></span><br><span class="line">a[i] = x             <span class="comment">// 设置新添加的元素</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>第三个操作中会创建一个临时对象，我们可以借用 copy 函数避免这个操作，这种方式操作语句虽然冗长了一点，但是相比前面的方法，可以减少中间创建的临时切片。</p>
</blockquote>
<h3 id="363-删除元素"><a class="markdownIt-Anchor" href="#363-删除元素">#</a> 3.6.3 删除元素</h3>
<p>根据要删除元素的位置有三种情况：</p>
<ol>
<li>从开头位置删除；</li>
</ol>
<ul>
<li>直接移动数据指针，代码如下：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ...&#125;</span><br><span class="line">a = a[<span class="number">1</span>:]                       <span class="comment">// 删除开头1个元素</span></span><br><span class="line">a = a[N:]                       <span class="comment">// 删除开头N个元素</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<ul>
<li>将后面的数据向开头移动，使用<strong> append 原地完成</strong>（所谓原地完成是指在原有的切片数据对应的内存区间内完成，不会导致内存空间结构的变化）</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ...&#125;</span><br><span class="line">a = <span class="built_in">append</span>(a[:<span class="number">0</span>], a[<span class="number">1</span>:]...) <span class="comment">// 删除开头1个元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:<span class="number">0</span>], a[N:]...) <span class="comment">// 删除开头N个元素</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用 copy 将后续数据向前移动，代码如下：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">a = a[:<span class="built_in">copy</span>(a, a[<span class="number">1</span>:])] <span class="comment">// 删除开头1个元素</span></span><br><span class="line">a = a[:<span class="built_in">copy</span>(a, a[N:])] <span class="comment">// 删除开头N个元素</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<ol>
<li>从中间位置删除；<br>
对于删除中间的元素，需要对剩余的元素进行一次整体挪动，同样可以用 append 或 copy 原地完成：</li>
</ol>
<ul>
<li>append 删除操作如下：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ...&#125;</span><br><span class="line">a = <span class="built_in">append</span>(a[:i], a[i+<span class="number">1</span>], ...)</span><br><span class="line">a = <span class="built_in">append</span>(a[:i], a[i+N:], ...)</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<ul>
<li>copy 删除操作如下：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">a = a[:<span class="built_in">copy</span>(a[:i], a[i+<span class="number">1</span>:])] <span class="comment">// 删除中间1个元素</span></span><br><span class="line">a = a[:<span class="built_in">copy</span>(a[:i], a[i+N:])] <span class="comment">// 删除中间N个元素</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<ol>
<li>从尾部删除。</li>
</ol>
<p>代码如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ...&#125;</span><br><span class="line"></span><br><span class="line">a = a[:<span class="built_in">len</span>(a)<span class="number">-1</span>]   <span class="comment">// 删除尾部1个元素</span></span><br><span class="line">a = a[:<span class="built_in">len</span>(a)-N]   <span class="comment">// 删除尾部N个元素</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>删除切片尾部的元素是最快的</p>
</blockquote>
<h2 id="37-函数"><a class="markdownIt-Anchor" href="#37-函数">#</a> 3.7 函数</h2>
<p>为完成某一功能的程序指令 (语句) 的集合，称为函数。</p>
<h3 id="371-函数分类"><a class="markdownIt-Anchor" href="#371-函数分类">#</a> 3.7.1 函数分类</h3>
<p>在 Go 语言中，函数是第一类对象，我们可以将函数保持到变量中。函数主要有<strong>具名</strong>和<strong>匿名</strong>之分，包级函数一般都是具名函数，具名函数是匿名函数的一种特例，当匿名函数引用了外部作用域中的变量时就成了<strong>闭包函数</strong>，闭包函数是函数式编程语言的核心。</p>
<p>举例代码如下：</p>
<ol>
<li>具名函数：就和 c 语言中的普通函数意义相同，具有函数名、返回值以及函数参数的函数。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<ol>
<li>匿名函数：指不需要定义函数名的一种函数实现方式，它由一个不带函数名的函数声明和函数体组成。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Add = <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>解释几个名词如下：</p>
<ol>
<li>闭包函数：返回为函数对象，不仅仅是一个函数对象，在该函数外还包裹了一层作用域，这使得，该函数无论在何处调用，优先使用自己外层包裹的作用域。</li>
<li>一级对象：支持闭包的多数语言都将函数作为第一级对象，就是说函数可以存储到变量中作为参数传递给其他函数，最重要的是能够被函数动态创建和返回。</li>
<li>包：go 的每一个文件都是属于一个包的，也就是说 go 是以包的形式来管理文件和项目目录结构的。</li>
</ol>
</blockquote>
<h3 id="372-函数声明和定义"><a class="markdownIt-Anchor" href="#372-函数声明和定义">#</a> 3.7.2 函数声明和定义</h3>
<p>Go 语言函数定义格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fuction_name</span><span class="params">([parameter list])</span></span>[<span class="keyword">return</span> types]&#123;</span><br><span class="line">	函数体</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th></th>
<th>解析</th>
</tr>
</thead>
<tbody>
<tr>
<td>func</td>
<td>函数由 func 开始声明</td>
</tr>
<tr>
<td>function_name</td>
<td>函数名称</td>
</tr>
<tr>
<td>parameter list</td>
<td>参数列表</td>
</tr>
<tr>
<td>return_types</td>
<td>返回类型</td>
</tr>
<tr>
<td>函数体</td>
<td>函数定义的代码集合</td>
</tr>
</tbody>
</table>
<h3 id="373-函数传参"><a class="markdownIt-Anchor" href="#373-函数传参">#</a> 3.7.3 函数传参</h3>
<blockquote>
<p>Go 语言中的函数可以有多个参数和多个返回值，参数和返回值都是以传值的方式和被调用者交换数据。在语法上，函数还支持可变数量的参数，<strong>可变数量的参数必须是最后出现的参数</strong>，可变数量的参数其实是一个切片类型的参数。</p>
</blockquote>
<p>当可变参数是一个<strong>空接口类型</strong>时，调用者是否解包可变参数会导致不同的结果，我们解释一下解包的含义，代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	Print(a...)   <span class="comment">// 解包</span></span><br><span class="line">	Print(a)	  <span class="comment">// 未解包</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">(a ...<span class="type">int</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	fmt.Println(a...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>
<p>以上当传入参数为 <code>a...</code>  时即是对切片 a 进行了解包，此时其实相当于直接调用 <code>Print(1,2,3)</code> 。当传入参数直接为  <code>a</code>  时等价于直接调用 <code>Print([]int&#123;&#125;&#123;1,2,3&#125;)</code></p>
<h3 id="374-函数返回值"><a class="markdownIt-Anchor" href="#374-函数返回值">#</a> 3.7.4 函数返回值</h3>
<blockquote>
<p>不仅函数的参数可以有名字，也可以给函数的返回值命名。</p>
</blockquote>
<p>举例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Find</span><span class="params">(m <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, key <span class="type">int</span>)</span></span>(value <span class="type">int</span>, ok <span class="type">bool</span>) &#123;</span><br><span class="line">	value,ok = m[key]</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<p>如果返回值命名了，可以通过名字来修改返回值，也可以通过 defer 语句在 return 语句之后修改返回值，举例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mian</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span> ; i&lt;<span class="number">3</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="built_in">println</span>(i) &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数最终的输出为：</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>
<p>以上代码中如果没有 defer 其实返回值就是 <code>0,1,2</code> ，但 defer 语句会在函数 return 之后才会执行，也就是或只有以上函数在执行结束 return 之后才会执行 defer 语句，而该函数 return 时的 <code>i</code>  值将会达到 3，所以最终的 defer 语句执行 printlin 的输出都是 3。</p>
<p>defer 语句延迟执行的其实是一个匿名函数，因为这个匿名函数捕获了外部函数的局部变量 v，这种函数我们一般叫闭包。闭包对捕获的外部变量并不是传值方式访问，而是以<strong>引用</strong>的方式访问。</p>
<p>这种方式往往会带来一些问题，修复方法为在每一轮迭代中都为 defer 函数提供一个独有的变量，修改代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        i := i <span class="comment">// 定义一个循环体内局部变量i</span></span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123; <span class="built_in">println</span>(i) &#125; ()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="comment">// 通过函数传入i</span></span><br><span class="line">        <span class="comment">// defer 语句会马上对调用参数求值</span></span><br><span class="line">        <span class="comment">// 不再捕获，而是直接传值</span></span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span>&#123; <span class="built_in">println</span>(i) &#125; (i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>
<h3 id="375-递归调用"><a class="markdownIt-Anchor" href="#375-递归调用">#</a> 3.7.5 递归调用</h3>
<p>Go 语言中，函数还可以直接或间接地调用自己，也就是支持递归调用。Go 语言函数的递归调用<strong>深度逻辑上没有限制</strong>，函数调用的栈是<strong>不会出现溢出错误</strong>的，因为 Go 语言运行时会根据需要动态地调整函数栈的大小。这部分的知识将会涉及 goroutint 和动态栈的相关知识，我们将会在之后的博文中向大家解释。</p>
<p>它的语法和 c 很相似，格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recursion</span><span class="params">()</span></span> &#123;</span><br><span class="line">   recursion() <span class="comment">/* 函数调用自身 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   recursion()</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>
<h2 id="38-方法"><a class="markdownIt-Anchor" href="#38-方法">#</a> 3.8 方法</h2>
<p>方法一般是面向对象编程 (OOP) 的一个特性，在 C++ 语言中方法对应一个类对象的成员函数，是关联到具体对象上的虚表中的。但是 Go 语言的方法却是<strong>关联到类型</strong>的，这样可以在<strong>编译阶段完成方法的静态绑定</strong>。一个面向对象的程序会用方法来表达其属性对应的操作，这样使用这个对象的用户就不需要直接去操作对象，而是借助方法来做这些事情。</p>
<p>实现 C 语言中的一组函数如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件对象</span></span><br><span class="line"><span class="keyword">type</span> File <span class="keyword">struct</span> &#123;</span><br><span class="line">    fd <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="type">string</span>)</span></span> (f *File, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CloseFile</span><span class="params">(f *File)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读文件数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(f *File, offset <span class="type">int64</span>, data []<span class="type">byte</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819</span></span><br></pre></td></tr></table></figure>
<p>以上的三个函数都是普通的函数，需要占用包级空间中的名字资源。不过 CloseFile 和 ReadFile 函数只是针对 File 类型对象的操作，这时候我们更希望这类函数和操作对象的类型紧密绑定在一起。</p>
<p>所以在 go 语言中我们修改如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> CloseFile() <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读文件数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> ReadFile(offset <span class="type">int64</span>, data []<span class="type">byte</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>
<p>将 CloseFile 和 ReadFile 函数的第一个参数移动到函数名的开头，这两个函数就成了<strong> File 类型</strong>独有的方法了（而不是 File 对象方法）</p>
<p>从代码角度看虽然只是一个小的改动，但是从编程哲学角度来看，Go 语言已经是进入面向对象语言的行列了。我们可以给任何自定义类型添加一个或多个方法。每种类型对应的方法必须和类型的定义在同一个包中，因此是无法给 int 这类内置类型添加方法的（因为方法的定义和类型的定义不在一个包中）。对于给定的类型，每个方法的名字必须是唯一的，同时方法和函数一样也不支持重载。</p>
<h2 id="39-接口"><a class="markdownIt-Anchor" href="#39-接口">#</a> 3.9 接口</h2>
<h3 id="391-什么是接口"><a class="markdownIt-Anchor" href="#391-什么是接口">#</a> 3.9.1 什么是接口</h3>
<p>Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。</p>
<p>Go 的接口类型是对其它类型行为的抽象和概括；因为接口类型<strong>不会和特定的实现细节绑定在一起</strong>，通过这种抽象的方式我们可以让对象更加灵活和更具有适应能力。很多面向对象的语言都有相似的接口概念，但 Go 语言中接口类型的独特之处在于它是满足隐式实现的鸭子类型。</p>
<p>所谓<strong>鸭子类型</strong>说的是：只要走起路来像鸭子、叫起来也像鸭子，那么就可以把它当作鸭子。Go 语言中的面向对象就是如此，如果一个对象只要看起来像是某种接口类型的实现，那么它就可以作为该接口类型使用。</p>
<p>就比如说在 c 语言中，使用 printf 在终端输出的时候只能输出有限类型的几个变量，而在 go 中可以使用 fmt.Printf，实际上是 fmt.Fprintf 向任意自定义的输出流对象打印，甚至可以打印到网络甚至是压缩文件，同时打印的数据不限于语言内置的基础类型，任意隐士满足 fmt.Stringer 接口的对象都可以打印，不满足 fmt.Stringer 接口的依然可以通过反射的技术打印。</p>
<h3 id="392-结构体类型"><a class="markdownIt-Anchor" href="#392-结构体类型">#</a> 3.9.2 结构体类型</h3>
<p>interface 实际上就是一个结构体，包含两个成员。其中一个成员是指向具体数据的指针，另一个成员中包含了类型信息。空接口和带方法的接口略有不同，下面分别是空接口的数据结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Eface</span><br><span class="line">&#123;</span><br><span class="line">    Type*    <span class="keyword">type</span>;</span><br><span class="line">    void*    data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>
<p>其中的 Type 指的是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uintptr</span> size;</span><br><span class="line">    <span class="type">uint32</span> hash;</span><br><span class="line">    <span class="type">uint8</span> _unused;</span><br><span class="line">    <span class="type">uint8</span> align;</span><br><span class="line">    <span class="type">uint8</span> fieldAlign;</span><br><span class="line">    <span class="type">uint8</span> kind;</span><br><span class="line">    Alg *alg;</span><br><span class="line">    void *gc;</span><br><span class="line">    String *<span class="type">string</span>;</span><br><span class="line">    UncommonType *x;</span><br><span class="line">    Type *ptrto;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>
<p>和带方法的接口使用的数据结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Iface</span><br><span class="line">&#123;</span><br><span class="line">    Itab*    tab;</span><br><span class="line">    void*    data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>
<p>其中的 Iface 指的是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span>    Itab</span><br><span class="line">&#123;</span><br><span class="line">    InterfaceType*    inter;</span><br><span class="line">    Type*    <span class="keyword">type</span>;</span><br><span class="line">    Itab*    link;</span><br><span class="line">    <span class="type">int32</span>    bad;</span><br><span class="line">    <span class="type">int32</span>    unused;</span><br><span class="line">    void    (*fun[])(void);   <span class="comment">// 方法表</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>
<h3 id="393-具体类型向接口类型赋值"><a class="markdownIt-Anchor" href="#393-具体类型向接口类型赋值">#</a> 3.9.3 具体类型向接口类型赋值</h3>
<p>将一个具体类型数据赋值给 interface 这样的抽象类型，需要进行类型转换。这个转换过程中涉及哪些操作呢？</p>
<p>如果转换为空接口，返回一个 Eface，将 Eface 中的 data 指针指向原型数据，type 指针会指向数据的 Type 结构体。</p>
<p>如果将其转化为带方法的 interface，需要进行一次检测，该类型必须实现 interface 中声明的所有方法才可以进行转换，这个检测将会在编译过程中进行。检测过程具体实现式通过比较具体类型的方法表和接口类型的方法表来进行的。</p>
<ul>
<li>具体类型方法表：Type 的 UncommonType 中有一个方法表，某个具体类型实现的所有方法都会被收集到这张表中。</li>
<li>接口类型方法表：Iface 的 Itab 的 InterfaceType 中也有一张方法表，这张方法表中是接口所声明的方法。Iface 中的 Itab 的 func 域也是一张方法表，这张表中的每一项就是一个函数指针，也就是只有实现没有声明。</li>
</ul>
<p>这两处方法表都是排序过的，只需要一遍顺序扫描进行比较，应该可以知道 Type 中否实现了接口中声明的所有方法。最后还会将 Type 方法表中的函数指针，拷贝到 Itab 的 fun 字段中。Iface 中的 Itab 的 func 域也是一张方法表，这张表中的每一项就是一个函数指针，也就是只有实现没有声明。</p>
<h3 id="394-获取接口类型数据的具体类型信息"><a class="markdownIt-Anchor" href="#394-获取接口类型数据的具体类型信息">#</a> 3.9.4 获取接口类型数据的具体类型信息</h3>
<p>接口类型转换为具体类型 (也就是反射，reflect)，也涉及到了类型转换。reflect 包中的 TypeOf 和 ValueOf 函数来得到接口变量的 Type 和 Value。</p>
<h2 id="310-channel"><a class="markdownIt-Anchor" href="#310-channel">#</a> 3.10 channel</h2>
<h3 id="3101-相关结构体定义"><a class="markdownIt-Anchor" href="#3101-相关结构体定义">#</a> 3.10.1 相关结构体定义</h3>
<p>go 中的 channel 是可以被存储在变量中，可以作为参数传递给函数，也可以作为函数返回值返回，我们先来看一下 channel 的结构体定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span>    Hchan</span><br><span class="line">&#123;</span><br><span class="line">    uintgo    qcount;            <span class="comment">// 队列q中的总数据数量</span></span><br><span class="line">    uintgo    dataqsize;        <span class="comment">// 环形队列q的数据大小</span></span><br><span class="line">    <span class="type">uint16</span>    elemsize;			<span class="comment">// 当前队列的使用量</span></span><br><span class="line">    <span class="type">bool</span>    closed;				</span><br><span class="line">    <span class="type">uint8</span>    elemalign;</span><br><span class="line">    Alg*    elemalg;        <span class="comment">// interface for element type</span></span><br><span class="line">    uintgo    sendx;            <span class="comment">// 发送index</span></span><br><span class="line">    uintgo    recvx;            <span class="comment">// 接收index</span></span><br><span class="line">    WaitQ    recvq;            <span class="comment">// 因recv而阻塞的等待队列</span></span><br><span class="line">    WaitQ    sendq;            <span class="comment">// 因send而阻塞的等待队列</span></span><br><span class="line">    Lock;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>
<p>Hchan 结构体中的核心部分是存放 channel 数据的环形队列，相关数据的作用已经在其后做出了备注。在该结构体中没有存放数据的域，如果是带缓冲区的 chan，则缓冲区数据实际上是紧接着 Hchan 结构体中分配的。</p>
<p>另一个重要部分就是 recvq 和 sendq 两个链表，一个是因读这个通道而导致阻塞的 goroutine，另一个是因为写这个通道而阻塞的 goroutine。如果一个 goroutine 阻塞于 channel 了，那么它就被挂在 recvq 或 sendq 中。WaitQ 是链表的定义，包含一个头结点和一个尾结点，该链表中中存放的成员是一个 sudoG 结构体变量，具体定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span>    SudoG</span><br><span class="line">&#123;</span><br><span class="line">    G*    g;        <span class="comment">// g and selgen constitute</span></span><br><span class="line">    <span class="type">uint32</span>    selgen;        <span class="comment">// a weak pointer to g</span></span><br><span class="line">    SudoG*    link;</span><br><span class="line">    <span class="type">int64</span>    releasetime;</span><br><span class="line">    <span class="type">byte</span>*    elem;        <span class="comment">// data element</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>
<p>该结构体中最主要的是 g 和 elem。elem 用于存储 goroutine 的数据。读通道时，数据会从 Hchan 的队列中拷贝到 SudoG 的 elem 域。写通道时，数据则是由 SudoG 的 elem 域拷贝到 Hchan 的队列中。</p>
<p>Hchan 结构如下：<br>
<img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/ddf2855d06234305a122bea469d0adaa.png" alt="在这里插入图片描述"></p>
<h3 id="3102-阻塞式读写channel操作"><a class="markdownIt-Anchor" href="#3102-阻塞式读写channel操作">#</a> 3.10.2 阻塞式读写 channel 操作</h3>
<p>写操作代码如下，其中的 c 就是 channel，v 指的是数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c &lt;- v</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>事实上基本的阻塞模式写 channel 操作在底层运行时库中对应的是一个 runtime.chansend 函数。具体如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void runtime·chansend(ChanType *t, Hchan *c, byte *ep, bool *pres, void *pc)</span><br></pre></td></tr></table></figure>
<p>其中的 ep 指的是变量 v 的地址，这里的传值约定是调用者负责分配好 ep 的空间，仅需要简单的取变量地址就好了，pres 是在 select 中的通道操作中使用的。</p>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/22fb68eff45145c89f2f64d51b3e556f.png" alt="在这里插入图片描述"></p>
<p>阻塞模式读操作的核心函数有两种包装如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool)</span><br></pre></td></tr></table></figure>
<p>以及</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected)</span><br></pre></td></tr></table></figure>
<p>这两种的区别主要在于返回值是否会返回一个 bool 类型值，该值只是用于判断 channel 是否能读取出数据。</p>
<p>读写操作的以上阻塞的过程类似，故而不再做出说明，我们补充三个细节：</p>
<ul>
<li>以上我们都强调是阻塞式的读写操作，其实相对应的也有<strong>非阻塞的</strong>读写操作，使用过 select-case 来进行调用的。</li>
<li>空通道，指的是将一个 channel 赋值为 nil，或者调用后不适用 make 进行初始化。读写空通道是永远阻塞的。</li>
<li>关闭的通道，永远不会阻塞，会返回一个通道数据类型的零值。首先将 closed 置为 1，第二步收集读等待队列 recvq 的所有 sg，每个 sg 的 elem 都设为类型零值，第三步收集写等待队列 sendq 的所有 sg，每个 sg 的 elem 都设为 nil，最后唤醒所有收集的 sg。</li>
</ul>
<h3 id="3103-非阻塞式读写channel操作"><a class="markdownIt-Anchor" href="#3103-非阻塞式读写channel操作">#</a> 3.10.3 非阻塞式读写 channel 操作</h3>
<p>如上文所说，非阻塞式其实就是使用 select-case 来实现，在编译时将会被编译为 if-else。</p>
<p>如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v = &lt;-c:</span><br><span class="line">        ...foo</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">        ...bar</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<p>就会被编译为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> selectnbrecv(&amp;v, c) &#123;</span><br><span class="line">        ...foo</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...bar</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>
<p>至于其中的 selectnbrecv 相关的函数简单地调 runtime.chanrecv 函数，设置了一个参数，告诉 runtime.chanrecv 函数，当不能完成操作时不要阻塞，而是返回失败。</p>
<p>但是 select 中的 case 的执行顺序是随机的，而不像 switch 中的 case 那样一条一条的顺序执行。让每一个 select 都对应一个 Select 结构体。在 Select 数据结构中有个 Scase 数组，记录下了每一个 case，而 Scase 中包含了 Hchan。然后 pollorder 数组将元素随机排列，这样就可以将 Scase 乱序了。</p>
<h2 id="311-map"><a class="markdownIt-Anchor" href="#311-map">#</a> 3.11 map</h2>
<p>map 表的底层原理是哈希表，其结构体定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">    Key  *Type <span class="comment">// Key type</span></span><br><span class="line">    Elem *Type <span class="comment">// Val (elem) type</span></span><br><span class="line"></span><br><span class="line">    Bucket *Type <span class="comment">// 哈希桶</span></span><br><span class="line">    Hmap   *Type <span class="comment">// 底层使用的哈希表元信息</span></span><br><span class="line">    Hiter  *Type <span class="comment">// 用于遍历哈希表的迭代器</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>
<p>其中的 Hmap 的具体化数据结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go.</span></span><br><span class="line">    <span class="comment">// Make sure this stays in sync with the compiler&#x27;s definition.</span></span><br><span class="line">    count     <span class="type">int</span> <span class="comment">// map目前的元素数目</span></span><br><span class="line">    flags     <span class="type">uint8</span> <span class="comment">// map状态（正在被遍历/正在被写入）</span></span><br><span class="line">    B         <span class="type">uint8</span>  <span class="comment">// 哈希桶数目以2为底的对数（哈希桶的数目都是 2 的整数次幂，用位运算来计算取余运算的值, 即 N mod M = N &amp; (M-1))）</span></span><br><span class="line">    noverflow <span class="type">uint16</span> <span class="comment">//溢出桶的数目, 这个数值不是恒定精确的, 当其 B&gt;=16 时为近似值</span></span><br><span class="line">    hash0     <span class="type">uint32</span> <span class="comment">// 随机哈希种子</span></span><br><span class="line"></span><br><span class="line">    buckets    unsafe.Pointer <span class="comment">// 指向当前哈希桶的指针</span></span><br><span class="line">    oldbuckets unsafe.Pointer <span class="comment">// 扩容时指向旧桶的指针</span></span><br><span class="line">    nevacuate  <span class="type">uintptr</span>        <span class="comment">// 桶进行调整时指示的搬迁进度</span></span><br><span class="line"></span><br><span class="line">    extra *mapextra <span class="comment">// 表征溢出桶的变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>
<p>以上 hmap 基本都是涉及到了哈希桶和溢出桶，我们首先看一下它的数据结构，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    topbits  [<span class="number">8</span>]<span class="type">uint8</span>    <span class="comment">// 键哈希值的高8位</span></span><br><span class="line">    keys     [<span class="number">8</span>]keytype  <span class="comment">// 哈希桶中所有键</span></span><br><span class="line">    elems    [<span class="number">8</span>]elemtype	<span class="comment">// 哈希桶中所有值</span></span><br><span class="line">    <span class="comment">//pad      uintptr(新的 go 版本已经移除了该字段, 我未具体了解此处的 change detail, 之前设置该字段是为了在 nacl/amd64p32 上的内存对齐)</span></span><br><span class="line">    overflow <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>
<p>我们会发现哈希桶 bmap 一般指定其能保存 8 个键值对，如果多于 8 个键值对，就会申请新的 buckets，并将其于之前的 buckets 链接在一起。</p>
<p>其中的联系如图所示：<br>
<img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/13c1b9f9899d48b08c32b76ef4037a17.png" alt="在这里插入图片描述"></p>
<p>在具体插入时，首先会根据 key 值采用相应的 hash 算法计算对应的哈希值，将哈希值的低 8 位作为 Hmap 结构体中 buckets 数组的索引，找到 key 值所对应的 bucket，将哈希值的高 8 位催出在 bucket 的 tophash 中。</p>
<p>特点如下：</p>
<ul>
<li>map 是<strong>无序的</strong>（原因为无序写入以及扩容导致的元素顺序发生变化），每次打印出来的 map 都会不一样，它不能通过 index 获取，而必须通过 key 获取</li>
<li>map 的<strong>长度是不固定</strong>的，也就是和 slice 一样，也是一种引用类型</li>
<li>内置的 len 函数同样适用于 map，返回 map 拥有的 key 的数量</li>
<li>map 的 key 可以是所有可比较的类型，如布尔型、整数型、浮点型、复杂型、字符串型…… 也可以键。</li>
</ul>
<p>如下方式即可进行初始化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">map</span>[keytype]valuetype</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>类型名</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>map 表名字</td>
</tr>
<tr>
<td>keytype</td>
<td>键类型</td>
</tr>
<tr>
<td>valuetype</td>
<td>键对应的值的类型</td>
</tr>
</tbody>
</table>
<p>除此以外还可以使用 make 进行初始化，代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map_variable = <span class="built_in">make</span>(<span class="keyword">map</span>[key_data_type]value_data_type)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>我们还可以使用初始值进行初始化，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;hunter&quot;</span>:<span class="number">12</span>,<span class="string">&quot;tony&quot;</span>:<span class="number">10</span>&#125;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="3111-插入数据"><a class="markdownIt-Anchor" href="#3111-插入数据">#</a> 3.11.1 插入数据</h3>
<p>map 的数据插入代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map_variable[<span class="string">&quot;mars&quot;</span>] = <span class="number">27</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>插入过程如下：</p>
<ol>
<li>根据 key 值计算出哈希值</li>
<li>取哈希值低位和 hmap.B 取模确定 bucket 位置</li>
<li>查找该 key 是否已经存在，如果存在则直接更新值</li>
<li>如果没有找到 key，则将这一对 key-value 插入</li>
</ol>
<h3 id="3112-删除数据"><a class="markdownIt-Anchor" href="#3112-删除数据">#</a> 3.11.2 删除数据</h3>
<p><strong>delete(map, key)</strong> 函数用于删除集合的元素，参数为 map 和其对应的 key。删除函数不返回任何值。相关代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   countryCapitalMap := <span class="keyword">map</span>[<span class="type">string</span>] <span class="type">string</span> &#123;<span class="string">&quot;France&quot;</span>:<span class="string">&quot;Paris&quot;</span>,<span class="string">&quot;Italy&quot;</span>:<span class="string">&quot;Rome&quot;</span>,<span class="string">&quot;Japan&quot;</span>:<span class="string">&quot;Tokyo&quot;</span>,<span class="string">&quot;India&quot;</span>:<span class="string">&quot;New Delhi&quot;</span>&#125;</span><br><span class="line">   <span class="comment">/* 删除元素 */</span></span><br><span class="line">   <span class="built_in">delete</span>(countryCapitalMap,<span class="string">&quot;France&quot;</span>);</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<h3 id="3113-查找数据"><a class="markdownIt-Anchor" href="#3113-查找数据">#</a> 3.11.3 查找数据</h3>
<p>通过 key 获取 map 中对应的 value 值。语法为： <code>map[key] </code> . 但是当 key 如果不存在的时候，我们会得到该 value 值类型的默认值，比如 string 类型得到空字符串，int 类型得到 0。但是程序不会报错。</p>
<p>所以我们可以使用<strong> ok-idiom</strong> 获取值，如下： <code>value, ok := map[key] </code> ，其中的 value 是返回值，ok 是一个 bool 值，可知道 key/value 是否存在。</p>
<p>在 map 表中的查找过程如下：</p>
<ol>
<li>查找或者操作 map 时，首先 key 经过 hash 函数生成 hash 值</li>
<li>通过哈希值的低 8 位来判断当前数据属于哪个桶</li>
<li>找到桶之后，通过哈希值的高八位与 bucket 存储的高位哈希值循环比对</li>
<li>如果相同就比较刚才找到的底层数组的 key 值，如果 key 相同，取出 value</li>
<li>如果高八位 hash 值在此 bucket 没有，或者有，但是 key 不相同，就去链表中下一个溢出 bucket 中查找，直到查找到链表的末尾</li>
<li>如果查找不到，也不会返回空值，而是返回相应类型的 0 值。</li>
</ol>
<h3 id="3114-扩容"><a class="markdownIt-Anchor" href="#3114-扩容">#</a> 3.11.4 扩容</h3>
<p>哈希表就是以空间换时间，访问速度是直接跟填充因子相关的，所以当哈希表太满之后就需要进行扩容。</p>
<p>如果扩容前的哈希表大小为 2B 扩容之后的大小为 2 (B+1)，每次扩容都变为<strong>原来大小的两倍</strong>，哈希表大小始终为 2 的指数倍，则有 (hash mod 2B) 等价于 (hash &amp; (2B-1))。这样可以简化运算，避免了取余操作。</p>
<blockquote>
<p>触发扩容的条件？</p>
</blockquote>
<ol>
<li>负载因子 (负载因子 = 键数量 /bucket 数量) &gt; 6.5 时，也即平均每个 bucket 存储的键值对达到 6.5 个。</li>
<li>溢出桶（overflow）数量 &gt; 2^15 时，也即 overflow 数量超过 32768 时。</li>
</ol>
<blockquote>
<p>什么是增量扩容呢？</p>
</blockquote>
<p>如果负载因子 &gt; 6.5 时，进行增量扩容。这时会新建一个桶（bucket），新的 bucket 长度是原来的 2 倍，然后旧桶数据搬迁到新桶。每个旧桶的键值对都会分流到两个新桶中</p>
<p>主要是缩短 map 容器的响应时间。假如我们直接将 map 用作某个响应实时性要求非常高的 web 应用存储，如果不采用增量扩容，当 map 里面存储的元素很多之后，扩容时系统就会卡往，导致较长一段时间内无法响应请求。不过增量扩容本质上还是将总的扩容时间分摊到了每一次哈希操作上面。</p>
<blockquote>
<p>什么是等量扩容？它的触发条件是什么？进行等量扩容后的优势是什么？</p>
</blockquote>
<p>等量扩容，就是创建和旧桶数目一样多的新桶，然后把原来的键值对迁移到新桶中，重新做一遍类似增量扩容的搬迁动作。</p>
<p>触发条件：负载因子没超标，溢出桶较多。这个较多的评判标准为：</p>
<ul>
<li>如果常规桶数目不大于 2^15，那么使用的溢出桶数目超过常规桶就算是多了；</li>
<li>如果常规桶数目大于 215，那么使用溢出桶数目一旦超过 215 就算多了。</li>
</ul>
<p>这样做的目的是把松散的键值对重新排列一次，能够存储的更加紧凑，进而减少溢出桶的使用，以使 bucket 的使用率更高，进而保证更快的存取。</p>
<h1 id="4-常用语句及关键字"><a class="markdownIt-Anchor" href="#4-常用语句及关键字">#</a> 4. 常用语句及关键字</h1>
<p>接下来我们了解一下关于 go 语言语句的基本内容。</p>
<h2 id="41-条件语句"><a class="markdownIt-Anchor" href="#41-条件语句">#</a> 4.1 条件语句</h2>
<p>和 c 语言类似，相关的条件语句如下表所示：</p>
<table>
<thead>
<tr>
<th>语句</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>if 语句</td>
<td>if 语句 由一个布尔表达式后紧跟一个或多个语句组成。</td>
</tr>
<tr>
<td>if…else 语句</td>
<td>if 语句 后可以使用可选的 else 语句，else 语句中的表达式在布尔表达式为 false 时执行。</td>
</tr>
<tr>
<td>switch 语句</td>
<td>switch 语句用于基于不同条件执行不同动作。</td>
</tr>
<tr>
<td>select 语句</td>
<td>select 语句类似于 switch 语句，但是 select 会随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。</td>
</tr>
</tbody>
</table>
<ul>
<li>if 语句<br>
语法如下：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 布尔表达式 &#123;</span><br><span class="line">   <span class="comment">/* 在布尔表达式为 true 时执行 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<ul>
<li>if-else 语句</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 布尔表达式 &#123;</span><br><span class="line">   <span class="comment">/* 在布尔表达式为 true 时执行 */</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">/* 在布尔表达式为 false 时执行 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>
<ul>
<li>switch 语句<br>
其中的变量 <code>v</code>  可以是任何类型， <code>val1</code>  和 <code>val2</code>  可以是同类型的任意值，类型不局限为常量或者整数，或者最终结果为相同类型的表达式。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> v &#123;</span><br><span class="line">    <span class="keyword">case</span> val1:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> val2:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>
<ul>
<li>select 语句<br>
 select 是 Go 中的一个控制结构，类似于用于通信的 switch 语句。每个 case 必须是一个<strong>通信操作</strong>，要么是发送要么是接收。它将会随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。一个默认的子句应该总是可运行的。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> communication clause  :</span><br><span class="line">       statement(s);      </span><br><span class="line">    <span class="keyword">case</span> communication clause  :</span><br><span class="line">       statement(s);</span><br><span class="line">    <span class="comment">/* 你可以定义任意数量的 case */</span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">/* 可选 */</span></span><br><span class="line">       statement(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
<ul>
<li>每个 case 必须都是一个通信</li>
<li>所有 channel 表达式都会被求值，所有被发送的表达式都会被求值</li>
<li>如果任意某一个通信都可以，它就执行，其他就忽略</li>
<li>如果有多个 case 都可以运行，select 就会随机挑选一个来执行。</li>
<li>如果没有一个 case 可以被运行：如果有 default 子句，就执行 default 子句，select 将被阻塞，直到某个通信可以运行，从而避免饥饿问题。</li>
</ul>
</blockquote>
<h2 id="42-循环语句"><a class="markdownIt-Anchor" href="#42-循环语句">#</a> 4.2 循环语句</h2>
<h3 id="421-循环处理语句"><a class="markdownIt-Anchor" href="#421-循环处理语句">#</a> 4.2.1 循环处理语句</h3>
<p>go 中时使用 for 实现循环的，共有三种形式：</p>
<table>
<thead>
<tr>
<th></th>
<th>语法</th>
</tr>
</thead>
<tbody>
<tr>
<td>和 c 语言中的 for 相同</td>
<td>for init; condition; post {}</td>
</tr>
<tr>
<td>和 c 语言中的 while 相同</td>
<td>for condition{}</td>
</tr>
<tr>
<td>和 c 语言中的 <code>for(;;)</code>  相同</td>
<td>for{}</td>
</tr>
</tbody>
</table>
<p>除此以外，for 循环还可以直接使用<strong> range</strong> 对 slice、map、数组以及字符串等进行迭代循环，格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> oldmap &#123;</span><br><span class="line">	newmap[key] = value</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<h3 id="421-循环控制语句"><a class="markdownIt-Anchor" href="#421-循环控制语句">#</a> 4.2.1 循环控制语句</h3>
<table>
<thead>
<tr>
<th>控制语句</th>
<th>详解</th>
</tr>
</thead>
<tbody>
<tr>
<td>break</td>
<td>中断跳出循环或者 switch 语句</td>
</tr>
<tr>
<td>continue</td>
<td>跳过当前循环的剩余语句，然后继续下一轮循环</td>
</tr>
<tr>
<td>goto 语句</td>
<td>将控制转移到被标记的语句</td>
</tr>
</tbody>
</table>
<ol>
<li>break<br>
break 主要用于循环语句跳出循环，和 c 语言中的使用方式是相同的。且在多重循环的时候还可以使用 label 标出想要 break 的循环。<br>
实例代码如下：</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> a&lt;<span class="number">5</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, a)</span><br><span class="line">	a++</span><br><span class="line">	<span class="keyword">if</span> a==<span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>
<ol>
<li>continue<br>
Go 语言的 continue 语句 有点像 break 语句。但是 continue 不是跳出循环，而是跳过当前循环执行下一次循环语句。在多重循环中，可以用标号 label 标出想 continue 的循环。<br>
实例代码如下：</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 不使用标记</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;---- continue ---- &quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;i: %d\n&quot;</span>, i)</span><br><span class="line">            <span class="keyword">for</span> i2 := <span class="number">11</span>; i2 &lt;= <span class="number">13</span>; i2++ &#123;</span><br><span class="line">                fmt.Printf(<span class="string">&quot;i2: %d\n&quot;</span>, i2)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">i: 1</span></span><br><span class="line"><span class="comment">i2: 11</span></span><br><span class="line"><span class="comment">i2: 12</span></span><br><span class="line"><span class="comment">i2: 13</span></span><br><span class="line"><span class="comment">i: 2</span></span><br><span class="line"><span class="comment">i2: 11</span></span><br><span class="line"><span class="comment">i2: 12</span></span><br><span class="line"><span class="comment">i2: 13</span></span><br><span class="line"><span class="comment">i: 3</span></span><br><span class="line"><span class="comment">i2: 11</span></span><br><span class="line"><span class="comment">i2: 12</span></span><br><span class="line"><span class="comment">i2: 13</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用标记</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;---- continue label ----&quot;</span>)</span><br><span class="line">    re:</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;i: %d&quot;</span>, i)</span><br><span class="line">                <span class="keyword">for</span> i2 := <span class="number">11</span>; i2 &lt;= <span class="number">13</span>; i2++ &#123;</span><br><span class="line">                    fmt.Printf(<span class="string">&quot;i2: %d\n&quot;</span>, i2)</span><br><span class="line">                    <span class="keyword">continue</span> re</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">i: 1</span></span><br><span class="line"><span class="comment">i2: 11</span></span><br><span class="line"><span class="comment">i: 2</span></span><br><span class="line"><span class="comment">i2: 11</span></span><br><span class="line"><span class="comment">i: 3</span></span><br><span class="line"><span class="comment">i2: 11</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435363738394041424344</span></span><br></pre></td></tr></table></figure>
<ol>
<li>goto<br>
goto 语句主要是无条件转移到过程中<strong>指定的行</strong>。goto 语句通常和条件语句配合使用，可用来实现条件转移、构成循环以及跳出循环体等功能。但是并不主张使用 goto 语句，以免造成程序流程混乱。<br>
示例代码如下：</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">0</span></span><br><span class="line">LOOP: <span class="keyword">for</span> a&lt;<span class="number">5</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a == <span class="number">2</span> &#123;</span><br><span class="line">		a = a+<span class="number">1</span></span><br><span class="line">		<span class="keyword">goto</span> LOOP</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, a)</span><br><span class="line">	a++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="number">123456789101112131415161718</span></span><br></pre></td></tr></table></figure>
<p>以上代码中的 LOOP 就是一个标签，当运行到 goto 语句的时候，此时执行流就会跳转到 LOOP 标志的哪一行上。</p>
<h2 id="43-关键字"><a class="markdownIt-Anchor" href="#43-关键字">#</a> 4.3 关键字</h2>
<p>我们这一部分直接列表供大家了解 go 中的关键字如下：</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>import</td>
<td>导入相应的包文件</td>
</tr>
<tr>
<td>package</td>
<td>创建包文件，用于标记该文件归属哪个包</td>
</tr>
<tr>
<td>chan</td>
<td>channal，通道</td>
</tr>
<tr>
<td>var</td>
<td>变量控制，用于简短声明定义变量（:= 符号只能在函数内部使用，不能全局使用）</td>
</tr>
<tr>
<td>const</td>
<td>常量声明，任何时候 const 和 var 都可以同时出现</td>
</tr>
<tr>
<td>func</td>
<td>定义函数和方法</td>
</tr>
<tr>
<td>interface</td>
<td>接口，是一种具有一组方法的类型，这些方法定义了 interface 的行为</td>
</tr>
<tr>
<td>map</td>
<td>哈希表</td>
</tr>
<tr>
<td>struct</td>
<td>定义结构体</td>
</tr>
<tr>
<td>type</td>
<td>声明类型，取别名</td>
</tr>
<tr>
<td>for</td>
<td>for 是 go 中唯一的循环结构，上文中已经介绍过它的用法</td>
</tr>
<tr>
<td>break</td>
<td>中止，跳出循环</td>
</tr>
<tr>
<td>continue</td>
<td>继续下一轮循环</td>
</tr>
<tr>
<td>select</td>
<td>选择流程，可以同时等待多个通道操作</td>
</tr>
<tr>
<td>switch</td>
<td>多分枝选择，上文中已经详细介绍过它的用法</td>
</tr>
<tr>
<td>case</td>
<td>和 switch 配套使用</td>
</tr>
<tr>
<td>default</td>
<td>用于选择结构的默认选型</td>
</tr>
<tr>
<td>defer</td>
<td>用于资源释放，会在函数返回之前进行调用</td>
</tr>
<tr>
<td>if</td>
<td>分支选择</td>
</tr>
<tr>
<td>else</td>
<td>和 if 配套使用</td>
</tr>
<tr>
<td>go</td>
<td>通过 <code>go func()</code>  来开启一个 goroutine</td>
</tr>
<tr>
<td>goto</td>
<td>跳转至标志点的代码块，不推荐使用</td>
</tr>
<tr>
<td>fallthrouth</td>
<td></td>
</tr>
<tr>
<td>range</td>
<td>用于遍历 slice 类型数据</td>
</tr>
<tr>
<td>return</td>
<td>用于标注函数返回值</td>
</tr>
</tbody>
</table>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-01-06T01:06:38.037Z" title="2023-1-6 9:06:38">2023-01-06</time>发表</span><span class="level-item"><time dateTime="2023-01-06T01:09:15.390Z" title="2023-1-6 9:09:15">2023-01-06</time>更新</span><span class="level-item">1 分钟读完 (大约193个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/06/%E3%80%90Jenkins%E3%80%91Linux%E4%B8%8B%E4%BD%BF%E7%94%A8war%E5%8C%85%E9%83%A8%E7%BD%B2Jenkins/">Linux下使用war包部署Jenkins</a></p><div class="content"><h1 id="linux下使用war包部署jenkins"><a class="markdownIt-Anchor" href="#linux下使用war包部署jenkins">#</a> Linux 下使用 war 包部署 Jenkins</h1>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言">#</a> 前言</h2>
<p>jenkins 可以多种方式安装，可以 docker，也可以直接下载 war 包，然后 java -jar 方式启动。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.创建安装目录</span><br><span class="line">	mkdir -p /jenkins</span><br><span class="line">2.切换目录</span><br><span class="line">	cd  /jenkins</span><br><span class="line">3.下载war包</span><br><span class="line">	wget -O /jenkins/jenkins.war http://mirrors.jenkins.io/war-stable/latest/jenkins.war</span><br><span class="line">4.启动</span><br><span class="line">	BUILD_ID=dontKillMe nohup java -DJENKINS_HOME=/jenkins (如果有历史home可以指定其他home：/root/.jenkins) -Xms1046m -Xmx2000m -jar jenkins.war --httpPort=9444  &gt;&gt;jenkinsLog.log 2&gt;&amp;1 &amp;</span><br><span class="line">5.访问</span><br><span class="line">	http://&#123;your ip&#125;:9444</span><br></pre></td></tr></table></figure>
<h3 id="备注"><a class="markdownIt-Anchor" href="#备注">#</a> <strong>备注:</strong></h3>
<ol>
<li>–httpPort 自定义端口</li>
<li>jenkins 默认工作目录：/root/.jenkins</li>
<li>nohup 后台启动</li>
<li>‘&gt;&gt;log’ 以追加的方式记录日志</li>
<li>2&gt;&amp;1 2: 标准异常输出 1: 标准输出 ，2&gt;&amp;1 两种输出都记录到 log 文件中</li>
<li>&amp; 后台启动方式</li>
<li>BUILD_ID=dontKillMe 防止误杀包</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-01-06T00:37:50.763Z" title="2023-1-6 8:37:50">2023-01-06</time>发表</span><span class="level-item"><time dateTime="2023-01-06T00:43:00.570Z" title="2023-1-6 8:43:00">2023-01-06</time>更新</span><span class="level-item">9 分钟读完 (大约1386个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/06/%E3%80%90Docker%E3%80%91Docker%E5%AE%89%E8%A3%85Jenkins/">Docker安装Jenkins</a></p><div class="content"><h1 id="docker安装jenkins"><a class="markdownIt-Anchor" href="#docker安装jenkins">#</a> Docker 安装 Jenkins</h1>
<h1 id="一-前言"><a class="markdownIt-Anchor" href="#一-前言">#</a> 一、前言</h1>
<h2 id="1-领头羊"><a class="markdownIt-Anchor" href="#1-领头羊">#</a> 1、领头羊</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">作为领先的开源自动化服务器，Jenkins 提供了数百个插件来支持构建、部署和自动化任何项目。</span><br></pre></td></tr></table></figure>
<h2 id="2-特点"><a class="markdownIt-Anchor" href="#2-特点">#</a> 2、特点</h2>
<ul>
<li>持续集成和持续交付：作为可扩展的自动化服务器，Jenkins 可以用作简单的 CI 服务器或变成任何项目的持续交付中心。</li>
<li>简易安装：Jenkins 是一个独立的基于 Java 的程序，可以开箱即用，包含适用于 Windows、Linux、macOS 和其他类 Unix 操作系统的软件包。</li>
<li>易于配置：Jenkins 可以通过其 Web 界面轻松设置和配置，其中包括即时错误检查和内置帮助。</li>
<li>插件：凭借更新中心的数百个插件，Jenkins 与持续集成和持续交付工具链中的几乎所有工具集成。</li>
<li>可扩展：Jenkins 可以通过其插件架构进行扩展，为 Jenkins 可以做的事情提供几乎无限的可能性。</li>
<li>分散式：Jenkins 可以轻松地在多台机器上分配工作，帮助更快地跨多个平台推动构建、测试和部署。</li>
</ul>
<h1 id="二-docker安装jenkins"><a class="markdownIt-Anchor" href="#二-docker安装jenkins">#</a> 二、<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Docker%E5%AE%89%E8%A3%85Jenkins&amp;spm=1001.2101.3001.7020">Docker 安装 Jenkins</a></h1>
<h2 id="1-docker-search-jenkins查询镜像"><a class="markdownIt-Anchor" href="#1-docker-search-jenkins查询镜像">#</a> 1、docker search jenkins 查询镜像</h2>
<h3 id="11-正常查询结果"><a class="markdownIt-Anchor" href="#11-正常查询结果">#</a> 1.1、正常查询结果</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker search jenkins</span><br><span class="line">NAME                               DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">jenkins                            DEPRECATED; use &quot;jenkins/jenkins:lts&quot; instead   5504                [OK]                </span><br><span class="line">jenkins/jenkins                    The leading open source automation server       3087                                    </span><br><span class="line">jenkins/jnlp-slave                 a Jenkins agent which can connect to Jenkins…   150                                     [OK]</span><br><span class="line">jenkins/inbound-agent                                                              65                                      </span><br><span class="line">bitnami/jenkins                    Bitnami Docker Image for Jenkins                53                                      [OK]</span><br><span class="line">jenkins/slave                      base image for a Jenkins Agent, which includ…   48                                      [OK]</span><br><span class="line">jenkins/agent                                                                      39                                      </span><br><span class="line">jenkins/ssh-slave                  A Jenkins slave using SSH to establish conne…   38                                      [OK]</span><br><span class="line">jenkins/ssh-agent                  Docker image for Jenkins agents connected ov…   24                                      </span><br><span class="line">jenkins/jnlp-agent-docker                                                          8                                       </span><br><span class="line">jenkins/jnlp-agent-maven           A JNLP-based agent with Maven 3 built in        7                                       </span><br><span class="line">jenkins/pct                        Plugin Compat Tester                            5                                       [OK]</span><br><span class="line">jenkins/jenkins-experimental       Experimental images of Jenkins. These images…   3                                       [OK]</span><br><span class="line">jenkins/jnlp-agent-python          A JNLP-based agent with Python built in         3                                       </span><br><span class="line">jenkins/jnlp-agent-alpine                                                          2                                       </span><br><span class="line">jenkins/jnlp-agent-node                                                            1                                       </span><br><span class="line">rancher/jenkins-jenkins                                                            1                                       </span><br><span class="line">jenkins/ath                        Jenkins Acceptance Test Harness                 1                                       [OK]</span><br><span class="line">jenkins/core-changelog-generator   Tool for generating Jenkins core changelogs     1                                       </span><br><span class="line">jenkins/jenkinsfile-runner         Jenkinsfile Runner packages                     1                                       </span><br><span class="line">jenkins/core-pr-tester             Docker image for testing pull-requests sent …   1                                       </span><br><span class="line">jenkins/jnlp-agent-ruby                                                            1                                       </span><br><span class="line">jenkins/remoting-kafka-agent       Remoting Kafka Agent                            1                                       [OK]</span><br><span class="line">rancher/jenkins-jnlp-slave                                                         0                                       </span><br><span class="line">rancher/jenkins-slave              Jenkins Build Slave                             0                                       [OK]</span><br><span class="line">[root@localhost ~]# ^C</span><br><span class="line">[root@localhost ~]# </span><br></pre></td></tr></table></figure>
<h3 id="12-可能异常情况这个异常解决方法为下面第2点"><a class="markdownIt-Anchor" href="#12-可能异常情况这个异常解决方法为下面第2点">#</a> 1.2、可能异常情况，这个异常解决方法为下面第 2 点</h3>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/07f347955491462592d6f37cc2394fc6.png" alt="img"></p>
<h2 id="2-上面报这个error解决方法"><a class="markdownIt-Anchor" href="#2-上面报这个error解决方法">#</a> 2、上面报这个 ERROR 解决方法</h2>
<h3 id="21-更新时间同步即可ntpdate-cnpoolntporg"><a class="markdownIt-Anchor" href="#21-更新时间同步即可ntpdate-cnpoolntporg">#</a> 2.1、更新<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5&amp;spm=1001.2101.3001.7020">时间同步</a>即可：ntpdate <a target="_blank" rel="noopener" href="http://cn.pool.ntp.org">cn.pool.ntp.org</a></h3>
<h3 id="22-如果提示不存在-ntpdate-命令需要先安装该命令yum-install-ntpdate"><a class="markdownIt-Anchor" href="#22-如果提示不存在-ntpdate-命令需要先安装该命令yum-install-ntpdate">#</a> 2.2、如果提示不存在 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=ntpdate&amp;spm=1001.2101.3001.7020">ntpdate</a> 命令需要先安装该命令：yum install ntpdate</h3>
<h3 id="23-date中国时间"><a class="markdownIt-Anchor" href="#23-date中国时间">#</a> 2.3、date 中国时间</h3>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/315167c9692b4ebbad480fdffdf439c0.png" alt="img"></p>
<h2 id="3-docker-pull-jenkinsciblueocean拉取jenkins镜像"><a class="markdownIt-Anchor" href="#3-docker-pull-jenkinsciblueocean拉取jenkins镜像">#</a> 3、****docker pull jenkinsci/blueocean**** 拉取 Jenkins 镜像</h2>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/1ef511da220c4ca4bca8143aa55c9e52.png" alt="img"></p>
<h2 id="4-docker-images-查看本地镜像"><a class="markdownIt-Anchor" href="#4-docker-images-查看本地镜像">#</a> 4、docker images 查看本地镜像</h2>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/d9690427ee344603ac96cfa1a6a5510c.png" alt="img"></p>
<h2 id="5-centos7安装jdk安装-已有jdk可以跳过"><a class="markdownIt-Anchor" href="#5-centos7安装jdk安装-已有jdk可以跳过">#</a> 5、CentOS7 安装 JDK 安装 已有 JDK 可以跳过</h2>
<h3 id="51-可以下载linux版本targz压缩包到本地不用解压"><a class="markdownIt-Anchor" href="#51-可以下载linux版本targz压缩包到本地不用解压">#</a> 5.1、可以下载 linux 版本 tar.gz 压缩包到本地不用解压</h3>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/b413890d2adc4b8ea27f016d215c14e7.png" alt="img"></p>
<h3 id="52-cd-usr-mkdir-java进入usr创建java文件夹"><a class="markdownIt-Anchor" href="#52-cd-usr-mkdir-java进入usr创建java文件夹">#</a> 5.2、****cd /usr, mkdir java**** 进入 usr 创建 java 文件夹</h3>
<h3 id="53-cd-java进入java文件夹用rz将linux版的jdk压缩包上传到这里"><a class="markdownIt-Anchor" href="#53-cd-java进入java文件夹用rz将linux版的jdk压缩包上传到这里">#</a> 5.3、****cd java*<em><strong> 进入 java 文件夹，用</strong></em> * rz**** 将 linux 版的 jdk 压缩包上传到这里</h3>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/32e9bd440462402a80f0aa6a0ef32a18.png" alt="img"></p>
<h3 id="54-将jdk移到javamv-jdk-8u301-linux-x64targz-usrjava移动文件命令"><a class="markdownIt-Anchor" href="#54-将jdk移到javamv-jdk-8u301-linux-x64targz-usrjava移动文件命令">#</a> 5.4、(将 JDK 移到 java，mv jdk-8u301-linux-x64.tar.gz/usr/java) 移动文件命令</h3>
<h3 id="55-tar-zxvf-jdk-8u301-linux-x64targz解压会有jdk180_301出现"><a class="markdownIt-Anchor" href="#55-tar-zxvf-jdk-8u301-linux-x64targz解压会有jdk180_301出现">#</a> 5.5、<em><strong>*tar*</strong></em> <em><strong>*-*</strong></em><em><strong>*zxvf*</strong></em> jdk-8u301-linux-x64.tar.gz，解压会有 jdk1.8.0_301 出现</h3>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/100d06f1ce4e4ee7b4b209cbf37491db.png" alt="img"></p>
<h3 id="56-vi-etcprofile配置linux系统jdk环境变量"><a class="markdownIt-Anchor" href="#56-vi-etcprofile配置linux系统jdk环境变量">#</a> 5.6、****vi /etc/profile**** 配置 linux 系统 JDK 环境变量</h3>
<p><strong>1) 配置内容</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_301</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br></pre></td></tr></table></figure>
<h3 id="57-source-etcprofile使配置生效"><a class="markdownIt-Anchor" href="#57-source-etcprofile使配置生效">#</a> 5.7、****source /etc/profile**** 使配置生效</h3>
<h3 id="58-sudo-yum-install-glibci686可能报错解决方案-否则会会报找不到"><a class="markdownIt-Anchor" href="#58-sudo-yum-install-glibci686可能报错解决方案-否则会会报找不到">#</a> 5.8、<em><strong>*sudo yum install glibc.i686*</strong></em>，可能报错解决方案、否则会会报找不到</h3>
<h3 id="59-java-version测试出现如下即为成功"><a class="markdownIt-Anchor" href="#59-java-version测试出现如下即为成功">#</a> 5.9、****java -version**** 测试，出现如下即为成功</h3>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/f3cca3db43c84bf79be1bfa8282c4ba9.png" alt="img"></p>
<h2 id="6-centos7安装maven"><a class="markdownIt-Anchor" href="#6-centos7安装maven">#</a> 6、CentOS7 安装 Maven</h2>
<h3 id="61-cd-usrlocal"><a class="markdownIt-Anchor" href="#61-cd-usrlocal">#</a> 6.1、<em><strong>*cd /usr/local*</strong></em></h3>
<h3 id="62-rz上传tar-zxvf-apache-maven-361-bintargz解压"><a class="markdownIt-Anchor" href="#62-rz上传tar-zxvf-apache-maven-361-bintargz解压">#</a> 6.2、****rz*<em><strong> 上传，</strong></em>*tar -zxvf apache-maven-3.6.1-bin.tar.gz**** 解压</h3>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/1055aa0df0184f6bb28bde13fed60bc5.png" alt="img"></p>
<h3 id="63-vi-etcprofile"><a class="markdownIt-Anchor" href="#63-vi-etcprofile">#</a> 6.3、<em><strong>*vi /etc/profile*</strong></em></h3>
<h3 id="64-source-etcprofile刷新环境变量"><a class="markdownIt-Anchor" href="#64-source-etcprofile刷新环境变量">#</a> 6.4、****source /etc/profile**** 刷新环境变量</h3>
<h3 id="65-mvn-v查看版本"><a class="markdownIt-Anchor" href="#65-mvn-v查看版本">#</a> 6.5、****mvn -v**** 查看版本</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost local]# mvn -v</span><br><span class="line">Apache Maven 3.6.3 (cecedd343002696d0abb50b32b541b8a6ba2883f)</span><br><span class="line">Maven home: /usr/local/apache-maven-3.6.3</span><br><span class="line">Java version: 1.8.0_301, vendor: Oracle Corporation, runtime: /usr/java/jdk1.8.0_301/jre</span><br><span class="line">Default locale: en_US, platform encoding: UTF-8</span><br><span class="line">OS name: &quot;linux&quot;, version: &quot;3.10.0-1127.el7.x86_64&quot;, arch: &quot;amd64&quot;, family: &quot;unix&quot;</span><br><span class="line">[root@localhost local]# </span><br></pre></td></tr></table></figure>
<p>到此 JDK、Maven 环境准备完成</p>
<h2 id="7-启动容器并挂载上面配置的环境"><a class="markdownIt-Anchor" href="#7-启动容器并挂载上面配置的环境">#</a> 7、<em><strong>* 启动容器，并 *</strong></em><em><strong>* 挂载上面配置的环境 *</strong></em></h2>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">-u root \</span><br><span class="line">-d \</span><br><span class="line">--restart=always \</span><br><span class="line">-p 8001:8080 \</span><br><span class="line">-p 50000:50000 \</span><br><span class="line">-v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">-v /var/jenkins_home:/var/jenkins_home \</span><br><span class="line">jenkinsci/blueocean</span><br></pre></td></tr></table></figure>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/172131aa0a9f47b3a15e5bd5d4555986.png" alt="img"></p>
<h2 id="9-访问jenkins提示输入密码"><a class="markdownIt-Anchor" href="#9-访问jenkins提示输入密码">#</a> 9、访问 Jenkins，提示输入密码</h2>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/2b6d909e4c4e46efaa98216f1c33fdf7.png" alt="img"></p>
<h2 id="10-初次可以选择推荐的"><a class="markdownIt-Anchor" href="#10-初次可以选择推荐的">#</a> 10、初次可以选择推荐的</h2>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/5e9a6ebdd6954093bf6a23f4f876221a.png" alt="img"></p>
<h2 id="11-等待安装"><a class="markdownIt-Anchor" href="#11-等待安装">#</a> 11、 <strong>等待安装</strong></h2>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/25caae9dae8b49878adca5e32647e915.png" alt="img"></p>
<h2 id="12-如下访问jenkins成功啦"><a class="markdownIt-Anchor" href="#12-如下访问jenkins成功啦">#</a> 12、如下访问 Jenkins 成功啦</h2>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/4beeeb654aec4e608a22ce6b49afa1ae.png" alt="img"></p>
<p>到此就结束 Docker 安装 Jenkins 啦，后面的章节将介绍如何配置 jenkins，敬请期待！</p>
<h6 id="版权声明本文为csdn博主卡布奇诺-海晨的原创文章遵循cc-40-by-sa版权协议转载请附上原文出处链接及本声明"><a class="markdownIt-Anchor" href="#版权声明本文为csdn博主卡布奇诺-海晨的原创文章遵循cc-40-by-sa版权协议转载请附上原文出处链接及本声明">#</a> 版权声明：本文为 CSDN 博主「卡布奇诺 - 海晨」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。</h6>
<h6 id="原文链接httpsblogcsdnnetqq_57756904articledetails125697440"><a class="markdownIt-Anchor" href="#原文链接httpsblogcsdnnetqq_57756904articledetails125697440">#</a> 原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_57756904/article/details/125697440">https://blog.csdn.net/qq_57756904/article/details/125697440</a></h6>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-01-04T00:25:41.825Z" title="2023-1-4 8:25:41">2023-01-04</time>发表</span><span class="level-item"><time dateTime="2023-02-10T06:15:20.398Z" title="2023-2-10 14:15:20">2023-02-10</time>更新</span><span class="level-item">2 分钟读完 (大约346个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/04/%E3%80%90RocketMQ%E3%80%91Docker%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%83%A8%E7%BD%B2RocketMQ%E4%BB%A5%E5%8F%8AConsole/">Docker环境下部署RocketMQ以及Console</a></p><div class="content"><h1 id="docker环境下部署rocketmq以及console"><a class="markdownIt-Anchor" href="#docker环境下部署rocketmq以及console">#</a> Docker 环境下部署 RocketMQ 以及 Console</h1>
<h2 id="1docker-安装rocketmq镜像"><a class="markdownIt-Anchor" href="#1docker-安装rocketmq镜像">#</a> 1.docker 安装 rocketmq 镜像</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#拉取镜像 </span><br><span class="line">docker pull foxiswho/rocketmq:server-4.7.0</span><br><span class="line">docker pull foxiswho/rocketmq:broker-4.7.0</span><br></pre></td></tr></table></figure>
<h2 id="2创建server和broker目录并在目录opt下创建brokerconf"><a class="markdownIt-Anchor" href="#2创建server和broker目录并在目录opt下创建brokerconf">#</a> 2. 创建 server 和 broker 目录，并在目录 /opt 下创建 broker.conf</h2>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建目录</span></span><br><span class="line">mkdir /opt/rocketmq-server</span><br><span class="line">mkdir /opt/rocketmq-broker/conf -p</span><br><span class="line">[root@localhost opt]# cat /opt/rocketmq-broker/conf/broker.conf </span><br><span class="line">namesrvAddr=【你的IP地址】:9876</span><br><span class="line">brokerClusterName = DefaultCluster</span><br><span class="line">brokerName = broker-a</span><br><span class="line">brokerId = 0</span><br><span class="line">deleteWhen = 04</span><br><span class="line">fileReservedTime = 48</span><br><span class="line">brokerRole = ASYNC_MASTER</span><br><span class="line">flushDiskType = ASYNC_FLUSH</span><br><span class="line">brokerIP1 = 【你的IP地址】</span><br><span class="line">listenPort=10911</span><br></pre></td></tr></table></figure>
<h2 id="3启动容器并在防火墙放行端口-9876-10911-11011"><a class="markdownIt-Anchor" href="#3启动容器并在防火墙放行端口-9876-10911-11011">#</a> 3. 启动容器并在防火墙放行端口 9876 、10911 、11011</h2>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">RocketMQ默认使用3个端口：9876 、10911 、11011</span><br><span class="line">如果防火墙没有关闭的话，那么防火墙就必须开放这些端口：</span><br><span class="line">nameserver 默认使用 9876 端口</span><br><span class="line">master 默认使用 10911 端口</span><br><span class="line">slave 默认使用11011 端口</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动rocketmq-server</span></span><br><span class="line">docker run -d \</span><br><span class="line">--restart=always \</span><br><span class="line">--name rmqnamesrv \</span><br><span class="line">-p 9876:9876 \</span><br><span class="line">-v /opt/rocketmq-server/logs:/root/logs \</span><br><span class="line">-v /opt/rocketmq-server/store:/root/store \</span><br><span class="line">-e &quot;MAX_POSSIBLE_HEAP=100000000&quot; \</span><br><span class="line">foxiswho/rocketmq:4.7.0 \</span><br><span class="line">sh mqnamesrv</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动rocketmq-broker</span></span><br><span class="line">docker run -d  \</span><br><span class="line">--restart=always \</span><br><span class="line">--name rmqbroker \</span><br><span class="line">--link rmqnamesrv:namesrv \</span><br><span class="line">-p 10911:10911 \</span><br><span class="line">-p 10909:10909 \</span><br><span class="line">-v  /opt/rocketmq-broker/logs:/root/logs \</span><br><span class="line">-v  /opt/rocketmq-broker/store:/root/store \</span><br><span class="line">-v /opt/rocketmq-broker/conf/broker.conf:/opt/rocketmq-broker/conf/broker.conf \</span><br><span class="line">-e &quot;NAMESRV_ADDR=【你的IP地址】:9876&quot; \</span><br><span class="line">-e &quot;MAX_POSSIBLE_HEAP=200000000&quot; \</span><br><span class="line">-e &quot;autoCreateTopicEnable=true&quot; \</span><br><span class="line">foxiswho/rocketmq:4.7.0 \</span><br><span class="line">sh mqbroker -c /opt/rocketmq-broker/conf/broker.conf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动RocketMQ的管理工具rocketmq-console</span></span><br><span class="line">docker run -itd -e &quot;JAVA_OPTS=-Drocketmq.namesrv.addr=【你的IP地址】:9876 -Dcom.rocketmq.sendMessageWithVIPChannel=false&quot; -p 9877:8080 -t styletang/rocketmq-console-ng:latest</span><br></pre></td></tr></table></figure>
<h2 id="4测试访问console控制台"><a class="markdownIt-Anchor" href="#4测试访问console控制台">#</a> 4. 测试访问 console 控制台</h2>
<p>浏览器输入：192.168.1.200:9877</p>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/image-20230104082814121.png" alt="image-20230104082814121"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-12-29T09:20:11.710Z" title="2022-12-29 17:20:11">2022-12-29</time>发表</span><span class="level-item"><time dateTime="2022-12-29T09:37:06.026Z" title="2022-12-29 17:37:06">2022-12-29</time>更新</span><span class="level-item">32 分钟读完 (大约4782个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/12/29/%E3%80%90Java%E3%80%91TheadLocal/">ThreadLocal</a></p><div class="content"><h1 id="threadlocal-详解"><a class="markdownIt-Anchor" href="#threadlocal-详解">#</a> ThreadLocal 详解</h1>
<p>ThreadLocal 概述<br>
 ThreadLocal 类用来提供线程内部的局部变量，不同的线程之间不会相互干扰<br>
这种变量在多线程环境下访问（通过 get 和 set 方法访问）时能保证各个线程的变量相对独立于其他线程内的变量<br>
在线程的生命周期内起作用，可以减少同一个线程内多个函数或组件之间一些公共变量传递的复杂度<br>
使用<br>
常用方法</p>
<table>
<thead>
<tr>
<th><strong>方法名</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>ThreadLocal()</td>
<td>创建 ThreadLocal 对象</td>
</tr>
<tr>
<td>public void set( T value)</td>
<td>设置当前线程绑定的局部变量</td>
</tr>
<tr>
<td>public T get()</td>
<td>获取当前线程绑定的局部变量</td>
</tr>
<tr>
<td>public T remove()</td>
<td>移除当前线程绑定的局部变量，该方法可以帮助 JVM 进行 GC</td>
</tr>
<tr>
<td>protected T initialValue()</td>
<td>返回当前线程局部变量的初始值</td>
</tr>
</tbody>
</table>
<p>案例<br>
场景：让每个线程获取其设置的对应的共享变量值<br>
共享变量访问问题案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程间访问共享变量之间问题</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoQuestion</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DemoQuestion</span> <span class="variable">demoQuestion</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoQuestion</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// int j = i;</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">                <span class="comment">// demoQuestion.setAge(j);</span></span><br><span class="line">                demoQuestion.setName(Thread.currentThread().getName() + <span class="string">&quot;的数据&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;=================&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + demoQuestion.getName());</span><br><span class="line">                <span class="comment">// System.out.println(Thread.currentThread().getName() + &quot;---&gt;&quot; + demoQuestion.getAge());</span></span><br><span class="line">            &#125;,<span class="string">&quot;t&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用关键字 Synchronized 关键字加锁解决方案</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用加锁的方式解决：线程间访问共享变量之间问题</span></span><br><span class="line"><span class="comment"> * 将对共享变量的操作进行加锁，保证其原子性</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SolveDemoQuestionBySynchronized</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SolveDemoQuestionBySynchronized</span> <span class="variable">demoQuestion</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SolveDemoQuestionBySynchronized</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// int j = i;</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (SolveDemoQuestionBySynchronized.class)&#123;</span><br><span class="line">                    demoQuestion.setName(Thread.currentThread().getName() + <span class="string">&quot;的数据&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;=================&quot;</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + demoQuestion.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="string">&quot;t&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 ThreadLocal 方式解决</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SolveDemoQuestionByThreadLocal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>  ThreadLocal&lt;String&gt; name = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SolveDemoQuestionByThreadLocal</span> <span class="variable">demoQuestion</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SolveDemoQuestionByThreadLocal</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">                demoQuestion.setName(Thread.currentThread().getName() + <span class="string">&quot;的数据&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;=================&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + demoQuestion.getName());</span><br><span class="line">            &#125;,<span class="string">&quot;t&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String content)</span> &#123;</span><br><span class="line">        name.set(content);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="threadlocalmap-内部结果"><a class="markdownIt-Anchor" href="#threadlocalmap-内部结果">#</a> ThreadLocalMap 内部结果</h2>
<blockquote>
<p>JDK8 之前的设计<br>
每个 ThreadLocal 都创建一个 ThreadLocalMap，用线程作为 ThreadLocalMap 的 key，要存储的局部变量作为 ThreadLocalMap 的 value，这样就能达到各个线程的局部变量隔离的效果</p>
</blockquote>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/baa00cdb33a14aaeab7b453c1bb1469b.png" alt="在这里插入图片描述"></p>
<p>JDK8 之后的设计<br>
每个 Thread 维护一个 ThreadLocalMap，这个 ThreadLocalMap 的 key 是 ThreadLocal 实例本身，value 才是真正要存储的值 Object<br>
 每个 Thread 线程内部都有一个 ThreadLocalMap<br>
Map 里面存储 ThreadLocal 对象（key）和线程的变量副本（value）<br>
Thread 内部的 Map 是由 ThreadLocal 维护的，由 ThreadLocal 负责向 map 获取和设置线程的变量值<br>
对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰</p>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/5633b9ff01d84aaeb06b799d825e289e.png" alt="在这里插入图片描述"></p>
<p>JDK 对 ThreadLocal 这样改造的好处<br>
减少 ThreadLocalMap 存储的 Entry 数量：因为之前的存储数量由 Thread 的数量决定，现在是由 ThreadLocal 的数量决定。在实际运用当中，往往 ThreadLocal 的数量要少于 Thread 的数量<br>
当 Thread 销毁之后，对应的 ThreadLocalMap 也会随之销毁，能减少内存的使用（但是不能避免内存泄漏问题，解决内存泄漏问题应该在使用完后及时调用 remove () 对 ThreadMap 里的 Entry 对象进行移除，由于 Entry 继承了弱引用类，会在下次 GC 时被 JVM 回收）</p>
<h2 id="threadlocal相关方法源码解析"><a class="markdownIt-Anchor" href="#threadlocal相关方法源码解析">#</a> ThreadLocal 相关方法源码解析</h2>
<h3 id="set方法"><a class="markdownIt-Anchor" href="#set方法">#</a> set 方法</h3>
<ul>
<li>源码及相关注释</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 设置当前线程对应的ThreadLocal的值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value 将要保存在当前线程对应的ThreadLocal的值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">       <span class="comment">// 获取当前线程对象</span></span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">       <span class="comment">// 获取此线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">       <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">       <span class="comment">// 判断map是否存在</span></span><br><span class="line">       <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">           <span class="comment">// 存在则调用map.set设置此实体entry,this这里指调用此方法的ThreadLocal对象</span></span><br><span class="line">           map.set(<span class="built_in">this</span>, value);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="comment">// 1）当前线程Thread 不存在ThreadLocalMap对象</span></span><br><span class="line">           <span class="comment">// 2）则调用createMap进行ThreadLocalMap对象的初始化</span></span><br><span class="line">           <span class="comment">// 3）并将 t(当前线程)和value(t对应的值)作为第一个entry存放至ThreadLocalMap中</span></span><br><span class="line">           createMap(t, value);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取当前线程Thread对应维护的ThreadLocalMap </span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  t the current thread 当前线程</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the map 对应维护的ThreadLocalMap </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *创建当前线程Thread对应维护的ThreadLocalMap </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> t 当前线程</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> firstValue 存放到map中第一个entry的值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">       <span class="comment">//这里的this是调用此方法的threadLocal</span></span><br><span class="line">       t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>相关流程图</li>
</ul>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/2430f09d315e40769a63720f84a8a06c.png" alt="在这里插入图片描述"></p>
<ul>
<li>执行流程</li>
</ul>
<ol>
<li>获取当前线程，并根据当前线程获取一个 Map</li>
<li>如果获取的 Map 不为空，则将参数设置到 Map 中（当前 ThreadLocal 的引用作为 key）</li>
<li>如果 Map 为空，则给该线程创建 Map，并设置初始值</li>
</ol>
<h3 id="get方法"><a class="markdownIt-Anchor" href="#get方法">#</a> get () 方法</h3>
<ul>
<li>源码及相关注释</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回当前线程中保存ThreadLocal的值</span></span><br><span class="line"><span class="comment">    * 如果当前线程没有此ThreadLocal变量，</span></span><br><span class="line"><span class="comment">    * 则它会通过调用&#123;<span class="doctag">@link</span> #initialValue&#125; 方法进行初始化值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 返回当前线程对应此ThreadLocal的值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">// 获取当前线程对象</span></span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">       <span class="comment">// 获取此线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">       <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">       <span class="comment">// 如果此map存在</span></span><br><span class="line">       <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 以当前的ThreadLocal 为 key，调用getEntry获取对应的存储实体e</span></span><br><span class="line">           ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">           <span class="comment">// 对e进行判空 </span></span><br><span class="line">           <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">               <span class="comment">// 获取存储实体 e 对应的 value值,即为我们想要的当前线程对应此ThreadLocal的值</span></span><br><span class="line">               <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">               <span class="keyword">return</span> result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       	初始化 : 有两种情况有执行当前代码</span></span><br><span class="line"><span class="comment">       	第一种情况: map不存在，表示此线程没有维护的ThreadLocalMap对象</span></span><br><span class="line"><span class="comment">       	第二种情况: map存在, 但是没有与当前ThreadLocal关联的entry</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">return</span> setInitialValue();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 初始化</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the initial value 初始化后的值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">// 调用initialValue获取初始化的值</span></span><br><span class="line">       <span class="comment">// 此方法可以被子类重写, 如果不重写默认返回null</span></span><br><span class="line">       <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">       <span class="comment">// 获取当前线程对象</span></span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">       <span class="comment">// 获取此线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">       <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">       <span class="comment">// 判断map是否存在</span></span><br><span class="line">       <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">           <span class="comment">// 存在则调用map.set设置此实体entry</span></span><br><span class="line">           map.set(<span class="built_in">this</span>, value);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="comment">// 1）当前线程Thread 不存在ThreadLocalMap对象</span></span><br><span class="line">           <span class="comment">// 2）则调用createMap进行ThreadLocalMap对象的初始化</span></span><br><span class="line">           <span class="comment">// 3）并将 t(当前线程)和value(t对应的值)作为第一个entry存放至ThreadLocalMap中</span></span><br><span class="line">           createMap(t, value);</span><br><span class="line">       <span class="comment">// 返回设置的值value</span></span><br><span class="line">       <span class="keyword">return</span> value;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>流程图</li>
</ul>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/a7e417b2719348729b4229071e4d3f4f.png" alt="在这里插入图片描述"></p>
<p>执行流程<br>
获取当前线程，根据当前线程获取一个 Map<br>
 如果获取的 Map 不为空，则在 Map 中以 ThreadLocal 的引用作为 key 来在 Map 中获取对应的 Entrye，否则转到 4<br>
 如果 e 不为 null，则返回 e.value，否则转到 4<br>
Map 为空或者 e 为空，则通过 initialValue 函数获取初始值 value，然后用 ThreadLocal 的引用和 value 作为 firstKey 和 firstValue 创建一个新的 Map</p>
<h2 id="remove方法"><a class="markdownIt-Anchor" href="#remove方法">#</a> remove 方法</h2>
<ul>
<li>源码及相关注释</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除当前线程中保存的ThreadLocal对应的实体entry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">         <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">        <span class="comment">// 如果此map存在</span></span><br><span class="line">         <span class="keyword">if</span> (m != <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 存在则调用map.remove</span></span><br><span class="line">            <span class="comment">// 以当前ThreadLocal为key删除对应的实体entry</span></span><br><span class="line">             m.remove(<span class="built_in">this</span>);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行流程</li>
</ul>
<ol>
<li>首先获取当前线程，并根据当前线程获取一个 Map</li>
<li>如果获取的 Map 不为空，则移除当前 ThreadLocal 对象对应的 entry</li>
</ol>
<p>initialValue 方法<br>
此方法的作用是返回该线程局部变量的初始值<br>
这个方法是一个延迟调用方法，从上面的代码我们得知，在 set 方法还未调用而先调用了 get 方法时才执行，并且仅执行 1 次<br>
这个方法缺省实现直接返回一个 null<br>
 如果想要一个除 null 之外的初始值，可以重写此方法。（备注： 该方法是一个 protected 的方法，显然是为了让子类覆盖而设计的）<br>
源码及相关注释</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 返回当前线程对应的ThreadLocal的初始值</span></span><br><span class="line"><span class="comment">  * 此方法的第一次调用发生在，当线程通过get方法访问此线程的ThreadLocal值时</span></span><br><span class="line"><span class="comment">  * 除非线程先调用了set方法，在这种情况下，initialValue 才不会被这个线程调用。</span></span><br><span class="line"><span class="comment">  * 通常情况下，每个线程最多调用一次这个方法。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;这个方法仅仅简单的返回null &#123;<span class="doctag">@code</span> null&#125;;</span></span><br><span class="line"><span class="comment">  * 如果想ThreadLocal线程局部变量有一个除null以外的初始值，</span></span><br><span class="line"><span class="comment">  * 必须通过子类继承&#123;<span class="doctag">@code</span> ThreadLocal&#125; 的方式去重写此方法</span></span><br><span class="line"><span class="comment">  * 通常, 可以通过匿名内部类的方式实现</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 当前ThreadLocal的初始值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ThreadLocalMap 解析</p>
<h2 id="内部结构"><a class="markdownIt-Anchor" href="#内部结构">#</a> 内部结构</h2>
<p>ThreadLocalMap 是 ThreadLocal 的内部类，没有实现 Map 接口，用独立的方式实现了 Map 的功能，其内部的 Entry 也是独立实现的，而 Entry 又是 ThreadLocalMap 的内部类，且集成弱引用 (WeakReference) 类。</p>
<h2 id="成员变量"><a class="markdownIt-Anchor" href="#成员变量">#</a> 成员变量</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">        * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">        * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">        * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">        * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">        * as &quot;stale entries&quot; in the code that follows.</span></span><br><span class="line"><span class="comment">        * </span></span><br><span class="line"><span class="comment">			* Entry继承WeakReference，并且用ThreadLocal作为key.</span></span><br><span class="line"><span class="comment">				* 如果key为null(entry.get() == null)，意味着key不再被引用，</span></span><br><span class="line"><span class="comment">				* 因此这时候entry也可以从table中清除。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">           <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">           Object value;</span><br><span class="line"></span><br><span class="line">           Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">               <span class="built_in">super</span>(k);</span><br><span class="line">               value = v;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 初始容量 —— 必须是2的整次幂</span></span><br><span class="line"><span class="comment">    *  The initial capacity -- MUST be a power of two.  </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 存放数据的table，Entry类的定义在下面分析</span></span><br><span class="line"><span class="comment">    * 同样，数组长度必须是2的整次幂。</span></span><br><span class="line"><span class="comment">    * The table, resized as necessary.</span></span><br><span class="line"><span class="comment">    * table.length MUST always be a power of two.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 数组里面entrys的个数，可以用于判断table当前使用量是否超过阈值。</span></span><br><span class="line"><span class="comment">    * The number of entries in the table</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 进行扩容的阈值，表使用量大于它的时候进行扩容。</span></span><br><span class="line"><span class="comment">    * The next size value at which to resize</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> threshold; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure>
<h2 id="弱引用和内存泄漏"><a class="markdownIt-Anchor" href="#弱引用和内存泄漏">#</a> 弱引用和内存泄漏</h2>
<p>弱引用相关概念<br>
强引用（“Strong” Reference），就是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还 “活着”，垃圾回收器就不会回收这种对象<br>
弱引用（WeakReference），垃圾回收器一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存</p>
<h2 id="内存泄漏相关概念"><a class="markdownIt-Anchor" href="#内存泄漏相关概念">#</a> 内存泄漏相关概念</h2>
<p>Memory overflow: 内存溢出，没有足够的内存提供申请者使用<br>
 Memory leak: 内存泄漏是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。内存泄漏的堆积终将导致内存溢出</p>
<h2 id="内存泄漏与强弱引用关系"><a class="markdownIt-Anchor" href="#内存泄漏与强弱引用关系">#</a> 内存泄漏与强弱引用关系</h2>
<p>ThreadLocal 内存结构</p>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/7476f5b3aec44f20b884e118880925b1.png" alt="在这里插入图片描述"></p>
<p>如果 key 使用强引用，也就是上图中的红色背景框部分<br>
业务代码中使用完 ThreadLocal ，threadLocal Ref 被回收了<br>
因为 threadLocalMap 的 Entry 强引用了 threadLocal，造成 threadLocal 无法被回收<br>
在没有手动删除这个 Entry 以及 CurrentThread 依然运行的前提下，始终有强引用链 threadRef-&gt;currentThread-&gt;threadLocalMap-&gt;entry，Entry 就不会被回收（Entry 中包括了 ThreadLocal 实例和 value），导致 Entry 内存泄漏<br>
如果 key 使用弱引用，也就是上图中的红色背景框部分<br>
业务代码中使用完 ThreadLocal ，threadLocal Ref 被回收了<br>
由于 ThreadLocalMap 只持有 ThreadLocal 的弱引用，没有任何强引用指向 threadlocal 实例，所以 threadlocal 就可以顺利被 gc 回收，此时 Entry 中的 key=null<br>
 但是在没有手动删除这个 Entry 以及 CurrentThread 依然运行的前提下，也存在有强引用链 threadRef-&gt;currentThread-&gt;threadLocalMap-&gt;entry -&gt; value ，value 不会被回收， 而这块 value 永远不会被访问到了，导致 value 内存泄漏</p>
<h2 id="出现内存泄漏的真实原因"><a class="markdownIt-Anchor" href="#出现内存泄漏的真实原因">#</a> 出现内存泄漏的真实原因</h2>
<p>没有手动删除对应的 Entry 节点信息<br>
 ThreadLocal 对象使用完后，对应线程仍然在运行</p>
<h2 id="避免内存泄漏的的两种方式"><a class="markdownIt-Anchor" href="#避免内存泄漏的的两种方式">#</a> 避免内存泄漏的的两种方式</h2>
<p>使用完 ThreadLocal，调用其 remove 方法删除对应的 Entry<br>
 使用完 ThreadLocal，当前 Thread 也随之运行结束<br>
对于第一种方式很好控制，调用对应 remove () 方法即可，但是对于第二种方式，我们是很难控制的，正因为不好控制，这也是为什么 ThreadLocalMap 里对应的 Entry 对象继承弱引用的原因，因为使用了弱引用，当 ThreadLocal 使用完后，key 的引用就会为 null，而在调用 ThreadLocal 中的 get ()/set () 方法时，当判断 key 为 null 时会将 value 置为 null，这就就会在 jvm 下次 GC 时将对应的 Entry 对象回收，从而避免内存泄漏问题的出现。</p>
<h2 id="hash冲突问题及解决方法"><a class="markdownIt-Anchor" href="#hash冲突问题及解决方法">#</a> hash 冲突问题及解决方法</h2>
<p>首先从 ThreadLocal 的 set () 方法入手</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocal.ThreadLocalMap map = getMap(t);</span><br><span class="line">        if (map != null)</span><br><span class="line">            //调用了ThreadLocalMap的set方法</span><br><span class="line">            map.set(this, value);</span><br><span class="line">        else</span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ThreadLocal.ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">        return t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void createMap(Thread t, T firstValue) &#123;</span><br><span class="line">        	//调用了ThreadLocalMap的构造方法</span><br><span class="line">        t.threadLocals = new ThreadLocal.ThreadLocalMap(this, firstValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>构造方法 <code>ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue)</code></p>
</li>
<li>
<pre><code> /*
  * firstKey : 本ThreadLocal实例(this)
  * firstValue ： 要保存的线程本地变量
  */
ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;
        //初始化table
        table = new ThreadLocal.ThreadLocalMap.Entry[INITIAL_CAPACITY];
        //计算索引(重点代码）
        int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);
        //设置值
        table[i] = new ThreadLocal.ThreadLocalMap.Entry(firstKey, firstValue);
        size = 1;
        //设置阈值
        setThreshold(INITIAL_CAPACITY);
    &#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">构造函数首先创建一个长度为16的Entry数组，然后计算出firstKey对应的索引，然后存储到table中，并设置size和threshold</span><br><span class="line"></span><br><span class="line">分析：int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1)</span><br><span class="line">关于：firstKey.threadLocalHashCode</span><br><span class="line"></span><br></pre></td></tr></table></figure>
private final int threadLocalHashCode = nextHashCode();
    
    private static int nextHashCode() &#123;
        return nextHashCode.getAndAdd(HASH_INCREMENT);
    &#125;
//AtomicInteger是一个提供原子操作的Integer类，通过线程安全的方式操作加减,适合高并发情况下的使用
    private static AtomicInteger nextHashCode =  new AtomicInteger();
     //特殊的hash值
    private static final int HASH_INCREMENT = 0x61c88647;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这里定义了一个AtomicInteger类型，每次获取当前值并加上HASH_INCREMENT，HASH_INCREMENT = 0x61c88647,这个值跟斐波那契数列（黄金分割数）有关，其主要目的就是为了让哈希码能均匀的分布在2的n次方的数组里, 也就是Entry[] table中，这样做可以尽量避免hash冲突</span><br><span class="line"></span><br><span class="line">关于：&amp; (INITIAL_CAPACITY - 1)</span><br><span class="line">计算hash的时候里面采用了hashCode &amp; (size - 1)的算法，这相当于取模运算hashCode % size的一个更高效的实现。正是因为这种算法，我们要求size必须是2的整次幂，这也能保证在索引不越界的前提下，使得hash发生冲突的次数减小</span><br><span class="line">ThreadLocalMap中的set方法</span><br><span class="line"></span><br></pre></td></tr></table></figure>
private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;
        ThreadLocal.ThreadLocalMap.Entry[] tab = table;
        int len = tab.length;
        //计算索引(重点代码，刚才分析过了）
        int i = key.threadLocalHashCode &amp; (len-1);
        /**
         * 使用线性探测法查找元素（重点代码）
         */
        for (ThreadLocal.ThreadLocalMap.Entry e = tab[i];
             e != null;
             e = tab[i = nextIndex(i, len)]) &#123;
            ThreadLocal&lt;?&gt; k = e.get();
            //ThreadLocal 对应的 key 存在，直接覆盖之前的值
            if (k == key) &#123;
                e.value = value;
                return;
            &#125;
            // key为 null，但是值不为 null，说明之前的 ThreadLocal 对象已经被回收了，
           // 当前数组中的 Entry 是一个陈旧（stale）的元素
            if (k == null) &#123;
                //用新元素替换陈旧的元素，这个方法进行了不少的垃圾清理动作，防止内存泄漏
                replaceStaleEntry(key, value, i);
                return;
            &#125;
        &#125;
    
    	//ThreadLocal对应的key不存在并且没有找到陈旧的元素，则在空元素的位置创建一个新的Entry。
            tab[i] = new Entry(key, value);
            int sz = ++size;
            /**
             * cleanSomeSlots用于清除那些e.get()==null的元素，
             * 这种数据key关联的对象已经被回收，所以这个Entry(table[index])可以被置null。
             * 如果没有清除任何entry,并且当前使用量达到了负载因子所定义(长度的2/3)，那么进行				 * rehash（执行一次全表的扫描清理工作）
             */
            if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)
                rehash();
&#125;

 /**
     * 获取环形数组的下一个索引
     */
    private static int nextIndex(int i, int len) &#123;
        return ((i + 1 &lt; len) ? i + 1 : 0);
    &#125;
</code></pre>
<h2 id="代码执行流程"><a class="markdownIt-Anchor" href="#代码执行流程">#</a> 代码执行流程：</h2>
<p>1. 首先还是根据 key 计算出索引 i，然后查找 i 位置上的 Entry</p>
<p>2. 若是 Entry 已经存在并且 key 等于传入的 key，那么这时候直接给这个 Entry 赋新的 value 值</p>
<p>3. 若是 Entry 存在，但是 key 为 null，则调用 replaceStaleEntry 来更换这个 key 为空的 Entry</p>
<p>4. 不断循环检测，直到遇到为 null 的地方，这时候要是还没在循环过程中 return，那么就在这个 null 的位置新建一个 Entry，并且插入，同时 size 增加 1</p>
<p>5. 最后调用 cleanSomeSlots，清理 key 为 null 的 Entry，最后返回是否清理了 Entry，接下来再判断 sz 是否 &gt;= thresgold 达到了 rehash 的条件，达到的话就会调用 rehash 函数执行一次全表的扫描清理</p>
<ul>
<li>分析 ： ThreadLocalMap 使用线性探测法来解决哈希冲突的</li>
</ul>
<p>1. 该方法一次探测下一个地址，直到有空的地址后插入，若整个空间都找不到空余的地址，则产生溢出<br>
 2. 假设当前 table 长度为 16，也就是说如果计算出来 key 的 hash 值为 14，如果 table [14] 上已经有值，并且其 key 与当前 key 不一致，那么就发生了 hash 冲突，这个时候将 14 加 1 得到 15，取 table [15] 进行判断，这个时候如果还是冲突会回到 0，取 table [0], 以此类推，直到可以插入</p>
<p>3. 可以把 Entry [] table 看成一个环形数组</p>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-12-27T08:18:48.660Z" title="2022-12-27 16:18:48">2022-12-27</time>发表</span><span class="level-item"><time dateTime="2022-06-01T01:04:37.353Z" title="2022-6-1 9:04:37">2022-06-01</time>更新</span><span class="level-item">8 分钟读完 (大约1157个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/12/27/%E3%80%90%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%91%E9%98%BF%E9%87%8C%E4%BA%91OSS%E7%9A%84CDN%E5%8A%A0%E9%80%9F%E5%92%8COSS%E4%BC%A0%E8%BE%93%E5%8A%A0%E9%80%9F%E7%9A%84%E5%8C%BA%E5%88%AB/">阿里云OSS的CDN加速和OSS传输加速的区别</a></p><div class="content"><h2 id="概述"><a class="markdownIt-Anchor" href="#概述">#</a> 概述</h2>
<p>本文主要介绍阿里云对象存储 OSS 的传输加速功能和 CDN 加速 OSS 资源的区别，以便您根据实际业务进行选择。</p>
<h2 id="详细信息"><a class="markdownIt-Anchor" href="#详细信息">#</a> 详细信息</h2>
<p>阿里云对象存储 OSS 以海量、安全、低成本、高可靠等特点已经成为用户存储静态资源和文件的首要选择，实际使用中面向全球各地用户访问 OSS 资源时，访问速度会受到客户端网络、OSS 的下行带宽、Bucket 地域、访问链路长等限制出现访问慢的情况。以下主要介绍 CDN 加速 OSS 和 OSS 传输加速的加速方式：</p>
<h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理">#</a> 实现原理</h3>
<p>具体实现加速的原理如下：</p>
<ul>
<li>CDN 加速 OSS：是建立并覆盖在承载网之上，由遍布全球的边缘节点服务器群组成的分布式网络。阿里云 CDN 能分担源站压力，避免网络拥塞，确保在不同区域、不同场景下加速网站内容的分发，提高资源访问速度。由 CDN 全球广泛分布的边缘节点缓存 OSS 存储的静态数据，从而实现客户端从边缘节点直接获取数据的方式来实现访问的加速。</li>
<li>OSS 传输加速：利用全球分布的云机房，将全球各地用户对您存储空间（Bucket）的访问，经过智能路由解析至就近的接入点，使用优化后的网络及协议，为云存储互联网的上传、下载提供端到端的加速方案。</li>
</ul>
<h3 id="资源加速场景介绍"><a class="markdownIt-Anchor" href="#资源加速场景介绍">#</a> 资源加速场景介绍</h3>
<p>OSS 传输加速是针对 OSS 的链路加速，使用 OSS 传输加速后支持 OSS 提供的任意特性。CDN 通过全球边缘节点缓存 OSS 资源，加速同时可降低带宽成本。OSS 传输加速和 CDN 加速完全是两个不同的产品，且应对的场景不同，详情请参见<a target="_blank" rel="noopener" href="https://help.aliyun.com/document_detail/109895.htm"> CDN 应用场景</a>和<a target="_blank" rel="noopener" href="https://help.aliyun.com/document_detail/131312.htm">传输加速场景</a>。</p>
<ul>
<li>如果您的业务是第三方数据源加速，推荐您使用 CDN 加速。</li>
<li>如果您的 OSS 资源需要进行多次下载的操作，并且不要求数据强一致性，推荐您使用 CDN 加速。</li>
<li>如果您的 OSS 资源需要加速下载，并且访问量少，推荐您使用 OSS 传输加速。</li>
<li>如果您的 OSS 资源需要进行多次下载的操作，并且要求数据强一致性，推荐您使用 OSS 传输加速。</li>
<li>如果您的业务存储的是动态资源，且数据更新频繁，推荐您使用 OSS 传输加速。</li>
<li>如果您的业务存储的是静态资源，且更新少，推荐您使用 CDN 加速。</li>
</ul>
<h3 id="cdn加速和oss传输加速的对比"><a class="markdownIt-Anchor" href="#cdn加速和oss传输加速的对比">#</a> CDN 加速和 OSS 传输加速的对比</h3>
<p>CDN 加速和 OSS 传输加速的使用场景不同，其优缺点对比如下：</p>
<table>
<thead>
<tr>
<th><strong>加速方式</strong></th>
<th><strong>实现方法</strong></th>
<th><strong>应用场景</strong></th>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>CDN 加速 OSS</td>
<td>通过全球分布的边缘节点缓存数据来实现加速。</td>
<td>网站或应用中小文件大文件的下载视音频点播</td>
<td>CDN 边缘节点全球分布，数量多。CDN 节点提供的服务带宽量大。</td>
<td>对于访问量大的资源，命中率高，访问量小的资源命中率低，节点未缓存的情况下，还是需要回源访问，回源依赖实时的公网回源链路。CDN 静态资源的访问，对于上传、删除等动态请求加速效果不明显。</td>
</tr>
<tr>
<td>OSS 传输加速</td>
<td>实现的是客户端到 OSS 服务端之间链路优化来实现的加速功能，实际每次资源的请求还是从 OSS 来进行获取。</td>
<td>远距离数据传输加速 GB、TB 级大文件上传和下载非静态、非热点数据下载加速</td>
<td>OSS 存储节点全球主要区域分布。远距离以及大文件的上传和下载加速。</td>
<td>所有的访问都是回源到 OSS 访问，占用 OSS 的服务带宽。同一区域大量用户集中访问资源的情况下，效果没有 CDN 加速效果好。只能使用 HTTPS 方式访问。</td>
</tr>
</tbody>
</table>
<h2 id=""><a class="markdownIt-Anchor" href="#">#</a> </h2>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-12-27T08:18:48.658Z" title="2022-12-27 16:18:48">2022-12-27</time>发表</span><span class="level-item"><time dateTime="2022-04-25T04:34:10.453Z" title="2022-4-25 12:34:10">2022-04-25</time>更新</span><span class="level-item">21 分钟读完 (大约3146个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/12/27/%E3%80%90Java%E3%80%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/">设计模式（一）</a></p><div class="content"><h3 id="设计模式笔记-__brathli"><a class="markdownIt-Anchor" href="#设计模式笔记-__brathli">#</a> 设计模式笔记  <strong>__Brath.Li</strong></h3>
<h3 id="gof2323种设计模式"><a class="markdownIt-Anchor" href="#gof2323种设计模式">#</a> GoF23：23 种设计模式</h3>
<p>​		<strong>设计模式的本质是面向对象设原则的实际运用，是对类的封装性，继承性，多态性以及类的关联关系和组合关系的充分理解。</strong></p>
<p>​			<strong>正确使用设计模式具有以下优点：</strong></p>
<p>​			<strong>1. 提高程序员思维能力，编程能力和设计能力</strong></p>
<p>​			<strong>2. 使程序设计更加标准化，代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开的周期。</strong></p>
<p>​			<strong>3. 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。</strong></p>
<h3 id="创建型模式"><a class="markdownIt-Anchor" href="#创建型模式">#</a> <strong>创建型模式：</strong></h3>
<p>​			<strong>单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式。</strong></p>
<h3 id="结构型模式"><a class="markdownIt-Anchor" href="#结构型模式">#</a> <strong>结构型模式：</strong></h3>
<p>​			<strong>适配器模式、桥接模式、装饰模式、组合模式、外欧冠模式、享元模式、代理模式。</strong></p>
<h3 id="行为性模式"><a class="markdownIt-Anchor" href="#行为性模式">#</a> <strong>行为性模式：</strong></h3>
<p>​			<strong>模板方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、责任链模式、访问者模式。</strong></p>
<h4 id="oop面向对象七大原则"><a class="markdownIt-Anchor" href="#oop面向对象七大原则">#</a> OOP 面向对象七大原则：</h4>
<p><strong>1.OCP 开闭原则：</strong></p>
<p>​			<strong>软件实体（包括类、模块、功能等）应该对扩展开放，但是对修改关闭。</strong></p>
<p><strong>2. 里氏替换原则：</strong></p>
<p>​			<strong>继承必须确保超类锁拥有的性质在子类中仍然成立。</strong></p>
<p><strong>3. 依赖倒置原则：</strong></p>
<p>​			<strong>面向接口编程，不要面向实现编程。</strong></p>
<p><strong>4. 单一职责原则：</strong></p>
<p>​			<strong>控制类粒度大小、将对象解耦合、提高内聚性。</strong></p>
<p><strong>5. 接口隔离原则：</strong></p>
<p>​			<strong>要为各个类建立他们需要的专用接口。</strong></p>
<p><strong>6. 迪米特法则：</strong></p>
<p>​			** 只与你的直接朋友交谈、不跟 “陌生人” 说话。 **</p>
<p><strong>7. 合成复用原则：</strong></p>
<p>​			<strong>尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</strong></p>
<h2 id="单例设计模式"><a class="markdownIt-Anchor" href="#单例设计模式">#</a> 单例设计模式：</h2>
<p>作用：让一个类只能创建一个实例（因为频繁的创建对象，回收对象会造成系统性能下降。）。解决对象的唯一性，保证了内存中一个对象是唯一的 。</p>
<h4 id="饿汉式hunary"><a class="markdownIt-Anchor" href="#饿汉式hunary">#</a> 饿汉式：Hunary</h4>
<p><img src="C:%5CUsers%5C26344%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C%E9%A5%BF%E6%B1%89%E5%BC%8F.png" alt="饿汉式"></p>
<p><strong>步骤：1. 私有化构造器  2. 直接创建静态对象 3. 创建一个静态的方法，供外部调用实例</strong></p>
<p>优点：类初始化的时候，会立即加载该对象，线程天生安全，调用效率高。</p>
<p>缺点：无法避免被反射破解，不安全</p>
<h4 id="懒汉式lazyman"><a class="markdownIt-Anchor" href="#懒汉式lazyman">#</a> 懒汉式：LazyMan</h4>
<p><img src="C:%5CUsers%5C26344%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210910151318667.png" alt="image-20210910151318667"></p>
<p>步骤：1. 私有化构造器，不会直接创建对象  2. 向外暴露调用对象方法，在方法中先进行对象判空，为空才创建对象，这就是懒汉式</p>
<p>优点：类初始化时，不会初始化该对象，真正需要使用的时候才会去创建该对象，具备懒加载功能。</p>
<p>缺点：</p>
<p>1. 判空浪费时间</p>
<p>2. 不加 Synchronized 的懒汉式线程不安全，需要用到 volatile 关键字保持 new 对象的原子性一致</p>
<p>懒汉式单线程下是 OK 的，但是多线程并发下不安全。</p>
<p><img src="C:%5CUsers%5C26344%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210910153316119.png" alt="image-20210910153316119"> 开启十次线程测试</p>
<p><img src="C:%5CUsers%5C26344%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210910153327761.png" alt="image-20210910153327761"></p>
<p><strong>每次重启线程数都不一致</strong>，线程不安全。</p>
<p>怎么解决：</p>
<p>Tips：懒汉式也是可以实现线程安全的：只要加上 Synchronized 加锁即可：</p>
<p>但是这样一来，会降低整个访问的速度，而且每次都要判断。那么有没有更好的方式来实现呢？</p>
<p>解决方案：</p>
<p><strong>double-check-lock 双重加锁</strong></p>
<p><img src="C:%5CUsers%5C26344%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210910152638263.png" alt="image-20210910152638263"></p>
<p>所谓双重加锁机制。指的是，并不是每次进入 getInstance 方法都需要同步，而是先不同步，进入方法之后先检查实例是否存在，如果不存在才进入下面 Synchronized 加锁，之后会再次检查实例是否存在，如果还不存在才创建实例。</p>
<p>双重检测方式（因为 JVM 本身重排序的原因，可能会出现多次的初始化）</p>
<p>这种模式下的懒汉式，称为<strong> DCL 懒汉式</strong>！</p>
<p>你以为这样就没问题了？大错特错，注意：这里的 new 对象操作不是原子性的</p>
<p><img src="C:%5CUsers%5C26344%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210910153630120.png" alt="image-20210910153630120"></p>
<p>new 一个对象的执行顺序 ↓</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 1.分配内存空间</span></span><br><span class="line"><span class="comment">  * 2.执行构造方法初始化对象</span></span><br><span class="line"><span class="comment">  * 3.把这个对象指向内存空间</span></span><br><span class="line"><span class="comment">  * 这是创建对象的步骤 正确顺序为 123</span></span><br><span class="line"><span class="comment">  * 举例：</span></span><br><span class="line"><span class="comment">  * 线程A 创建对象 步骤为 123, 我们的代码没有问题</span></span><br><span class="line"><span class="comment">  * 线程B 创建对象 因为操作步骤不是原子性的，可能会走成 1 3 2，先指向了内存空间，再去构造对象</span></span><br><span class="line"><span class="comment">  * 这时会出现一个问题，指令重排：双重检测模式会失效，因为此时我们的类，不为空了，但是里面返回的对象是空的。</span></span><br><span class="line"><span class="comment">  * 所以就要用到一个关键字volatile，避免指令重排，保持操作原子性</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>
<p><img src="C:%5CUsers%5C26344%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210910153756918.png" alt="image-20210910153756918"></p>
<h4 id="静态内部类模式"><a class="markdownIt-Anchor" href="#静态内部类模式">#</a> 静态内部类模式：</h4>
<p><img src="C:%5CUsers%5C26344%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210910155204370.png" alt="image-20210910155204370"></p>
<p>步骤：1. 私有化构造器  2. 创建一个静态内部类，类中创建外部类的实例  3. 向外暴露一个方法获取静态内部类中创建的对象</p>
<p>优点：结合了懒汉式和饿汉式各自的优点，真正需要对象的时候才会加载，加载类是线程安全的。</p>
<p>缺点：每次调用都会创建多余的对象</p>
<h3 id="以上单例设计模式都会被反射破解枚举不会"><a class="markdownIt-Anchor" href="#以上单例设计模式都会被反射破解枚举不会">#</a> 以上单例设计模式都会被反射破解，枚举不会！</h3>
<p>枚举：枚举本身是一个类，继承了 Enum 的实例就成为了枚举类</p>
<p>使用枚举实现单例模式，实现简单、调用效率高，枚举本身就是单例，由 JVM 从根本上提供保障，避免通过反射和反序列化的漏洞，缺点是没有延迟加载。</p>
<p>在源码 Constructor 中<img src="C:%5CUsers%5C26344%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210910150042754.png" alt="image-20210910150042754"></p>
<p>如果是对象是通过反射机制创建的会抛出一个异常</p>
<p>IllegalArgumentException: Cannot reflectively create enum objects</p>
<p>枚举类在 traget 输出的代码中，构造器是空的，隐藏起来了，用 javap -p 反编译也看不见构造器</p>
<p><img src="C:%5CUsers%5C26344%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210910150706569.png" alt="image-20210910150706569"></p>
<p>我们用反射机制获取空构造器会获取不到对象，这时候用 jad 反编译工具，得到的 java 文件中，</p>
<p><img src="C:%5CUsers%5C26344%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210910150400927.png" alt="image-20210910150400927"></p>
<p>可以看见构造器其实是有数据的，我们把数据放到反射中实现，就会得到这个异常 Cannot reflectively create enum objects</p>
<p><img src="C:%5CUsers%5C26344%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210910150429958.png" alt="image-20210910150429958"></p>
<p><img src="C:%5CUsers%5C26344%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210910150418256.png" alt="image-20210910150418256"></p>
<p>由此可见，反射不能破坏枚举的单例模式</p>
<p>优点：实现简单，线程安全，防止反射攻击等。</p>
<p>缺点： 在不需要的时候可能就加载了，造成内存浪费</p>
<p>Tips：利用反射破解懒汉式。懒汉式不是安全的！</p>
<p><img src="C:%5CUsers%5C26344%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210910160648326.png" alt="image-20210910160648326"></p>
<p>私有化构造器的时候判断外面的字段 guoqing 是否 ==false，等于的话就设置为 true，如果不等于的话就抛出运行异常，这样设计的话在我们用反射机制获取构造器的时候，就获取不到对象了</p>
<p>但是有解决方法：利用反射强大的机制，假如我们反编译，知道要破解的字段是 guoqing，那我们直接用反射获取 guoqing 字段，然后设置解除私有化限制，在创建构造器实例的时候，把 guoqing 设置为 true，就可以破解 DCL 懒汉式了</p>
<p><img src="C:%5CUsers%5C26344%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210910160638735.png" alt="image-20210910160638735"></p>
<h2 id="工厂设计模式-factory-model"><a class="markdownIt-Anchor" href="#工厂设计模式-factory-model">#</a> 工厂设计模式 Factory Model：</h2>
<p>​		<strong>核心本质：</strong></p>
<p>​			<strong>实例化对象不使用 new，用工厂方法代替</strong></p>
<p>​			<strong>将选择实现类，创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。</strong></p>
<p>​		<strong>详细分类：</strong></p>
<p>​			<strong>简单工厂模式</strong></p>
<p>​						<strong>用来生产同一等级结构中的任意产品：扩展性差</strong></p>
<p>​			<strong>工厂方法模式</strong></p>
<p>​						<strong>用来生产同一等级结构中的固定产品：扩展性强</strong></p>
<p>​			<strong>抽象工厂模式</strong></p>
<p>​						<strong>围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。</strong></p>
<p><strong>工厂设计模式应用场景：</strong></p>
<p>​			<strong>JDK 中的 Calendar 的 getInstance 方法</strong></p>
<p>​			<strong>JDBC 中的 Connection 对象的获取</strong></p>
<p>​			<strong>Spring 的 IOC 容器创建管理 Bean 对象</strong></p>
<p>​			<strong>反射 Class 对象的 newInsetance 方法</strong></p>
<h2 id="建造者模式"><a class="markdownIt-Anchor" href="#建造者模式">#</a> 建造者模式：</h2>
<p>​	<strong>建造者模式也属于创建型模式，它提供了一种创建对象的最佳方式。</strong></p>
<p>​	<strong>定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</strong></p>
<p>​	<strong>主要作用：在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂对象。</strong></p>
<p>​	<strong>用户只需要给出指定复杂对象的类型和内容，建造者模式负责将按顺序创建复杂对象（把内部的建造过程和细节隐藏起来）</strong></p>
<p>​	<strong>例子：</strong></p>
<p>​			<strong>工厂（建造者模式）：负责制造汽车（组装过程和细节在工厂内）</strong></p>
<p>​			<strong>汽车购买者（用户）：你只需要说你需要的型号（对象的类型和内容），然后直接购买就可以了（不需要知道汽车是怎么组装的（发动机、变速箱、轮毂、车门））</strong></p>
<h2 id="原型模式"><a class="markdownIt-Anchor" href="#原型模式">#</a> 原型模式：</h2>
<p>​		创建型模式之一。</p>
<p>​</p>
<h2 id="适配器模式"><a class="markdownIt-Anchor" href="#适配器模式">#</a> 适配器模式</h2>
<p>​		将一个类的接口转换成客户希望的另外一个接口，Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作！</p>
<p>​		角色分析：</p>
<p>​				1 . 目标接口：客户所期待的接口，目标可以使具体或抽象的类，也可以是接口。</p>
<p>​				2 . 需要适配的类：需要适配的类或者适配者类。</p>
<p>​				3 . 适配器：通过包装一个需要适配的对象，将原接口转换成目标对象。</p>
<p>​		对象适配器优点</p>
<p>​				1 . 一个对象适配器可以把多个不同的适配者适配到同一个目标</p>
<p>​				2 . 可以适配一个适配者的子类，由于适配器和适配者之间是关联关系，根据 “里氏代换原则” ，适配者的子类也可以通过该适配器进行适配。</p>
<p>​		类适配器缺点：</p>
<p>​				1 . 对于 Java、C# 等不支持多重类继承的语言，一次最多只能适配一个适配者类，不能同时适配多个适配者。</p>
<p>​				2 . 在 Java、C# 等语言中，适配器模式中的目标抽象类只能为接口，不能为类，其使用有一定的局限性。</p>
<p>​		适用场景：</p>
<p>​				1 . 系统需要使用一些现有的类，而这些类的接口不符合系统的需要，甚至没有这些类的代码。</p>
<p>​				2 . 想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-12-27T08:18:48.655Z" title="2022-12-27 16:18:48">2022-12-27</time>发表</span><span class="level-item"><time dateTime="2022-07-15T03:30:24.028Z" title="2022-7-15 11:30:24">2022-07-15</time>更新</span><span class="level-item">1 分钟读完 (大约155个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/12/27/%E3%80%90SpringBoot%E3%80%91%E8%85%BE%E8%AE%AF%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8liux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E6%97%A0%E6%B3%95%E9%80%9A%E8%BF%87springBoot%E5%86%85%E7%BD%AEmail%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">腾讯云服务器liux系统下无法通过springBoot内置mail发送邮件的解决方案</a></p><div class="content"><h3 id="腾讯云服务器liux系统下无法通过springboot内置mail发送邮件的解决方案"><a class="markdownIt-Anchor" href="#腾讯云服务器liux系统下无法通过springboot内置mail发送邮件的解决方案">#</a> 腾讯云服务器 liux 系统下无法通过 springBoot 内置 mail 发送邮件的解决方案</h3>
<p>原因</p>
<p>原来是腾讯云基于安全考虑，禁用了端口 25。改成 465 或者解封 25 就可以发邮件了。</p>
<p>原始配置  本地可发送</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  mail:</span><br><span class="line">    username: ***********</span><br><span class="line">    password: ***********</span><br><span class="line">    host: smtp<span class="number">.163</span>.com</span><br><span class="line">    port: <span class="number">25</span></span><br><span class="line">    <span class="keyword">default</span>-encoding: UTF-<span class="number">8</span></span><br><span class="line">    properties:</span><br><span class="line">      mail:</span><br><span class="line">        smtp:</span><br><span class="line">          timeout: <span class="number">10000</span></span><br><span class="line">          auth: <span class="literal">true</span></span><br><span class="line">          starttls:</span><br><span class="line">            enable: <span class="literal">true</span></span><br><span class="line">            required: <span class="literal">true</span></span><br><span class="line">          socketFactory:</span><br><span class="line">            port: <span class="number">25</span></span><br><span class="line">            class: javax.net.ssl.SSLSocketFactory</span><br><span class="line">            fallback: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>修改的配置 测试 部署到服务器上是可以发送的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  mail:</span><br><span class="line">    username: ***********</span><br><span class="line">    password: ***********</span><br><span class="line">    host: smtp<span class="number">.163</span>.com</span><br><span class="line">    port: <span class="number">465</span></span><br><span class="line">    <span class="keyword">default</span>-encoding: UTF-<span class="number">8</span></span><br><span class="line">    properties:</span><br><span class="line">      mail:</span><br><span class="line">        smtp:</span><br><span class="line">          timeout: <span class="number">10000</span></span><br><span class="line">          auth: <span class="literal">true</span></span><br><span class="line">          starttls:</span><br><span class="line">            enable: <span class="literal">true</span></span><br><span class="line">            required: <span class="literal">true</span></span><br><span class="line">          socketFactory:</span><br><span class="line">            port: <span class="number">465</span></span><br><span class="line">            class: javax.net.ssl.SSLSocketFactory</span><br><span class="line">            fallback: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-12-27T08:18:48.652Z" title="2022-12-27 16:18:48">2022-12-27</time>发表</span><span class="level-item"><time dateTime="2022-04-25T04:32:07.082Z" title="2022-4-25 12:32:07">2022-04-25</time>更新</span><span class="level-item">几秒读完 (大约59个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/12/27/%E3%80%90Java%E3%80%91%E7%AB%AF%E5%8F%A3%E5%8F%B7%E8%A2%AB%E5%8D%A0%E7%94%A8%E7%9A%84%E6%83%85%E5%86%B5%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3/">端口占用问题</a></p><div class="content"><p>安装好 Maven 之后配置环境变量：</p>
<p>netstat -ano：查询全部活动连接</p>
<p>tasklist ：查询全部的进程和 PID</p>
<p>tasklist | findstr “占用端口的进程 PID”</p>
<p>taskkill /f/t /im 占用端口的进程名字.exe</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/4/">上一页</a></div><div class="pagination-next"><a href="/page/6/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/4/">4</a></li><li><a class="pagination-link is-current" href="/page/5/">5</a></li><li><a class="pagination-link" href="/page/6/">6</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/11/">11</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-11T09:18:33.616Z">2023-04-11</time></p><p class="title"><a href="/2023/04/11/%E3%80%90Redis%E3%80%91SpringBoot%E6%95%B4%E5%90%88Redis%EF%BC%8C%E7%BC%93%E5%AD%98%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4%20%20redisTemplate.keys(pattern)%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%E6%89%BE%E4%B8%8D%E5%88%B0keys%EF%BC%8C%E2%80%9C%20%20%E2%80%9C%20%E9%80%9A%E9%85%8D%E7%AC%A6%E6%97%A0%E6%95%88/">【Redis】SpringBoot整合Redis，缓存批量删除  redisTemplate.keys(pattern)模糊查询找不到keys，“  “ 通配符无效</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-11T07:25:27.293Z">2023-04-11</time></p><p class="title"><a href="/2023/04/11/%E3%80%90MySQL%E3%80%91MySql%E7%9B%B8%E5%85%B3%E4%BC%98%E5%8C%96%E5%88%86%E4%BA%AB/">【MySQL】MySql相关优化分享</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-11T01:43:21.561Z">2023-04-11</time></p><p class="title"><a href="/2023/04/11/%E3%80%90Npm%E3%80%91npm%20install%E6%97%B6%E5%8D%A1%E4%BD%8F%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/">【Npm】npm install时卡住怎么办？</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-11T01:41:41.029Z">2023-04-11</time></p><p class="title"><a href="/2023/04/11/%E3%80%90Vue%E3%80%91Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">Vue的生命周期</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-11T01:21:58.399Z">2023-04-11</time></p><p class="title"><a href="/2023/04/11/%E3%80%90GOSN%E3%80%91Gosn%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%EF%BC%9F/">【GOSN】Gosn是什么？怎么使用？</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">45</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/"><span class="level-start"><span class="level-item">2022</span></span><span class="level-end"><span class="level-item tag">56</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://brath.cloud/7f71f67568cbf455bf7b2c32345f71e3.jpg" alt="Brath"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Brath</p><p class="is-size-6 is-block">为了更好的你，也为了更好的世界。</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·江苏·无锡</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">101</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Guoqing815" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Guoqing815"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Gitee" href="https://gitee.com/Guoqing-Li"><i class="fab fa-gitee"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://schokolade.cn/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">泠灵(特别呜谢)</span></span><span class="level-right"><span class="level-item tag">schokolade.cn</span></span></a></li><li><a class="level is-mobile" href="https://gitee.com/Guoqing-Li" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Gitee(码云)</span></span><span class="level-right"><span class="level-item tag">gitee.com</span></span></a></li><li><a class="level is-mobile" href="https://blog.csdn.net/Brath?type=blog" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">CSDN</span></span><span class="level-right"><span class="level-item tag">blog.csdn.net</span></span></a></li><li><a class="level is-mobile" href="https://juejin.cn/user/settings/profile" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">掘金</span></span><span class="level-right"><span class="level-item tag">juejin.cn</span></span></a></li><li><a class="level is-mobile" href="https://oss.console.aliyun.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">AliCloud(阿里云)</span></span><span class="level-right"><span class="level-item tag">oss.console.aliyun.com</span></span></a></li><li><a class="level is-mobile" href="https://cloud.tencent.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">TencentCloud(腾讯云)</span></span><span class="level-right"><span class="level-item tag">cloud.tencent.com</span></span></a></li><li><a class="level is-mobile" href="https://www.zhipin.com/web/user/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">BOSS</span></span><span class="level-right"><span class="level-item tag">www.zhipin.com</span></span></a></li><li><a class="level is-mobile" href="https://www.bilibili.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bilibili(B站)</span></span><span class="level-right"><span class="level-item tag">www.bilibili.com</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://brath.cloud/me.png" alt="Brath-Blog" height="28"></a><p class="is-size-7"><span>&copy; 2023 Brath</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2029</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>