<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Brath-Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Brath-Blog"><meta name="msapplication-TileImage" content="https://brath.cloud/me.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Brath-Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Brath-Blog"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="Brath-Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="Brath"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"Brath-Blog","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"Brath"},"publisher":{"@type":"Organization","name":"Brath-Blog","logo":{"@type":"ImageObject","url":"https://brath.cloud/me.png"}},"description":""}</script><link rel="icon" href="https://brath.cloud/me.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://brath.cloud/me.png" alt="Brath-Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">文章列表</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">更多</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Guoqing815"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-12-27T08:18:48.660Z" title="2022-12-27 16:18:48">2022-12-27</time>发表</span><span class="level-item"><time dateTime="2022-06-01T01:04:37.353Z" title="2022-6-1 9:04:37">2022-06-01</time>更新</span><span class="level-item">8 分钟读完 (大约1157个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/12/27/%E3%80%90%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%91%E9%98%BF%E9%87%8C%E4%BA%91OSS%E7%9A%84CDN%E5%8A%A0%E9%80%9F%E5%92%8COSS%E4%BC%A0%E8%BE%93%E5%8A%A0%E9%80%9F%E7%9A%84%E5%8C%BA%E5%88%AB/">阿里云OSS的CDN加速和OSS传输加速的区别</a></p><div class="content"><h2 id="概述"><a class="markdownIt-Anchor" href="#概述">#</a> 概述</h2>
<p>本文主要介绍阿里云对象存储 OSS 的传输加速功能和 CDN 加速 OSS 资源的区别，以便您根据实际业务进行选择。</p>
<h2 id="详细信息"><a class="markdownIt-Anchor" href="#详细信息">#</a> 详细信息</h2>
<p>阿里云对象存储 OSS 以海量、安全、低成本、高可靠等特点已经成为用户存储静态资源和文件的首要选择，实际使用中面向全球各地用户访问 OSS 资源时，访问速度会受到客户端网络、OSS 的下行带宽、Bucket 地域、访问链路长等限制出现访问慢的情况。以下主要介绍 CDN 加速 OSS 和 OSS 传输加速的加速方式：</p>
<h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理">#</a> 实现原理</h3>
<p>具体实现加速的原理如下：</p>
<ul>
<li>CDN 加速 OSS：是建立并覆盖在承载网之上，由遍布全球的边缘节点服务器群组成的分布式网络。阿里云 CDN 能分担源站压力，避免网络拥塞，确保在不同区域、不同场景下加速网站内容的分发，提高资源访问速度。由 CDN 全球广泛分布的边缘节点缓存 OSS 存储的静态数据，从而实现客户端从边缘节点直接获取数据的方式来实现访问的加速。</li>
<li>OSS 传输加速：利用全球分布的云机房，将全球各地用户对您存储空间（Bucket）的访问，经过智能路由解析至就近的接入点，使用优化后的网络及协议，为云存储互联网的上传、下载提供端到端的加速方案。</li>
</ul>
<h3 id="资源加速场景介绍"><a class="markdownIt-Anchor" href="#资源加速场景介绍">#</a> 资源加速场景介绍</h3>
<p>OSS 传输加速是针对 OSS 的链路加速，使用 OSS 传输加速后支持 OSS 提供的任意特性。CDN 通过全球边缘节点缓存 OSS 资源，加速同时可降低带宽成本。OSS 传输加速和 CDN 加速完全是两个不同的产品，且应对的场景不同，详情请参见<a target="_blank" rel="noopener" href="https://help.aliyun.com/document_detail/109895.htm"> CDN 应用场景</a>和<a target="_blank" rel="noopener" href="https://help.aliyun.com/document_detail/131312.htm">传输加速场景</a>。</p>
<ul>
<li>如果您的业务是第三方数据源加速，推荐您使用 CDN 加速。</li>
<li>如果您的 OSS 资源需要进行多次下载的操作，并且不要求数据强一致性，推荐您使用 CDN 加速。</li>
<li>如果您的 OSS 资源需要加速下载，并且访问量少，推荐您使用 OSS 传输加速。</li>
<li>如果您的 OSS 资源需要进行多次下载的操作，并且要求数据强一致性，推荐您使用 OSS 传输加速。</li>
<li>如果您的业务存储的是动态资源，且数据更新频繁，推荐您使用 OSS 传输加速。</li>
<li>如果您的业务存储的是静态资源，且更新少，推荐您使用 CDN 加速。</li>
</ul>
<h3 id="cdn加速和oss传输加速的对比"><a class="markdownIt-Anchor" href="#cdn加速和oss传输加速的对比">#</a> CDN 加速和 OSS 传输加速的对比</h3>
<p>CDN 加速和 OSS 传输加速的使用场景不同，其优缺点对比如下：</p>
<table>
<thead>
<tr>
<th><strong>加速方式</strong></th>
<th><strong>实现方法</strong></th>
<th><strong>应用场景</strong></th>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>CDN 加速 OSS</td>
<td>通过全球分布的边缘节点缓存数据来实现加速。</td>
<td>网站或应用中小文件大文件的下载视音频点播</td>
<td>CDN 边缘节点全球分布，数量多。CDN 节点提供的服务带宽量大。</td>
<td>对于访问量大的资源，命中率高，访问量小的资源命中率低，节点未缓存的情况下，还是需要回源访问，回源依赖实时的公网回源链路。CDN 静态资源的访问，对于上传、删除等动态请求加速效果不明显。</td>
</tr>
<tr>
<td>OSS 传输加速</td>
<td>实现的是客户端到 OSS 服务端之间链路优化来实现的加速功能，实际每次资源的请求还是从 OSS 来进行获取。</td>
<td>远距离数据传输加速 GB、TB 级大文件上传和下载非静态、非热点数据下载加速</td>
<td>OSS 存储节点全球主要区域分布。远距离以及大文件的上传和下载加速。</td>
<td>所有的访问都是回源到 OSS 访问，占用 OSS 的服务带宽。同一区域大量用户集中访问资源的情况下，效果没有 CDN 加速效果好。只能使用 HTTPS 方式访问。</td>
</tr>
</tbody>
</table>
<h2 id=""><a class="markdownIt-Anchor" href="#">#</a> </h2>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-12-27T08:18:48.658Z" title="2022-12-27 16:18:48">2022-12-27</time>发表</span><span class="level-item"><time dateTime="2022-04-25T04:34:10.453Z" title="2022-4-25 12:34:10">2022-04-25</time>更新</span><span class="level-item">21 分钟读完 (大约3146个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/12/27/%E3%80%90Java%E3%80%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/">设计模式（一）</a></p><div class="content"><h3 id="设计模式笔记-__brathli"><a class="markdownIt-Anchor" href="#设计模式笔记-__brathli">#</a> 设计模式笔记  <strong>__Brath.Li</strong></h3>
<h3 id="gof2323种设计模式"><a class="markdownIt-Anchor" href="#gof2323种设计模式">#</a> GoF23：23 种设计模式</h3>
<p>​		<strong>设计模式的本质是面向对象设原则的实际运用，是对类的封装性，继承性，多态性以及类的关联关系和组合关系的充分理解。</strong></p>
<p>​			<strong>正确使用设计模式具有以下优点：</strong></p>
<p>​			<strong>1. 提高程序员思维能力，编程能力和设计能力</strong></p>
<p>​			<strong>2. 使程序设计更加标准化，代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开的周期。</strong></p>
<p>​			<strong>3. 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。</strong></p>
<h3 id="创建型模式"><a class="markdownIt-Anchor" href="#创建型模式">#</a> <strong>创建型模式：</strong></h3>
<p>​			<strong>单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式。</strong></p>
<h3 id="结构型模式"><a class="markdownIt-Anchor" href="#结构型模式">#</a> <strong>结构型模式：</strong></h3>
<p>​			<strong>适配器模式、桥接模式、装饰模式、组合模式、外欧冠模式、享元模式、代理模式。</strong></p>
<h3 id="行为性模式"><a class="markdownIt-Anchor" href="#行为性模式">#</a> <strong>行为性模式：</strong></h3>
<p>​			<strong>模板方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、责任链模式、访问者模式。</strong></p>
<h4 id="oop面向对象七大原则"><a class="markdownIt-Anchor" href="#oop面向对象七大原则">#</a> OOP 面向对象七大原则：</h4>
<p><strong>1.OCP 开闭原则：</strong></p>
<p>​			<strong>软件实体（包括类、模块、功能等）应该对扩展开放，但是对修改关闭。</strong></p>
<p><strong>2. 里氏替换原则：</strong></p>
<p>​			<strong>继承必须确保超类锁拥有的性质在子类中仍然成立。</strong></p>
<p><strong>3. 依赖倒置原则：</strong></p>
<p>​			<strong>面向接口编程，不要面向实现编程。</strong></p>
<p><strong>4. 单一职责原则：</strong></p>
<p>​			<strong>控制类粒度大小、将对象解耦合、提高内聚性。</strong></p>
<p><strong>5. 接口隔离原则：</strong></p>
<p>​			<strong>要为各个类建立他们需要的专用接口。</strong></p>
<p><strong>6. 迪米特法则：</strong></p>
<p>​			** 只与你的直接朋友交谈、不跟 “陌生人” 说话。 **</p>
<p><strong>7. 合成复用原则：</strong></p>
<p>​			<strong>尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</strong></p>
<h2 id="单例设计模式"><a class="markdownIt-Anchor" href="#单例设计模式">#</a> 单例设计模式：</h2>
<p>作用：让一个类只能创建一个实例（因为频繁的创建对象，回收对象会造成系统性能下降。）。解决对象的唯一性，保证了内存中一个对象是唯一的 。</p>
<h4 id="饿汉式hunary"><a class="markdownIt-Anchor" href="#饿汉式hunary">#</a> 饿汉式：Hunary</h4>
<p><img src="C:%5CUsers%5C26344%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C%E9%A5%BF%E6%B1%89%E5%BC%8F.png" alt="饿汉式"></p>
<p><strong>步骤：1. 私有化构造器  2. 直接创建静态对象 3. 创建一个静态的方法，供外部调用实例</strong></p>
<p>优点：类初始化的时候，会立即加载该对象，线程天生安全，调用效率高。</p>
<p>缺点：无法避免被反射破解，不安全</p>
<h4 id="懒汉式lazyman"><a class="markdownIt-Anchor" href="#懒汉式lazyman">#</a> 懒汉式：LazyMan</h4>
<p><img src="C:%5CUsers%5C26344%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210910151318667.png" alt="image-20210910151318667"></p>
<p>步骤：1. 私有化构造器，不会直接创建对象  2. 向外暴露调用对象方法，在方法中先进行对象判空，为空才创建对象，这就是懒汉式</p>
<p>优点：类初始化时，不会初始化该对象，真正需要使用的时候才会去创建该对象，具备懒加载功能。</p>
<p>缺点：</p>
<p>1. 判空浪费时间</p>
<p>2. 不加 Synchronized 的懒汉式线程不安全，需要用到 volatile 关键字保持 new 对象的原子性一致</p>
<p>懒汉式单线程下是 OK 的，但是多线程并发下不安全。</p>
<p><img src="C:%5CUsers%5C26344%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210910153316119.png" alt="image-20210910153316119"> 开启十次线程测试</p>
<p><img src="C:%5CUsers%5C26344%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210910153327761.png" alt="image-20210910153327761"></p>
<p><strong>每次重启线程数都不一致</strong>，线程不安全。</p>
<p>怎么解决：</p>
<p>Tips：懒汉式也是可以实现线程安全的：只要加上 Synchronized 加锁即可：</p>
<p>但是这样一来，会降低整个访问的速度，而且每次都要判断。那么有没有更好的方式来实现呢？</p>
<p>解决方案：</p>
<p><strong>double-check-lock 双重加锁</strong></p>
<p><img src="C:%5CUsers%5C26344%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210910152638263.png" alt="image-20210910152638263"></p>
<p>所谓双重加锁机制。指的是，并不是每次进入 getInstance 方法都需要同步，而是先不同步，进入方法之后先检查实例是否存在，如果不存在才进入下面 Synchronized 加锁，之后会再次检查实例是否存在，如果还不存在才创建实例。</p>
<p>双重检测方式（因为 JVM 本身重排序的原因，可能会出现多次的初始化）</p>
<p>这种模式下的懒汉式，称为<strong> DCL 懒汉式</strong>！</p>
<p>你以为这样就没问题了？大错特错，注意：这里的 new 对象操作不是原子性的</p>
<p><img src="C:%5CUsers%5C26344%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210910153630120.png" alt="image-20210910153630120"></p>
<p>new 一个对象的执行顺序 ↓</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 1.分配内存空间</span></span><br><span class="line"><span class="comment">  * 2.执行构造方法初始化对象</span></span><br><span class="line"><span class="comment">  * 3.把这个对象指向内存空间</span></span><br><span class="line"><span class="comment">  * 这是创建对象的步骤 正确顺序为 123</span></span><br><span class="line"><span class="comment">  * 举例：</span></span><br><span class="line"><span class="comment">  * 线程A 创建对象 步骤为 123, 我们的代码没有问题</span></span><br><span class="line"><span class="comment">  * 线程B 创建对象 因为操作步骤不是原子性的，可能会走成 1 3 2，先指向了内存空间，再去构造对象</span></span><br><span class="line"><span class="comment">  * 这时会出现一个问题，指令重排：双重检测模式会失效，因为此时我们的类，不为空了，但是里面返回的对象是空的。</span></span><br><span class="line"><span class="comment">  * 所以就要用到一个关键字volatile，避免指令重排，保持操作原子性</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>
<p><img src="C:%5CUsers%5C26344%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210910153756918.png" alt="image-20210910153756918"></p>
<h4 id="静态内部类模式"><a class="markdownIt-Anchor" href="#静态内部类模式">#</a> 静态内部类模式：</h4>
<p><img src="C:%5CUsers%5C26344%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210910155204370.png" alt="image-20210910155204370"></p>
<p>步骤：1. 私有化构造器  2. 创建一个静态内部类，类中创建外部类的实例  3. 向外暴露一个方法获取静态内部类中创建的对象</p>
<p>优点：结合了懒汉式和饿汉式各自的优点，真正需要对象的时候才会加载，加载类是线程安全的。</p>
<p>缺点：每次调用都会创建多余的对象</p>
<h3 id="以上单例设计模式都会被反射破解枚举不会"><a class="markdownIt-Anchor" href="#以上单例设计模式都会被反射破解枚举不会">#</a> 以上单例设计模式都会被反射破解，枚举不会！</h3>
<p>枚举：枚举本身是一个类，继承了 Enum 的实例就成为了枚举类</p>
<p>使用枚举实现单例模式，实现简单、调用效率高，枚举本身就是单例，由 JVM 从根本上提供保障，避免通过反射和反序列化的漏洞，缺点是没有延迟加载。</p>
<p>在源码 Constructor 中<img src="C:%5CUsers%5C26344%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210910150042754.png" alt="image-20210910150042754"></p>
<p>如果是对象是通过反射机制创建的会抛出一个异常</p>
<p>IllegalArgumentException: Cannot reflectively create enum objects</p>
<p>枚举类在 traget 输出的代码中，构造器是空的，隐藏起来了，用 javap -p 反编译也看不见构造器</p>
<p><img src="C:%5CUsers%5C26344%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210910150706569.png" alt="image-20210910150706569"></p>
<p>我们用反射机制获取空构造器会获取不到对象，这时候用 jad 反编译工具，得到的 java 文件中，</p>
<p><img src="C:%5CUsers%5C26344%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210910150400927.png" alt="image-20210910150400927"></p>
<p>可以看见构造器其实是有数据的，我们把数据放到反射中实现，就会得到这个异常 Cannot reflectively create enum objects</p>
<p><img src="C:%5CUsers%5C26344%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210910150429958.png" alt="image-20210910150429958"></p>
<p><img src="C:%5CUsers%5C26344%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210910150418256.png" alt="image-20210910150418256"></p>
<p>由此可见，反射不能破坏枚举的单例模式</p>
<p>优点：实现简单，线程安全，防止反射攻击等。</p>
<p>缺点： 在不需要的时候可能就加载了，造成内存浪费</p>
<p>Tips：利用反射破解懒汉式。懒汉式不是安全的！</p>
<p><img src="C:%5CUsers%5C26344%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210910160648326.png" alt="image-20210910160648326"></p>
<p>私有化构造器的时候判断外面的字段 guoqing 是否 ==false，等于的话就设置为 true，如果不等于的话就抛出运行异常，这样设计的话在我们用反射机制获取构造器的时候，就获取不到对象了</p>
<p>但是有解决方法：利用反射强大的机制，假如我们反编译，知道要破解的字段是 guoqing，那我们直接用反射获取 guoqing 字段，然后设置解除私有化限制，在创建构造器实例的时候，把 guoqing 设置为 true，就可以破解 DCL 懒汉式了</p>
<p><img src="C:%5CUsers%5C26344%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210910160638735.png" alt="image-20210910160638735"></p>
<h2 id="工厂设计模式-factory-model"><a class="markdownIt-Anchor" href="#工厂设计模式-factory-model">#</a> 工厂设计模式 Factory Model：</h2>
<p>​		<strong>核心本质：</strong></p>
<p>​			<strong>实例化对象不使用 new，用工厂方法代替</strong></p>
<p>​			<strong>将选择实现类，创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。</strong></p>
<p>​		<strong>详细分类：</strong></p>
<p>​			<strong>简单工厂模式</strong></p>
<p>​						<strong>用来生产同一等级结构中的任意产品：扩展性差</strong></p>
<p>​			<strong>工厂方法模式</strong></p>
<p>​						<strong>用来生产同一等级结构中的固定产品：扩展性强</strong></p>
<p>​			<strong>抽象工厂模式</strong></p>
<p>​						<strong>围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。</strong></p>
<p><strong>工厂设计模式应用场景：</strong></p>
<p>​			<strong>JDK 中的 Calendar 的 getInstance 方法</strong></p>
<p>​			<strong>JDBC 中的 Connection 对象的获取</strong></p>
<p>​			<strong>Spring 的 IOC 容器创建管理 Bean 对象</strong></p>
<p>​			<strong>反射 Class 对象的 newInsetance 方法</strong></p>
<h2 id="建造者模式"><a class="markdownIt-Anchor" href="#建造者模式">#</a> 建造者模式：</h2>
<p>​	<strong>建造者模式也属于创建型模式，它提供了一种创建对象的最佳方式。</strong></p>
<p>​	<strong>定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</strong></p>
<p>​	<strong>主要作用：在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂对象。</strong></p>
<p>​	<strong>用户只需要给出指定复杂对象的类型和内容，建造者模式负责将按顺序创建复杂对象（把内部的建造过程和细节隐藏起来）</strong></p>
<p>​	<strong>例子：</strong></p>
<p>​			<strong>工厂（建造者模式）：负责制造汽车（组装过程和细节在工厂内）</strong></p>
<p>​			<strong>汽车购买者（用户）：你只需要说你需要的型号（对象的类型和内容），然后直接购买就可以了（不需要知道汽车是怎么组装的（发动机、变速箱、轮毂、车门））</strong></p>
<h2 id="原型模式"><a class="markdownIt-Anchor" href="#原型模式">#</a> 原型模式：</h2>
<p>​		创建型模式之一。</p>
<p>​</p>
<h2 id="适配器模式"><a class="markdownIt-Anchor" href="#适配器模式">#</a> 适配器模式</h2>
<p>​		将一个类的接口转换成客户希望的另外一个接口，Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作！</p>
<p>​		角色分析：</p>
<p>​				1 . 目标接口：客户所期待的接口，目标可以使具体或抽象的类，也可以是接口。</p>
<p>​				2 . 需要适配的类：需要适配的类或者适配者类。</p>
<p>​				3 . 适配器：通过包装一个需要适配的对象，将原接口转换成目标对象。</p>
<p>​		对象适配器优点</p>
<p>​				1 . 一个对象适配器可以把多个不同的适配者适配到同一个目标</p>
<p>​				2 . 可以适配一个适配者的子类，由于适配器和适配者之间是关联关系，根据 “里氏代换原则” ，适配者的子类也可以通过该适配器进行适配。</p>
<p>​		类适配器缺点：</p>
<p>​				1 . 对于 Java、C# 等不支持多重类继承的语言，一次最多只能适配一个适配者类，不能同时适配多个适配者。</p>
<p>​				2 . 在 Java、C# 等语言中，适配器模式中的目标抽象类只能为接口，不能为类，其使用有一定的局限性。</p>
<p>​		适用场景：</p>
<p>​				1 . 系统需要使用一些现有的类，而这些类的接口不符合系统的需要，甚至没有这些类的代码。</p>
<p>​				2 . 想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-12-27T08:18:48.655Z" title="2022-12-27 16:18:48">2022-12-27</time>发表</span><span class="level-item"><time dateTime="2022-07-15T03:30:24.028Z" title="2022-7-15 11:30:24">2022-07-15</time>更新</span><span class="level-item">1 分钟读完 (大约155个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/12/27/%E3%80%90SpringBoot%E3%80%91%E8%85%BE%E8%AE%AF%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8liux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E6%97%A0%E6%B3%95%E9%80%9A%E8%BF%87springBoot%E5%86%85%E7%BD%AEmail%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">腾讯云服务器liux系统下无法通过springBoot内置mail发送邮件的解决方案</a></p><div class="content"><h3 id="腾讯云服务器liux系统下无法通过springboot内置mail发送邮件的解决方案"><a class="markdownIt-Anchor" href="#腾讯云服务器liux系统下无法通过springboot内置mail发送邮件的解决方案">#</a> 腾讯云服务器 liux 系统下无法通过 springBoot 内置 mail 发送邮件的解决方案</h3>
<p>原因</p>
<p>原来是腾讯云基于安全考虑，禁用了端口 25。改成 465 或者解封 25 就可以发邮件了。</p>
<p>原始配置  本地可发送</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  mail:</span><br><span class="line">    username: ***********</span><br><span class="line">    password: ***********</span><br><span class="line">    host: smtp<span class="number">.163</span>.com</span><br><span class="line">    port: <span class="number">25</span></span><br><span class="line">    <span class="keyword">default</span>-encoding: UTF-<span class="number">8</span></span><br><span class="line">    properties:</span><br><span class="line">      mail:</span><br><span class="line">        smtp:</span><br><span class="line">          timeout: <span class="number">10000</span></span><br><span class="line">          auth: <span class="literal">true</span></span><br><span class="line">          starttls:</span><br><span class="line">            enable: <span class="literal">true</span></span><br><span class="line">            required: <span class="literal">true</span></span><br><span class="line">          socketFactory:</span><br><span class="line">            port: <span class="number">25</span></span><br><span class="line">            class: javax.net.ssl.SSLSocketFactory</span><br><span class="line">            fallback: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>修改的配置 测试 部署到服务器上是可以发送的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  mail:</span><br><span class="line">    username: ***********</span><br><span class="line">    password: ***********</span><br><span class="line">    host: smtp<span class="number">.163</span>.com</span><br><span class="line">    port: <span class="number">465</span></span><br><span class="line">    <span class="keyword">default</span>-encoding: UTF-<span class="number">8</span></span><br><span class="line">    properties:</span><br><span class="line">      mail:</span><br><span class="line">        smtp:</span><br><span class="line">          timeout: <span class="number">10000</span></span><br><span class="line">          auth: <span class="literal">true</span></span><br><span class="line">          starttls:</span><br><span class="line">            enable: <span class="literal">true</span></span><br><span class="line">            required: <span class="literal">true</span></span><br><span class="line">          socketFactory:</span><br><span class="line">            port: <span class="number">465</span></span><br><span class="line">            class: javax.net.ssl.SSLSocketFactory</span><br><span class="line">            fallback: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-12-27T08:18:48.652Z" title="2022-12-27 16:18:48">2022-12-27</time>发表</span><span class="level-item"><time dateTime="2022-04-25T04:32:07.082Z" title="2022-4-25 12:32:07">2022-04-25</time>更新</span><span class="level-item">几秒读完 (大约59个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/12/27/%E3%80%90Java%E3%80%91%E7%AB%AF%E5%8F%A3%E5%8F%B7%E8%A2%AB%E5%8D%A0%E7%94%A8%E7%9A%84%E6%83%85%E5%86%B5%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3/">端口占用问题</a></p><div class="content"><p>安装好 Maven 之后配置环境变量：</p>
<p>netstat -ano：查询全部活动连接</p>
<p>tasklist ：查询全部的进程和 PID</p>
<p>tasklist | findstr “占用端口的进程 PID”</p>
<p>taskkill /f/t /im 占用端口的进程名字.exe</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-12-27T08:18:48.649Z" title="2022-12-27 16:18:48">2022-12-27</time>发表</span><span class="level-item"><time dateTime="2022-04-25T04:34:42.511Z" title="2022-4-25 12:34:42">2022-04-25</time>更新</span><span class="level-item">5 分钟读完 (大约708个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/12/27/%E3%80%90SpringCloud%E3%80%91%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86%E7%BB%86%E5%88%99/">微服务拆分细则</a></p><div class="content"><p>​	在微服务的设计过程中，微服务设计有多大，微服务粒度的把控，一直是设计人员需要考虑和设计的难点。</p>
<p>因为服务粒度设计过大，不能得到微服务架构带来的便利，例如：更加敏态的开发，更频繁的版本发布，由于服务功能划分的小，可以根据实际的业务场景，选择更加合适的技术进行代码重构等等。</p>
<p>​		但同时我们也要注意，不是服务越” 微 “越好，因为服务的过度拆分会使架构的设计复杂度大大提升，同时也会大大提升运维和测试的复杂度等。</p>
<p>​		所以对服务拆分粒度的把控，对设计人员来讲就至关重要了，甚至对项目的成败有非常重要的影响。</p>
<p>这篇文档提供了一些主要的微服务拆分原则，供您参考，来帮助您进行更加合理粒度的微服务设计。</p>
<h3 id="微服务的拆分原则-通用"><a class="markdownIt-Anchor" href="#微服务的拆分原则-通用">#</a> 微服务的拆分原则 - 通用</h3>
<table>
<thead>
<tr>
<th><strong>编号</strong></th>
<th><strong>原则</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>原则 1</td>
<td>基于业务分析拆分</td>
<td>基于 TOGAF， ADA 等</td>
</tr>
<tr>
<td>原则 2</td>
<td>基于 DDD 领域驱动设计中的子域设计拆分</td>
<td>基于领域驱动设计</td>
</tr>
<tr>
<td>原则 3</td>
<td>根据动作和用例拆分</td>
<td>比如支付</td>
</tr>
<tr>
<td>原则 4</td>
<td>根据名词或者资源拆</td>
<td>比如账号</td>
</tr>
<tr>
<td>原则 5</td>
<td>架构稳定</td>
<td>拆分的结构稳定，不会经常修改</td>
</tr>
<tr>
<td>原则 6</td>
<td>服务是可测试的</td>
<td>集成测试要可定义，测试可回溯</td>
</tr>
<tr>
<td>原则 7</td>
<td>单一原则</td>
<td>一个服务做一个业务， 自己治理自己的数据库</td>
</tr>
<tr>
<td>原则 8</td>
<td>开闭原则</td>
<td>面向对象理论， 对扩展开放， 对修改关闭</td>
</tr>
<tr>
<td>原则 9</td>
<td>高内聚</td>
<td>强一致，强依赖关系的放在一起， 减少分布式事务</td>
</tr>
<tr>
<td>原则 10</td>
<td>低耦合</td>
<td>服务间互相独立</td>
</tr>
<tr>
<td>原则 11</td>
<td>足够小的团队可维护，最大两个 pizza team</td>
<td>6-10 人一个 pizza team</td>
</tr>
<tr>
<td>原则 12</td>
<td>团队自治，自己的服务的开发和发布要跟别的团队尽可能小的协调</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="微服务的拆分原则-技术侧重点"><a class="markdownIt-Anchor" href="#微服务的拆分原则-技术侧重点">#</a> 微服务的拆分原则 - 技术侧重点</h2>
<table>
<thead>
<tr>
<th><strong>编号</strong></th>
<th><strong>原则</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>原则 1</td>
<td>潜在风险</td>
<td>服务的风险性</td>
</tr>
<tr>
<td>原则 2</td>
<td>资源性能计算性能硬盘性能内存容量网络带宽</td>
<td>机器的性能决定了方案的部分选择</td>
</tr>
<tr>
<td>原则 3</td>
<td>安全</td>
<td>安全要求是否很高，安全的策略</td>
</tr>
<tr>
<td>原则 4</td>
<td>高并发瞬时并发持续并发</td>
<td>并发的种类， 持续的时间</td>
</tr>
<tr>
<td>原则 5</td>
<td>数据库数据量大小读操作写操作数据类型</td>
<td>数据的类型， 读写的多少，数据量</td>
</tr>
</tbody>
</table>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-12-27T08:18:48.646Z" title="2022-12-27 16:18:48">2022-12-27</time>发表</span><span class="level-item"><time dateTime="2022-07-12T02:37:09.713Z" title="2022-7-12 10:37:09">2022-07-12</time>更新</span><span class="level-item">3 分钟读完 (大约397个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/12/27/%E3%80%90MySQL%E3%80%91%E5%AE%9D%E5%A1%94%E9%83%A8%E7%BD%B2Docker%E2%80%94Mysql%E9%95%9C%E5%83%8F/">宝塔部署Docker—Mysql镜像</a></p><div class="content"><p>转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/u011630259/article/details/124497343">https://blog.csdn.net/u011630259/article/details/124497343</a></p>
<h2 id="宝塔部署dockermysql镜像"><a class="markdownIt-Anchor" href="#宝塔部署dockermysql镜像">#</a> 宝塔部署 Docker—Mysql 镜像</h2>
<p>如何在面板上使用 Docker 项目管理器快速创建多个版本的 MySQL？手把手的教你如何创建多个版本的 MySQL 服务<br>
环境介绍：<br>
宿主机：CentOS7.9<br>
 配置：2 核 4G（测试机器，生产环境建议配置高点）<br>
面板版本：7.9.26（测试版）<br>
Docker 项目管理器：3.9</p>
<p><img src="https://brath.cloud/blogImg/90825147a852493a8feea8efc0220deb.png" alt="img"></p>
<p>Docker 版本：Docker version 20.10.14, build a224086<br>
 测试 MySQL 版本：<br>
MySQL5.7.37<br>
MySQL8.0.28<br>
1、获取 MySQL 版本</p>
<p><img src="https://brath.cloud/blogImg/0241ca9c68d545819f8f100b33b2d8b9.png" alt="img"></p>
<p><img src="https://brath.cloud/blogImg/90825147a852493a8feea8efc0220deb.png" alt=""></p>
<p>默认情况下，直接输入 mysql 名，会拉取 mysql:latest 镜像，就是最新版本的镜像，指定版本后拉取的是指定版本的 MySQL 镜像，如 mysql:5.7.37</p>
<p><img src="https://brath.cloud/blogImg/2418dbfa7fac47bbac12fd3abe9e7229.png" alt="img"></p>
<p>2、创建容器：</p>
<p>指定容器中数据库的密码：</p>
<p><img src="https://brath.cloud/blogImg/5d2c09a1667744fd9538381efd7b67b0.png" alt="img"></p>
<p>MYSQL_ROOT_PASSWORD=dapaotest1</p>
<p><img src="https://brath.cloud/blogImg/241882e051fd4940bd09e98f61369215.png" alt="img"></p>
<p>3、容器创建成功后，进入终端命令行查看数据库</p>
<p><img src="https://brath.cloud/blogImg/f6245e7abacc4d768dd616d4067c3a4a.png" alt="img"></p>
<p>4、创建数据库表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">查看数据库的命令</span><br><span class="line">show databases;</span><br><span class="line">创建数据库的命令</span><br><span class="line">create database dapaodocker;</span><br><span class="line">创建用户的命令</span><br><span class="line">create user &#x27;dapaodocker&#x27;@&#x27;%&#x27; identified by &#x27;dapao666!&#x27;;</span><br><span class="line">授权</span><br><span class="line">grant all on dapaodocker.* to dapaodocker@&#x27;%&#x27;;</span><br><span class="line"></span><br><span class="line">查看用户权限</span><br><span class="line">select host,user from user;</span><br><span class="line">测试数据库是否可以连接</span><br></pre></td></tr></table></figure>
<p><img src="https://brath.cloud/blogImg/ee582242679c4da1b2fc04db16bad384.png" alt="img"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-12-27T08:18:48.644Z" title="2022-12-27 16:18:48">2022-12-27</time>发表</span><span class="level-item"><time dateTime="2022-04-25T04:31:31.722Z" title="2022-4-25 12:31:31">2022-04-25</time>更新</span><span class="level-item">3 分钟读完 (大约435个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/12/27/%E3%80%90Docker%E3%80%91%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%AE%B0%E5%BD%95/">使用docker搭建开发环境记录</a></p><div class="content"><h1 id="使用docker搭建开发环境记录"><a class="markdownIt-Anchor" href="#使用docker搭建开发环境记录">#</a> 使用 docker 搭建开发环境记录</h1>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器名</span><br><span class="line">docker stop 容器名</span><br><span class="line">docker restart 容器名</span><br><span class="line"></span><br><span class="line">docker run = docker create + docker start</span><br></pre></td></tr></table></figure>
<h3 id="mysql"><a class="markdownIt-Anchor" href="#mysql">#</a> mysql</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取镜像</span></span><br><span class="line">docker pull mysql:5.7</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建实例并启动</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-p 映射端口</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--name 名称</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-v 映射文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-e MYSQL_ROOT_PASSWORD mysql密码</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-d 后台运行并运行</span></span><br><span class="line">docker run -p 3306:3306 --name mysql -v /mydata/mysql/log:/var/log/mysql -v /mydata/mysql/data:/var/lib/mysql -v /mydata/mysql/conf:/etc/mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入容器</span></span><br><span class="line">docker exec -it mysql /bin/bash</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">退出容器</span></span><br><span class="line">exit</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置my.conf</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 1.在容器外编辑配置文件</span></span></span><br><span class="line">vi /mydata/mysql/conf/my.cnf</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[mysqld]</span><br><span class="line">init_connect=&#x27;SET conllation_connection = utf8_unicode_ci&#x27;</span><br><span class="line">init_connect=&#x27;SET NAMES utf8&#x27;</span><br><span class="line">character-set-server=utf8</span><br><span class="line">collation-server=utf8_unicode_ci</span><br><span class="line">skip-character-set-client-handshake</span><br><span class="line">skip-name-resolve</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 2. 重启mysql容器</span></span></span><br><span class="line">docker restart mysql</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 3. 进入mysql容器验证</span></span></span><br><span class="line">docker exec -it mysql /bin/bash </span><br><span class="line">cat /etc/mysql/my.cnf</span><br></pre></td></tr></table></figure>
<h3 id="redis"><a class="markdownIt-Anchor" href="#redis">#</a> Redis</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取镜像</span></span><br><span class="line">docker pull redis</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置文件</span></span><br><span class="line">本地：/mydata/redis/data/redis.conf 提前准备好</span><br><span class="line">主要配置</span><br><span class="line">bind 127.0.0.1 #注释掉这部分，使redis可以外部访问</span><br><span class="line">daemonize no#用守护线程的方式启动</span><br><span class="line">requirepass 你的密码#给redis设置密码</span><br><span class="line">appendonly yes#redis持久化　　默认是no</span><br><span class="line">tcp-keepalive 300 #防止出现远程主机强迫关闭了一个现有的连接的错误 默认是300</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建实例并启动</span></span><br><span class="line">docker run -p 6379:6379 --name redis -v /mydata/redis/data/redis.conf:/etc/redis/redis.conf  -v /mydata/redis/data:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="rabbitmq"><a class="markdownIt-Anchor" href="#rabbitmq">#</a> Rabbitmq</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取镜像management带控制台</span></span><br><span class="line">docker pull rabbitmq:management</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建实例并启动</span></span><br><span class="line">docker run -d --hostname my-rabbit --name rabbit -v /mydata/rabbitmq:/var/lib/rabbitmq -e RABBITMQ_DEFAULT_USER=root -e RABBITMQ_DEFAULT_PASS=Mm_123456 -p 15672:15672 -p 5672:5672 rabbitmq:management</span><br></pre></td></tr></table></figure>
<h3 id="mongo"><a class="markdownIt-Anchor" href="#mongo">#</a> mongo</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取镜像</span></span><br><span class="line">docker pull mongo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建实例并启动</span></span><br><span class="line">docker run -p 27017:27017 -v /mydata/mongo:/data/db --name mongodb -d mongo</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-12-27T08:18:48.640Z" title="2022-12-27 16:18:48">2022-12-27</time>发表</span><span class="level-item"><time dateTime="2022-04-25T04:33:32.841Z" title="2022-4-25 12:33:32">2022-04-25</time>更新</span><span class="level-item">1 分钟读完 (大约122个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/12/27/%E3%80%90%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%91%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E5%AE%9D%E5%A1%94/">云服务器部署宝塔面板</a></p><div class="content"><p>购买好服务器后，进入 Xshell：</p>
<p>1. 安装宝塔面板</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh</span><br></pre></td></tr></table></figure>
<p>获得：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">==================================================================</span><br><span class="line">Congratulations! Installed successfully!</span><br><span class="line">==================================================================</span><br><span class="line">外网面板地址: http://42.193.125.92:8888/ef1f509f</span><br><span class="line">内网面板地址: http://172.21.0.3:8888/ef1f509f</span><br><span class="line">username: upqknxq4</span><br><span class="line">password: f3701931</span><br><span class="line">If you cannot access the panel,</span><br><span class="line">release the following panel port [8888] in the security group</span><br><span class="line">若无法访问面板，请检查防火墙/安全组是否有放行面板[8888]端口</span><br><span class="line">==================================================================</span><br><span class="line">Time consumed: 1 Minute!</span><br></pre></td></tr></table></figure>
<p>访问 <a target="_blank" rel="noopener" href="http://ip:8888/ef1f509f">http://ip:8888/ef1f509f</a> 打开宝塔</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-12-27T08:18:48.638Z" title="2022-12-27 16:18:48">2022-12-27</time>发表</span><span class="level-item"><time dateTime="2022-10-18T05:03:48.735Z" title="2022-10-18 13:03:48">2022-10-18</time>更新</span><span class="level-item">2 分钟读完 (大约284个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/12/27/%E3%80%90MYSQL%E3%80%91%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%BC%82%E5%B8%B8%E8%AE%B0%E5%BD%95/">主从同步遇到 Got fatal error 1236 from master when reading data from binary log</a></p><div class="content"><h1 id=""><a class="markdownIt-Anchor" href="#">#</a> </h1>
<p>首先遇到这个是因为 binlog 位置索引处的问题，不要<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=reset&amp;spm=1001.2101.3001.7020"> reset</a> slave；</p>
<p>reset slave 会将主从同步的文件以及位置恢复到初始状态，一开始没有数据还好，有数据的话，相当于重新开始同步，可能会出现一些问题；</p>
<p>一般做主从同步，都是要求以后的数据实现主从同步，而对于旧的数据完全可以使用数据库同步工具先将数据库同步，完了再进行主从同步；</p>
<p>好了遇到上面的问题，正确做法是：</p>
<p>1. 打开主服务器，进入 mysql</p>
<p>2. 执行 flush logs；// 这时主服务器会重新创建一个 binlog 文件；</p>
<p>3. 在主服务上执行 show master status;  显示如下：</p>
<p><img src="https://brath.cloud/blogImg/1620811-20190720113929965-58969472.png" alt="img"></p>
<p>4. 来到从服务器的 mysql；</p>
<p>5.stop slave;</p>
<p>6.change master to master_log_file=‘mysql-bin.000012’,master_log_pos=154;// 这里的 file 和 pos 都是上面主服务器 master 显示的。</p>
<p>7.start slave;// 这时候就应可以了</p>
<p>8.show slave status \G;</p>
<p><img src="https://brath.cloud/blogImg/1620811-20190720114247073-1479221471.png" alt="img"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-12-27T08:18:48.635Z" title="2022-12-27 16:18:48">2022-12-27</time>发表</span><span class="level-item"><time dateTime="2022-09-29T04:05:33.582Z" title="2022-9-29 12:05:33">2022-09-29</time>更新</span><span class="level-item">35 分钟读完 (大约5262个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/12/27/%E3%80%90Java%E3%80%91ZGC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AZGC%E7%AE%80%E4%BB%8B%E5%92%8CJDK17%E5%AF%B9ZGC%E7%9A%84%E4%BC%98%E5%8C%96/">ZGC学习笔记：ZGC简介和JDK17对ZGC的优化</a></p><div class="content"><p>01 ZGC 简介<br>
 ZGC 是一个可扩展的低延迟垃圾收集器，能够处理 8MB 到 16TB 大小的堆，最大暂停时间为亚毫秒。</p>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/image-20220929120415958.png" alt="image-20220929120415958"></p>
<p>OpenJDK 的官网只写到这里，然后让我们自己去看 Wiki（链接 2）…… 好偷懒……</p>
<pre><code>    Wiki的介绍是更详细一些。

    Z Garbage Collector，也称为 ZGC，是一种可扩展的低延迟垃圾收集器，旨在满足以下目标：
</code></pre>
<p>亚毫秒最大暂停时间</p>
<p>暂停时间不会随着堆、live-set 或 root-set 的大小而增加</p>
<p>处理大小从 8MB 到 16TB 的堆</p>
<p>ZGC 最初是作为 JDK 11 中的一项实验性功能引入的，并在 JDK 15 中被宣布为 Production Ready。</p>
<p>ZGC 的几个特征：</p>
<p>并发</p>
<p>基于区域</p>
<p>基于压缩</p>
<p>NUMA 感知</p>
<p>使用染色指针</p>
<p>使用负载屏障（原文为 load barriers）</p>
<p>ZGC 的核心是一个并发垃圾收集器，这意味着所有繁重的工作都在 Java 线程继续执行的同时完成。这极大地减少了垃圾收集对应用程序响应时间的影响。</p>
<p>ZGC 项目由 HotSpot Group 赞助。</p>
<p>下图是截止目前为止（2020-04-17）的 ZGC 的发布时间表，可以看出 ZGC 总 JDK11 开始实验性推出，JDK15 开始正式发布。</p>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/07193612e6885c5946cf49cd8b796561.png" alt="img"></p>
<pre><code>    ZGC的部分参数：
</code></pre>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/5cd0e8857e5f10201c406b4b8c23a379.png" alt="img"></p>
<p>ZGC 部分操作：</p>
<p>使用下述命令选项启用 ZGC</p>
<p>-XX:+UseZGC<br>
 启用 ZGC</p>
<p>设置堆大小</p>
<pre><code>ZGC 最重要的调优选项是设置最大堆大小（-Xmx&lt;size&gt;）。由于 ZGC 是一个并发收集器，因此必须选择最大堆大小，以便 
</code></pre>
<ol>
<li>
<p>堆可以容纳应用程序的实时集，</p>
</li>
<li>
<p>堆中有足够的空间来允许在 GC 时处理处理分配。</p>
</li>
</ol>
<p>需要多少空间取决于应用程序的分配率和 live-set 大小。一般而言，给 ZGC 的内存越多越好。但与此同时，浪费内存是不可取的，所以这一切都是为了在内存使用和 GC 需要运行的频率之间找到一个平衡点。</p>
<p>3. 设置并发 GC 线程数</p>
<pre><code>    第二个重要的选项是设置并发 GC 线程的数量 (-XX:ConcGCThreads=&lt;number&gt;)。ZGC 具有自动选择此数字的启发式方法。这种启发式通常效果很好，但根据应用程序的特性，这可能需要进行调整。这个选项本质上决定了应该给 GC 多少 CPU-time（ps：这个不知道咋翻译，就叫CPU时间？先不翻译）。给了ZGC太多运行时间，GC 将从应用程序中占用过多的 CPU-time。给它太少，应用程序分配垃圾的速度可能比 GC 收集它的速度快。

    一般来说，如果低延迟（即低应用程序响应时间）是工业环境中的最大痛点，在配置相应操作时候就不需要太吝啬。理想情况下，系统的 CPU 利用率不应超过 70%。
</code></pre>
<p>4. 返回未使用内存给操作系统</p>
<pre><code>    默认情况下，ZGC 取消提交未使用的内存，将其返回给操作系统。这对于注重内存占用的应用程序和环境很有用。可以使用 -XX:-ZUncommit 禁用此功能。此外，内存不会被取消提交，因此堆大小会缩小到最小堆大小 (-Xms) 以下。这意味着如果最小堆大小 (-Xms) 配置为等于最大堆大小 (-Xmx)，则此功能将被隐式禁用。

    可以使用 -XX:ZUncommitDelay=&lt;seconds&gt; 配置取消提交延迟（默认为 300 秒）。此延迟指定内存在有资格取消提交之前应该未使用多长时间。

注意事项：在 Linux 上，取消提交未使用的内存需要具有 FALLOC_FL_PUNCH_HOLE 支持的 fallocate(2)，此特性首先出现在内核版本 3.5（用于 tmpfs）和 4.3（用于 hugetlbfs）中。
</code></pre>
<p>5. 启用 Linux 的大页（large page）操作</p>
<pre><code>    将 ZGC 配置为使用大页面通常会产生更好的性能（在吞吐量、延迟和启动时间方面）并且没有真正的缺点，只是设置起来稍微复杂一些。设置过程通常需要 root 权限，这就是默认情况下不启用它的原因。

    在 Linux/x86 上，大页面（英文原文为large page和huge page）的大小为 2MB。

    假设您需要一个 16G Java 堆。这意味着您需要 16G / 2M = 8192 个大页面。

    首先为大页面池分配至少 16G（8192 页）的内存。“至少”部分很重要，因为在 JVM 中启用大页面意味着不仅 GC 会尝试将这些用于 Java 堆，而且 JVM 的其他部分也会尝试将它们用于各种 内部数据结构（代码堆、标记位图等）。因此，在本例中，我们将保留 9216 个页面 (18G) 以允许 2G 的非 Java 堆分配来使用大页面。
</code></pre>
<p>6. 启用 Linux 的透明大页（transparent large page）操作</p>
<pre><code>    使用显式大页面（explicit large pages，就是5小节的大页面）的替代方法是使用透明大页面（ transparent huge pages）。通常不建议对延迟敏感的应用程序使用透明大页面（ latency sensitive，因为它往往会导致不必要的延迟峰值。但是，可能值得尝试看看系统的工作负载是否/如何受到它的影响。

    注意事项：在 Linux 上，使用启用透明大页的 ZGC 需要kernel &gt;= 4.7。
</code></pre>
<p>7. 启用 NUMA 支持</p>
<pre><code>    ZGC 支持 NUMA，这意味着它会尽量将 Java 堆分配指向 NUMA 本地内存。默认情况下启用此功能。但是，如果 JVM 检测到它只能使用单个 NUMA 节点上的内存，它将自动被禁用。通常，无需担心此设置，但如果您想显式覆盖 JVM 的决定，可以使用 -XX:+UseNUMA 或 -XX:-UseNUMA 选项来实现。

    在 NUMA 机器（例如多插槽 x86 机器）上运行时，启用 NUMA 支持通常会显著提升性能。

    注:

   关于NUMA,即Non Uniform Memory Access，非统一内存管理技术。以下直接截图于百度百科：
</code></pre>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/9fa912e0f93d4dd49a4eecd618d86951.png" alt="img"></p>
<p>8. 启用 GC 日志</p>
<p>打个日志而已，就截图了。</p>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/0f12489b9377904e0ada4b5977cb3e19.png" alt="img"></p>
<p>具体操作还是参考链接 2。</p>
<p>02 ZGC 在 JDK17 中的最新优化<br>
翻译自链接 4。</p>
<pre><code>   JDK 17 于2021年 9 月 14 日发布。这是一个长期支持 (LTS) 版本，这意味着它将得到多年的支持和更新。这也是第一个包含 ZGC 生产就绪版本（production ready version）的 LTS 版本。 稍微回忆一下，JDK 11（以前的 LTS 版本）中包含了 ZGC 的实验版本，而 ZGC 的第一个生产就绪版本出现在 JDK 15（非 LTS 版本）中。

    因此，可以说JDK17是第一个开始推出成熟的ZGC的长期支持的ZGC版本。

    （本来还想把JDK15，JDK16啥的ZGC的翻译一下，不过既然JDK17中ZGC这么重要，就只搬运JDK17的优化好了。）
</code></pre>
<p>1. 动态 GC 线程数</p>
<pre><code>    长期以来，JVM 都有一个名为

    -XX:+UseDynamicNumberOfGCThreads 
</code></pre>
<p>的选项。它默认启用，并告诉 GC 智能地了解它用于各种操作的 GC 线程数。使用的线程数将不断重新评估，因此会随着时间而变化。这个选项很有用有几个原因。例如，很难确定给定工作负载的最佳 GC 线程数是多少。通常发生的情况是，运维人员尝试各种设置 -XX:ParallelGCThreads 和 / 或 -XX:ConcGCThreads （取决于使用的 GC），看看哪个似乎给出了最好的结果。更复杂的是，最佳 GC 线程数可能会随着应用程序经历不同阶段而随时间变化，因此设置固定数量的 GC 线程本质上可能不是最佳的。</p>
<pre><code>    在 JDK 17 之前，ZGC 忽略 -XX:+UseDynamicNumberOfGCThreads 并始终使用固定数量的线程。在 JVM 启动期间，ZGC 使用启发式方法来决定该固定数字 (-XX:ConcGCThreads) 应该是什么。一旦设定了这个数字，它就再也不会改变了。从 JDK 17 开始，ZGC 现在支持 -XX:+UseDynamicNumberOfGCThreads 并尝试使用尽可能少、但是足够多的线程来保持以创建的速度收集垃圾。这有助于避免使用比需要更多的 CPU 时间，从而使 Java 线程可以使用更多的 CPU 时间。

    另请注意，启用此功能后，-XX:ConcGCThreads 的含义从“使用这么多线程”变为“最多使用这么多线程”。除非有一个非常规的工作负载，否则你通常不需要摆弄 -XX:ConcGCThreads。ZGC 的启发式算法会根据运行的系统的大小为机器选择合适的最大线程数。

    （注：就是说JDK17开始，ZGC的运行时线程数是动态的，-XX:ConcGCThreads 设置的是最大可用线程，但是如果更少的线程就能满足需求，ZGC就会使用更少的线程；如果运行中需要增加线程数，ZGC也会动态增加线程数）
</code></pre>
<p>为了说明此功能的实际作用，官方贴出了一下运行 SPECjbb2015 时的一些图表。</p>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/8d76e888d04e4ade98e9570cc2e6b6c2.png" alt="img"></p>
<pre><code>    第一张图显示了整个运行过程中使用的 GC 线程数。SPECjbb2015 有一个初始加速阶段，随后是一个较长的阶段，其中负载（注入速率）逐渐增加。我们可以看到 ZGC 使用的线程数反映了它需要做的工作量来跟上。只有在少数情况下，它需要所有（在本例中为 5 个）线程。

    JDK16和JDK17的打分比较图如下。
</code></pre>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/0ee86707c2957f6abf19e262612ec1db.png" alt="img"></p>
<pre><code>    如果出于某种原因希望始终使用固定数量的 GC 线程（如在 JDK 16 和更早版本中），则可以使用 -XX:-UseDynamicNumberOfGCThreads 禁用此功能（注：应该没人会用吧？）。
</code></pre>
<p>2. 快速 JVM 终止</p>
<pre><code>    在之前使用版本的Java程序中，如果使用的垃圾回收器是 ZGC ，终止正在运行的 Java 进程（例如，通过按 Ctrl+C 或通过让应用程序调用 System.exit()）， JVM 有时可能需要一段时间（在最坏的情况下为数秒）才能真正终止。这在一些需要快速宕机的场景下很烦人，如果某个场景需要快速终止程序，JVM的慢停止会导致一定问题。。

    那么，为什么之前在使用 ZGC 时，JVM 有时会需要一些时间来终止呢？原因是 JVM 的关闭顺序需要与 GC 协调，让 GC 停止正在做的事情，进入“安全”状态。ZGC 仅在空闲时处于“安全”状态，即当前不收集垃圾。如果终止信号到达时正在进行一个非常长的 GC 周期，那么 JVM 关闭序列只需等待该 GC 周期完成，然后 ZGC 变为空闲并再次进入“安全”状态。

    这已在 JDK 17 中得到解决。ZGC 现在能够中止正在进行的 GC 循环，以按需快速达到“安全”状态。终止运行 ZGC 的 JVM 现在或多或少是即时的。
</code></pre>
<p>3. 减少标记堆栈内存使用</p>
<pre><code>    ZGC做条纹标记。这是指将堆划分为条带，并分配每个 GC 线程来标记其中一个条带（strip）中的对象。这有助于最小化 GC 线程之间的共享状态，并使标记过程对缓存更加友好，因为两个 GC 线程不会在堆的同一部分标记对象。这种方法还可以在 GC 线程之间实现自然的工作平衡，因为一个条带（strip）中的工作量往往大致相同。

    下图是ZGC的基于多线程垃圾回收器对基于条带的Java堆内存的回收机制示意图。
</code></pre>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/3792f57ec3bd3c6ddb1b3f61b7f70b5c.png" alt="img"></p>
<pre><code>    在 JDK 17 之前，ZGC 的标记严格遵守条带化。如果一个 GC 线程在跟踪对象图时遇到一个对象引用，该对象引用指向不属于其分配的条带的堆的一部分，则该对象引用被放置在与该其他对象关联的线程本地标记堆栈上条纹。一旦该堆栈已满（254 个条目），它就会被移交给分配给该条带处理标记的 GC 线程。将对象引用加载到尚未标记的对象的 Java 线程会做同样的事情，只是它总是将对象引用放在关联的线程本地标记堆栈上，并且不会自己做任何实际的标记工作。

    这种方法适用于大多数工作负载，但也存在病态问题。如果您有一个具有一个或多个 N:1 关系的对象图，其中 N 是一个非常大的数字，那么您可能会为标记堆栈使用大量内存（如许多 GB）。我们一直都知道这可能是一个问题，您可以编写一个小型综合测试来引发它，但我们从未真正遇到过暴露它的真实工作负载。也就是说，直到来自腾讯的 OpenJDK 贡献者报告他们在野外遇到了这个问题（注：我去，鹅厂！）。

    JDK 17 中对此的修复涉及通过以下方式放松严格条带化：
</code></pre>
<p>对于 GC 线程，无论对象引用指向哪个条带，首先尝试标记对象（即可能跳出 GC 线程分配的条带），如果尚未标记，则将对象引用推送到关联标记 堆。</p>
<p>对于 Java 线程，首先检查对象是否已标记，如果尚未标记，则将对象引用推送到关联的标记堆栈。</p>
<p>（注：这一块我其实看的不是很懂。要是有人有兴趣讨论的话欢迎交流）。</p>
<pre><code>这些调整有助于阻止在病态 N:1 情况下过度使用标记堆栈内存，其中 GC 线程一遍又一遍地遇到相同的对象引用，将大量重复的对象引用推入标记堆栈。重复是没有用的，因为一个对象只需要标记一次。通过在推送之前进行标记，并且只推送以前未标记的对象，复制品的生产就会停止。

我们最初有点不愿意这样做，因为 GC 线程现在正在执行原子比较和交换操作，以标记内存中属于分配给其他 GC 线程工作的条带的对象。这打破了严格的条带化，使其对缓存不太友好。Java 线程现在也在进行原子加载以查看对象是否被标记，这是他们以前没有做过的事情。同时，GC 线程完成的其他工作（扫描/跟踪对象字段和跟踪每个堆区域的活动对象/字节数）仍然遵守严格的条带化。最后，基准测试表明我们最初的担忧是没有根据的。GC 标记时间不受影响，对 Java 线程的影响也不明显。另一方面，我们现在有一个更健壮的标记方案，不会出现过多的内存使用。

    （注：所以其实出现这个问题，是不是因为只是因为某厂的代码写的太烂了……）
</code></pre>
<p>支持 ARM 上的 macOS</p>
<pre><code>    前段时间（注：苹果2020年的秋季发布会的消息），Apple 宣布了一项将其 Mac 计算机产品线从 x86 过渡到 ARM 的长期计划。不久之后，JEP 391: macOS/AArch64 Port 提出了 JDK 到这个新平台的移植。JVM 代码库是相当模块化的，特定于操作系统和 CPU 的代码与共享平台无关代码隔离。JDK 已经支持 macOS/x86 和 Linux/Aarch64，因此支持 macOS/Aarch64 所需的主要部分已经存在。当然，任何计划发布和支持 JDK 的 macOS/Aarch64 构建的人仍然需要做一些工作，比如投资新硬件，将这个新平台集成到 CI 管道中等。

    ZGC的故事几乎相同。macOS/x86 和 Linux/Aarch64 都已经得到支持，因此主要是启用构建和测试这种新的 OS/CPU 组合的问题。从 JDK 17 开始，ZGC 在以下平台上运行：
</code></pre>
<p>Linux/x64</p>
<p>Linux/AArch64</p>
<p>macOS/x64</p>
<p>macOS/AArch64</p>
<p>Window/x64</p>
<p>Windows/AArch64</p>
<p>大多数 ZGC 代码库继续独立于平台。当前的代码分布如下所示：</p>
<p>​        <img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/d43c84500703a456f8a4ad7e2a2c686b.png" alt="img"></p>
<p>用于循环和暂停的 GarbageCollectorMXBeans</p>
<pre><code>    GarbageCollectorMXBean 提供有关 GC 的信息。通过这个 bean，应用程序可以提取摘要信息（到目前为止完成的 GC 次数、累计花费的 GC 时间等）并监听 GarbageCollectionNotificationInfo 通知以获取有关单个 GC 的更细粒度的信息（GC 原因、开始时间、结束时间， ETC）。

    在 JDK 17 之前，ZGC 发布了一个名为 ZGC 的单个 bean。这个 bean 提供了有关 ZGC 周期的信息。一个循环包括从开始到结束的所有 GC 阶段。大多数阶段是并发的，但有些是 Stop-The-World 暂停。虽然有关周期的信息很有用，但您可能还想知道在执行 GC 上花费了多少时间在 Stop-The-World 暂停上。此信息不适用于单个 ZGC bean。为了解决这个问题，ZGC 现在发布了两个 bean，一个称为 ZGC Cycles，一个称为 ZGC Pauses。顾名思义，每个 bean 提供的信息分别映射到周期和暂停。
</code></pre>
<p>总结：</p>
<pre><code>    作为第一个支持生产版本ZGC的LTS版本的JDK，JDK17中对ZGC做了下述优化：
</code></pre>
<p>支持 JVM 选项 -XX:+UseDynamicNumberOfGCThreads。此功能默认启用，并告诉 ZGC 对其使用的 GC 线程数保持智能，这通常会导致 Java 应用程序级别的更高吞吐量和更低延迟。</p>
<p>使用了 ZGC 的 JVM 在停止运行时， 基本上是实时的，而之前版本花费的时间更多。</p>
<p>标记算法现在通常使用更少的内存，并且不再容易出现过多的内存使用。</p>
<p>ZGC 现在可以在 macOS/Aarch64 上运行。</p>
<p>ZGC 现在发布了两个 GarbageCollectorMXBean，以提供有关 GC 周期和 GC 暂停的信息。</p>
<p>03 一些很搞笑的事情</p>
<pre><code>    据说有哥们在面试时候被面试官问到，ZGC的Z代表的是啥？

    面试者老哥内心OS：我去葛格不讲武德啊，之前面经没有讲到这个啊。但是呆胶布，我现场编一个。

    于是他说，“ZGC的Z是英文字母的最后一个字母，这说明Oracle公司想把ZGC作为Java的最终解决方案，是一个革命性的Java垃圾回收机制解决方案，blabla。”

    面试官微微一笑贴出官网截屏：
</code></pre>
<p>​</p>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/b5813b2129f9db814556823199eb2355.png" alt="img"></p>
<p>翻译：ZGC 的 Z 毛线都不表示，莫得含义。</p>
<pre><code>    面试者：不听不听王八念经。

    笑死。</code></pre>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/4/">上一页</a></div><div class="pagination-next"><a href="/page/6/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/4/">4</a></li><li><a class="pagination-link is-current" href="/page/5/">5</a></li><li><a class="pagination-link" href="/page/6/">6</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/10/">10</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-03-22T05:43:30.956Z">2023-03-22</time></p><p class="title"><a href="/2023/03/22/%E3%80%90ChatGPT%E3%80%91%E5%85%85%E6%BB%A1%E5%8F%AF%E8%83%BD%E7%9A%84%E6%96%B0%E4%B8%80%E4%BB%A3%E8%BE%85%E5%8A%A9%E7%BC%96%E7%A8%8B%E7%A5%9E%E5%99%A8%EF%BC%9ACursor/">充满可能的新一代辅助编程神器：Cursor</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-03-21T07:46:57.392Z">2023-03-21</time></p><p class="title"><a href="/2023/03/21/%E3%80%90Mysql%E3%80%91Mysql%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE%E5%8F%AA%E4%BF%9D%E7%95%99%E4%B8%80%E6%9D%A1/">【Mysql】Mysql删除重复数据只保留一条</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-03-21T07:46:57.390Z">2023-03-21</time></p><p class="title"><a href="/2023/03/21/%E3%80%90Flutter%E3%80%91flutter%20%E5%9C%A8%E7%9C%9F%E6%9C%BA%E4%B8%8A%E8%B0%83%E8%AF%95%E5%8D%B8%E8%BD%BD%E5%AE%89%E8%A3%85%E5%8C%85%E5%90%8E%E5%8D%A1%E4%BD%8F%E6%B2%A1%E5%8F%8D%E5%BA%94%E9%97%AE%E9%A2%98/">【Flutter】flutter 在真机上调试卸载安装包后卡住没反应问题</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-03-21T07:46:57.388Z">2023-03-21</time></p><p class="title"><a href="/2023/03/21/%E3%80%90Java%E3%80%91canal%E6%9C%8D%E5%8A%A1%E8%BF%90%E8%A1%8C%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%81%8D%E5%8E%86%E4%B8%8D%E5%88%B0%E6%95%B0%E6%8D%AE/">【Java】canal服务运行一段时间客户端遍历不到数据</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-03-21T07:46:57.386Z">2023-03-21</time></p><p class="title"><a href="/2023/03/21/%E3%80%90Java%E3%80%91Elastic%20canal%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%88%B0ES%E9%85%8D%E7%BD%AE%E5%B8%B8%E8%A7%81%E6%8A%A5%E9%94%99/">【Java】Elastic canal数据同步到ES配置常见报错</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">39</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/"><span class="level-start"><span class="level-item">2022</span></span><span class="level-end"><span class="level-item tag">56</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://brath.oss-cn-shanghai.aliyuncs.com/me.png" alt="Brath"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Brath</p><p class="is-size-6 is-block">为了更好的你，也为了更好的世界。</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·江苏·无锡</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">95</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Guoqing815" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Guoqing815"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Gitee" href="https://gitee.com/Guoqing-Li"><i class="fab fa-gitee"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://gitee.com/Guoqing-Li" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Gitee(码云)</span></span><span class="level-right"><span class="level-item tag">gitee.com</span></span></a></li><li><a class="level is-mobile" href="https://blog.csdn.net/Brath?type=blog" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">CSDN</span></span><span class="level-right"><span class="level-item tag">blog.csdn.net</span></span></a></li><li><a class="level is-mobile" href="https://juejin.cn/user/settings/profile" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">掘金</span></span><span class="level-right"><span class="level-item tag">juejin.cn</span></span></a></li><li><a class="level is-mobile" href="https://oss.console.aliyun.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">AliCloud(阿里云)</span></span><span class="level-right"><span class="level-item tag">oss.console.aliyun.com</span></span></a></li><li><a class="level is-mobile" href="https://cloud.tencent.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">TencentCloud(腾讯云)</span></span><span class="level-right"><span class="level-item tag">cloud.tencent.com</span></span></a></li><li><a class="level is-mobile" href="https://www.zhipin.com/web/user/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">BOSS</span></span><span class="level-right"><span class="level-item tag">www.zhipin.com</span></span></a></li><li><a class="level is-mobile" href="https://www.bilibili.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bilibili(B站)</span></span><span class="level-right"><span class="level-item tag">www.bilibili.com</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://brath.cloud/me.png" alt="Brath-Blog" height="28"></a><p class="is-size-7"><span>&copy; 2023 Brath</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2029</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>