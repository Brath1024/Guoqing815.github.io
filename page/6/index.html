<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Brath-Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Brath-Blog"><meta name="msapplication-TileImage" content="https://brath.cloud/me.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Brath-Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Brath-Blog"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="Brath-Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="Brath"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"Brath-Blog","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"Brath"},"publisher":{"@type":"Organization","name":"Brath-Blog","logo":{"@type":"ImageObject","url":"https://brath.cloud/me.png"}},"description":""}</script><link rel="icon" href="https://brath.cloud/me.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://brath.cloud/me.png" alt="Brath-Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">文章列表</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">更多</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Guoqing815"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-12-27T08:18:48.652Z" title="2022-12-27 16:18:48">2022-12-27</time>发表</span><span class="level-item"><time dateTime="2022-04-25T04:32:07.082Z" title="2022-4-25 12:32:07">2022-04-25</time>更新</span><span class="level-item">几秒读完 (大约59个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/12/27/%E3%80%90Java%E3%80%91%E7%AB%AF%E5%8F%A3%E5%8F%B7%E8%A2%AB%E5%8D%A0%E7%94%A8%E7%9A%84%E6%83%85%E5%86%B5%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3/">端口占用问题</a></p><div class="content"><p>安装好 Maven 之后配置环境变量：</p>
<p>netstat -ano：查询全部活动连接</p>
<p>tasklist ：查询全部的进程和 PID</p>
<p>tasklist | findstr “占用端口的进程 PID”</p>
<p>taskkill /f/t /im 占用端口的进程名字.exe</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-12-27T08:18:48.649Z" title="2022-12-27 16:18:48">2022-12-27</time>发表</span><span class="level-item"><time dateTime="2022-04-25T04:34:42.511Z" title="2022-4-25 12:34:42">2022-04-25</time>更新</span><span class="level-item">5 分钟读完 (大约708个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/12/27/%E3%80%90SpringCloud%E3%80%91%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86%E7%BB%86%E5%88%99/">微服务拆分细则</a></p><div class="content"><p>​	在微服务的设计过程中，微服务设计有多大，微服务粒度的把控，一直是设计人员需要考虑和设计的难点。</p>
<p>因为服务粒度设计过大，不能得到微服务架构带来的便利，例如：更加敏态的开发，更频繁的版本发布，由于服务功能划分的小，可以根据实际的业务场景，选择更加合适的技术进行代码重构等等。</p>
<p>​		但同时我们也要注意，不是服务越” 微 “越好，因为服务的过度拆分会使架构的设计复杂度大大提升，同时也会大大提升运维和测试的复杂度等。</p>
<p>​		所以对服务拆分粒度的把控，对设计人员来讲就至关重要了，甚至对项目的成败有非常重要的影响。</p>
<p>这篇文档提供了一些主要的微服务拆分原则，供您参考，来帮助您进行更加合理粒度的微服务设计。</p>
<h3 id="微服务的拆分原则-通用"><a class="markdownIt-Anchor" href="#微服务的拆分原则-通用">#</a> 微服务的拆分原则 - 通用</h3>
<table>
<thead>
<tr>
<th><strong>编号</strong></th>
<th><strong>原则</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>原则 1</td>
<td>基于业务分析拆分</td>
<td>基于 TOGAF， ADA 等</td>
</tr>
<tr>
<td>原则 2</td>
<td>基于 DDD 领域驱动设计中的子域设计拆分</td>
<td>基于领域驱动设计</td>
</tr>
<tr>
<td>原则 3</td>
<td>根据动作和用例拆分</td>
<td>比如支付</td>
</tr>
<tr>
<td>原则 4</td>
<td>根据名词或者资源拆</td>
<td>比如账号</td>
</tr>
<tr>
<td>原则 5</td>
<td>架构稳定</td>
<td>拆分的结构稳定，不会经常修改</td>
</tr>
<tr>
<td>原则 6</td>
<td>服务是可测试的</td>
<td>集成测试要可定义，测试可回溯</td>
</tr>
<tr>
<td>原则 7</td>
<td>单一原则</td>
<td>一个服务做一个业务， 自己治理自己的数据库</td>
</tr>
<tr>
<td>原则 8</td>
<td>开闭原则</td>
<td>面向对象理论， 对扩展开放， 对修改关闭</td>
</tr>
<tr>
<td>原则 9</td>
<td>高内聚</td>
<td>强一致，强依赖关系的放在一起， 减少分布式事务</td>
</tr>
<tr>
<td>原则 10</td>
<td>低耦合</td>
<td>服务间互相独立</td>
</tr>
<tr>
<td>原则 11</td>
<td>足够小的团队可维护，最大两个 pizza team</td>
<td>6-10 人一个 pizza team</td>
</tr>
<tr>
<td>原则 12</td>
<td>团队自治，自己的服务的开发和发布要跟别的团队尽可能小的协调</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="微服务的拆分原则-技术侧重点"><a class="markdownIt-Anchor" href="#微服务的拆分原则-技术侧重点">#</a> 微服务的拆分原则 - 技术侧重点</h2>
<table>
<thead>
<tr>
<th><strong>编号</strong></th>
<th><strong>原则</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>原则 1</td>
<td>潜在风险</td>
<td>服务的风险性</td>
</tr>
<tr>
<td>原则 2</td>
<td>资源性能计算性能硬盘性能内存容量网络带宽</td>
<td>机器的性能决定了方案的部分选择</td>
</tr>
<tr>
<td>原则 3</td>
<td>安全</td>
<td>安全要求是否很高，安全的策略</td>
</tr>
<tr>
<td>原则 4</td>
<td>高并发瞬时并发持续并发</td>
<td>并发的种类， 持续的时间</td>
</tr>
<tr>
<td>原则 5</td>
<td>数据库数据量大小读操作写操作数据类型</td>
<td>数据的类型， 读写的多少，数据量</td>
</tr>
</tbody>
</table>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-12-27T08:18:48.646Z" title="2022-12-27 16:18:48">2022-12-27</time>发表</span><span class="level-item"><time dateTime="2022-07-12T02:37:09.713Z" title="2022-7-12 10:37:09">2022-07-12</time>更新</span><span class="level-item">3 分钟读完 (大约397个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/12/27/%E3%80%90MySQL%E3%80%91%E5%AE%9D%E5%A1%94%E9%83%A8%E7%BD%B2Docker%E2%80%94Mysql%E9%95%9C%E5%83%8F/">宝塔部署Docker—Mysql镜像</a></p><div class="content"><p>转自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/u011630259/article/details/124497343">https://blog.csdn.net/u011630259/article/details/124497343</a></p>
<h2 id="宝塔部署dockermysql镜像"><a class="markdownIt-Anchor" href="#宝塔部署dockermysql镜像">#</a> 宝塔部署 Docker—Mysql 镜像</h2>
<p>如何在面板上使用 Docker 项目管理器快速创建多个版本的 MySQL？手把手的教你如何创建多个版本的 MySQL 服务<br>
环境介绍：<br>
宿主机：CentOS7.9<br>
 配置：2 核 4G（测试机器，生产环境建议配置高点）<br>
面板版本：7.9.26（测试版）<br>
Docker 项目管理器：3.9</p>
<p><img src="https://brath.cloud/blogImg/90825147a852493a8feea8efc0220deb.png" alt="img"></p>
<p>Docker 版本：Docker version 20.10.14, build a224086<br>
 测试 MySQL 版本：<br>
MySQL5.7.37<br>
MySQL8.0.28<br>
1、获取 MySQL 版本</p>
<p><img src="https://brath.cloud/blogImg/0241ca9c68d545819f8f100b33b2d8b9.png" alt="img"></p>
<p><img src="https://brath.cloud/blogImg/90825147a852493a8feea8efc0220deb.png" alt=""></p>
<p>默认情况下，直接输入 mysql 名，会拉取 mysql:latest 镜像，就是最新版本的镜像，指定版本后拉取的是指定版本的 MySQL 镜像，如 mysql:5.7.37</p>
<p><img src="https://brath.cloud/blogImg/2418dbfa7fac47bbac12fd3abe9e7229.png" alt="img"></p>
<p>2、创建容器：</p>
<p>指定容器中数据库的密码：</p>
<p><img src="https://brath.cloud/blogImg/5d2c09a1667744fd9538381efd7b67b0.png" alt="img"></p>
<p>MYSQL_ROOT_PASSWORD=dapaotest1</p>
<p><img src="https://brath.cloud/blogImg/241882e051fd4940bd09e98f61369215.png" alt="img"></p>
<p>3、容器创建成功后，进入终端命令行查看数据库</p>
<p><img src="https://brath.cloud/blogImg/f6245e7abacc4d768dd616d4067c3a4a.png" alt="img"></p>
<p>4、创建数据库表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">查看数据库的命令</span><br><span class="line">show databases;</span><br><span class="line">创建数据库的命令</span><br><span class="line">create database dapaodocker;</span><br><span class="line">创建用户的命令</span><br><span class="line">create user &#x27;dapaodocker&#x27;@&#x27;%&#x27; identified by &#x27;dapao666!&#x27;;</span><br><span class="line">授权</span><br><span class="line">grant all on dapaodocker.* to dapaodocker@&#x27;%&#x27;;</span><br><span class="line"></span><br><span class="line">查看用户权限</span><br><span class="line">select host,user from user;</span><br><span class="line">测试数据库是否可以连接</span><br></pre></td></tr></table></figure>
<p><img src="https://brath.cloud/blogImg/ee582242679c4da1b2fc04db16bad384.png" alt="img"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-12-27T08:18:48.644Z" title="2022-12-27 16:18:48">2022-12-27</time>发表</span><span class="level-item"><time dateTime="2022-04-25T04:31:31.722Z" title="2022-4-25 12:31:31">2022-04-25</time>更新</span><span class="level-item">3 分钟读完 (大约435个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/12/27/%E3%80%90Docker%E3%80%91%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%AE%B0%E5%BD%95/">使用docker搭建开发环境记录</a></p><div class="content"><h1 id="使用docker搭建开发环境记录"><a class="markdownIt-Anchor" href="#使用docker搭建开发环境记录">#</a> 使用 docker 搭建开发环境记录</h1>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器名</span><br><span class="line">docker stop 容器名</span><br><span class="line">docker restart 容器名</span><br><span class="line"></span><br><span class="line">docker run = docker create + docker start</span><br></pre></td></tr></table></figure>
<h3 id="mysql"><a class="markdownIt-Anchor" href="#mysql">#</a> mysql</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取镜像</span></span><br><span class="line">docker pull mysql:5.7</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建实例并启动</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-p 映射端口</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--name 名称</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-v 映射文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-e MYSQL_ROOT_PASSWORD mysql密码</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-d 后台运行并运行</span></span><br><span class="line">docker run -p 3306:3306 --name mysql -v /mydata/mysql/log:/var/log/mysql -v /mydata/mysql/data:/var/lib/mysql -v /mydata/mysql/conf:/etc/mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入容器</span></span><br><span class="line">docker exec -it mysql /bin/bash</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">退出容器</span></span><br><span class="line">exit</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置my.conf</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 1.在容器外编辑配置文件</span></span></span><br><span class="line">vi /mydata/mysql/conf/my.cnf</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[mysqld]</span><br><span class="line">init_connect=&#x27;SET conllation_connection = utf8_unicode_ci&#x27;</span><br><span class="line">init_connect=&#x27;SET NAMES utf8&#x27;</span><br><span class="line">character-set-server=utf8</span><br><span class="line">collation-server=utf8_unicode_ci</span><br><span class="line">skip-character-set-client-handshake</span><br><span class="line">skip-name-resolve</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 2. 重启mysql容器</span></span></span><br><span class="line">docker restart mysql</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 3. 进入mysql容器验证</span></span></span><br><span class="line">docker exec -it mysql /bin/bash </span><br><span class="line">cat /etc/mysql/my.cnf</span><br></pre></td></tr></table></figure>
<h3 id="redis"><a class="markdownIt-Anchor" href="#redis">#</a> Redis</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取镜像</span></span><br><span class="line">docker pull redis</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置文件</span></span><br><span class="line">本地：/mydata/redis/data/redis.conf 提前准备好</span><br><span class="line">主要配置</span><br><span class="line">bind 127.0.0.1 #注释掉这部分，使redis可以外部访问</span><br><span class="line">daemonize no#用守护线程的方式启动</span><br><span class="line">requirepass 你的密码#给redis设置密码</span><br><span class="line">appendonly yes#redis持久化　　默认是no</span><br><span class="line">tcp-keepalive 300 #防止出现远程主机强迫关闭了一个现有的连接的错误 默认是300</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建实例并启动</span></span><br><span class="line">docker run -p 6379:6379 --name redis -v /mydata/redis/data/redis.conf:/etc/redis/redis.conf  -v /mydata/redis/data:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="rabbitmq"><a class="markdownIt-Anchor" href="#rabbitmq">#</a> Rabbitmq</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取镜像management带控制台</span></span><br><span class="line">docker pull rabbitmq:management</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建实例并启动</span></span><br><span class="line">docker run -d --hostname my-rabbit --name rabbit -v /mydata/rabbitmq:/var/lib/rabbitmq -e RABBITMQ_DEFAULT_USER=root -e RABBITMQ_DEFAULT_PASS=Mm_123456 -p 15672:15672 -p 5672:5672 rabbitmq:management</span><br></pre></td></tr></table></figure>
<h3 id="mongo"><a class="markdownIt-Anchor" href="#mongo">#</a> mongo</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取镜像</span></span><br><span class="line">docker pull mongo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建实例并启动</span></span><br><span class="line">docker run -p 27017:27017 -v /mydata/mongo:/data/db --name mongodb -d mongo</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-12-27T08:18:48.640Z" title="2022-12-27 16:18:48">2022-12-27</time>发表</span><span class="level-item"><time dateTime="2022-04-25T04:33:32.841Z" title="2022-4-25 12:33:32">2022-04-25</time>更新</span><span class="level-item">1 分钟读完 (大约122个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/12/27/%E3%80%90%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%91%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E5%AE%9D%E5%A1%94/">云服务器部署宝塔面板</a></p><div class="content"><p>购买好服务器后，进入 Xshell：</p>
<p>1. 安装宝塔面板</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh</span><br></pre></td></tr></table></figure>
<p>获得：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">==================================================================</span><br><span class="line">Congratulations! Installed successfully!</span><br><span class="line">==================================================================</span><br><span class="line">外网面板地址: http://42.193.125.92:8888/ef1f509f</span><br><span class="line">内网面板地址: http://172.21.0.3:8888/ef1f509f</span><br><span class="line">username: upqknxq4</span><br><span class="line">password: f3701931</span><br><span class="line">If you cannot access the panel,</span><br><span class="line">release the following panel port [8888] in the security group</span><br><span class="line">若无法访问面板，请检查防火墙/安全组是否有放行面板[8888]端口</span><br><span class="line">==================================================================</span><br><span class="line">Time consumed: 1 Minute!</span><br></pre></td></tr></table></figure>
<p>访问 <a target="_blank" rel="noopener" href="http://ip:8888/ef1f509f">http://ip:8888/ef1f509f</a> 打开宝塔</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-12-27T08:18:48.638Z" title="2022-12-27 16:18:48">2022-12-27</time>发表</span><span class="level-item"><time dateTime="2022-10-18T05:03:48.735Z" title="2022-10-18 13:03:48">2022-10-18</time>更新</span><span class="level-item">2 分钟读完 (大约284个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/12/27/%E3%80%90MYSQL%E3%80%91%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%BC%82%E5%B8%B8%E8%AE%B0%E5%BD%95/">主从同步遇到 Got fatal error 1236 from master when reading data from binary log</a></p><div class="content"><h1 id=""><a class="markdownIt-Anchor" href="#">#</a> </h1>
<p>首先遇到这个是因为 binlog 位置索引处的问题，不要<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=reset&amp;spm=1001.2101.3001.7020"> reset</a> slave；</p>
<p>reset slave 会将主从同步的文件以及位置恢复到初始状态，一开始没有数据还好，有数据的话，相当于重新开始同步，可能会出现一些问题；</p>
<p>一般做主从同步，都是要求以后的数据实现主从同步，而对于旧的数据完全可以使用数据库同步工具先将数据库同步，完了再进行主从同步；</p>
<p>好了遇到上面的问题，正确做法是：</p>
<p>1. 打开主服务器，进入 mysql</p>
<p>2. 执行 flush logs；// 这时主服务器会重新创建一个 binlog 文件；</p>
<p>3. 在主服务上执行 show master status;  显示如下：</p>
<p><img src="https://brath.cloud/blogImg/1620811-20190720113929965-58969472.png" alt="img"></p>
<p>4. 来到从服务器的 mysql；</p>
<p>5.stop slave;</p>
<p>6.change master to master_log_file=‘mysql-bin.000012’,master_log_pos=154;// 这里的 file 和 pos 都是上面主服务器 master 显示的。</p>
<p>7.start slave;// 这时候就应可以了</p>
<p>8.show slave status \G;</p>
<p><img src="https://brath.cloud/blogImg/1620811-20190720114247073-1479221471.png" alt="img"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-12-27T08:18:48.635Z" title="2022-12-27 16:18:48">2022-12-27</time>发表</span><span class="level-item"><time dateTime="2022-09-29T04:05:33.582Z" title="2022-9-29 12:05:33">2022-09-29</time>更新</span><span class="level-item">35 分钟读完 (大约5262个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/12/27/%E3%80%90Java%E3%80%91ZGC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AZGC%E7%AE%80%E4%BB%8B%E5%92%8CJDK17%E5%AF%B9ZGC%E7%9A%84%E4%BC%98%E5%8C%96/">ZGC学习笔记：ZGC简介和JDK17对ZGC的优化</a></p><div class="content"><p>01 ZGC 简介<br>
 ZGC 是一个可扩展的低延迟垃圾收集器，能够处理 8MB 到 16TB 大小的堆，最大暂停时间为亚毫秒。</p>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/image-20220929120415958.png" alt="image-20220929120415958"></p>
<p>OpenJDK 的官网只写到这里，然后让我们自己去看 Wiki（链接 2）…… 好偷懒……</p>
<pre><code>    Wiki的介绍是更详细一些。

    Z Garbage Collector，也称为 ZGC，是一种可扩展的低延迟垃圾收集器，旨在满足以下目标：
</code></pre>
<p>亚毫秒最大暂停时间</p>
<p>暂停时间不会随着堆、live-set 或 root-set 的大小而增加</p>
<p>处理大小从 8MB 到 16TB 的堆</p>
<p>ZGC 最初是作为 JDK 11 中的一项实验性功能引入的，并在 JDK 15 中被宣布为 Production Ready。</p>
<p>ZGC 的几个特征：</p>
<p>并发</p>
<p>基于区域</p>
<p>基于压缩</p>
<p>NUMA 感知</p>
<p>使用染色指针</p>
<p>使用负载屏障（原文为 load barriers）</p>
<p>ZGC 的核心是一个并发垃圾收集器，这意味着所有繁重的工作都在 Java 线程继续执行的同时完成。这极大地减少了垃圾收集对应用程序响应时间的影响。</p>
<p>ZGC 项目由 HotSpot Group 赞助。</p>
<p>下图是截止目前为止（2020-04-17）的 ZGC 的发布时间表，可以看出 ZGC 总 JDK11 开始实验性推出，JDK15 开始正式发布。</p>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/07193612e6885c5946cf49cd8b796561.png" alt="img"></p>
<pre><code>    ZGC的部分参数：
</code></pre>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/5cd0e8857e5f10201c406b4b8c23a379.png" alt="img"></p>
<p>ZGC 部分操作：</p>
<p>使用下述命令选项启用 ZGC</p>
<p>-XX:+UseZGC<br>
 启用 ZGC</p>
<p>设置堆大小</p>
<pre><code>ZGC 最重要的调优选项是设置最大堆大小（-Xmx&lt;size&gt;）。由于 ZGC 是一个并发收集器，因此必须选择最大堆大小，以便 
</code></pre>
<ol>
<li>
<p>堆可以容纳应用程序的实时集，</p>
</li>
<li>
<p>堆中有足够的空间来允许在 GC 时处理处理分配。</p>
</li>
</ol>
<p>需要多少空间取决于应用程序的分配率和 live-set 大小。一般而言，给 ZGC 的内存越多越好。但与此同时，浪费内存是不可取的，所以这一切都是为了在内存使用和 GC 需要运行的频率之间找到一个平衡点。</p>
<p>3. 设置并发 GC 线程数</p>
<pre><code>    第二个重要的选项是设置并发 GC 线程的数量 (-XX:ConcGCThreads=&lt;number&gt;)。ZGC 具有自动选择此数字的启发式方法。这种启发式通常效果很好，但根据应用程序的特性，这可能需要进行调整。这个选项本质上决定了应该给 GC 多少 CPU-time（ps：这个不知道咋翻译，就叫CPU时间？先不翻译）。给了ZGC太多运行时间，GC 将从应用程序中占用过多的 CPU-time。给它太少，应用程序分配垃圾的速度可能比 GC 收集它的速度快。

    一般来说，如果低延迟（即低应用程序响应时间）是工业环境中的最大痛点，在配置相应操作时候就不需要太吝啬。理想情况下，系统的 CPU 利用率不应超过 70%。
</code></pre>
<p>4. 返回未使用内存给操作系统</p>
<pre><code>    默认情况下，ZGC 取消提交未使用的内存，将其返回给操作系统。这对于注重内存占用的应用程序和环境很有用。可以使用 -XX:-ZUncommit 禁用此功能。此外，内存不会被取消提交，因此堆大小会缩小到最小堆大小 (-Xms) 以下。这意味着如果最小堆大小 (-Xms) 配置为等于最大堆大小 (-Xmx)，则此功能将被隐式禁用。

    可以使用 -XX:ZUncommitDelay=&lt;seconds&gt; 配置取消提交延迟（默认为 300 秒）。此延迟指定内存在有资格取消提交之前应该未使用多长时间。

注意事项：在 Linux 上，取消提交未使用的内存需要具有 FALLOC_FL_PUNCH_HOLE 支持的 fallocate(2)，此特性首先出现在内核版本 3.5（用于 tmpfs）和 4.3（用于 hugetlbfs）中。
</code></pre>
<p>5. 启用 Linux 的大页（large page）操作</p>
<pre><code>    将 ZGC 配置为使用大页面通常会产生更好的性能（在吞吐量、延迟和启动时间方面）并且没有真正的缺点，只是设置起来稍微复杂一些。设置过程通常需要 root 权限，这就是默认情况下不启用它的原因。

    在 Linux/x86 上，大页面（英文原文为large page和huge page）的大小为 2MB。

    假设您需要一个 16G Java 堆。这意味着您需要 16G / 2M = 8192 个大页面。

    首先为大页面池分配至少 16G（8192 页）的内存。“至少”部分很重要，因为在 JVM 中启用大页面意味着不仅 GC 会尝试将这些用于 Java 堆，而且 JVM 的其他部分也会尝试将它们用于各种 内部数据结构（代码堆、标记位图等）。因此，在本例中，我们将保留 9216 个页面 (18G) 以允许 2G 的非 Java 堆分配来使用大页面。
</code></pre>
<p>6. 启用 Linux 的透明大页（transparent large page）操作</p>
<pre><code>    使用显式大页面（explicit large pages，就是5小节的大页面）的替代方法是使用透明大页面（ transparent huge pages）。通常不建议对延迟敏感的应用程序使用透明大页面（ latency sensitive，因为它往往会导致不必要的延迟峰值。但是，可能值得尝试看看系统的工作负载是否/如何受到它的影响。

    注意事项：在 Linux 上，使用启用透明大页的 ZGC 需要kernel &gt;= 4.7。
</code></pre>
<p>7. 启用 NUMA 支持</p>
<pre><code>    ZGC 支持 NUMA，这意味着它会尽量将 Java 堆分配指向 NUMA 本地内存。默认情况下启用此功能。但是，如果 JVM 检测到它只能使用单个 NUMA 节点上的内存，它将自动被禁用。通常，无需担心此设置，但如果您想显式覆盖 JVM 的决定，可以使用 -XX:+UseNUMA 或 -XX:-UseNUMA 选项来实现。

    在 NUMA 机器（例如多插槽 x86 机器）上运行时，启用 NUMA 支持通常会显著提升性能。

    注:

   关于NUMA,即Non Uniform Memory Access，非统一内存管理技术。以下直接截图于百度百科：
</code></pre>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/9fa912e0f93d4dd49a4eecd618d86951.png" alt="img"></p>
<p>8. 启用 GC 日志</p>
<p>打个日志而已，就截图了。</p>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/0f12489b9377904e0ada4b5977cb3e19.png" alt="img"></p>
<p>具体操作还是参考链接 2。</p>
<p>02 ZGC 在 JDK17 中的最新优化<br>
翻译自链接 4。</p>
<pre><code>   JDK 17 于2021年 9 月 14 日发布。这是一个长期支持 (LTS) 版本，这意味着它将得到多年的支持和更新。这也是第一个包含 ZGC 生产就绪版本（production ready version）的 LTS 版本。 稍微回忆一下，JDK 11（以前的 LTS 版本）中包含了 ZGC 的实验版本，而 ZGC 的第一个生产就绪版本出现在 JDK 15（非 LTS 版本）中。

    因此，可以说JDK17是第一个开始推出成熟的ZGC的长期支持的ZGC版本。

    （本来还想把JDK15，JDK16啥的ZGC的翻译一下，不过既然JDK17中ZGC这么重要，就只搬运JDK17的优化好了。）
</code></pre>
<p>1. 动态 GC 线程数</p>
<pre><code>    长期以来，JVM 都有一个名为

    -XX:+UseDynamicNumberOfGCThreads 
</code></pre>
<p>的选项。它默认启用，并告诉 GC 智能地了解它用于各种操作的 GC 线程数。使用的线程数将不断重新评估，因此会随着时间而变化。这个选项很有用有几个原因。例如，很难确定给定工作负载的最佳 GC 线程数是多少。通常发生的情况是，运维人员尝试各种设置 -XX:ParallelGCThreads 和 / 或 -XX:ConcGCThreads （取决于使用的 GC），看看哪个似乎给出了最好的结果。更复杂的是，最佳 GC 线程数可能会随着应用程序经历不同阶段而随时间变化，因此设置固定数量的 GC 线程本质上可能不是最佳的。</p>
<pre><code>    在 JDK 17 之前，ZGC 忽略 -XX:+UseDynamicNumberOfGCThreads 并始终使用固定数量的线程。在 JVM 启动期间，ZGC 使用启发式方法来决定该固定数字 (-XX:ConcGCThreads) 应该是什么。一旦设定了这个数字，它就再也不会改变了。从 JDK 17 开始，ZGC 现在支持 -XX:+UseDynamicNumberOfGCThreads 并尝试使用尽可能少、但是足够多的线程来保持以创建的速度收集垃圾。这有助于避免使用比需要更多的 CPU 时间，从而使 Java 线程可以使用更多的 CPU 时间。

    另请注意，启用此功能后，-XX:ConcGCThreads 的含义从“使用这么多线程”变为“最多使用这么多线程”。除非有一个非常规的工作负载，否则你通常不需要摆弄 -XX:ConcGCThreads。ZGC 的启发式算法会根据运行的系统的大小为机器选择合适的最大线程数。

    （注：就是说JDK17开始，ZGC的运行时线程数是动态的，-XX:ConcGCThreads 设置的是最大可用线程，但是如果更少的线程就能满足需求，ZGC就会使用更少的线程；如果运行中需要增加线程数，ZGC也会动态增加线程数）
</code></pre>
<p>为了说明此功能的实际作用，官方贴出了一下运行 SPECjbb2015 时的一些图表。</p>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/8d76e888d04e4ade98e9570cc2e6b6c2.png" alt="img"></p>
<pre><code>    第一张图显示了整个运行过程中使用的 GC 线程数。SPECjbb2015 有一个初始加速阶段，随后是一个较长的阶段，其中负载（注入速率）逐渐增加。我们可以看到 ZGC 使用的线程数反映了它需要做的工作量来跟上。只有在少数情况下，它需要所有（在本例中为 5 个）线程。

    JDK16和JDK17的打分比较图如下。
</code></pre>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/0ee86707c2957f6abf19e262612ec1db.png" alt="img"></p>
<pre><code>    如果出于某种原因希望始终使用固定数量的 GC 线程（如在 JDK 16 和更早版本中），则可以使用 -XX:-UseDynamicNumberOfGCThreads 禁用此功能（注：应该没人会用吧？）。
</code></pre>
<p>2. 快速 JVM 终止</p>
<pre><code>    在之前使用版本的Java程序中，如果使用的垃圾回收器是 ZGC ，终止正在运行的 Java 进程（例如，通过按 Ctrl+C 或通过让应用程序调用 System.exit()）， JVM 有时可能需要一段时间（在最坏的情况下为数秒）才能真正终止。这在一些需要快速宕机的场景下很烦人，如果某个场景需要快速终止程序，JVM的慢停止会导致一定问题。。

    那么，为什么之前在使用 ZGC 时，JVM 有时会需要一些时间来终止呢？原因是 JVM 的关闭顺序需要与 GC 协调，让 GC 停止正在做的事情，进入“安全”状态。ZGC 仅在空闲时处于“安全”状态，即当前不收集垃圾。如果终止信号到达时正在进行一个非常长的 GC 周期，那么 JVM 关闭序列只需等待该 GC 周期完成，然后 ZGC 变为空闲并再次进入“安全”状态。

    这已在 JDK 17 中得到解决。ZGC 现在能够中止正在进行的 GC 循环，以按需快速达到“安全”状态。终止运行 ZGC 的 JVM 现在或多或少是即时的。
</code></pre>
<p>3. 减少标记堆栈内存使用</p>
<pre><code>    ZGC做条纹标记。这是指将堆划分为条带，并分配每个 GC 线程来标记其中一个条带（strip）中的对象。这有助于最小化 GC 线程之间的共享状态，并使标记过程对缓存更加友好，因为两个 GC 线程不会在堆的同一部分标记对象。这种方法还可以在 GC 线程之间实现自然的工作平衡，因为一个条带（strip）中的工作量往往大致相同。

    下图是ZGC的基于多线程垃圾回收器对基于条带的Java堆内存的回收机制示意图。
</code></pre>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/3792f57ec3bd3c6ddb1b3f61b7f70b5c.png" alt="img"></p>
<pre><code>    在 JDK 17 之前，ZGC 的标记严格遵守条带化。如果一个 GC 线程在跟踪对象图时遇到一个对象引用，该对象引用指向不属于其分配的条带的堆的一部分，则该对象引用被放置在与该其他对象关联的线程本地标记堆栈上条纹。一旦该堆栈已满（254 个条目），它就会被移交给分配给该条带处理标记的 GC 线程。将对象引用加载到尚未标记的对象的 Java 线程会做同样的事情，只是它总是将对象引用放在关联的线程本地标记堆栈上，并且不会自己做任何实际的标记工作。

    这种方法适用于大多数工作负载，但也存在病态问题。如果您有一个具有一个或多个 N:1 关系的对象图，其中 N 是一个非常大的数字，那么您可能会为标记堆栈使用大量内存（如许多 GB）。我们一直都知道这可能是一个问题，您可以编写一个小型综合测试来引发它，但我们从未真正遇到过暴露它的真实工作负载。也就是说，直到来自腾讯的 OpenJDK 贡献者报告他们在野外遇到了这个问题（注：我去，鹅厂！）。

    JDK 17 中对此的修复涉及通过以下方式放松严格条带化：
</code></pre>
<p>对于 GC 线程，无论对象引用指向哪个条带，首先尝试标记对象（即可能跳出 GC 线程分配的条带），如果尚未标记，则将对象引用推送到关联标记 堆。</p>
<p>对于 Java 线程，首先检查对象是否已标记，如果尚未标记，则将对象引用推送到关联的标记堆栈。</p>
<p>（注：这一块我其实看的不是很懂。要是有人有兴趣讨论的话欢迎交流）。</p>
<pre><code>这些调整有助于阻止在病态 N:1 情况下过度使用标记堆栈内存，其中 GC 线程一遍又一遍地遇到相同的对象引用，将大量重复的对象引用推入标记堆栈。重复是没有用的，因为一个对象只需要标记一次。通过在推送之前进行标记，并且只推送以前未标记的对象，复制品的生产就会停止。

我们最初有点不愿意这样做，因为 GC 线程现在正在执行原子比较和交换操作，以标记内存中属于分配给其他 GC 线程工作的条带的对象。这打破了严格的条带化，使其对缓存不太友好。Java 线程现在也在进行原子加载以查看对象是否被标记，这是他们以前没有做过的事情。同时，GC 线程完成的其他工作（扫描/跟踪对象字段和跟踪每个堆区域的活动对象/字节数）仍然遵守严格的条带化。最后，基准测试表明我们最初的担忧是没有根据的。GC 标记时间不受影响，对 Java 线程的影响也不明显。另一方面，我们现在有一个更健壮的标记方案，不会出现过多的内存使用。

    （注：所以其实出现这个问题，是不是因为只是因为某厂的代码写的太烂了……）
</code></pre>
<p>支持 ARM 上的 macOS</p>
<pre><code>    前段时间（注：苹果2020年的秋季发布会的消息），Apple 宣布了一项将其 Mac 计算机产品线从 x86 过渡到 ARM 的长期计划。不久之后，JEP 391: macOS/AArch64 Port 提出了 JDK 到这个新平台的移植。JVM 代码库是相当模块化的，特定于操作系统和 CPU 的代码与共享平台无关代码隔离。JDK 已经支持 macOS/x86 和 Linux/Aarch64，因此支持 macOS/Aarch64 所需的主要部分已经存在。当然，任何计划发布和支持 JDK 的 macOS/Aarch64 构建的人仍然需要做一些工作，比如投资新硬件，将这个新平台集成到 CI 管道中等。

    ZGC的故事几乎相同。macOS/x86 和 Linux/Aarch64 都已经得到支持，因此主要是启用构建和测试这种新的 OS/CPU 组合的问题。从 JDK 17 开始，ZGC 在以下平台上运行：
</code></pre>
<p>Linux/x64</p>
<p>Linux/AArch64</p>
<p>macOS/x64</p>
<p>macOS/AArch64</p>
<p>Window/x64</p>
<p>Windows/AArch64</p>
<p>大多数 ZGC 代码库继续独立于平台。当前的代码分布如下所示：</p>
<p>​        <img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/d43c84500703a456f8a4ad7e2a2c686b.png" alt="img"></p>
<p>用于循环和暂停的 GarbageCollectorMXBeans</p>
<pre><code>    GarbageCollectorMXBean 提供有关 GC 的信息。通过这个 bean，应用程序可以提取摘要信息（到目前为止完成的 GC 次数、累计花费的 GC 时间等）并监听 GarbageCollectionNotificationInfo 通知以获取有关单个 GC 的更细粒度的信息（GC 原因、开始时间、结束时间， ETC）。

    在 JDK 17 之前，ZGC 发布了一个名为 ZGC 的单个 bean。这个 bean 提供了有关 ZGC 周期的信息。一个循环包括从开始到结束的所有 GC 阶段。大多数阶段是并发的，但有些是 Stop-The-World 暂停。虽然有关周期的信息很有用，但您可能还想知道在执行 GC 上花费了多少时间在 Stop-The-World 暂停上。此信息不适用于单个 ZGC bean。为了解决这个问题，ZGC 现在发布了两个 bean，一个称为 ZGC Cycles，一个称为 ZGC Pauses。顾名思义，每个 bean 提供的信息分别映射到周期和暂停。
</code></pre>
<p>总结：</p>
<pre><code>    作为第一个支持生产版本ZGC的LTS版本的JDK，JDK17中对ZGC做了下述优化：
</code></pre>
<p>支持 JVM 选项 -XX:+UseDynamicNumberOfGCThreads。此功能默认启用，并告诉 ZGC 对其使用的 GC 线程数保持智能，这通常会导致 Java 应用程序级别的更高吞吐量和更低延迟。</p>
<p>使用了 ZGC 的 JVM 在停止运行时， 基本上是实时的，而之前版本花费的时间更多。</p>
<p>标记算法现在通常使用更少的内存，并且不再容易出现过多的内存使用。</p>
<p>ZGC 现在可以在 macOS/Aarch64 上运行。</p>
<p>ZGC 现在发布了两个 GarbageCollectorMXBean，以提供有关 GC 周期和 GC 暂停的信息。</p>
<p>03 一些很搞笑的事情</p>
<pre><code>    据说有哥们在面试时候被面试官问到，ZGC的Z代表的是啥？

    面试者老哥内心OS：我去葛格不讲武德啊，之前面经没有讲到这个啊。但是呆胶布，我现场编一个。

    于是他说，“ZGC的Z是英文字母的最后一个字母，这说明Oracle公司想把ZGC作为Java的最终解决方案，是一个革命性的Java垃圾回收机制解决方案，blabla。”

    面试官微微一笑贴出官网截屏：
</code></pre>
<p>​</p>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/b5813b2129f9db814556823199eb2355.png" alt="img"></p>
<p>翻译：ZGC 的 Z 毛线都不表示，莫得含义。</p>
<pre><code>    面试者：不听不听王八念经。

    笑死。</code></pre>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-12-27T08:18:48.633Z" title="2022-12-27 16:18:48">2022-12-27</time>发表</span><span class="level-item"><time dateTime="2022-12-27T05:30:49.077Z" title="2022-12-27 13:30:49">2022-12-27</time>更新</span><span class="level-item">12 分钟读完 (大约1798个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/12/27/%E3%80%90Java%E3%80%91Volatile%E5%85%B3%E9%94%AE%E5%AD%97/">Volatile关键字</a></p><div class="content"><h1 id="volatile关键字"><a class="markdownIt-Anchor" href="#volatile关键字">#</a> Volatile 关键字</h1>
<p>Volatile 关键字的作用主要有如下两个：</p>
<p>线程的可见性：当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。</p>
<p>顺序一致性：禁止指令重排序。</p>
<h1 id="一-线程可见性"><a class="markdownIt-Anchor" href="#一-线程可见性">#</a> 一、线程可见性</h1>
<p>我们先通过一个例子来看看线程的可见性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileTest</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFlag</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = <span class="literal">false</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;修改flag值为：&quot;</span> + <span class="built_in">this</span>.flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">VolatileTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatileTest</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (test.flag) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;Thread1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                test.updateFlag();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Thread2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果如下，我们可以看到虽然线程 Thread2 已经把 flag 修改为 false 了，但是线程 Thread1 没有读取到 flag 修改后的值，线程一直在运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修改flag值为：false</span><br></pre></td></tr></table></figure>
<p>我们把 flag 变量加上 volatile：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatile  boolean flag = true;</span><br></pre></td></tr></table></figure>
<p>重新运行程序，打印结果如下。Thread1 结束，说明 Thread1 读取到了 flage 修改后的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">修改flag值为：false</span><br><span class="line">Thread1结束</span><br></pre></td></tr></table></figure>
<p>说到可见性，我们需要先了解一下 Java 内存模型，Java 内存模型如下所示：</p>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/d90e39f9caa340b0bb589ef1dbb2f667.png" alt="在这里插入图片描述"></p>
<p>线程之间的共享变量存储在主内存中（Main Memory）中，每个线程都一个都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读 / 写共享变量的副本。</p>
<p>所以当一个线程把主内存中的共享变量读取到自己的本地内存中，然后做了更新。在还没有把共享变量刷新的主内存的时候，另外一个线程是看不到的。</p>
<p>如何把修改后的值刷新到主内存中的？<br>
现代的处理器使用写缓冲区临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，较少对内存总线的占用。但是什么时候写入到内存是不知道的。<img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/f96ceb17a5644f7db67d3a64f8b888fa.png" alt="在这里插入图片描述"></p>
<p>所以就引入了 volatile，volatile 是如何保证可见性的呢？<br>
在 X86 处理器下通过工具获取 JIT 编译器生成的汇编指令来查看对 volatile 进行写操作时，会多出 lock addl。Lock 前缀的指令在多核处理器下会引发两件事情：</p>
<p>1. 将当前处理器缓存行的数据写回到系统内存。<br>
2. 这个写回内存的操作会使其他 cpu 里缓存了该内存地址的数据无效。<br>
如果声明了 volatile 的变量进行写操作，JVM 就会向处理器发送一条 Lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的还是旧的，在执行操作就会有问题。所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p>
<h1 id="二-顺序一致性"><a class="markdownIt-Anchor" href="#二-顺序一致性">#</a> 二、顺序一致性</h1>
<p>在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分为如下三种：</p>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/39a6b41a1a1a4d0191f418b0519aa532.png" alt="在这里插入图片描述"></p>
<p>1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序可能会导致多线程程序出现内存可见性问题。<br>
当变量声明为 volatile 时，Java 编译器在生成指令序列时，会插入内存屏障指令。通过内存屏障指令来禁止重排序。<br>
JMM 内存屏障插入策略如下：<br>
在每个 volatile 写操作的前面插入一个 StoreStore 屏障，后面插入一个 StoreLoad 屏障。<br>
在每个 volatile 读操作后面插入一个 LoadLoad，LoadStore 屏障。</p>
<p>Volatile 写插入内存屏障后生成指令序列示意图：</p>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/f44d26762f704a28905e2f65b2a75d53.png" alt="在这里插入图片描述"></p>
<p>Volatile 读插入内存屏障后生成指令序列示意图：</p>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/97e184ee75ed4e18b3066e1c8ab585e1.png" alt="在这里插入图片描述"></p>
<p>通过上面这些我们可以得出如下结论：编译器不会对 volatile 读与 volatile 读后面的任意内存操作重排序；编译器不会对 volatile 写与 volatile 写前面的任意内存操作重排序。</p>
<p>防止重排序使用案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafeDoubleCheckedLocking</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Instance instane;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> Instance <span class="title function_">getInstane</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instane==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SafeDoubleCheckedLocking.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instane==<span class="literal">null</span>)&#123;</span><br><span class="line">                    instane=<span class="keyword">new</span> <span class="title class_">Instance</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instane;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个对象主要分为如下三步：</p>
<p>分配对象的内存空间。<br>
初始化对象。<br>
设置 instance 指向内存空间。<br>
如果 instane 不加 volatile，上面的 2，3 可能会发生重排序。假设 A，B 两个线程同时获取，A 线程获取到了锁，发生了指令重排序，先设置了 instance 指向内存空间。这个时候 B 线程也来获取，instance 不为空，这样 B 拿到了没有初始化完成的单例对象（如下图）</p>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/70457cf0d7904aa5a8b3edb1bffd4561.png" alt="在这里插入图片描述"></p>
<p>二、Volatile 与 Synchronized 比较<br>
 1.Volatile 是轻量级的 synchronized，因为它不会引起上下文的切换和调度，所以 Volatile 性能更好。<br>
2.Volatile 只能修饰变量，synchronized 可以修饰方法，静态方法，代码块。<br>
3.Volatile 对任意单个变量的读 / 写具有原子性，但是类似于 i++ 这种复合操作不具有原子性。而锁的互斥执行的特性可以确保对整个临界区代码执行具有原子性。<br>
4. 多线程访问 volatile 不会发生阻塞，而 synchronized 会发生阻塞。<br>
5.volatile 是变量在多线程之间的可见性，synchronize 是多线程之间访问资源的同步性。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-12-27T08:18:48.631Z" title="2022-12-27 16:18:48">2022-12-27</time>发表</span><span class="level-item"><time dateTime="2022-04-28T02:29:34.446Z" title="2022-4-28 10:29:34">2022-04-28</time>更新</span><span class="level-item">5 分钟读完 (大约698个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/12/27/%E3%80%90Typora%E3%80%91typora%E9%85%8D%E7%BD%AEAliCloudOss%E5%9B%BE%E5%BA%93%E4%BD%BF%E7%94%A8picgo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/">Typora使用gitee作为图库用picgo上传图片的教程~</a></p><div class="content"><h2 id="前言"><a class="markdownIt-Anchor" href="#前言">#</a> 前言</h2>
<ul>
<li>这一年，写的博客也多，总是需要<strong>插入图片</strong>的，图片存在本地的话上传到博客网站去就没法显示了，就算一个图一个图的复制粘贴上去，想移植到其他的博客网站，图就会失效，为了解决这个问题，这篇文章就诞生了！</li>
<li>首先，还是一如既往的推荐别人是怎么搞的！</li>
<li>参考文章如下：</li>
<li><a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/make_11111111/article/details/104839492">《Typora 上传图片到 CSDN——PicGo + Gitee (码云) 实现 markdown 免费图床 —— 开局第一篇》</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//segmentfault.com/a/1190000022535154">《markdown 笔记神器 Typora 如何上传图片？（图床功能）</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//www.codenong.com/cs106528795/">《一文教你用 Typora + Gitee (码云) + PicGo 实现 云 markdown 笔记》</a></li>
</ul>
<h2 id="环境配置预览"><a class="markdownIt-Anchor" href="#环境配置预览">#</a> 环境配置预览</h2>
<ul>
<li>安装 nodejs：<a href="https://link.zhihu.com/?target=https%3A//nodejs.org/en/">https://nodejs.org/en/</a></li>
<li>Gitee 账户：<a href="https://link.zhihu.com/?target=https%3A//gitee.com/">https://gitee.com/</a></li>
<li>Typora 软件:<a href="https://link.zhihu.com/?target=https%3A//www.typora.io/%23windows">https://www.typora.io/#windows</a></li>
<li>PicGo:<a href="https://link.zhihu.com/?target=https%3A//molunerfinn.com/PicGo/">https://molunerfinn.com/PicGo/</a></li>
<li></li>
</ul>
<h2 id="01安装nodejs"><a class="markdownIt-Anchor" href="#01安装nodejs">#</a> 01. 安装 nodejs</h2>
<p>请百度自行安装，不过多介绍</p>
<p>node 和 npm 环境检测：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;node -v</span><br><span class="line">v14.16.0</span><br><span class="line"></span><br><span class="line">C:\&gt;npm -v</span><br><span class="line">6.14.11</span><br></pre></td></tr></table></figure>
<h2 id="02gitee账户配置"><a class="markdownIt-Anchor" href="#02gitee账户配置">#</a> 02.Gitee 账户配置</h2>
<h2 id="新建仓库"><a class="markdownIt-Anchor" href="#新建仓库">#</a> 新建仓库</h2>
<p><img src="https://brath.cloud/blogImg/v2-2fe1a9ce620e81b91401ea878be94548_720w.jpg" alt="img"></p>
<p><img src="https://brath.cloud/blogImg/v2-02b0a2c63381b110e5bdc4ac994bd274_720w.jpg" alt="img"></p>
<h2 id="私人令牌token配置获取"><a class="markdownIt-Anchor" href="#私人令牌token配置获取">#</a> 私人令牌 token 配置获取</h2>
<ul>
<li>找到 <code>设置</code>  -&gt; <code>安全设置</code>  -&gt; <code>私人令牌</code> ，点击生成新令牌</li>
</ul>
<p><img src="https://brath.cloud/blogImg/v2-5493431b257b8313f420cd1c456d5550_720w.jpg" alt="img"></p>
<ul>
<li>选择下面的选项即可！</li>
</ul>
<p><img src="https://brath.cloud/blogImg/v2-06263bbbc624e2b9d5d3782cad1f68b3_720w.jpg" alt="img"></p>
<ul>
<li>点击提交，账户安全验证即可</li>
</ul>
<p><img src="https://brath.cloud/blogImg/v2-a9ab747329a35bc374101fe870a48084_720w.jpg" alt="img"></p>
<ul>
<li>保存后面生成的私人令牌</li>
</ul>
<p><img src="https://brath.cloud/blogImg/v2-cf484c849d232aaf07e91460899b0a0e_720w.jpg" alt="v2-cf484c849d232aaf07e91460899b0a0e_720w"></p>
<ul>
<li>gitee 配置到此完毕！</li>
</ul>
<h2 id="03picgo配置"><a class="markdownIt-Anchor" href="#03picgo配置">#</a> 03.PicGo 配置</h2>
<h2 id="插件安装"><a class="markdownIt-Anchor" href="#插件安装">#</a> 插件安装</h2>
<p><img src="https://brath.cloud/blogImg/v2-c6b94bdc27f8f0300673d02e4800c360_720w.jpg" alt="img"></p>
<h2 id="插件配置"><a class="markdownIt-Anchor" href="#插件配置">#</a> 插件配置</h2>
<p><img src="https://brath.cloud/blogImg/v2-599672d63434fc5cc4dff76104f21778_720w.jpg" alt="img"></p>
<h2 id="上传尝试"><a class="markdownIt-Anchor" href="#上传尝试">#</a> 上传尝试</h2>
<p><img src="https://brath.cloud/blogImg/v2-9cd264eef40166488ebdda103631689d_720w.jpg" alt="img"></p>
<ul>
<li>这里，您可以随便截图一张，剪贴板图片上传试试效果</li>
<li>图片放大看看，本文的图片是不是就在下面这里！哈哈哈！</li>
</ul>
<p><img src="https://brath.cloud/blogImg/v2-05a45967b7af32a9f3299d93fdeab526_720w.jpg" alt="img"></p>
<h2 id="04typora配置"><a class="markdownIt-Anchor" href="#04typora配置">#</a> 04.Typora 配置</h2>
<ul>
<li>说实话，写这篇文章，就是想用到 markdown 自动上传图片，自动同步图片到各个平台！</li>
<li>废话不多说，建议直接和博主配置一样就行！</li>
</ul>
<p><img src="https://brath.cloud/blogImg/image-20220428093756533.png" alt="image-20220428093756533"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-12-27T08:18:48.629Z" title="2022-12-27 16:18:48">2022-12-27</time>发表</span><span class="level-item"><time dateTime="2022-01-21T01:54:17.311Z" title="2022-1-21 9:54:17">2022-01-21</time>更新</span><span class="level-item">27 分钟读完 (大约4021个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/12/27/%E3%80%90Git%E3%80%91SVN&amp;Git%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/">SVN&amp;Git使用手册</a></p><div class="content"><p>切记 代码是先更新再提交.<br>
（一）SVN 和 GIt 区别<br>
 1．基本<br>
 SVN 是集中式版本控制工具<br>
 git 是分布式版本控制工具</p>
<p>2．SVN 和 Git 优缺点<br>
 svn 优点:<br>
1. 方便管理者查看每个开发者开发进度<br>
 2. 方便对开发者进行权限控制<br>
 svn 缺点:<br>
1. 严重依赖网络环境进行版本控制<br>
 2. 中央服务器宕机，无法进行版本控制<br>
 3. 中央服务器磁盘损坏，丢失历史版本内容<br>
 Git 优点:<br>
1. 很完美的解决了 SVN 存在的缺点</p>
<p>TortoiseGit 小乌龟<br>
给当前项目提交到码云上<br>
 1. 用浏览器登录码云，在码云上创建一个仓库<br>
 2. 打开 TortoiseGit 软件<br>
 3. 新建一个文件夹改好名字 (注意是空文件夹)<br>
 4. 右键文件夹–&gt;Git 克隆…–&gt; 弹出如下图–&gt; 粘贴好 url<br>
5. 点击确定就可以了</p>
<p>6. 然后就给你自己的代码放入刚才的文件夹下，然后就点击推送等等.<br>
2．设置用户名和邮箱</p>
<p>直接设置即可。签名密钥不需要管</p>
<p>Git 使用笔记<br>
（一）概念<br>
 1．什么是版本控制</p>
<p>版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 除了项目源代码，你可以对任何类型的文件进行版本控制。</p>
<p>2．为什么要版本控制<br>
有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。<br>
许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易犯错。 有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。<br>
为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。<br>
3．集中化的版本控制系统<br>
接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？ 于是，集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）应运而生。<br>
集中化的版本控制系统都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。<br>
这么做虽然解决了本地版本控制系统无法让在不同系统上的开发者协同工作的诟病，但也还是存在下面的问题：</p>
<p>单点故障： 中央服务器宕机，则其他人无法使用；如果中心数据库磁盘损坏有没有进行备份，你将丢失所有数据。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。</p>
<p>必须联网才能工作： 受网络状况、带宽影响。</p>
<p>4．分布式版本控制系统<br>
于是分布式版本控制系统（Distributed Version Control System，简称 DVCS）面世了。 Git 就是一个典型的分布式版本控制系统。<br>
这类系统，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。<br>
分布式版本控制系统可以不用联网就可以工作，因为每个人的电脑上都是完整的版本库，当你修改了某个文件后，你只需要将自己的修改推送给别人就可以了。但是，在实际使用分布式版本控制系统的时候，很少会直接进行推送修改，而是使用一台充当 “中央服务器” 的东西。这个服务器的作用仅仅是用来方便 “交换” 大家的修改，没有它大家也一样干活，只是交换修改不方便而已。<br>
分布式版本控制系统的优势不单是不必联网这么简单，后面我们还会看到 Git 极其强大的分支管理等功能。<br>
5．Git 与其他版本管理系统的主要区别<br>
 Git 在保存和对待各种信息的时候与其它版本控制系统有很大差异，尽管操作起来的命令形式非常相近，理解这些差异将有助于防止你使用中的困惑。<br>
下面我们主要说一个关于 Git 其他版本管理系统的主要差别：对待数据的方式。<br>
Git 采用的是直接记录快照的方式，而非差异比较。我后面会详细介绍这两种方式的差别。<br>
大部分版本控制系统（CVS、Subversion、Perforce、Bazaar 等等）都是以文件变更列表的方式存储信息，这类系统将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。<br>
具体原理如下图所示，理解起来其实很简单，每个我们对提交更新一个文件之后，系统记录都会记录这个文件做了哪些更新，以增量符号 Δ(Delta) 表示。</p>
<p>我们怎样才能得到一个文件的最终版本呢？<br>
很简单，高中数学的基本知识，我们只需要将这些原文件和这些增加进行相加就行了。<br>
这种方式有什么问题呢？<br>
比如我们的增量特别特别多的话，如果我们要得到最终的文件是不是会耗费时间和性能。<br>
Git 不按照以上方式对待或保存数据。 反之，Git 更像是把数据看作是对小型文件系统的一组快照。 每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 快照流。</p>
<p>6．使用 git 原因<br>
分布式版本控制工具<br>
为什么使用 git 呢？<br>
互联网项目，业务越来越复杂，项目越来越大，使用 SVN 版本控制不太好使了。<br>
从 git 目标，看 git 的优势 速度快、分布式、有能力管理大型项目</p>
<p>7．工作流程以及流程图</p>
<p>在工作目录中修改文件。<br>
暂存文件，将文件的快照放入暂存区域。<br>
提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。<br>
8．程序员工作流程<br>
项目经理：1 创建项目 2 项目添加本地暂存态 3 项目提交到本地 4 建立远程连接 5 推送代码到远程服务器<br>
程序员 A：1 克隆代码到本地 2 编写代码，将代码添加本地暂存态 3 代码提交本地 4 推送代码到服务器<br>
程序员 B：1 克隆代码到本地 2 编写代码，将代码添加本地暂存态 3 代码提交本地 4 推送代码到服务器 5 更新其他程序员提交的代码<br>
 9．git 三种状态</p>
<p>已提交（committed）：数据已经安全的保存在本地数据库中。</p>
<p>已修改（modified）：已修改表示修改了文件，但还没保存到数据库中。</p>
<p>已暂存（staged）：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</p>
<p>由此引入 Git 项目的三个工作区域的概念：Git 仓库 (.git directoty) 、工作目录 (Working Directory) 以及 暂存区域 (Staging Area) 。</p>
<p>（二）Git 分支<br>
 1．分支概念</p>
<p>几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。在很多版本控制系统中，这是个昂贵的过程，常常需要创建一个源代码目录的完整副本，对大型项目来说会花费很长时间。</p>
<p>有人把 Git 的分支模型称为 “必杀技特性”，而正是因为它，将 Git 从版本控制系统家族里区分出来。Git 有何特别之处呢？Git 的分支可谓是难以置信的轻量级，它的新建操作几乎可以在瞬间完成，并且在不同分支间切换起来也差不多一样快。和许多其他版本控制系统不同，Git 鼓励在工作流程中频繁使用分支与合并，哪怕一天之内进行许多次都没有关系。理解分支的概念并熟练运用后，你才会意识到为什么 Git 是一个如此强大而独特的工具，并从此真正改变你的开发方式。<br>
2．分支需求<br>
现在让我们来看一个简单的分支与合并的例子，实际工作中大体也会用到这样的工作流<br>
程：</p>
<p>开发某个网站。<br>
为实现某个新的需求，创建一个分支。<br>
在这个分支上开展工作。<br>
假设此时，你突然接到一个电话说有个很严重的问题需要紧急修补，那么可以按照下面的方<br>
式处理：<br>
返回到原先已经发布到生产服务器上的分支。<br>
为这次紧急修补建立一个新分支。<br>
测试通过后，将此修补分支合并，再推送到生产服务器上。<br>
切换到之前实现新需求的分支，继续工作。<br>
（三）git 指令<br>
 1．创建 git 目录<br>
 git init</p>
<p>创建 git 目录:<br>
 该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。(参见 Git 内部原理 来了解更多关于到底 .git 文件夹中包含了哪些文件的信息。)<br>
 2．克隆仓库<br>
 git clone [url]<br>
 克隆仓库的命令格式是 git clone [url] 。比如，要克隆 Git 的可链接库 libgit2，可以用下面的命令<br>
 $ git clone <a target="_blank" rel="noopener" href="https://github.com/libgit2/libgit2">https://github.com/libgit2/libgit2</a></p>
<p>这会在当前目录下创建一个名为 “libgit2” 的目录，并在这个目录下初始化一个 .git 文件夹，从远程仓库拉取下所有数据放入 .git 文件夹，然后从中读取最新版本的文件的拷贝。如果你进入到这个新建的 libgit2 文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。如果你想在克隆远程仓库的时<br>
候，自定义本地仓库的名字，你可以使用如下命令<br>
 $ git clone <a target="_blank" rel="noopener" href="https://github.com/libgit2/libgit2">https://github.com/libgit2/libgit2</a> mylibgit<br>
 这将执行与上一个命令相同的操作，不过在本地创建的仓库名字变为 mylibgit<br>
3．查看文件状态<br>
 git status<br>
 要查看哪些文件处于什么状态，可以用 git status 命令。如果在克隆仓库后立即使用此命令，会看到类似这<br>
样的输出.</p>
<p>跟踪新文件</p>
<p>（四）使用<br>
 1．安装 git</p>
<p><a target="_blank" rel="noopener" href="http://note.youdao.com/noteshare?id=448878ab8bdba693717f8967e6aa6a4f">http://note.youdao.com/noteshare?id=448878ab8bdba693717f8967e6aa6a4f</a></p>
<p>2．将项目上传到码云上</p>
<p>如果账户已经配置好，git 客户端也安装好，在将要上传的文件中，右键打开 Git Bash Here, 按如下步骤即可：<br>
1.git init<br>
2.git remote add origin “你的码云项目地址（ssh 或 https）”<br>
 开始提交项目<br>
 3.git pull origin master 如果密码报错看下面<br>
 4.git touch init .txt  // 如果已经存在更改的文件，则操作这一步，否则跳过即可<br>
 5.git add .<br>
6.git commit -m “第一次提交（提交信息）”<br>
7.git push origin master<br>
 如出现错误 hint: Updates were rejected because the tip of your current branch is behind<br>
hint: its remote counterpart. Integrate the remote changes (e.g.<br>
hint: ‘git pull …’) before pushing again.<br>
hint: See the ‘Note about fast-forwards’ in ‘git push --help’ for details.<br>
 可执行此操作继续，git push -u origin master -f  强制命令会覆盖别人分支，慎用</p>
<p>密码报错在这里进行修改</p>
<p>3．用 git 从 github 上下载代码</p>
<p>新建一个文件夹，放你需要下载的东西。右键点击 “Git Bash Here”</p>
<p>此时会弹出 git 的命令窗口</p>
<p>3、输入  git clone + 下载地址，回车即可。如   git clone <a target="_blank" rel="noopener" href="https://github.comxxx.git">https://github.comxxx.git</a><br>
 等待下载</p>
<p>下载好之后，文件夹里就会出现相应的项目啦～</p>
<p>（五）GitGUI 操作<br>
 1．使用 gui 上传代码到码云上<br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33867131/article/details/80831491"> https://blog.csdn.net/qq_33867131/article/details/80831491</a></p>
<p>SVN 的基本使用<br>
（一）基本简介<br>
开源的版本控制系统，可以用来保存代码，同步代码，也可以保存图片文档电影什么的.<br>
 主要作用就是可以随时进行代码同步。但是会存在一些问题，会有一些解决方案<br>
（二）服务端创建仓库<br>
 1．搭建仓库，添加用户</p>
<p><a target="_blank" rel="noopener" href="http://note.youdao.com/noteshare?id=549663e56580a3643bbcc9104c357226">http://note.youdao.com/noteshare?id=549663e56580a3643bbcc9104c357226</a></p>
<p>2．分配权限</p>
<p>创建好用户后，用户还是不能访问我们的仓库，接下来我们要给用户分个组（如果想让用户不进组也能访问仓库，可以直接给单个用户权限</p>
<p>3．给代码放到 svn 上面</p>
<p>然后复制仓库地址</p>
<p>在你要上传的项目右键</p>
<p>然后点击确定</p>
<p>（三）错误解决<br>
 1．代码错乱问题<br>
去查看日志，下载正确的时间段的代码，然后再创建新的仓库，放那个代码，原来的仓库就删除掉就可以了.</p>
<p>2．No appropriate protocol<br>
 公司的 SVN 协议从 svn 协议变更到 https 协议，结果 IDEA 的 SVN 报 No appropriate protocol，查询资料，最终解决方案是：<br>
Go to Preferences &gt; Version Control &gt; SubVersion &gt; Enable Interactive Mode<br>
3．versionControl 里面找不到 subversion 选项<br>
去安装 svnToolBox 插件 即可解决</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/5/">上一页</a></div><div class="pagination-next"><a href="/page/7/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/5/">5</a></li><li><a class="pagination-link is-current" href="/page/6/">6</a></li><li><a class="pagination-link" href="/page/7/">7</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/11/">11</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-12T06:27:52.331Z">2023-04-12</time></p><p class="title"><a href="/2023/04/12/%E3%80%90Java%E3%80%91%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%B0%86%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BAList%E9%9B%86%E5%90%88/">【Java】如何优雅的将数组转换为List集合</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-11T09:18:33.616Z">2023-04-11</time></p><p class="title"><a href="/2023/04/11/%E3%80%90Redis%E3%80%91SpringBoot%E6%95%B4%E5%90%88Redis%EF%BC%8C%E7%BC%93%E5%AD%98%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4%20%20redisTemplate.keys(pattern)%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%E6%89%BE%E4%B8%8D%E5%88%B0keys%EF%BC%8C%E2%80%9C%20%20%E2%80%9C%20%E9%80%9A%E9%85%8D%E7%AC%A6%E6%97%A0%E6%95%88/">【Redis】SpringBoot整合Redis，缓存批量删除  redisTemplate.keys(pattern)模糊查询找不到keys，“  “ 通配符无效</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-11T07:25:27.293Z">2023-04-11</time></p><p class="title"><a href="/2023/04/11/%E3%80%90MySQL%E3%80%91MySql%E7%9B%B8%E5%85%B3%E4%BC%98%E5%8C%96%E5%88%86%E4%BA%AB/">【MySQL】MySql相关优化分享</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-11T01:43:21.561Z">2023-04-11</time></p><p class="title"><a href="/2023/04/11/%E3%80%90Npm%E3%80%91npm%20install%E6%97%B6%E5%8D%A1%E4%BD%8F%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/">【Npm】npm install时卡住怎么办？</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-11T01:41:41.029Z">2023-04-11</time></p><p class="title"><a href="/2023/04/11/%E3%80%90Vue%E3%80%91Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">Vue的生命周期</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">46</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/"><span class="level-start"><span class="level-item">2022</span></span><span class="level-end"><span class="level-item tag">56</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://brath.cloud/7f71f67568cbf455bf7b2c32345f71e3.jpg" alt="Brath"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Brath</p><p class="is-size-6 is-block">为了更好的你，也为了更好的世界。</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·江苏·无锡</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">102</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Guoqing815" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Guoqing815"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Gitee" href="https://gitee.com/Guoqing-Li"><i class="fab fa-gitee"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://schokolade.cn/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">泠灵(特别呜谢)</span></span><span class="level-right"><span class="level-item tag">schokolade.cn</span></span></a></li><li><a class="level is-mobile" href="https://gitee.com/Guoqing-Li" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Gitee(码云)</span></span><span class="level-right"><span class="level-item tag">gitee.com</span></span></a></li><li><a class="level is-mobile" href="https://blog.csdn.net/Brath?type=blog" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">CSDN</span></span><span class="level-right"><span class="level-item tag">blog.csdn.net</span></span></a></li><li><a class="level is-mobile" href="https://juejin.cn/user/settings/profile" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">掘金</span></span><span class="level-right"><span class="level-item tag">juejin.cn</span></span></a></li><li><a class="level is-mobile" href="https://oss.console.aliyun.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">AliCloud(阿里云)</span></span><span class="level-right"><span class="level-item tag">oss.console.aliyun.com</span></span></a></li><li><a class="level is-mobile" href="https://cloud.tencent.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">TencentCloud(腾讯云)</span></span><span class="level-right"><span class="level-item tag">cloud.tencent.com</span></span></a></li><li><a class="level is-mobile" href="https://www.zhipin.com/web/user/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">BOSS</span></span><span class="level-right"><span class="level-item tag">www.zhipin.com</span></span></a></li><li><a class="level is-mobile" href="https://www.bilibili.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bilibili(B站)</span></span><span class="level-right"><span class="level-item tag">www.bilibili.com</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://brath.cloud/me.png" alt="Brath-Blog" height="28"></a><p class="is-size-7"><span>&copy; 2023 Brath</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2029</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>