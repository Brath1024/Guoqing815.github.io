<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Go语言超全详解（入门级） - Brath-Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Brath-Blog"><meta name="msapplication-TileImage" content="https://brath.cloud/me.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Brath-Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="# Go 语言超全详解（入门级） # 文章目录  1. Go 语言的出现 2. go 版本的 hello world 3. 数据类型   3.0 定义变量   3.0.1 如果变量没有初始化 3.0.2 如果变量没有指定类型 3.0.3 :&amp;#x3D; 符号 3.0.4 多变量声明 3.0.5 匿名变量 3.0.6 变量作用域   3.1 基本类型 3.2 指针   3.2.1 指针声明和初始化 3.2."><meta property="og:type" content="blog"><meta property="og:title" content="Go语言超全详解（入门级）"><meta property="og:url" content="http://example.com/2021/05/17/%E3%80%90Go%E3%80%91Go%E8%AF%AD%E8%A8%80%E8%B6%85%E5%85%A8%E8%AF%A6%E8%A7%A3(%E5%85%A5%E9%97%A8%E7%BA%A7)/"><meta property="og:site_name" content="Brath-Blog"><meta property="og:description" content="# Go 语言超全详解（入门级） # 文章目录  1. Go 语言的出现 2. go 版本的 hello world 3. 数据类型   3.0 定义变量   3.0.1 如果变量没有初始化 3.0.2 如果变量没有指定类型 3.0.3 :&amp;#x3D; 符号 3.0.4 多变量声明 3.0.5 匿名变量 3.0.6 变量作用域   3.1 基本类型 3.2 指针   3.2.1 指针声明和初始化 3.2."><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png"><meta property="og:image" content="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/ddf2855d06234305a122bea469d0adaa.png"><meta property="og:image" content="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/22fb68eff45145c89f2f64d51b3e556f.png"><meta property="og:image" content="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/13c1b9f9899d48b08c32b76ef4037a17.png"><meta property="og:image" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png"><meta property="article:published_time" content="2021-05-17T02:43:26.000Z"><meta property="article:modified_time" content="2022-02-11T06:56:47.000Z"><meta property="article:author" content="Brath"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2021/05/17/%E3%80%90Go%E3%80%91Go%E8%AF%AD%E8%A8%80%E8%B6%85%E5%85%A8%E8%AF%A6%E8%A7%A3(%E5%85%A5%E9%97%A8%E7%BA%A7)/"},"headline":"Go语言超全详解（入门级）","image":["https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png","https://brath.oss-cn-shanghai.aliyuncs.com/pigo/ddf2855d06234305a122bea469d0adaa.png","https://brath.oss-cn-shanghai.aliyuncs.com/pigo/22fb68eff45145c89f2f64d51b3e556f.png","https://brath.oss-cn-shanghai.aliyuncs.com/pigo/13c1b9f9899d48b08c32b76ef4037a17.png","https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png"],"datePublished":"2021-05-17T02:43:26.000Z","dateModified":"2022-02-11T06:56:47.000Z","author":{"@type":"Person","name":"Brath"},"publisher":{"@type":"Organization","name":"Brath-Blog","logo":{"@type":"ImageObject","url":"https://brath.cloud/me.png"}},"description":"# Go 语言超全详解（入门级） # 文章目录  1. Go 语言的出现 2. go 版本的 hello world 3. 数据类型   3.0 定义变量   3.0.1 如果变量没有初始化 3.0.2 如果变量没有指定类型 3.0.3 :&#x3D; 符号 3.0.4 多变量声明 3.0.5 匿名变量 3.0.6 变量作用域   3.1 基本类型 3.2 指针   3.2.1 指针声明和初始化 3.2."}</script><link rel="canonical" href="http://example.com/2021/05/17/%E3%80%90Go%E3%80%91Go%E8%AF%AD%E8%A8%80%E8%B6%85%E5%85%A8%E8%AF%A6%E8%A7%A3(%E5%85%A5%E9%97%A8%E7%BA%A7)/"><link rel="icon" href="https://brath.cloud/me.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://brath.cloud/me.png" alt="Brath-Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">文章列表</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">更多</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Guoqing815"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-17T02:43:26.000Z" title="2021/5/17 10:43:26">2021-05-17</time>发表</span><span class="level-item"><time dateTime="2022-02-11T06:56:47.000Z" title="2022/2/11 14:56:47">2022-02-11</time>更新</span><span class="level-item">2 小时读完 (大约14373个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">Go语言超全详解（入门级）</h1><div class="content"><p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png" alt="InterviewCoder"></p>
<h1 id="go语言超全详解入门级"><a class="markdownIt-Anchor" href="#go语言超全详解入门级">#</a> Go 语言超全详解（入门级）</h1>
<h3 id="文章目录"><a class="markdownIt-Anchor" href="#文章目录">#</a> 文章目录</h3>
<ul>
<li><a href="#1_Go_6">1. Go 语言的出现</a></li>
<li><a href="#2_gohello_world_12">2. go 版本的 hello world</a></li>
<li><a href="#3__36">3. 数据类型</a></li>
<li>
<ul>
<li><a href="#30__48">3.0 定义变量</a></li>
<li>
<ul>
<li><a href="#301__61">3.0.1 如果变量没有初始化</a></li>
<li><a href="#302__70">3.0.2 如果变量没有指定类型</a></li>
<li><a href="#303___82">3.0.3 := 符号</a></li>
<li><a href="#304__94">3.0.4 多变量声明</a></li>
<li><a href="#305__121">3.0.5 匿名变量</a></li>
<li><a href="#306__141">3.0.6 变量作用域</a></li>
</ul>
</li>
<li><a href="#31__150">3.1 基本类型</a></li>
<li><a href="#32__164">3.2 指针</a></li>
<li>
<ul>
<li><a href="#321__169">3.2.1 指针声明和初始化</a></li>
<li><a href="#322__188">3.2.2 空指针</a></li>
</ul>
</li>
<li><a href="#33__193">3.3 数组</a></li>
<li>
<ul>
<li><a href="#331__196">3.3.1 声明数组</a></li>
<li><a href="#332__208">3.3.2 初始化数组</a></li>
<li><a href="#333_go_219">3.3.3 go 中的数组名意义</a></li>
<li><a href="#334__225">3.3.4 数组指针</a></li>
</ul>
</li>
<li><a href="#34__243">3.4 结构体</a></li>
<li>
<ul>
<li><a href="#341__246">3.4.1 声明结构体</a></li>
<li><a href="#342__265">3.4.2 访问结构体成员</a></li>
<li><a href="#343__285">3.4.3 结构体指针</a></li>
</ul>
</li>
<li><a href="#35__297">3.5 字符串</a></li>
<li>
<ul>
<li><a href="#351__301">3.5.1 字符串定义和初始化</a></li>
<li><a href="#352_UTF8_317">3.5.2 字符串 UTF8 编码</a></li>
<li><a href="#353__343">3.5.3 字符串的强制类型转换</a></li>
</ul>
</li>
<li><a href="#36_slice_354">3.6 slice</a></li>
<li>
<ul>
<li><a href="#361_slice_359">3.6.1 slice 定义</a></li>
<li><a href="#362__381">3.6.2 添加元素</a></li>
<li><a href="#363__428">3.6.3 删除元素</a></li>
</ul>
</li>
<li><a href="#37__491">3.7 函数</a></li>
<li>
<ul>
<li><a href="#371__493">3.7.1 函数分类</a></li>
<li><a href="#372__521">3.7.2 函数声明和定义</a></li>
<li><a href="#373__538">3.7.3 函数传参</a></li>
<li><a href="#374__559">3.7.4 函数返回值</a></li>
<li><a href="#375__610">3.7.5 递归调用</a></li>
</ul>
</li>
<li><a href="#38__628">3.8 方法</a></li>
<li><a href="#39__673">3.9 接口</a></li>
<li>
<ul>
<li><a href="#391__674">3.9.1 什么是接口</a></li>
<li><a href="#392__684">3.9.2 结构体类型</a></li>
<li><a href="#393__738">3.9.3 具体类型向接口类型赋值</a></li>
<li><a href="#394__749">3.9.4 获取接口类型数据的具体类型信息</a></li>
</ul>
</li>
<li><a href="#310_channel_754">3.10 channel</a></li>
<li>
<ul>
<li><a href="#3101__755">3.10.1 相关结构体定义</a></li>
<li><a href="#3102_channel_794">3.10.2 阻塞式读写 channel 操作</a></li>
<li><a href="#3103_channel_826">3.10.3 非阻塞式读写 channel 操作</a></li>
</ul>
</li>
<li><a href="#311_map_855">3.11 map</a></li>
<li>
<ul>
<li><a href="#3111__944">3.11.1 插入数据</a></li>
<li><a href="#3112__957">3.11.2 删除数据</a></li>
<li><a href="#3113__966">3.11.3 查找数据</a></li>
<li><a href="#3114__980">3.11.4 扩容</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4__1012">4. 常用语句及关键字</a></li>
<li>
<ul>
<li><a href="#41__1014">4.1 条件语句</a></li>
<li><a href="#42__1078">4.2 循环语句</a></li>
<li>
<ul>
<li><a href="#421__1079">4.2.1 循环处理语句</a></li>
<li><a href="#421__1095">4.2.1 循环控制语句</a></li>
</ul>
</li>
<li><a href="#43__1200">4.3 关键字</a></li>
</ul>
</li>
</ul>
<hr>
<h1 id="1-go语言的出现"><a class="markdownIt-Anchor" href="#1-go语言的出现">#</a> 1. Go 语言的出现</h1>
<p>在具体学习 go 语言的基础语法之前，我们来了解一下 go 语言出现的时机及其特点。</p>
<p>Go 语言最初由 Google 公司的 Robert Griesemer、Ken Thompson 和 Rob Pike 三个大牛于 2007 年开始设计发明，他们最终的目标是设计一种<strong>适应网络和多核时代的 C 语言</strong>。所以 Go 语言很多时候被描述为 “类 C 语言”，或者是 “21 世纪的 C 语言”，当然从各种角度看，Go 语言确实是从 C 语言继承了相似的表达式语法、控制流结构、基础数据类型、调用参数传值、指针等诸多编程思想。但是 Go 语言更是对 C 语言最彻底的一次扬弃，它舍弃了 C 语言中灵活但是危险的指针运算，还重新设计了 C 语言中部分不太合理运算符的优先级，并在很多细微的地方都做了必要的打磨和改变。</p>
<h1 id="2-go版本的hello-world"><a class="markdownIt-Anchor" href="#2-go版本的hello-world">#</a> 2. go 版本的 hello world</h1>
<p>在这一部分我们只是使用 “hello world” 的程序来向大家介绍一下 go 语言的所编写的程序的基本组成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import <span class="string">&quot;fmt&quot;</span></span><br><span class="line">func <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 终端输出hello world</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<p>和 C 语言相似，go 语言的基本组成有：</p>
<ul>
<li>包声明，编写源文件时，必须在非注释的第一行指明这个文件属于哪个包，如 <code>package main</code> 。</li>
<li>引入包，其实就是告诉 Go 编译器这个程序需要使用的包，如 <code>import &quot;fmt&quot;</code>  其实就是引入了 fmt 包。</li>
<li>函数，和 c 语言相同，即是一个可以实现某一个功能的函数体，每一个可执行程序中必须拥有一个 main 函数。</li>
<li>变量，Go 语言变量名由字母、数字、下划线组成，其中首个字符不能为数字。</li>
<li>语句 / 表达式，在 Go 程序中，一行代表一个语句结束。每个语句不需要像 C 家族中的其它语言一样以分号；结尾，因为这些工作都将由 Go 编译器自动完成。</li>
<li>注释，和 c 语言中的注释方式相同，可以在任何地方使用以 // 开头的单行注释。以 /* 开头，并以 */ 结尾来进行多行注释，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。</li>
</ul>
<blockquote>
<p>需要注意的是：<strong>标识符</strong>是用来命名变量、类型等程序实体。一个标识符实际上就是一个或是多个字母和数字、下划线_组成的序列，但是第一个字符必须是字母或下划线而不能是数字。</p>
<ol>
<li>当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；</li>
<li>标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected）。</li>
</ol>
</blockquote>
<h1 id="3-数据类型"><a class="markdownIt-Anchor" href="#3-数据类型">#</a> 3. 数据类型</h1>
<p>在 Go 编程语言中，数据类型用于声明函数和变量。</p>
<p>数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。具体分类如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>详解</th>
</tr>
</thead>
<tbody>
<tr>
<td>布尔型</td>
<td>布尔型的值只可以是常量 true 或者 false。</td>
</tr>
<tr>
<td>数字类型</td>
<td>整型 int 和浮点型 float。Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。</td>
</tr>
<tr>
<td>字符串类型</td>
<td>字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。</td>
</tr>
<tr>
<td>派生类型</td>
<td>(a) 指针类型（Pointer）(b) 数组类型 © 结构化类型 (struct)(d) Channel 类型 (e) 函数类型 (f) 切片类型 (g) 接口类型（interface）(h) Map 类型</td>
</tr>
</tbody>
</table>
<h2 id="30-定义变量"><a class="markdownIt-Anchor" href="#30-定义变量">#</a> 3.0 定义变量</h2>
<p>声明变量的一般形式是使用 var 关键字，具体格式为： <code>var identifier typename</code> 。如下的代码中我们定义了一个类型为 int 的变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="type">int</span> = <span class="number">27</span></span><br><span class="line">	fmt.Println(a);</span><br><span class="line">&#125; </span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<h3 id="301-如果变量没有初始化"><a class="markdownIt-Anchor" href="#301-如果变量没有初始化">#</a> 3.0.1 如果变量没有初始化</h3>
<p>在 go 语言中定义了一个变量，指定变量类型，如果没有初始化，则变量默认为零值。<strong>零值就是变量没有做初始化时系统默认设置的值</strong>。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>零值</th>
</tr>
</thead>
<tbody>
<tr>
<td>数值类型</td>
<td>0</td>
</tr>
<tr>
<td>布尔类型</td>
<td>false</td>
</tr>
<tr>
<td>字符串</td>
<td>“”（空字符串）</td>
</tr>
</tbody>
</table>
<h3 id="302-如果变量没有指定类型"><a class="markdownIt-Anchor" href="#302-如果变量没有指定类型">#</a> 3.0.2 如果变量没有指定类型</h3>
<p>在 go 语言中如果没有指定变量类型，可以通过变量的初始值来判断变量类型。如下代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> d = <span class="literal">true</span></span><br><span class="line">    fmt.Println(d)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<h3 id="303-符号"><a class="markdownIt-Anchor" href="#303-符号">#</a> 3.0.3 := 符号</h3>
<p>当我们定义一个变量后又使用该符号初始化变量，就会产生编译错误，因为该符号其实是一个声明语句。</p>
<p>使用格式： <code>typename := value</code></p>
<p>也就是说 <code>intVal := 1</code>  相等于：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intVal <span class="type">int</span> </span><br><span class="line">intVal =<span class="number">1</span> </span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>
<h3 id="304-多变量声明"><a class="markdownIt-Anchor" href="#304-多变量声明">#</a> 3.0.4 多变量声明</h3>
<p>可以同时声明多个类型相同的变量（非全局变量），如下图所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x, y <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> c, d <span class="type">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">g, h := <span class="number">123</span>, <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<p>关于全局变量的声明如下：<br>
 <code>var ( vname1 v_type1 vname2 v_type2 )</code> <br>
 具体举例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ( </span><br><span class="line">    a <span class="type">int</span></span><br><span class="line">    b <span class="type">bool</span></span><br><span class="line">)</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<h3 id="305-匿名变量"><a class="markdownIt-Anchor" href="#305-匿名变量">#</a> 3.0.5 匿名变量</h3>
<p>匿名变量的特点是一个下画线 <code>_</code> ，这本身就是一个特殊的标识符，被称为空白标识符。它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值<strong>不能在后续的代码中使用</strong>，也不可以使用这个标识符作为变量对其它变量进行赋值或运算。</p>
<p>使用匿名变量时，只需要在<strong>变量声明的地方</strong>使用下画线替换即可。</p>
<p>示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">GetData</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>, <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a, _ := GetData()</span><br><span class="line">        _, b := GetData()</span><br><span class="line">        fmt.Println(a, b)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是匿名变量不占用内存空间，不会分配内存。匿名变量与匿名变量之间也不会因为多次声明而无法使用。</p>
<h3 id="306-变量作用域"><a class="markdownIt-Anchor" href="#306-变量作用域">#</a> 3.0.6 变量作用域</h3>
<p>作用域指的是已声明的标识符所表示的常量、类型、函数或者包在源代码中的作用范围，在此我们主要看一下 go 中变量的作用域，根据变量定义位置的不同，可以分为一下三个类型：</p>
<ol>
<li>函数内定义的变量为<strong>局部变量</strong>，这种局部变量的作用域只在函数体内，函数的参数和返回值变量都属于局部变量。这种变量在存在于函数被调用时，销毁于函数调用结束后。</li>
<li>函数外定义的变量为<strong>全局变量</strong>，全局变量只需要在一个源文件中定义，就可以在所有源文件中使用，甚至可以使用 import 引入外部包来使用。全局变量声明必须<strong>以 var 关键字开头</strong>，如果想要在<strong>外部包中使用</strong>全局变量的<strong>首字母必须大写</strong>。</li>
<li>函数定义中的变量成为<strong>形式参数</strong>，定义函数时函数名后面括号中的变量叫做形式参数（简称形参）。形式参数只在函数调用时才会生效，函数调用结束后就会被销毁，在函数未被调用时，函数的形参并不占用实际的存储单元，也没有实际值。<strong>形式参数会作为函数的局部变量来使用</strong>。</li>
</ol>
<h2 id="31-基本类型"><a class="markdownIt-Anchor" href="#31-基本类型">#</a> 3.1 基本类型</h2>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>uint8 / uint16 / uint32 / uint64</td>
<td>无符号 8 / 16 / 32 / 64 位整型</td>
</tr>
<tr>
<td>int8 / int16 / int32 / int64</td>
<td>有符号 8 / 16 / 32 / 64 位整型</td>
</tr>
<tr>
<td>float32 / float64</td>
<td>IEEE-754 32 / 64 位浮点型数</td>
</tr>
<tr>
<td>complex64 / complex128</td>
<td>32 / 64 位实数和虚数</td>
</tr>
<tr>
<td>byte</td>
<td>类似 uint8</td>
</tr>
<tr>
<td>rune</td>
<td>类似 int32</td>
</tr>
<tr>
<td>uintptr</td>
<td>无符号整型，用于存放一个指针</td>
</tr>
</tbody>
</table>
<p>以上就是 go 语言基本的数据类型，有了数据类型，我们就可以使用这些类型来定义变量，Go 语言变量名由字母、数字、下划线组成，其中首个字符不能为数字。</p>
<h2 id="32-指针"><a class="markdownIt-Anchor" href="#32-指针">#</a> 3.2 指针</h2>
<p>与 C 相同，Go 语言让程序员决定何时使用指针。变量其实是一种使用方便的占位符，用于引用计算机内存地址。Go 语言中的的取地址符是 <code>&amp;</code> ，放到一个变量前使用就会返回相应变量的内存地址。</p>
<p>指针变量其实就是用于存放某一个对象的内存地址。</p>
<h3 id="321-指针声明和初始化"><a class="markdownIt-Anchor" href="#321-指针声明和初始化">#</a> 3.2.1 指针声明和初始化</h3>
<p>和基础类型数据相同，在使用指针变量之前我们首先需要申明指针，声明格式如下： <code>var var_name *var-type</code> ，其中的 var-type 为指针类型，var_name 为指针变量名，* 号用于指定变量是作为一个指针。</p>
<p>代码举例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ip *<span class="type">int</span>        <span class="comment">/* 指向整型*/</span></span><br><span class="line"><span class="keyword">var</span> fp *<span class="type">float32</span>    <span class="comment">/* 指向浮点型 */</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>指针的初始化就是取出相对应的变量地址对指针进行赋值，具体如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">var</span> a <span class="type">int</span>= <span class="number">20</span>   <span class="comment">/* 声明实际变量 */</span></span><br><span class="line">   <span class="keyword">var</span> ip *<span class="type">int</span>        <span class="comment">/* 声明指针变量 */</span></span><br><span class="line"></span><br><span class="line">   ip = &amp;a  <span class="comment">/* 指针变量的存储地址 */</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<h3 id="322-空指针"><a class="markdownIt-Anchor" href="#322-空指针">#</a> 3.2.2 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%A9%BA%E6%8C%87%E9%92%88&amp;spm=1001.2101.3001.7020">空指针</a></h3>
<p>当一个指针被定义后<strong>没有分配到任何变量</strong>时，它的值为 <strong>nil</strong>，也称为空指针。它概念上和其它语言的 null、NULL 一样，都指代零值或空值。</p>
<h2 id="33-数组"><a class="markdownIt-Anchor" href="#33-数组">#</a> 3.3 数组</h2>
<p>和 c 语言相同，Go 语言也提供了数组类型的数据结构，数组是具有<strong>相同唯一类型</strong>的一组已编号且<strong>长度固定</strong>的数据项序列，这种类型可以是任意的原始类型例如整型、字符串或者自定义类型。</p>
<h3 id="331-声明数组"><a class="markdownIt-Anchor" href="#331-声明数组">#</a> 3.3.1 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%A3%B0%E6%98%8E%E6%95%B0%E7%BB%84&amp;spm=1001.2101.3001.7020">声明数组</a></h3>
<p>Go 语言数组声明需要指定元素类型及元素个数，语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var variable_name [SIZE] variable_type</span><br></pre></td></tr></table></figure>
<p>以上就可以定一个一维数组，我们举例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> balance [<span class="number">10</span>] <span class="type">float32</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="332-初始化数组"><a class="markdownIt-Anchor" href="#332-初始化数组">#</a> 3.3.2 初始化数组</h3>
<p>数组的初始化方式有不止一种方式，我们列举如下：</p>
<ol>
<li>直接进行初始化： <code>var balance = [5]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;</code></li>
<li>通过字面量在声明数组的同时快速初始化数组： <code>balance := [5]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;</code></li>
<li>数组长度不确定，编译器通过元素个数自行推断数组长度，在 [ ] 中填入 <code>...</code> ，举例如下： <code>var balance = [...]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;</code>  和 <code>balance := [...]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;</code></li>
<li>数组长度确定，指定下标进行部分初始化： <code>balanced := [5]float32(1:2.0, 3:7.0)</code></li>
</ol>
<blockquote>
<p>注意：</p>
<ul>
<li>初始化数组中 {} 中的元素个数不能大于 [] 中的数字。<br>
如果忽略 [] 中的数字不设置数组大小，Go 语言会根据元素的个数来设置数组的大小。</li>
</ul>
</blockquote>
<h3 id="333-go中的数组名意义"><a class="markdownIt-Anchor" href="#333-go中的数组名意义">#</a> 3.3.3 go 中的数组名意义</h3>
<p>在 c 语言中我们知道数组名在本质上是数组中第一个元素的地址，而在 go 语言中，数组名仅仅表示整个数组，是一个完整的值，一个数组变量即是表示整个数组。</p>
<p>所以在 go 中一个数组变量被赋值或者被传递的时候实际上就会复制整个数组。如果数组比较大的话，这种复制往往会占有很大的开销。所以为了避免这种开销，往往需要传递一个指向数组的指针，这个数组指针并不是数组。关于数组指针具体在指针的部分深入的了解。</p>
<h3 id="334-数组指针"><a class="markdownIt-Anchor" href="#334-数组指针">#</a> 3.3.4 数组指针</h3>
<p>通过数组和指针的知识我们就可以定义一个数组指针，代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// a 是一个数组</span></span><br><span class="line"><span class="keyword">var</span> b = &amp;a                <span class="comment">// b 是指向数组的指针</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>数组指针除了可以防止数组作为参数传递的时候浪费空间，还可以利用其和 <code>for range</code>  来遍历数组，具体代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> b &#123;     <span class="comment">// 通过数组指针迭代数组的元素</span></span><br><span class="line">    fmt.Println(i, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<p>具体关于 go 语言的循环语句我们在后文中再进行详细介绍。</p>
<h2 id="34-结构体"><a class="markdownIt-Anchor" href="#34-结构体">#</a> 3.4 结构体</h2>
<p>通过上述数组的学习，我们就可以直接定义多个同类型的变量，但这往往也是一种限制，只能存储同一种类型的数据，而我们在结构体中就可以定义多个不同的数据类型。</p>
<h3 id="341-声明结构体"><a class="markdownIt-Anchor" href="#341-声明结构体">#</a> 3.4.1 声明结构体</h3>
<p>在声明结构体之前我们首先需要定义一个结构体类型，这需要使用 type 和 struct，type 用于设定结构体的名称，struct 用于定义一个新的数据类型。具体结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> struct_variable_type <span class="keyword">struct</span> &#123;</span><br><span class="line">   member definition</span><br><span class="line">   member definition</span><br><span class="line">   ...</span><br><span class="line">   member definition</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<p>定义好了结构体类型，我们就可以使用该结构体声明这样一个结构体变量，语法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">variable_name := structure_variable_type &#123;value1, value2...valuen&#125;</span><br><span class="line"></span><br><span class="line">variable_name := structure_variable_type &#123; key1: value1, key2: value2..., keyn: valuen&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<h3 id="342-访问结构体成员"><a class="markdownIt-Anchor" href="#342-访问结构体成员">#</a> 3.4.2 访问结构体成员</h3>
<p>如果要访问结构体成员，需要使用点号  <code>.</code>  操作符，格式为： <code>结构体变量名.成员名</code> 。举例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Books <span class="keyword">struct</span> &#123;</span><br><span class="line">   title <span class="type">string</span></span><br><span class="line">   author <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> book1 Books</span><br><span class="line">	Book1.title = <span class="string">&quot;Go 语言入门&quot;</span></span><br><span class="line">	Book1.author = <span class="string">&quot;mars.hao&quot;</span>	</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>
<h3 id="343-结构体指针"><a class="markdownIt-Anchor" href="#343-结构体指针">#</a> 3.4.3 结构体指针</h3>
<p>关于结构体指针的定义和申明同样可以套用前文中讲到的指针的相关定义，从而使用一个指针变量存放一个结构体变量的地址。</p>
<p>定义一个结构体变量的语法： <code>var struct_pointer *Books</code> 。</p>
<p>这种指针变量的初始化和上文指针部分的初始化方式相同 <code>struct_pointer = &amp;Book1</code> ，但是和 c 语言中有所不同，使用结构体指针访问结构体成员仍然使用 <code>.</code>  操作符。格式如下： <code>struct_pointer.title</code></p>
<h2 id="35-字符串"><a class="markdownIt-Anchor" href="#35-字符串">#</a> 3.5 字符串</h2>
<p>一个字符串是一个<strong>不可改变</strong>的字节序列，字符串通常是用来包含人类可读的文本数据。和数组不同的是，字符串的元素不可修改，是一个只读的<strong>字节数组</strong>。每个字符串的长度虽然也是固定的，但是字符串的长度并不是字符串类型的一部分。</p>
<h3 id="351-字符串定义和初始化"><a class="markdownIt-Anchor" href="#351-字符串定义和初始化">#</a> 3.5.1 字符串定义和初始化</h3>
<p>Go 语言字符串的底层结构在 reflect.StringHeader 中定义，具体如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="type">uintptr</span></span><br><span class="line">    Len  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<p>也就是说字符串结构由两个信息组成：第一个是字符串指向的底层字节数组，第二个是字符串的字节的长度。</p>
<p>字符串其实是一个结构体，因此字符串的赋值操作也就是 reflect.StringHeader 结构体的复制过程，并不会涉及底层字节数组的复制，所以我们也可以将字符串数组看作一个结构体数组。</p>
<p>字符串和数组类似，内置的 len 函数返回字符串的长度。</p>
<h3 id="352-字符串utf8编码"><a class="markdownIt-Anchor" href="#352-字符串utf8编码">#</a> 3.5.2 字符串 UTF8 编码</h3>
<p>根据 Go 语言规范，Go 语言的源文件都是采用<strong> UTF8</strong> 编码。因此，Go 源文件中出现的字符串面值常量一般也是 UTF8 编码的（对于转义字符，则没有这个限制）。提到 Go 字符串时，我们一般都会假设字符串对应的是一个合法的 UTF8 编码的字符序列。</p>
<p>Go 语言的字符串中可以存放任意的二进制字节序列，而且即使是 UTF8 字符序列也可能会遇到坏的编码。如果遇到一个<strong>错误的 UTF8 编码输入</strong>，将生成一个<strong>特别的 Unicode 字符</strong>‘\uFFFD’，这个字符在不同的软件中的显示效果可能不太一样，在印刷中这个符号通常是一个黑色六角形或钻石形状，里面包含一个白色的问号‘ ’。</p>
<p>下面的字符串中，我们故意损坏了第一字符的第二和第三字节，因此第一字符将会打印为 “”，第二和第三字节则被忽略；后面的 “abc” 依然可以正常解码打印（<strong>错误编码不会向后扩散是 UTF8 编码的优秀特性之一</strong>）。代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;\xe4\x00\x00\xe7\x95\x8cabc&quot;</span>) <span class="comment">//  界abc</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>不过在 for range 迭代这个含有损坏的 UTF8 字符串时，第一字符的第二和第三字节依然会被单独迭代到，不过此时迭代的值是损坏后的 0：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0 65533  // \uFFFD, 对应  </span></span><br><span class="line"><span class="comment">// 1 0      // 空字符</span></span><br><span class="line"><span class="comment">// 2 0      // 空字符</span></span><br><span class="line"><span class="comment">// 3 30028  // 界</span></span><br><span class="line"><span class="comment">// 6 97     // a</span></span><br><span class="line"><span class="comment">// 7 98     // b</span></span><br><span class="line"><span class="comment">// 8 99     // c</span></span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>
<h3 id="353-字符串的强制类型转换"><a class="markdownIt-Anchor" href="#353-字符串的强制类型转换">#</a> 3.5.3 字符串的强制类型转换</h3>
<p>在上文中我们知道源代码往往会采用 UTF8 编码，如果不想解码 UTF8 字符串，想直接遍历原始的字节码：</p>
<ol>
<li>可以将字符串强制转为 [] byte 字节序列后再行遍历（这里的转换一般不会产生运行时开销）：</li>
<li>采用传统的下标方式遍历字符串的字节数组</li>
</ol>
<p>除此以外，字符串相关的强制类型转换主要<strong>涉及到 [] byte 和 [] rune 两种类型</strong>。每个转换都可能隐含<strong>重新分配内存</strong>的代价，最坏的情况下它们的运算时间复杂度都是 O (n)。</p>
<p>不过字符串和 [] rune 的转换要更为特殊一些，因为一般这种强制类型转换要求两个类型的底层内存结构要尽量一致，显然它们底层对应的 [] byte 和 [] int32 类型是完全不同的内部布局，因此这种转换可能隐含重新分配内存的操作。</p>
<h2 id="36-slice"><a class="markdownIt-Anchor" href="#36-slice">#</a> 3.6 slice</h2>
<p>简单地说，切片就是一种简化版的<strong>动态数组</strong>。因为动态数组的<strong>长度不固定</strong>，切片的长度自然也就不能是类型的组成部分了。数组虽然有适用它们的地方，但是数组的类型和操作都不够灵活，而切片则使用得相当广泛。</p>
<p>切片高效操作的要点是要降低内存分配的次数，尽量保证 append 操作（在后续的插入和删除操作中都涉及到这个函数）不会超出 cap 的容量，降低触发内存分配的次数和每次分配内存大小。</p>
<h3 id="361-slice定义"><a class="markdownIt-Anchor" href="#361-slice定义">#</a> 3.6.1 slice 定义</h3>
<p>我们先看看切片的结构定义，reflect.SliceHeader：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="type">uintptr</span>   <span class="comment">// 指向底层的的数组指针</span></span><br><span class="line">    Len  <span class="type">int</span>	   <span class="comment">// 切片长度</span></span><br><span class="line">    Cap  <span class="type">int</span>	   <span class="comment">// 切片最大长度</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>
<p>和数组一样，内置的 len 函数返回切片中有效元素的长度，内置的 cap 函数返回切片容量大小，容量必须大于或等于切片的长度。</p>
<p>切片可以和<strong> nil</strong> 进行比较，只有当切片<strong>底层数据指针为空时</strong>切片本身为 nil，这时候<strong>切片的长度和容量信息将是无效的</strong>。如果有切片的底层数据指针为空，但是长度和容量不为 0 的情况，那么说明切片本身已经被损坏了</p>
<p>只要是<strong>切片的底层</strong>数据指针、长度和容量<strong>没有发生变化</strong>的话，对切片的遍历、元素的读取和修改都和数组是一样的。在对切片本身赋值或参数传递时，和数组指针的操作方式类似，只是复制切片头信息（reflect.SliceHeader），并不会复制底层的数据。对于类型，和数组的最大不同是，切片的类型和长度信息无关，只要是相同类型元素构成的切片均对应相同的切片类型。</p>
<p>当我们想定义声明一个切片时可以如下：</p>
<p>在对切片本身赋值或参数传递时，和数组指针的操作方式类似，只是复制切片头信息・（reflect.SliceHeader），并不会复制底层的数据。对于类型，和数组的最大不同是，切片的类型和长度信息无关，<strong>只要是相同类型元素构成的切片均对应相同的切片类型</strong>。</p>
<h3 id="362-添加元素"><a class="markdownIt-Anchor" href="#362-添加元素">#</a> 3.6.2 添加元素</h3>
<p><code>append()</code>  ：内置的泛型函数，可以向切片中增加元素。</p>
<ol>
<li>在切片尾部追加 N 个元素</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="type">int</span></span><br><span class="line">a = <span class="built_in">append</span>(a, <span class="number">1</span>)               <span class="comment">// 追加1个元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)         <span class="comment">// 追加多个元素, 手写解包方式</span></span><br><span class="line">a = <span class="built_in">append</span>(a, []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;...) <span class="comment">// 追加一个切片, 切片需要解包</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：尾部添加在容量不足的条件下需要重新分配内存，可能导致巨大的内存分配和复制数据代价。即使容量足够，依然需要用 append 函数的返回值来更新切片本身，因为新切片的长度已经发生了变化。</p>
</blockquote>
<ol>
<li>在切片开头位置添加元素</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">a = <span class="built_in">append</span>([]<span class="type">int</span>&#123;<span class="number">0</span>&#125;, a...)        <span class="comment">// 在开头位置添加1个元素</span></span><br><span class="line">a = <span class="built_in">append</span>([]<span class="type">int</span>&#123;<span class="number">-3</span>,<span class="number">-2</span>,<span class="number">-1</span>&#125;, a...) <span class="comment">// 在开头添加1个切片</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：在开头一般都会导致内存的重新分配，而且会导致已有的元素全部复制 1 次。因此，从切片的开头添加元素的性能一般要比从尾部追加元素的性能差很多。</p>
</blockquote>
<ol>
<li>append 链式操作</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="type">int</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:i], <span class="built_in">append</span>([]<span class="type">int</span>&#123;x&#125;, a[i:]...)...)     <span class="comment">// 在第i个位置插入x</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:i], <span class="built_in">append</span>([]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, a[i:]...)...) <span class="comment">// 在第i个位置插入切片</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>每个添加操作中的第二个 append 调用都会创建一个<strong>临时切片</strong>，并将 a [i:] 的内容复制到新创建的切片中，然后将临时创建的切片再追加到 a [:i]。</p>
</blockquote>
<ol>
<li>append 和 copy 组合</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">append</span>(a, <span class="number">0</span>)     <span class="comment">// 切片扩展1个空间</span></span><br><span class="line"><span class="built_in">copy</span>(a[i+<span class="number">1</span>:], a[i:]) <span class="comment">// a[i:]向后移动1个位置</span></span><br><span class="line">a[i] = x             <span class="comment">// 设置新添加的元素</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>第三个操作中会创建一个临时对象，我们可以借用 copy 函数避免这个操作，这种方式操作语句虽然冗长了一点，但是相比前面的方法，可以减少中间创建的临时切片。</p>
</blockquote>
<h3 id="363-删除元素"><a class="markdownIt-Anchor" href="#363-删除元素">#</a> 3.6.3 删除元素</h3>
<p>根据要删除元素的位置有三种情况：</p>
<ol>
<li>从开头位置删除；</li>
</ol>
<ul>
<li>直接移动数据指针，代码如下：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ...&#125;</span><br><span class="line">a = a[<span class="number">1</span>:]                       <span class="comment">// 删除开头1个元素</span></span><br><span class="line">a = a[N:]                       <span class="comment">// 删除开头N个元素</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<ul>
<li>将后面的数据向开头移动，使用<strong> append 原地完成</strong>（所谓原地完成是指在原有的切片数据对应的内存区间内完成，不会导致内存空间结构的变化）</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ...&#125;</span><br><span class="line">a = <span class="built_in">append</span>(a[:<span class="number">0</span>], a[<span class="number">1</span>:]...) <span class="comment">// 删除开头1个元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:<span class="number">0</span>], a[N:]...) <span class="comment">// 删除开头N个元素</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用 copy 将后续数据向前移动，代码如下：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">a = a[:<span class="built_in">copy</span>(a, a[<span class="number">1</span>:])] <span class="comment">// 删除开头1个元素</span></span><br><span class="line">a = a[:<span class="built_in">copy</span>(a, a[N:])] <span class="comment">// 删除开头N个元素</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<ol>
<li>从中间位置删除；<br>
对于删除中间的元素，需要对剩余的元素进行一次整体挪动，同样可以用 append 或 copy 原地完成：</li>
</ol>
<ul>
<li>append 删除操作如下：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ...&#125;</span><br><span class="line">a = <span class="built_in">append</span>(a[:i], a[i+<span class="number">1</span>], ...)</span><br><span class="line">a = <span class="built_in">append</span>(a[:i], a[i+N:], ...)</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<ul>
<li>copy 删除操作如下：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">a = a[:<span class="built_in">copy</span>(a[:i], a[i+<span class="number">1</span>:])] <span class="comment">// 删除中间1个元素</span></span><br><span class="line">a = a[:<span class="built_in">copy</span>(a[:i], a[i+N:])] <span class="comment">// 删除中间N个元素</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<ol>
<li>从尾部删除。</li>
</ol>
<p>代码如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ...&#125;</span><br><span class="line"></span><br><span class="line">a = a[:<span class="built_in">len</span>(a)<span class="number">-1</span>]   <span class="comment">// 删除尾部1个元素</span></span><br><span class="line">a = a[:<span class="built_in">len</span>(a)-N]   <span class="comment">// 删除尾部N个元素</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>删除切片尾部的元素是最快的</p>
</blockquote>
<h2 id="37-函数"><a class="markdownIt-Anchor" href="#37-函数">#</a> 3.7 函数</h2>
<p>为完成某一功能的程序指令 (语句) 的集合，称为函数。</p>
<h3 id="371-函数分类"><a class="markdownIt-Anchor" href="#371-函数分类">#</a> 3.7.1 函数分类</h3>
<p>在 Go 语言中，函数是第一类对象，我们可以将函数保持到变量中。函数主要有<strong>具名</strong>和<strong>匿名</strong>之分，包级函数一般都是具名函数，具名函数是匿名函数的一种特例，当匿名函数引用了外部作用域中的变量时就成了<strong>闭包函数</strong>，闭包函数是函数式编程语言的核心。</p>
<p>举例代码如下：</p>
<ol>
<li>具名函数：就和 c 语言中的普通函数意义相同，具有函数名、返回值以及函数参数的函数。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<ol>
<li>匿名函数：指不需要定义函数名的一种函数实现方式，它由一个不带函数名的函数声明和函数体组成。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Add = <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>解释几个名词如下：</p>
<ol>
<li>闭包函数：返回为函数对象，不仅仅是一个函数对象，在该函数外还包裹了一层作用域，这使得，该函数无论在何处调用，优先使用自己外层包裹的作用域。</li>
<li>一级对象：支持闭包的多数语言都将函数作为第一级对象，就是说函数可以存储到变量中作为参数传递给其他函数，最重要的是能够被函数动态创建和返回。</li>
<li>包：go 的每一个文件都是属于一个包的，也就是说 go 是以包的形式来管理文件和项目目录结构的。</li>
</ol>
</blockquote>
<h3 id="372-函数声明和定义"><a class="markdownIt-Anchor" href="#372-函数声明和定义">#</a> 3.7.2 函数声明和定义</h3>
<p>Go 语言函数定义格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fuction_name</span><span class="params">([parameter list])</span></span>[<span class="keyword">return</span> types]&#123;</span><br><span class="line">	函数体</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th></th>
<th>解析</th>
</tr>
</thead>
<tbody>
<tr>
<td>func</td>
<td>函数由 func 开始声明</td>
</tr>
<tr>
<td>function_name</td>
<td>函数名称</td>
</tr>
<tr>
<td>parameter list</td>
<td>参数列表</td>
</tr>
<tr>
<td>return_types</td>
<td>返回类型</td>
</tr>
<tr>
<td>函数体</td>
<td>函数定义的代码集合</td>
</tr>
</tbody>
</table>
<h3 id="373-函数传参"><a class="markdownIt-Anchor" href="#373-函数传参">#</a> 3.7.3 函数传参</h3>
<blockquote>
<p>Go 语言中的函数可以有多个参数和多个返回值，参数和返回值都是以传值的方式和被调用者交换数据。在语法上，函数还支持可变数量的参数，<strong>可变数量的参数必须是最后出现的参数</strong>，可变数量的参数其实是一个切片类型的参数。</p>
</blockquote>
<p>当可变参数是一个<strong>空接口类型</strong>时，调用者是否解包可变参数会导致不同的结果，我们解释一下解包的含义，代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	Print(a...)   <span class="comment">// 解包</span></span><br><span class="line">	Print(a)	  <span class="comment">// 未解包</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">(a ...<span class="type">int</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	fmt.Println(a...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>
<p>以上当传入参数为 <code>a...</code>  时即是对切片 a 进行了解包，此时其实相当于直接调用 <code>Print(1,2,3)</code> 。当传入参数直接为  <code>a</code>  时等价于直接调用 <code>Print([]int&#123;&#125;&#123;1,2,3&#125;)</code></p>
<h3 id="374-函数返回值"><a class="markdownIt-Anchor" href="#374-函数返回值">#</a> 3.7.4 函数返回值</h3>
<blockquote>
<p>不仅函数的参数可以有名字，也可以给函数的返回值命名。</p>
</blockquote>
<p>举例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Find</span><span class="params">(m <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, key <span class="type">int</span>)</span></span>(value <span class="type">int</span>, ok <span class="type">bool</span>) &#123;</span><br><span class="line">	value,ok = m[key]</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<p>如果返回值命名了，可以通过名字来修改返回值，也可以通过 defer 语句在 return 语句之后修改返回值，举例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mian</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span> ; i&lt;<span class="number">3</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="built_in">println</span>(i) &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数最终的输出为：</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>
<p>以上代码中如果没有 defer 其实返回值就是 <code>0,1,2</code> ，但 defer 语句会在函数 return 之后才会执行，也就是或只有以上函数在执行结束 return 之后才会执行 defer 语句，而该函数 return 时的 <code>i</code>  值将会达到 3，所以最终的 defer 语句执行 printlin 的输出都是 3。</p>
<p>defer 语句延迟执行的其实是一个匿名函数，因为这个匿名函数捕获了外部函数的局部变量 v，这种函数我们一般叫闭包。闭包对捕获的外部变量并不是传值方式访问，而是以<strong>引用</strong>的方式访问。</p>
<p>这种方式往往会带来一些问题，修复方法为在每一轮迭代中都为 defer 函数提供一个独有的变量，修改代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        i := i <span class="comment">// 定义一个循环体内局部变量i</span></span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123; <span class="built_in">println</span>(i) &#125; ()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="comment">// 通过函数传入i</span></span><br><span class="line">        <span class="comment">// defer 语句会马上对调用参数求值</span></span><br><span class="line">        <span class="comment">// 不再捕获，而是直接传值</span></span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span>&#123; <span class="built_in">println</span>(i) &#125; (i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>
<h3 id="375-递归调用"><a class="markdownIt-Anchor" href="#375-递归调用">#</a> 3.7.5 递归调用</h3>
<p>Go 语言中，函数还可以直接或间接地调用自己，也就是支持递归调用。Go 语言函数的递归调用<strong>深度逻辑上没有限制</strong>，函数调用的栈是<strong>不会出现溢出错误</strong>的，因为 Go 语言运行时会根据需要动态地调整函数栈的大小。这部分的知识将会涉及 goroutint 和动态栈的相关知识，我们将会在之后的博文中向大家解释。</p>
<p>它的语法和 c 很相似，格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recursion</span><span class="params">()</span></span> &#123;</span><br><span class="line">   recursion() <span class="comment">/* 函数调用自身 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   recursion()</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>
<h2 id="38-方法"><a class="markdownIt-Anchor" href="#38-方法">#</a> 3.8 方法</h2>
<p>方法一般是面向对象编程 (OOP) 的一个特性，在 C++ 语言中方法对应一个类对象的成员函数，是关联到具体对象上的虚表中的。但是 Go 语言的方法却是<strong>关联到类型</strong>的，这样可以在<strong>编译阶段完成方法的静态绑定</strong>。一个面向对象的程序会用方法来表达其属性对应的操作，这样使用这个对象的用户就不需要直接去操作对象，而是借助方法来做这些事情。</p>
<p>实现 C 语言中的一组函数如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件对象</span></span><br><span class="line"><span class="keyword">type</span> File <span class="keyword">struct</span> &#123;</span><br><span class="line">    fd <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="type">string</span>)</span></span> (f *File, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CloseFile</span><span class="params">(f *File)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读文件数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(f *File, offset <span class="type">int64</span>, data []<span class="type">byte</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819</span></span><br></pre></td></tr></table></figure>
<p>以上的三个函数都是普通的函数，需要占用包级空间中的名字资源。不过 CloseFile 和 ReadFile 函数只是针对 File 类型对象的操作，这时候我们更希望这类函数和操作对象的类型紧密绑定在一起。</p>
<p>所以在 go 语言中我们修改如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> CloseFile() <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读文件数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> ReadFile(offset <span class="type">int64</span>, data []<span class="type">byte</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>
<p>将 CloseFile 和 ReadFile 函数的第一个参数移动到函数名的开头，这两个函数就成了<strong> File 类型</strong>独有的方法了（而不是 File 对象方法）</p>
<p>从代码角度看虽然只是一个小的改动，但是从编程哲学角度来看，Go 语言已经是进入面向对象语言的行列了。我们可以给任何自定义类型添加一个或多个方法。每种类型对应的方法必须和类型的定义在同一个包中，因此是无法给 int 这类内置类型添加方法的（因为方法的定义和类型的定义不在一个包中）。对于给定的类型，每个方法的名字必须是唯一的，同时方法和函数一样也不支持重载。</p>
<h2 id="39-接口"><a class="markdownIt-Anchor" href="#39-接口">#</a> 3.9 接口</h2>
<h3 id="391-什么是接口"><a class="markdownIt-Anchor" href="#391-什么是接口">#</a> 3.9.1 什么是接口</h3>
<p>Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。</p>
<p>Go 的接口类型是对其它类型行为的抽象和概括；因为接口类型<strong>不会和特定的实现细节绑定在一起</strong>，通过这种抽象的方式我们可以让对象更加灵活和更具有适应能力。很多面向对象的语言都有相似的接口概念，但 Go 语言中接口类型的独特之处在于它是满足隐式实现的鸭子类型。</p>
<p>所谓<strong>鸭子类型</strong>说的是：只要走起路来像鸭子、叫起来也像鸭子，那么就可以把它当作鸭子。Go 语言中的面向对象就是如此，如果一个对象只要看起来像是某种接口类型的实现，那么它就可以作为该接口类型使用。</p>
<p>就比如说在 c 语言中，使用 printf 在终端输出的时候只能输出有限类型的几个变量，而在 go 中可以使用 fmt.Printf，实际上是 fmt.Fprintf 向任意自定义的输出流对象打印，甚至可以打印到网络甚至是压缩文件，同时打印的数据不限于语言内置的基础类型，任意隐士满足 fmt.Stringer 接口的对象都可以打印，不满足 fmt.Stringer 接口的依然可以通过反射的技术打印。</p>
<h3 id="392-结构体类型"><a class="markdownIt-Anchor" href="#392-结构体类型">#</a> 3.9.2 结构体类型</h3>
<p>interface 实际上就是一个结构体，包含两个成员。其中一个成员是指向具体数据的指针，另一个成员中包含了类型信息。空接口和带方法的接口略有不同，下面分别是空接口的数据结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Eface</span><br><span class="line">&#123;</span><br><span class="line">    Type*    <span class="keyword">type</span>;</span><br><span class="line">    void*    data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>
<p>其中的 Type 指的是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uintptr</span> size;</span><br><span class="line">    <span class="type">uint32</span> hash;</span><br><span class="line">    <span class="type">uint8</span> _unused;</span><br><span class="line">    <span class="type">uint8</span> align;</span><br><span class="line">    <span class="type">uint8</span> fieldAlign;</span><br><span class="line">    <span class="type">uint8</span> kind;</span><br><span class="line">    Alg *alg;</span><br><span class="line">    void *gc;</span><br><span class="line">    String *<span class="type">string</span>;</span><br><span class="line">    UncommonType *x;</span><br><span class="line">    Type *ptrto;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>
<p>和带方法的接口使用的数据结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Iface</span><br><span class="line">&#123;</span><br><span class="line">    Itab*    tab;</span><br><span class="line">    void*    data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>
<p>其中的 Iface 指的是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span>    Itab</span><br><span class="line">&#123;</span><br><span class="line">    InterfaceType*    inter;</span><br><span class="line">    Type*    <span class="keyword">type</span>;</span><br><span class="line">    Itab*    link;</span><br><span class="line">    <span class="type">int32</span>    bad;</span><br><span class="line">    <span class="type">int32</span>    unused;</span><br><span class="line">    void    (*fun[])(void);   <span class="comment">// 方法表</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>
<h3 id="393-具体类型向接口类型赋值"><a class="markdownIt-Anchor" href="#393-具体类型向接口类型赋值">#</a> 3.9.3 具体类型向接口类型赋值</h3>
<p>将一个具体类型数据赋值给 interface 这样的抽象类型，需要进行类型转换。这个转换过程中涉及哪些操作呢？</p>
<p>如果转换为空接口，返回一个 Eface，将 Eface 中的 data 指针指向原型数据，type 指针会指向数据的 Type 结构体。</p>
<p>如果将其转化为带方法的 interface，需要进行一次检测，该类型必须实现 interface 中声明的所有方法才可以进行转换，这个检测将会在编译过程中进行。检测过程具体实现式通过比较具体类型的方法表和接口类型的方法表来进行的。</p>
<ul>
<li>具体类型方法表：Type 的 UncommonType 中有一个方法表，某个具体类型实现的所有方法都会被收集到这张表中。</li>
<li>接口类型方法表：Iface 的 Itab 的 InterfaceType 中也有一张方法表，这张方法表中是接口所声明的方法。Iface 中的 Itab 的 func 域也是一张方法表，这张表中的每一项就是一个函数指针，也就是只有实现没有声明。</li>
</ul>
<p>这两处方法表都是排序过的，只需要一遍顺序扫描进行比较，应该可以知道 Type 中否实现了接口中声明的所有方法。最后还会将 Type 方法表中的函数指针，拷贝到 Itab 的 fun 字段中。Iface 中的 Itab 的 func 域也是一张方法表，这张表中的每一项就是一个函数指针，也就是只有实现没有声明。</p>
<h3 id="394-获取接口类型数据的具体类型信息"><a class="markdownIt-Anchor" href="#394-获取接口类型数据的具体类型信息">#</a> 3.9.4 获取接口类型数据的具体类型信息</h3>
<p>接口类型转换为具体类型 (也就是反射，reflect)，也涉及到了类型转换。reflect 包中的 TypeOf 和 ValueOf 函数来得到接口变量的 Type 和 Value。</p>
<h2 id="310-channel"><a class="markdownIt-Anchor" href="#310-channel">#</a> 3.10 channel</h2>
<h3 id="3101-相关结构体定义"><a class="markdownIt-Anchor" href="#3101-相关结构体定义">#</a> 3.10.1 相关结构体定义</h3>
<p>go 中的 channel 是可以被存储在变量中，可以作为参数传递给函数，也可以作为函数返回值返回，我们先来看一下 channel 的结构体定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span>    Hchan</span><br><span class="line">&#123;</span><br><span class="line">    uintgo    qcount;            <span class="comment">// 队列q中的总数据数量</span></span><br><span class="line">    uintgo    dataqsize;        <span class="comment">// 环形队列q的数据大小</span></span><br><span class="line">    <span class="type">uint16</span>    elemsize;			<span class="comment">// 当前队列的使用量</span></span><br><span class="line">    <span class="type">bool</span>    closed;				</span><br><span class="line">    <span class="type">uint8</span>    elemalign;</span><br><span class="line">    Alg*    elemalg;        <span class="comment">// interface for element type</span></span><br><span class="line">    uintgo    sendx;            <span class="comment">// 发送index</span></span><br><span class="line">    uintgo    recvx;            <span class="comment">// 接收index</span></span><br><span class="line">    WaitQ    recvq;            <span class="comment">// 因recv而阻塞的等待队列</span></span><br><span class="line">    WaitQ    sendq;            <span class="comment">// 因send而阻塞的等待队列</span></span><br><span class="line">    Lock;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>
<p>Hchan 结构体中的核心部分是存放 channel 数据的环形队列，相关数据的作用已经在其后做出了备注。在该结构体中没有存放数据的域，如果是带缓冲区的 chan，则缓冲区数据实际上是紧接着 Hchan 结构体中分配的。</p>
<p>另一个重要部分就是 recvq 和 sendq 两个链表，一个是因读这个通道而导致阻塞的 goroutine，另一个是因为写这个通道而阻塞的 goroutine。如果一个 goroutine 阻塞于 channel 了，那么它就被挂在 recvq 或 sendq 中。WaitQ 是链表的定义，包含一个头结点和一个尾结点，该链表中中存放的成员是一个 sudoG 结构体变量，具体定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span>    SudoG</span><br><span class="line">&#123;</span><br><span class="line">    G*    g;        <span class="comment">// g and selgen constitute</span></span><br><span class="line">    <span class="type">uint32</span>    selgen;        <span class="comment">// a weak pointer to g</span></span><br><span class="line">    SudoG*    link;</span><br><span class="line">    <span class="type">int64</span>    releasetime;</span><br><span class="line">    <span class="type">byte</span>*    elem;        <span class="comment">// data element</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>
<p>该结构体中最主要的是 g 和 elem。elem 用于存储 goroutine 的数据。读通道时，数据会从 Hchan 的队列中拷贝到 SudoG 的 elem 域。写通道时，数据则是由 SudoG 的 elem 域拷贝到 Hchan 的队列中。</p>
<p>Hchan 结构如下：<br>
<img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/ddf2855d06234305a122bea469d0adaa.png" alt="在这里插入图片描述"></p>
<h3 id="3102-阻塞式读写channel操作"><a class="markdownIt-Anchor" href="#3102-阻塞式读写channel操作">#</a> 3.10.2 阻塞式读写 channel 操作</h3>
<p>写操作代码如下，其中的 c 就是 channel，v 指的是数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c &lt;- v</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>事实上基本的阻塞模式写 channel 操作在底层运行时库中对应的是一个 runtime.chansend 函数。具体如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void runtime·chansend(ChanType *t, Hchan *c, byte *ep, bool *pres, void *pc)</span><br></pre></td></tr></table></figure>
<p>其中的 ep 指的是变量 v 的地址，这里的传值约定是调用者负责分配好 ep 的空间，仅需要简单的取变量地址就好了，pres 是在 select 中的通道操作中使用的。</p>
<p><img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/22fb68eff45145c89f2f64d51b3e556f.png" alt="在这里插入图片描述"></p>
<p>阻塞模式读操作的核心函数有两种包装如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool)</span><br></pre></td></tr></table></figure>
<p>以及</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected)</span><br></pre></td></tr></table></figure>
<p>这两种的区别主要在于返回值是否会返回一个 bool 类型值，该值只是用于判断 channel 是否能读取出数据。</p>
<p>读写操作的以上阻塞的过程类似，故而不再做出说明，我们补充三个细节：</p>
<ul>
<li>以上我们都强调是阻塞式的读写操作，其实相对应的也有<strong>非阻塞的</strong>读写操作，使用过 select-case 来进行调用的。</li>
<li>空通道，指的是将一个 channel 赋值为 nil，或者调用后不适用 make 进行初始化。读写空通道是永远阻塞的。</li>
<li>关闭的通道，永远不会阻塞，会返回一个通道数据类型的零值。首先将 closed 置为 1，第二步收集读等待队列 recvq 的所有 sg，每个 sg 的 elem 都设为类型零值，第三步收集写等待队列 sendq 的所有 sg，每个 sg 的 elem 都设为 nil，最后唤醒所有收集的 sg。</li>
</ul>
<h3 id="3103-非阻塞式读写channel操作"><a class="markdownIt-Anchor" href="#3103-非阻塞式读写channel操作">#</a> 3.10.3 非阻塞式读写 channel 操作</h3>
<p>如上文所说，非阻塞式其实就是使用 select-case 来实现，在编译时将会被编译为 if-else。</p>
<p>如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v = &lt;-c:</span><br><span class="line">        ...foo</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">        ...bar</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<p>就会被编译为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> selectnbrecv(&amp;v, c) &#123;</span><br><span class="line">        ...foo</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...bar</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>
<p>至于其中的 selectnbrecv 相关的函数简单地调 runtime.chanrecv 函数，设置了一个参数，告诉 runtime.chanrecv 函数，当不能完成操作时不要阻塞，而是返回失败。</p>
<p>但是 select 中的 case 的执行顺序是随机的，而不像 switch 中的 case 那样一条一条的顺序执行。让每一个 select 都对应一个 Select 结构体。在 Select 数据结构中有个 Scase 数组，记录下了每一个 case，而 Scase 中包含了 Hchan。然后 pollorder 数组将元素随机排列，这样就可以将 Scase 乱序了。</p>
<h2 id="311-map"><a class="markdownIt-Anchor" href="#311-map">#</a> 3.11 map</h2>
<p>map 表的底层原理是哈希表，其结构体定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">    Key  *Type <span class="comment">// Key type</span></span><br><span class="line">    Elem *Type <span class="comment">// Val (elem) type</span></span><br><span class="line"></span><br><span class="line">    Bucket *Type <span class="comment">// 哈希桶</span></span><br><span class="line">    Hmap   *Type <span class="comment">// 底层使用的哈希表元信息</span></span><br><span class="line">    Hiter  *Type <span class="comment">// 用于遍历哈希表的迭代器</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>
<p>其中的 Hmap 的具体化数据结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go.</span></span><br><span class="line">    <span class="comment">// Make sure this stays in sync with the compiler&#x27;s definition.</span></span><br><span class="line">    count     <span class="type">int</span> <span class="comment">// map目前的元素数目</span></span><br><span class="line">    flags     <span class="type">uint8</span> <span class="comment">// map状态（正在被遍历/正在被写入）</span></span><br><span class="line">    B         <span class="type">uint8</span>  <span class="comment">// 哈希桶数目以2为底的对数（哈希桶的数目都是 2 的整数次幂，用位运算来计算取余运算的值, 即 N mod M = N &amp; (M-1))）</span></span><br><span class="line">    noverflow <span class="type">uint16</span> <span class="comment">//溢出桶的数目, 这个数值不是恒定精确的, 当其 B&gt;=16 时为近似值</span></span><br><span class="line">    hash0     <span class="type">uint32</span> <span class="comment">// 随机哈希种子</span></span><br><span class="line"></span><br><span class="line">    buckets    unsafe.Pointer <span class="comment">// 指向当前哈希桶的指针</span></span><br><span class="line">    oldbuckets unsafe.Pointer <span class="comment">// 扩容时指向旧桶的指针</span></span><br><span class="line">    nevacuate  <span class="type">uintptr</span>        <span class="comment">// 桶进行调整时指示的搬迁进度</span></span><br><span class="line"></span><br><span class="line">    extra *mapextra <span class="comment">// 表征溢出桶的变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>
<p>以上 hmap 基本都是涉及到了哈希桶和溢出桶，我们首先看一下它的数据结构，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    topbits  [<span class="number">8</span>]<span class="type">uint8</span>    <span class="comment">// 键哈希值的高8位</span></span><br><span class="line">    keys     [<span class="number">8</span>]keytype  <span class="comment">// 哈希桶中所有键</span></span><br><span class="line">    elems    [<span class="number">8</span>]elemtype	<span class="comment">// 哈希桶中所有值</span></span><br><span class="line">    <span class="comment">//pad      uintptr(新的 go 版本已经移除了该字段, 我未具体了解此处的 change detail, 之前设置该字段是为了在 nacl/amd64p32 上的内存对齐)</span></span><br><span class="line">    overflow <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>
<p>我们会发现哈希桶 bmap 一般指定其能保存 8 个键值对，如果多于 8 个键值对，就会申请新的 buckets，并将其于之前的 buckets 链接在一起。</p>
<p>其中的联系如图所示：<br>
<img src="https://brath.oss-cn-shanghai.aliyuncs.com/pigo/13c1b9f9899d48b08c32b76ef4037a17.png" alt="在这里插入图片描述"></p>
<p>在具体插入时，首先会根据 key 值采用相应的 hash 算法计算对应的哈希值，将哈希值的低 8 位作为 Hmap 结构体中 buckets 数组的索引，找到 key 值所对应的 bucket，将哈希值的高 8 位催出在 bucket 的 tophash 中。</p>
<p>特点如下：</p>
<ul>
<li>map 是<strong>无序的</strong>（原因为无序写入以及扩容导致的元素顺序发生变化），每次打印出来的 map 都会不一样，它不能通过 index 获取，而必须通过 key 获取</li>
<li>map 的<strong>长度是不固定</strong>的，也就是和 slice 一样，也是一种引用类型</li>
<li>内置的 len 函数同样适用于 map，返回 map 拥有的 key 的数量</li>
<li>map 的 key 可以是所有可比较的类型，如布尔型、整数型、浮点型、复杂型、字符串型…… 也可以键。</li>
</ul>
<p>如下方式即可进行初始化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">map</span>[keytype]valuetype</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>类型名</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>map 表名字</td>
</tr>
<tr>
<td>keytype</td>
<td>键类型</td>
</tr>
<tr>
<td>valuetype</td>
<td>键对应的值的类型</td>
</tr>
</tbody>
</table>
<p>除此以外还可以使用 make 进行初始化，代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map_variable = <span class="built_in">make</span>(<span class="keyword">map</span>[key_data_type]value_data_type)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>我们还可以使用初始值进行初始化，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;hunter&quot;</span>:<span class="number">12</span>,<span class="string">&quot;tony&quot;</span>:<span class="number">10</span>&#125;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="3111-插入数据"><a class="markdownIt-Anchor" href="#3111-插入数据">#</a> 3.11.1 插入数据</h3>
<p>map 的数据插入代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map_variable[<span class="string">&quot;mars&quot;</span>] = <span class="number">27</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>插入过程如下：</p>
<ol>
<li>根据 key 值计算出哈希值</li>
<li>取哈希值低位和 hmap.B 取模确定 bucket 位置</li>
<li>查找该 key 是否已经存在，如果存在则直接更新值</li>
<li>如果没有找到 key，则将这一对 key-value 插入</li>
</ol>
<h3 id="3112-删除数据"><a class="markdownIt-Anchor" href="#3112-删除数据">#</a> 3.11.2 删除数据</h3>
<p><strong>delete(map, key)</strong> 函数用于删除集合的元素，参数为 map 和其对应的 key。删除函数不返回任何值。相关代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   countryCapitalMap := <span class="keyword">map</span>[<span class="type">string</span>] <span class="type">string</span> &#123;<span class="string">&quot;France&quot;</span>:<span class="string">&quot;Paris&quot;</span>,<span class="string">&quot;Italy&quot;</span>:<span class="string">&quot;Rome&quot;</span>,<span class="string">&quot;Japan&quot;</span>:<span class="string">&quot;Tokyo&quot;</span>,<span class="string">&quot;India&quot;</span>:<span class="string">&quot;New Delhi&quot;</span>&#125;</span><br><span class="line">   <span class="comment">/* 删除元素 */</span></span><br><span class="line">   <span class="built_in">delete</span>(countryCapitalMap,<span class="string">&quot;France&quot;</span>);</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<h3 id="3113-查找数据"><a class="markdownIt-Anchor" href="#3113-查找数据">#</a> 3.11.3 查找数据</h3>
<p>通过 key 获取 map 中对应的 value 值。语法为： <code>map[key] </code> . 但是当 key 如果不存在的时候，我们会得到该 value 值类型的默认值，比如 string 类型得到空字符串，int 类型得到 0。但是程序不会报错。</p>
<p>所以我们可以使用<strong> ok-idiom</strong> 获取值，如下： <code>value, ok := map[key] </code> ，其中的 value 是返回值，ok 是一个 bool 值，可知道 key/value 是否存在。</p>
<p>在 map 表中的查找过程如下：</p>
<ol>
<li>查找或者操作 map 时，首先 key 经过 hash 函数生成 hash 值</li>
<li>通过哈希值的低 8 位来判断当前数据属于哪个桶</li>
<li>找到桶之后，通过哈希值的高八位与 bucket 存储的高位哈希值循环比对</li>
<li>如果相同就比较刚才找到的底层数组的 key 值，如果 key 相同，取出 value</li>
<li>如果高八位 hash 值在此 bucket 没有，或者有，但是 key 不相同，就去链表中下一个溢出 bucket 中查找，直到查找到链表的末尾</li>
<li>如果查找不到，也不会返回空值，而是返回相应类型的 0 值。</li>
</ol>
<h3 id="3114-扩容"><a class="markdownIt-Anchor" href="#3114-扩容">#</a> 3.11.4 扩容</h3>
<p>哈希表就是以空间换时间，访问速度是直接跟填充因子相关的，所以当哈希表太满之后就需要进行扩容。</p>
<p>如果扩容前的哈希表大小为 2B 扩容之后的大小为 2 (B+1)，每次扩容都变为<strong>原来大小的两倍</strong>，哈希表大小始终为 2 的指数倍，则有 (hash mod 2B) 等价于 (hash &amp; (2B-1))。这样可以简化运算，避免了取余操作。</p>
<blockquote>
<p>触发扩容的条件？</p>
</blockquote>
<ol>
<li>负载因子 (负载因子 = 键数量 /bucket 数量) &gt; 6.5 时，也即平均每个 bucket 存储的键值对达到 6.5 个。</li>
<li>溢出桶（overflow）数量 &gt; 2^15 时，也即 overflow 数量超过 32768 时。</li>
</ol>
<blockquote>
<p>什么是增量扩容呢？</p>
</blockquote>
<p>如果负载因子 &gt; 6.5 时，进行增量扩容。这时会新建一个桶（bucket），新的 bucket 长度是原来的 2 倍，然后旧桶数据搬迁到新桶。每个旧桶的键值对都会分流到两个新桶中</p>
<p>主要是缩短 map 容器的响应时间。假如我们直接将 map 用作某个响应实时性要求非常高的 web 应用存储，如果不采用增量扩容，当 map 里面存储的元素很多之后，扩容时系统就会卡往，导致较长一段时间内无法响应请求。不过增量扩容本质上还是将总的扩容时间分摊到了每一次哈希操作上面。</p>
<blockquote>
<p>什么是等量扩容？它的触发条件是什么？进行等量扩容后的优势是什么？</p>
</blockquote>
<p>等量扩容，就是创建和旧桶数目一样多的新桶，然后把原来的键值对迁移到新桶中，重新做一遍类似增量扩容的搬迁动作。</p>
<p>触发条件：负载因子没超标，溢出桶较多。这个较多的评判标准为：</p>
<ul>
<li>如果常规桶数目不大于 2^15，那么使用的溢出桶数目超过常规桶就算是多了；</li>
<li>如果常规桶数目大于 215，那么使用溢出桶数目一旦超过 215 就算多了。</li>
</ul>
<p>这样做的目的是把松散的键值对重新排列一次，能够存储的更加紧凑，进而减少溢出桶的使用，以使 bucket 的使用率更高，进而保证更快的存取。</p>
<h1 id="4-常用语句及关键字"><a class="markdownIt-Anchor" href="#4-常用语句及关键字">#</a> 4. 常用语句及关键字</h1>
<p>接下来我们了解一下关于 go 语言语句的基本内容。</p>
<h2 id="41-条件语句"><a class="markdownIt-Anchor" href="#41-条件语句">#</a> 4.1 条件语句</h2>
<p>和 c 语言类似，相关的条件语句如下表所示：</p>
<table>
<thead>
<tr>
<th>语句</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>if 语句</td>
<td>if 语句 由一个布尔表达式后紧跟一个或多个语句组成。</td>
</tr>
<tr>
<td>if…else 语句</td>
<td>if 语句 后可以使用可选的 else 语句，else 语句中的表达式在布尔表达式为 false 时执行。</td>
</tr>
<tr>
<td>switch 语句</td>
<td>switch 语句用于基于不同条件执行不同动作。</td>
</tr>
<tr>
<td>select 语句</td>
<td>select 语句类似于 switch 语句，但是 select 会随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。</td>
</tr>
</tbody>
</table>
<ul>
<li>if 语句<br>
语法如下：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 布尔表达式 &#123;</span><br><span class="line">   <span class="comment">/* 在布尔表达式为 true 时执行 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<ul>
<li>if-else 语句</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 布尔表达式 &#123;</span><br><span class="line">   <span class="comment">/* 在布尔表达式为 true 时执行 */</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">/* 在布尔表达式为 false 时执行 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>
<ul>
<li>switch 语句<br>
其中的变量 <code>v</code>  可以是任何类型， <code>val1</code>  和 <code>val2</code>  可以是同类型的任意值，类型不局限为常量或者整数，或者最终结果为相同类型的表达式。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> v &#123;</span><br><span class="line">    <span class="keyword">case</span> val1:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> val2:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>
<ul>
<li>select 语句<br>
 select 是 Go 中的一个控制结构，类似于用于通信的 switch 语句。每个 case 必须是一个<strong>通信操作</strong>，要么是发送要么是接收。它将会随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。一个默认的子句应该总是可运行的。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> communication clause  :</span><br><span class="line">       statement(s);      </span><br><span class="line">    <span class="keyword">case</span> communication clause  :</span><br><span class="line">       statement(s);</span><br><span class="line">    <span class="comment">/* 你可以定义任意数量的 case */</span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">/* 可选 */</span></span><br><span class="line">       statement(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
<ul>
<li>每个 case 必须都是一个通信</li>
<li>所有 channel 表达式都会被求值，所有被发送的表达式都会被求值</li>
<li>如果任意某一个通信都可以，它就执行，其他就忽略</li>
<li>如果有多个 case 都可以运行，select 就会随机挑选一个来执行。</li>
<li>如果没有一个 case 可以被运行：如果有 default 子句，就执行 default 子句，select 将被阻塞，直到某个通信可以运行，从而避免饥饿问题。</li>
</ul>
</blockquote>
<h2 id="42-循环语句"><a class="markdownIt-Anchor" href="#42-循环语句">#</a> 4.2 循环语句</h2>
<h3 id="421-循环处理语句"><a class="markdownIt-Anchor" href="#421-循环处理语句">#</a> 4.2.1 循环处理语句</h3>
<p>go 中时使用 for 实现循环的，共有三种形式：</p>
<table>
<thead>
<tr>
<th></th>
<th>语法</th>
</tr>
</thead>
<tbody>
<tr>
<td>和 c 语言中的 for 相同</td>
<td>for init; condition; post {}</td>
</tr>
<tr>
<td>和 c 语言中的 while 相同</td>
<td>for condition{}</td>
</tr>
<tr>
<td>和 c 语言中的 <code>for(;;)</code>  相同</td>
<td>for{}</td>
</tr>
</tbody>
</table>
<p>除此以外，for 循环还可以直接使用<strong> range</strong> 对 slice、map、数组以及字符串等进行迭代循环，格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> oldmap &#123;</span><br><span class="line">	newmap[key] = value</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<h3 id="421-循环控制语句"><a class="markdownIt-Anchor" href="#421-循环控制语句">#</a> 4.2.1 循环控制语句</h3>
<table>
<thead>
<tr>
<th>控制语句</th>
<th>详解</th>
</tr>
</thead>
<tbody>
<tr>
<td>break</td>
<td>中断跳出循环或者 switch 语句</td>
</tr>
<tr>
<td>continue</td>
<td>跳过当前循环的剩余语句，然后继续下一轮循环</td>
</tr>
<tr>
<td>goto 语句</td>
<td>将控制转移到被标记的语句</td>
</tr>
</tbody>
</table>
<ol>
<li>break<br>
break 主要用于循环语句跳出循环，和 c 语言中的使用方式是相同的。且在多重循环的时候还可以使用 label 标出想要 break 的循环。<br>
实例代码如下：</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> a&lt;<span class="number">5</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, a)</span><br><span class="line">	a++</span><br><span class="line">	<span class="keyword">if</span> a==<span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>
<ol>
<li>continue<br>
Go 语言的 continue 语句 有点像 break 语句。但是 continue 不是跳出循环，而是跳过当前循环执行下一次循环语句。在多重循环中，可以用标号 label 标出想 continue 的循环。<br>
实例代码如下：</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 不使用标记</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;---- continue ---- &quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;i: %d\n&quot;</span>, i)</span><br><span class="line">            <span class="keyword">for</span> i2 := <span class="number">11</span>; i2 &lt;= <span class="number">13</span>; i2++ &#123;</span><br><span class="line">                fmt.Printf(<span class="string">&quot;i2: %d\n&quot;</span>, i2)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">i: 1</span></span><br><span class="line"><span class="comment">i2: 11</span></span><br><span class="line"><span class="comment">i2: 12</span></span><br><span class="line"><span class="comment">i2: 13</span></span><br><span class="line"><span class="comment">i: 2</span></span><br><span class="line"><span class="comment">i2: 11</span></span><br><span class="line"><span class="comment">i2: 12</span></span><br><span class="line"><span class="comment">i2: 13</span></span><br><span class="line"><span class="comment">i: 3</span></span><br><span class="line"><span class="comment">i2: 11</span></span><br><span class="line"><span class="comment">i2: 12</span></span><br><span class="line"><span class="comment">i2: 13</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用标记</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;---- continue label ----&quot;</span>)</span><br><span class="line">    re:</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;i: %d&quot;</span>, i)</span><br><span class="line">                <span class="keyword">for</span> i2 := <span class="number">11</span>; i2 &lt;= <span class="number">13</span>; i2++ &#123;</span><br><span class="line">                    fmt.Printf(<span class="string">&quot;i2: %d\n&quot;</span>, i2)</span><br><span class="line">                    <span class="keyword">continue</span> re</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">i: 1</span></span><br><span class="line"><span class="comment">i2: 11</span></span><br><span class="line"><span class="comment">i: 2</span></span><br><span class="line"><span class="comment">i2: 11</span></span><br><span class="line"><span class="comment">i: 3</span></span><br><span class="line"><span class="comment">i2: 11</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435363738394041424344</span></span><br></pre></td></tr></table></figure>
<ol>
<li>goto<br>
goto 语句主要是无条件转移到过程中<strong>指定的行</strong>。goto 语句通常和条件语句配合使用，可用来实现条件转移、构成循环以及跳出循环体等功能。但是并不主张使用 goto 语句，以免造成程序流程混乱。<br>
示例代码如下：</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">0</span></span><br><span class="line">LOOP: <span class="keyword">for</span> a&lt;<span class="number">5</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a == <span class="number">2</span> &#123;</span><br><span class="line">		a = a+<span class="number">1</span></span><br><span class="line">		<span class="keyword">goto</span> LOOP</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, a)</span><br><span class="line">	a++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="number">123456789101112131415161718</span></span><br></pre></td></tr></table></figure>
<p>以上代码中的 LOOP 就是一个标签，当运行到 goto 语句的时候，此时执行流就会跳转到 LOOP 标志的哪一行上。</p>
<h2 id="43-关键字"><a class="markdownIt-Anchor" href="#43-关键字">#</a> 4.3 关键字</h2>
<p>我们这一部分直接列表供大家了解 go 中的关键字如下：</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>import</td>
<td>导入相应的包文件</td>
</tr>
<tr>
<td>package</td>
<td>创建包文件，用于标记该文件归属哪个包</td>
</tr>
<tr>
<td>chan</td>
<td>channal，通道</td>
</tr>
<tr>
<td>var</td>
<td>变量控制，用于简短声明定义变量（:= 符号只能在函数内部使用，不能全局使用）</td>
</tr>
<tr>
<td>const</td>
<td>常量声明，任何时候 const 和 var 都可以同时出现</td>
</tr>
<tr>
<td>func</td>
<td>定义函数和方法</td>
</tr>
<tr>
<td>interface</td>
<td>接口，是一种具有一组方法的类型，这些方法定义了 interface 的行为</td>
</tr>
<tr>
<td>map</td>
<td>哈希表</td>
</tr>
<tr>
<td>struct</td>
<td>定义结构体</td>
</tr>
<tr>
<td>type</td>
<td>声明类型，取别名</td>
</tr>
<tr>
<td>for</td>
<td>for 是 go 中唯一的循环结构，上文中已经介绍过它的用法</td>
</tr>
<tr>
<td>break</td>
<td>中止，跳出循环</td>
</tr>
<tr>
<td>continue</td>
<td>继续下一轮循环</td>
</tr>
<tr>
<td>select</td>
<td>选择流程，可以同时等待多个通道操作</td>
</tr>
<tr>
<td>switch</td>
<td>多分枝选择，上文中已经详细介绍过它的用法</td>
</tr>
<tr>
<td>case</td>
<td>和 switch 配套使用</td>
</tr>
<tr>
<td>default</td>
<td>用于选择结构的默认选型</td>
</tr>
<tr>
<td>defer</td>
<td>用于资源释放，会在函数返回之前进行调用</td>
</tr>
<tr>
<td>if</td>
<td>分支选择</td>
</tr>
<tr>
<td>else</td>
<td>和 if 配套使用</td>
</tr>
<tr>
<td>go</td>
<td>通过 <code>go func()</code>  来开启一个 goroutine</td>
</tr>
<tr>
<td>goto</td>
<td>跳转至标志点的代码块，不推荐使用</td>
</tr>
<tr>
<td>fallthrouth</td>
<td></td>
</tr>
<tr>
<td>range</td>
<td>用于遍历 slice 类型数据</td>
</tr>
<tr>
<td>return</td>
<td>用于标注函数返回值</td>
</tr>
</tbody>
</table>
<h2 id="关于我"><a class="markdownIt-Anchor" href="#关于我">#</a> 关于我</h2>
<p>Brath 是一个热爱技术的 Java 程序猿，公众号「InterviewCoder」定期分享有趣有料的精品原创文章！</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png" alt="InterviewCoder"></p>
<p>非常感谢各位人才能看到这里，原创不易，文章如果有帮助可以关注、点赞、分享或评论，这都是对我的莫大支持！</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Go语言超全详解（入门级）</p><p><a href="http://example.com/2021/05/17/【Go】Go语言超全详解(入门级)/">http://example.com/2021/05/17/【Go】Go语言超全详解(入门级)/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Brath</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-05-17</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2022-02-11</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="sharethis-inline-share-buttons"></div><script src="https://brath.cn" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="https://brath.cloud/zfb.jpg" alt="支付宝"></span></a><a class="button donate" href="https://brath.cloud/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E5%AE%9D%E4%BA%8C%E5%90%88%E4%B8%80.png" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a><a class="button donate" href="https://brath.cloud/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E5%AE%9D%E4%BA%8C%E5%90%88%E4%B8%80.png" target="_blank" rel="noopener" data-type="patreon"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="https://brath.cloud/wx.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/05/24/%E3%80%90ElasticSearch%E3%80%91ElasticSearch%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">ElasticSearch 处理检索海量数据“神器”？</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/05/11/%E3%80%90Docker%E3%80%91Docker%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2Reids%E9%95%9C%E5%83%8F%E4%BD%9C%E4%B8%BA%E4%BB%8E%E8%8A%82%E7%82%B9/"><span class="level-item">Docker环境部署Reids镜像作为从节点</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="SOHUCS" sid="2021/05/17/【Go】Go语言超全详解(入门级)/"></div><script charset="utf-8" src="https://changyan.sohu.com/upload/changyan.js"></script><script>window.changyan.api.config({appid: 'cywzQRCbe',conf: '485cd826ef6d780dcea71d0f3b37304a'});</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-27T09:20:49.000Z">2023-04-27</time></p><p class="title"><a href="/2023/04/27/%E3%80%90Dubbo%E3%80%91Dubbo%E8%AF%A6%E8%A7%A3%EF%BC%8C%E7%94%A8%E5%BF%83%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91/">【Dubbo】Dubbo详解，用心看这一篇文章就够了【重点】</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-27T09:20:49.000Z">2023-04-27</time></p><p class="title"><a href="/2023/04/27/%E3%80%90MySql%E3%80%9121%E4%B8%AAMySQL%E8%A1%A8%E8%AE%BE%E8%AE%A1%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%87%86%E5%88%99/">【MySql】21个MySQL表设计的经验准则</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-27T09:20:49.000Z">2023-04-27</time></p><p class="title"><a href="/2023/04/27/%E3%80%90Zookeeper%E3%80%91Zookeeper%E5%85%A5%E9%97%A8%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/">【Zookeeper】Zookeeper入门看这篇就够了</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-27T09:20:48.000Z">2023-04-27</time></p><p class="title"><a href="/2023/04/27/%E3%80%90Log4J%E3%80%91JAVA%E5%AE%89%E5%85%A8--log4j%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6%E5%88%86%E6%9E%90/">【Log4J】JAVA安全--log4j漏洞研究分析</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-27T09:20:48.000Z">2023-04-27</time></p><p class="title"><a href="/2023/04/27/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%9123%20%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%88%E5%85%A823%E7%A7%8D%EF%BC%89/">【设计模式】23 种设计模式详解（全23种）</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">31</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/"><span class="level-start"><span class="level-item">2022</span></span><span class="level-end"><span class="level-item tag">51</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/"><span class="level-start"><span class="level-item">2021</span></span><span class="level-end"><span class="level-item tag">44</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/"><span class="level-start"><span class="level-item">2020</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png" alt="InterviewCoder"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">InterviewCoder</p><p class="is-size-6 is-block">面试记官方公众号</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">133</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://mp.weixin.qq.com/s/jWs6lLHl5L-atXJhHc4YvA" target="_blank" rel="noopener">关注我</a></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://brath.cloud/me.png" alt="Brath"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Brath</p><p class="is-size-6 is-block">技能改变人生，知识改变命运。</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·江苏·无锡</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">133</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Guoqing815" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Guoqing815"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Gitee" href="https://gitee.com/Guoqing-Li"><i class="fab fa-gitee"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://schokolade.cn/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">泠灵(特别呜谢)</span></span><span class="level-right"><span class="level-item tag">schokolade.cn</span></span></a></li><li><a class="level is-mobile" href="https://gitee.com/Guoqing-Li" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Gitee(码云)</span></span><span class="level-right"><span class="level-item tag">gitee.com</span></span></a></li><li><a class="level is-mobile" href="https://blog.csdn.net/Brath?type=blog" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">CSDN</span></span><span class="level-right"><span class="level-item tag">blog.csdn.net</span></span></a></li><li><a class="level is-mobile" href="https://juejin.cn/user/settings/profile" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">掘金</span></span><span class="level-right"><span class="level-item tag">juejin.cn</span></span></a></li><li><a class="level is-mobile" href="https://oss.console.aliyun.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">AliCloud(阿里云)</span></span><span class="level-right"><span class="level-item tag">oss.console.aliyun.com</span></span></a></li><li><a class="level is-mobile" href="https://cloud.tencent.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">TencentCloud(腾讯云)</span></span><span class="level-right"><span class="level-item tag">cloud.tencent.com</span></span></a></li><li><a class="level is-mobile" href="https://www.zhipin.com/web/user/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">BOSS</span></span><span class="level-right"><span class="level-item tag">www.zhipin.com</span></span></a></li><li><a class="level is-mobile" href="https://www.bilibili.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bilibili(B站)</span></span><span class="level-right"><span class="level-item tag">www.bilibili.com</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://brath.cloud/me.png" alt="Brath-Blog" height="28"></a><p class="is-size-7"><span>&copy; 2023 Brath</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p><p class="is-size-7">© 2029</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>