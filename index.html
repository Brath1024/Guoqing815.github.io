<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Brath-Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Brath-Blog"><meta name="msapplication-TileImage" content="https://brath.cloud/avatar.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Brath-Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Brath-Blog"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="Brath-Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="Brath"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"Brath-Blog","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"Brath"},"publisher":{"@type":"Organization","name":"Brath-Blog","logo":{"@type":"ImageObject","url":"https://brath.cloud/avatar.png"}},"description":""}</script><link rel="icon" href="https://brath.cloud/avatar.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://brath.cloud/avatar.png" alt="Brath-Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">主页</a><a class="navbar-item" href="/archives">文章列表</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">更多</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Guoqing815"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-05-23T02:04:23.000Z" title="2023-5-23 10:04:23">2023-05-23</time>发表</span><span class="level-item"><time dateTime="2023-06-05T07:22:15.429Z" title="2023-6-5 15:22:15">2023-06-05</time>更新</span><span class="level-item">9 分钟读完 (大约1318个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/05/23/%E3%80%90Linux%E3%80%91%E9%98%BF%E9%87%8C%E4%BA%91linux%20%E6%8C%82%E8%BD%BD%E6%95%B0%E6%8D%AE%E7%9B%98%E5%B9%B6docker%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%E8%BF%81%E7%A7%BB%E5%88%B0%E6%95%B0%E6%8D%AE%E7%9B%98/">【Linux】阿里云linux 挂载数据盘并docker工作目录迁移到数据盘</a></p><div class="content"><p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png" alt="InterviewCoder"></p>
<h1 id="linux阿里云linux-挂载数据盘并docker工作目录迁移到数据盘"><a class="markdownIt-Anchor" href="#linux阿里云linux-挂载数据盘并docker工作目录迁移到数据盘">#</a> 【Linux】阿里云 linux 挂载数据盘并 docker 工作目录迁移到数据盘</h1>
<p><strong>一、挂载数据盘，分区 - 格式化 - 挂载</strong></p>
<p>1、fdisk -l 查看磁盘情况</p>
<p>执行命令 fdisk -l 发现 2 个磁盘，但是磁盘 nvme1n1 没有分区，nvme0n1 是有 2 个分区了。</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/cceb22f4006cbef75fcd0469ee6f66b4.png" alt="img"></p>
<p>2、fdisk /dev/nvme1n1 执行创建分区</p>
<p>执行命令 fdisk /dev/nvme1n1</p>
<p>输入 n 再回车创建新分区：</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/549659e940ec22bb06edfaaff24fbcb9.png" alt="img"></p>
<p>输入 p 再回车创建主分区：</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/b74a9ade7fe427394a9fd29c1341185d.png" alt="img"></p>
<p>输入 1 设置分区号：</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/65ef7ff6d5b47dda182b008d7a76bf7a.png" alt="img"></p>
<p>起始扇区设置，直接回车就可以：</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/49ba78c89a3adc99c197d3f86b1bfa0d.png" alt="img"></p>
<p>扇区结束位置，直接回车就可以：</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/f90577aa65369904459b9d92c6812f42.png" alt="img"></p>
<p>最后输入 w 再回车保存设置：</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/14aff319e909413dd137a79ecdaa5f5c.png" alt="img"></p>
<p>3、格式化分区</p>
<p>运行 fdisk -lu /dev/nvme1n1 查看分区情况</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/e66c56ebcc4ff70a98e0d896e6c79a48.png" alt="img"></p>
<p>格式化分区，并建立文件系统 ext4。 执行命令：sudo mkfs.ext4 /dev/nvme1n1p1</p>
<p>注意：也有人说硬盘应该是买来就已经格式化过了的，说的好像也有那么些道理。但是我现在是 nvme1n1 这个硬盘根本看不到分区的情况下创建了一个新的分区 nvme1n1p1 ，格式化一下这个分区我个人认为也没错。</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/0bac4af4597d43a13aa40c2c6bd37287.png" alt="img"></p>
<p>4、挂载分区</p>
<p>执行命令：sudo mount /dev/nvme1n1p1 /mnt 将分区 /dev/nvme1n1p1 挂载到 mnt 目录下。</p>
<p>然后执行 df 查看是否挂载成功 ，执行 df -Th 查看新挂载的磁盘文件系统和其他磁盘是否一致。</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/06cef34afe1a743950a164cd40fe272f.png" alt="img"></p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/924b718ee9c86531e0221e614998cf05.png" alt="img"></p>
<p>5、设置开机自动挂载</p>
<p>sudo vim /etc/fstab 使用这个命令进入 配置文件，然后按 i 键进入插入编辑模式</p>
<p>在文件末尾增加下面的一行</p>
<p>/dev/nvme1n1p1 /mnt ext4 defaults 0 0</p>
<p>按 esc 退出编辑，输入 :wq 保存退出。</p>
<p><strong>二、docker 目录从系统盘迁移到数据盘</strong></p>
<p>1、确认已经将 /dev/nvme1n1 这个数据硬盘的 /dev/nvme1n1p1 分区挂载到了 mnt 目录</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/06cef34afe1a743950a164cd40fe272f.png" alt="img"></p>
<p>2、执行 docker info 命令，得到 docker 基本信息，其中可以看到 Docker Root Dir: /var/lib/docker 和 Storage Driver: overlay2 这两个信息，说明了 docker 程序文件安装在 /var/lib/docker，其中 overlay2 为数据存储位置。</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/a2885575e1d6701f9d340f19e6ef7b2f.png" alt="img"></p>
<p>3、先停止 Docker ，保证移动的时候数据完整，执行 service docker stop 命令停止 Docker daemon。 命令：systemctl stop docker</p>
<p>可以用 ps 命令进一步检查：ps faux | grep -i docker</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/dd32ff8fb25e4b37f053b51533f4f896.png" alt="img"></p>
<p>4、将 Docker 默认数据目录下的数据移动到一个备份的目录，例如 /mnt/Docker_data，执行命令:</p>
<p>mv /var/lib/docker /mnt/Docker_data</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/7080e757f909be46d25c0402119f9b70.png" alt="img"></p>
<p>5、把 Docker 的工作目录切换到 /mnt/Docker_data/docker</p>
<p>（1）更改 Docker 服务的 service 文件： vi /lib/systemd/system/docker.service</p>
<p>（2）使用输入 /<em>ExecSt</em>art 搜索关键字 ， 找到这一行：ExecStart=/usr/bin/dockerd -H fd://--containerd=/run/containerd/containerd.sock</p>
<p>改为：<em>ExecSt</em>art=/usr/bin/dockerd -g /mnt/Docker_data/docker -H fd:// --containerd=/run/containerd/containerd.sock</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/3132eaca23c769fef0fc97685485249b.png" alt="img"></p>
<p>(3) 刷新 docker 服务 ：<em>sudo s</em>ystemctl daemon-reload</p>
<p>重启 docker 服务：<em>system</em>ctl start docker</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/455d262fec86518eda5c68c77bc3464e.png" alt="img"></p>
<p>(4) 查看 docker 状态：systemctl status docker</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/e4859b458ec4262825ca347decd46183.png" alt="img"></p>
<p>注意 ：如果查看状态出现了失败的红色的提示，那么就要返回第 3 步停止服务开始，再走一遍步骤，重新修改 Docker 服务的 service 文件，比如我开始的时候 - H 前面少了一个空格，就报红色错误了。</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/b50944f9ba4c5ee837e8ab64113b002a.png" alt="img"></p>
<h2 id="关于我"><a class="markdownIt-Anchor" href="#关于我">#</a> 关于我</h2>
<p>Brath 是一个热爱技术的 Java 程序猿，公众号「InterviewCoder」定期分享有趣有料的精品原创文章！</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png" alt="InterviewCoder"></p>
<p>非常感谢各位人才能看到这里，原创不易，文章如果有帮助可以关注、点赞、分享或评论，这都是对我的莫大支持！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-05-23T02:04:23.000Z" title="2023-5-23 10:04:23">2023-05-23</time>发表</span><span class="level-item"><time dateTime="2023-06-05T07:31:10.671Z" title="2023-6-5 15:31:10">2023-06-05</time>更新</span><span class="level-item">1 小时读完 (大约8834个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/05/23/%E3%80%90Seata%E3%80%91%E6%9D%A5%E8%87%AA%E9%98%BF%E9%87%8C%E5%BC%80%E6%BA%90%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A1%86%E6%9E%B6-Seata%E7%9A%84%E5%8E%9F%E7%90%86/">【Seata】来自阿里开源分布式事务框架-Seata的原理</a></p><div class="content"><p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png" alt="InterviewCoder"></p>
<h1 id="seata来自阿里开源分布式事务框架-seata的原理"><a class="markdownIt-Anchor" href="#seata来自阿里开源分布式事务框架-seata的原理">#</a> 【Seata】来自阿里开源分布式事务框架 - Seata 的原理</h1>
<p>首先  <code>Seata</code>  客户端启动一般分为以下几个流程：</p>
<ol>
<li>自动加载 Bean 属性和配置信息</li>
<li>初始化 TM</li>
<li>初始化 RM</li>
<li>初始化分布式事务客户端完成，完成代理数据库配置</li>
<li>连接 TC (Seata 服务端)，注册 RM 和 TM</li>
<li>开启全局事务</li>
</ol>
<p>在这篇源码的讲解中，我们主要以 AT 模式为主导，官网也是主推 AT 模式，我们在上篇的文章中也讲解过，感兴趣的小伙伴可以去看一看<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA4MjM0MTQ1Mg==&amp;mid=2458786001&amp;idx=1&amp;sn=98f3b3c5d211f60a803446913fbb12e3&amp;chksm=88fd83f2bf8a0ae4b2682af7b15f9493c33d7771a066d1eb1c73583cfc67da891cffa1c9f55c&amp;token=1008440856&amp;lang=zh_CN#rd">分布式事务 (Seata) 四大模式详解</a>，在官网中也提供了对应的流程地址：<a target="_blank" rel="noopener" href="https://seata.io/zh-cn/docs/dev/mode/at-mode.html">https://seata.io/zh-cn/docs/dev/mode/at-mode.html</a> ，在这里我们只是做一些简单的介绍，AT 模式主要分为两个阶段：</p>
<p><strong>一阶段：</strong></p>
<ul>
<li>解析 SQL，获取 SQL 类型（CRUD）、表信息、条件 (where) 等相关信息</li>
<li>查询前镜像 (改变之前的数据)，根据解析得到的条件信息，生成查询语句，定位数据</li>
<li>执行业务 SQL，更新数据</li>
<li>查询后镜像（改变后的数据），根据前镜像的结果，通过主键都给你为数据</li>
<li>插入回滚日志，将前后镜像数据以及业务 SQL 等信息，组织成一条回滚日志记录，插入到 undo Log 表中</li>
<li>提交前，向 TC 注册分支，申请全局锁</li>
<li>本地事务提交，业务数据的更细腻和生成的 undoLog 一起提交</li>
<li>将本地事务提交的结果通知给 TC</li>
</ul>
<p><strong>二阶段：</strong></p>
<p>如果 TC 收到的是回滚请求</p>
<ul>
<li>开启本地事务，通过 XID 和 BranchID 查找到对应的 undo Log 记录</li>
<li>根据 undoLog 中的前镜像和业务 SQL 的相关信息生成并执行回滚语句</li>
<li>提交本地事务，将本地事务的执行结果（分支事务回滚的信息）通知给 TC</li>
</ul>
<p>如果没问题，执行提交操作</p>
<ul>
<li>收到 TC 分支提交请求，将请求放入到一个异步任务的队列中，马上返回提交成功的结果给 TC</li>
<li>异步任务阶段的分支提交请求删除 undoLog 中记录</li>
</ul>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/6b4a6708a964d51d954cec9fb660b72f.png" alt="img"></p>
<h2 id="源码入口"><a class="markdownIt-Anchor" href="#源码入口">#</a> 源码入口</h2>
<p>接下来，我们就需要从官网中去下载源码，下载地址：<a target="_blank" rel="noopener" href="https://seata.io/zh-cn/blog/download.html%EF%BC%8C%E9%80%89%E6%8B%A9">https://seata.io/zh-cn/blog/download.html，选择</a>  <code>source</code>  即可，下载完成之后，通过 IDEA 打开项目。</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/bdca1226de54c44b76fbcb81ad5203ec.png" alt="img"></p>
<p>源码下载下来之后，我们应该如何去找入口呢？首先我们需要找到对应引入的  <code>Seata</code>  包  <code>spring-alibaba-seata</code> ，我们在回想一下，我们开启事务的时候，是不是添加过一个 <code>@GlobalTransactional</code>  的注解，这个注解就是我们入手的一个点，我们在  <code>spring.factories</code>  中看到有一个  <code>GlobalTransactionAutoConfiguration</code> ，这个就是我们需要关注的点，也就是我们源码的入口</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/23af43bca4492008ae3b80c10bd77c4f.png" alt="img"></p>
<p>在  <code>GlobalTransactionAutoConfiguration</code>  中我们找到一个用 Bean 注入的方法  <code>globalTransactionScanner</code> ，这个就是全局事务扫描器，这个类型主要负责加载配置，注入相关的 Bean</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/0f9703310464018bedfecc661d4c4e91.png" alt="img"></p>
<p>这里给大家展示了当前 GlobalTransactionScanner 的类关系图，其中我们现在继承了 Aop 的 AbstractAutoProxyCreator 类型，在这其中有一个重点方法，这个方法就是判断 Bean 对象是否需要代理，是否需要增强。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(SeataProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalTransactionAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//全局事务扫描器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> GlobalTransactionScanner <span class="title function_">globalTransactionScanner</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="type">String</span> <span class="variable">applicationName</span> <span class="operator">=</span> applicationContext.getEnvironment()</span><br><span class="line">          .getProperty(<span class="string">&quot;spring.application.name&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="type">String</span> <span class="variable">txServiceGroup</span> <span class="operator">=</span> seataProperties.getTxServiceGroup();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (StringUtils.isEmpty(txServiceGroup)) &#123;</span><br><span class="line">        txServiceGroup = applicationName + <span class="string">&quot;-fescar-service-group&quot;</span>;</span><br><span class="line">        seataProperties.setTxServiceGroup(txServiceGroup);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 构建全局扫描器，传入参数：应用名、事务分组名，失败处理器</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GlobalTransactionScanner</span>(applicationName, txServiceGroup);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这其中我们要关心的是  <code>GlobalTransactionScanner</code>  这个类型，这个类型扫描  <code>@GlobalTransactional</code>  注解，并对代理方法进行拦截增强事务的功能。我们就从源码中搜索这个 <code>GlobalTransactionScanner</code>  类，看看里面具体是做了什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The type Global transaction scanner.</span></span><br><span class="line"><span class="comment"> * 全局事务扫描器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> slievrly</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalTransactionScanner</span></span><br><span class="line">        <span class="comment">//AbstractAutoProxyCreator AOP动态代理 增强Bean</span></span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">AbstractAutoProxyCreator</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * ConfigurationChangeListener: 监听器基准接口</span></span><br><span class="line"><span class="comment">         * InitializingBean： Bean初始化</span></span><br><span class="line"><span class="comment">         * ApplicationContextAware： Spring容器</span></span><br><span class="line"><span class="comment">         * DisposableBean： Spring 容器销毁</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">ConfigurationChangeListener</span>, InitializingBean, ApplicationContextAware, DisposableBean &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String applicationId;<span class="comment">//服务名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String txServiceGroup;<span class="comment">//事务分组        </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//启动日志</span></span><br><span class="line">        <span class="keyword">if</span> (LOGGER.isInfoEnabled()) &#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;Initializing Global Transaction Clients ... &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查应用名以及事务分组名，为空抛出异常IllegalArgumentException</span></span><br><span class="line">        <span class="keyword">if</span> (DEFAULT_TX_GROUP_OLD.equals(txServiceGroup)) &#123;</span><br><span class="line">            LOGGER.warn(<span class="string">&quot;the default value of seata.tx-service-group: &#123;&#125; has already changed to &#123;&#125; since Seata 1.5, &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;please change your default configuration as soon as possible &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;and we don&#x27;t recommend you to use default tx-service-group&#x27;s value provided by seata&quot;</span>,</span><br><span class="line">                    DEFAULT_TX_GROUP_OLD, DEFAULT_TX_GROUP);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNullOrEmpty(applicationId) || StringUtils.isNullOrEmpty(txServiceGroup)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format(<span class="string">&quot;applicationId: %s, txServiceGroup: %s&quot;</span>, applicationId, txServiceGroup));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//init TM</span></span><br><span class="line">        <span class="comment">//初始化TM</span></span><br><span class="line">        TMClient.init(applicationId, txServiceGroup, accessKey, secretKey);</span><br><span class="line">        <span class="keyword">if</span> (LOGGER.isInfoEnabled()) &#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;Transaction Manager Client is initialized. applicationId[&#123;&#125;] txServiceGroup[&#123;&#125;]&quot;</span>, applicationId, txServiceGroup);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//init RM</span></span><br><span class="line">        <span class="comment">//初始化RM</span></span><br><span class="line">        RMClient.init(applicationId, txServiceGroup);</span><br><span class="line">        <span class="keyword">if</span> (LOGGER.isInfoEnabled()) &#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;Resource Manager is initialized. applicationId[&#123;&#125;] txServiceGroup[&#123;&#125;]&quot;</span>, applicationId, txServiceGroup);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LOGGER.isInfoEnabled()) &#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;Global Transaction Clients are initialized. &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        registerSpringShutdownHook();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (disableGlobalTransaction) &#123;</span><br><span class="line">            <span class="keyword">if</span> (LOGGER.isInfoEnabled()) &#123;</span><br><span class="line">                LOGGER.info(<span class="string">&quot;Global transaction is disabled.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ConfigurationCache.addConfigListener(ConfigurationKeys.DISABLE_GLOBAL_TRANSACTION,</span><br><span class="line">                    (ConfigurationChangeListener)<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (initialized.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">            initClient();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//启动日志</span></span><br><span class="line">        <span class="keyword">if</span> (LOGGER.isInfoEnabled()) &#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;Initializing Global Transaction Clients ... &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查应用名以及事务分组名，为空抛出异常IllegalArgumentException</span></span><br><span class="line">        <span class="keyword">if</span> (DEFAULT_TX_GROUP_OLD.equals(txServiceGroup)) &#123;</span><br><span class="line">            LOGGER.warn(<span class="string">&quot;the default value of seata.tx-service-group: &#123;&#125; has already changed to &#123;&#125; since Seata 1.5, &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;please change your default configuration as soon as possible &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;and we don&#x27;t recommend you to use default tx-service-group&#x27;s value provided by seata&quot;</span>,</span><br><span class="line">                    DEFAULT_TX_GROUP_OLD, DEFAULT_TX_GROUP);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检查应用名以及事务分组名，为空抛出异常IllegalArgumentException</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNullOrEmpty(applicationId) || StringUtils.isNullOrEmpty(txServiceGroup)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format(<span class="string">&quot;applicationId: %s, txServiceGroup: %s&quot;</span>, applicationId, txServiceGroup));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//init TM</span></span><br><span class="line">        <span class="comment">//初始化TM</span></span><br><span class="line">        TMClient.init(applicationId, txServiceGroup, accessKey, secretKey);</span><br><span class="line">        <span class="keyword">if</span> (LOGGER.isInfoEnabled()) &#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;Transaction Manager Client is initialized. applicationId[&#123;&#125;] txServiceGroup[&#123;&#125;]&quot;</span>, applicationId, txServiceGroup);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//init RM</span></span><br><span class="line">        <span class="comment">//初始化RM</span></span><br><span class="line">        RMClient.init(applicationId, txServiceGroup);</span><br><span class="line">        <span class="keyword">if</span> (LOGGER.isInfoEnabled()) &#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;Resource Manager is initialized. applicationId[&#123;&#125;] txServiceGroup[&#123;&#125;]&quot;</span>, applicationId, txServiceGroup);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LOGGER.isInfoEnabled()) &#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;Global Transaction Clients are initialized. &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        registerSpringShutdownHook();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//代理增强，Spring 所有的Bean都会经过这个方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> &#123;</span><br><span class="line">        <span class="comment">// do checkers</span></span><br><span class="line">        <span class="comment">//检查bean和beanName</span></span><br><span class="line">        <span class="keyword">if</span> (!doCheckers(bean, beanName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//加锁防止并发</span></span><br><span class="line">            <span class="keyword">synchronized</span> (PROXYED_SET) &#123;</span><br><span class="line">                <span class="keyword">if</span> (PROXYED_SET.contains(beanName)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> bean;</span><br><span class="line">                &#125;</span><br><span class="line">                interceptor = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">//check TCC proxy</span></span><br><span class="line">                <span class="comment">//检查是否为TCC模式</span></span><br><span class="line">                <span class="keyword">if</span> (TCCBeanParserUtils.isTccAutoProxy(bean, beanName, applicationContext)) &#123;</span><br><span class="line">                    <span class="comment">// init tcc fence clean task if enable useTccFence</span></span><br><span class="line">                    <span class="comment">//如果启用useTccFence 失败 ，则初始化TCC清理任务</span></span><br><span class="line">                    TCCBeanParserUtils.initTccFenceCleanTask(TCCBeanParserUtils.getRemotingDesc(beanName), applicationContext);</span><br><span class="line">                    <span class="comment">//TCC interceptor, proxy bean of sofa:reference/dubbo:reference, and LocalTCC</span></span><br><span class="line">                    <span class="comment">//如果是，添加TCC拦截器</span></span><br><span class="line">                    interceptor = <span class="keyword">new</span> <span class="title class_">TccActionInterceptor</span>(TCCBeanParserUtils.getRemotingDesc(beanName));</span><br><span class="line">                    ConfigurationCache.addConfigListener(ConfigurationKeys.DISABLE_GLOBAL_TRANSACTION,</span><br><span class="line">                            (ConfigurationChangeListener)interceptor);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//不是TCC</span></span><br><span class="line">                    Class&lt;?&gt; serviceInterface = SpringProxyUtils.findTargetClass(bean);</span><br><span class="line">                    Class&lt;?&gt;[] interfacesIfJdk = SpringProxyUtils.findInterfaces(bean);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//判断是否有相关事务注解，如果没有不进行代理</span></span><br><span class="line">                    <span class="keyword">if</span> (!existsAnnotation(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;serviceInterface&#125;)</span><br><span class="line">                        &amp;&amp; !existsAnnotation(interfacesIfJdk)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> bean;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//发现存在全局事务注解标注的Bean对象，添加拦截器</span></span><br><span class="line">                    <span class="keyword">if</span> (globalTransactionalInterceptor == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//添加拦截器</span></span><br><span class="line">                        globalTransactionalInterceptor = <span class="keyword">new</span> <span class="title class_">GlobalTransactionalInterceptor</span>(failureHandlerHook);</span><br><span class="line">                        ConfigurationCache.addConfigListener(</span><br><span class="line">                                ConfigurationKeys.DISABLE_GLOBAL_TRANSACTION,</span><br><span class="line">                                (ConfigurationChangeListener)globalTransactionalInterceptor);</span><br><span class="line">                    &#125;</span><br><span class="line">                    interceptor = globalTransactionalInterceptor;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                LOGGER.info(<span class="string">&quot;Bean[&#123;&#125;] with name [&#123;&#125;] would use interceptor [&#123;&#125;]&quot;</span>, bean.getClass().getName(), beanName, interceptor.getClass().getName());</span><br><span class="line">                <span class="comment">//检查是否为代理对象</span></span><br><span class="line">                <span class="keyword">if</span> (!AopUtils.isAopProxy(bean)) &#123;</span><br><span class="line">                    <span class="comment">//不是代理对象，调用父级</span></span><br><span class="line">                    bean = <span class="built_in">super</span>.wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//是代理对象，反射获取代理类中已经存在的拦截器组合，然后添加到这个集合中</span></span><br><span class="line">                    <span class="type">AdvisedSupport</span> <span class="variable">advised</span> <span class="operator">=</span> SpringProxyUtils.getAdvisedSupport(bean);</span><br><span class="line">                    Advisor[] advisor = buildAdvisors(beanName, getAdvicesAndAdvisorsForBean(<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>));</span><br><span class="line">                    <span class="type">int</span> pos;</span><br><span class="line">                    <span class="keyword">for</span> (Advisor avr : advisor) &#123;</span><br><span class="line">                        <span class="comment">// Find the position based on the advisor&#x27;s order, and add to advisors by pos</span></span><br><span class="line">                        pos = findAddSeataAdvisorPosition(advised, avr);</span><br><span class="line">                        advised.addAdvisor(pos, avr);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                PROXYED_SET.add(beanName);</span><br><span class="line">                <span class="keyword">return</span> bean;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exx) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(exx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">InitializingBean`：中实现了一个 `afterPropertiesSet()`方法，在这个方法中，调用了`initClient()</span><br></pre></td></tr></table></figure>
<p><code>AbstractAutoProxyCreator</code> ：APO 动态代理，在之前的的 Nacos 和 Sentiel 中都有这个代理类，AOP 在我们越往深入学习，在学习源码的会见到的越来越多，越来越重要，很多相关代理，都是通过 AOP 进行增强，在这个类中，我们需要关注有一个 <code>wrapIfNecessary()</code>  方法， 这个方法主要是判断被代理的 bean 或者类是否需要代理增强，在这个方法中会调用 <code>GlobalTransactionalInterceptor.invoke()</code>  进行带来增强。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalTransactionalInterceptor</span> <span class="keyword">implements</span> <span class="title class_">ConfigurationChangeListener</span>, MethodInterceptor, SeataInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GlobalTransactionalInterceptor</span><span class="params">(FailureHandler failureHandler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.failureHandler = failureHandler == <span class="literal">null</span> ? DEFAULT_FAIL_HANDLER : failureHandler;</span><br><span class="line">        <span class="built_in">this</span>.disable = ConfigurationFactory.getInstance().getBoolean(ConfigurationKeys.DISABLE_GLOBAL_TRANSACTION,</span><br><span class="line">            DEFAULT_DISABLE_GLOBAL_TRANSACTION);</span><br><span class="line">        <span class="built_in">this</span>.order =</span><br><span class="line">            ConfigurationFactory.getInstance().getInt(ConfigurationKeys.TM_INTERCEPTOR_ORDER, TM_INTERCEPTOR_ORDER);</span><br><span class="line">        degradeCheck = ConfigurationFactory.getInstance().getBoolean(ConfigurationKeys.CLIENT_DEGRADE_CHECK,</span><br><span class="line">            DEFAULT_TM_DEGRADE_CHECK);</span><br><span class="line">        <span class="keyword">if</span> (degradeCheck) &#123;</span><br><span class="line">            ConfigurationCache.addConfigListener(ConfigurationKeys.CLIENT_DEGRADE_CHECK, <span class="built_in">this</span>);</span><br><span class="line">            degradeCheckPeriod = ConfigurationFactory.getInstance()</span><br><span class="line">                .getInt(ConfigurationKeys.CLIENT_DEGRADE_CHECK_PERIOD, DEFAULT_TM_DEGRADE_CHECK_PERIOD);</span><br><span class="line">            degradeCheckAllowTimes = ConfigurationFactory.getInstance()</span><br><span class="line">                .getInt(ConfigurationKeys.CLIENT_DEGRADE_CHECK_ALLOW_TIMES, DEFAULT_TM_DEGRADE_CHECK_ALLOW_TIMES);</span><br><span class="line">            EVENT_BUS.register(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (degradeCheckPeriod &gt; <span class="number">0</span> &amp;&amp; degradeCheckAllowTimes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                startDegradeCheck();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.initDefaultGlobalTransactionTimeout();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(<span class="keyword">final</span> MethodInvocation methodInvocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//获取执行的方法</span></span><br><span class="line">        Class&lt;?&gt; targetClass =</span><br><span class="line">            methodInvocation.getThis() != <span class="literal">null</span> ? AopUtils.getTargetClass(methodInvocation.getThis()) : <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">specificMethod</span> <span class="operator">=</span> ClassUtils.getMostSpecificMethod(methodInvocation.getMethod(), targetClass);</span><br><span class="line">        <span class="keyword">if</span> (specificMethod != <span class="literal">null</span> &amp;&amp; !specificMethod.getDeclaringClass().equals(Object.class)) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> BridgeMethodResolver.findBridgedMethod(specificMethod);</span><br><span class="line">            <span class="comment">//获取GlobalTransactional（全局事务）、GlobalLock(全局锁)元数据</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">GlobalTransactional</span> <span class="variable">globalTransactionalAnnotation</span> <span class="operator">=</span></span><br><span class="line">                getAnnotation(method, targetClass, GlobalTransactional.class);</span><br><span class="line">            <span class="comment">//GlobalLock会将本地事务的执行纳入Seata分布式事务的管理，共同竞争全局锁</span></span><br><span class="line">            <span class="comment">//保证全局事务在执行的时候，本地事务不可以操作全局事务的记录</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">GlobalLock</span> <span class="variable">globalLockAnnotation</span> <span class="operator">=</span> getAnnotation(method, targetClass, GlobalLock.class);<span class="comment">//获取全局锁</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">localDisable</span> <span class="operator">=</span> disable || (degradeCheck &amp;&amp; degradeNum &gt;= degradeCheckAllowTimes);</span><br><span class="line">            <span class="keyword">if</span> (!localDisable) &#123;</span><br><span class="line">                <span class="keyword">if</span> (globalTransactionalAnnotation != <span class="literal">null</span> || <span class="built_in">this</span>.aspectTransactional != <span class="literal">null</span>) &#123;</span><br><span class="line">                    AspectTransactional transactional;</span><br><span class="line">                    <span class="keyword">if</span> (globalTransactionalAnnotation != <span class="literal">null</span>) &#123;</span><br><span class="line">                        transactional = <span class="keyword">new</span> <span class="title class_">AspectTransactional</span>(globalTransactionalAnnotation.timeoutMills(),</span><br><span class="line">                            globalTransactionalAnnotation.name(), globalTransactionalAnnotation.rollbackFor(),</span><br><span class="line">                            globalTransactionalAnnotation.noRollbackForClassName(),</span><br><span class="line">                            globalTransactionalAnnotation.noRollbackFor(),</span><br><span class="line">                            globalTransactionalAnnotation.noRollbackForClassName(),</span><br><span class="line">                            globalTransactionalAnnotation.propagation(),</span><br><span class="line">                            globalTransactionalAnnotation.lockRetryInterval(),</span><br><span class="line">                            globalTransactionalAnnotation.lockRetryTimes());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        transactional = <span class="built_in">this</span>.aspectTransactional;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//执行全局事务</span></span><br><span class="line">                    <span class="keyword">return</span> handleGlobalTransaction(methodInvocation, transactional);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (globalLockAnnotation != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//执行全局锁</span></span><br><span class="line">                    <span class="keyword">return</span> handleGlobalLock(methodInvocation, globalLockAnnotation);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> methodInvocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体流程图如下所示：</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/45838801f4caeefec5623a955be68146.png" alt="img"></p>
<h2 id="核心源码"><a class="markdownIt-Anchor" href="#核心源码">#</a> 核心源码</h2>
<p>在上面我们讲解到  <code>GlobalTransactionalInterceptor</code>  作为全局事务拦截器，一旦执行拦截，就会进入 invoke 方法，其中，我们会做  <code>@GlobalTransactional</code>  注解的判断，如果有这个注解的存在，会执行全局事务和全局锁，再执行全局事务的时候会调用  <code>handleGlobalTransaction</code>  全局事务处理器，获取事务信息，那我们接下来就来看一下  <code>GlobalTransactionalInterceptor.handleGlobalTransaction</code>  到底是如何执行全局事务的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">handleGlobalTransaction</span><span class="params">(<span class="keyword">final</span> MethodInvocation methodInvocation,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> AspectTransactional aspectTransactional)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">succeed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> transactionalTemplate.execute(<span class="keyword">new</span> <span class="title class_">TransactionalExecutor</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> Object <span class="title function_">execute</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                    <span class="keyword">return</span> methodInvocation.proceed();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//获取事务名称，默认获取方法名</span></span><br><span class="line">                <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> aspectTransactional.getName();</span><br><span class="line">                    <span class="keyword">if</span> (!StringUtils.isNullOrEmpty(name)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> name;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> formatMethod(methodInvocation.getMethod());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 解析GlobalTransation注解属性，封装对对象</span></span><br><span class="line"><span class="comment">                 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> TransactionInfo <span class="title function_">getTransactionInfo</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="comment">// reset the value of timeout</span></span><br><span class="line">                    <span class="comment">//获取超时时间，默认60秒</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">timeout</span> <span class="operator">=</span> aspectTransactional.getTimeoutMills();</span><br><span class="line">                    <span class="keyword">if</span> (timeout &lt;= <span class="number">0</span> || timeout == DEFAULT_GLOBAL_TRANSACTION_TIMEOUT) &#123;</span><br><span class="line">                        timeout = defaultGlobalTransactionTimeout;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//构建事务信息对象</span></span><br><span class="line">                    <span class="type">TransactionInfo</span> <span class="variable">transactionInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionInfo</span>();</span><br><span class="line">                    transactionInfo.setTimeOut(timeout);<span class="comment">//超时时间</span></span><br><span class="line">                    transactionInfo.setName(name());<span class="comment">//事务名称</span></span><br><span class="line">                    transactionInfo.setPropagation(aspectTransactional.getPropagation());<span class="comment">//事务传播</span></span><br><span class="line">                    transactionInfo.setLockRetryInterval(aspectTransactional.getLockRetryInterval());<span class="comment">//校验或占用全局锁重试间隔</span></span><br><span class="line">                    transactionInfo.setLockRetryTimes(aspectTransactional.getLockRetryTimes());<span class="comment">//校验或占用全局锁重试次数</span></span><br><span class="line">                    Set&lt;RollbackRule&gt; rollbackRules = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">                    <span class="comment">//其他构建信息</span></span><br><span class="line">                    <span class="keyword">for</span> (Class&lt;?&gt; rbRule : aspectTransactional.getRollbackFor()) &#123;</span><br><span class="line">                        rollbackRules.add(<span class="keyword">new</span> <span class="title class_">RollbackRule</span>(rbRule));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (String rbRule : aspectTransactional.getRollbackForClassName()) &#123;</span><br><span class="line">                        rollbackRules.add(<span class="keyword">new</span> <span class="title class_">RollbackRule</span>(rbRule));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (Class&lt;?&gt; rbRule : aspectTransactional.getNoRollbackFor()) &#123;</span><br><span class="line">                        rollbackRules.add(<span class="keyword">new</span> <span class="title class_">NoRollbackRule</span>(rbRule));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (String rbRule : aspectTransactional.getNoRollbackForClassName()) &#123;</span><br><span class="line">                        rollbackRules.add(<span class="keyword">new</span> <span class="title class_">NoRollbackRule</span>(rbRule));</span><br><span class="line">                    &#125;</span><br><span class="line">                    transactionInfo.setRollbackRules(rollbackRules);</span><br><span class="line">                    <span class="keyword">return</span> transactionInfo;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TransactionalExecutor.ExecutionException e) &#123;</span><br><span class="line">            <span class="comment">//执行异常</span></span><br><span class="line">            TransactionalExecutor.<span class="type">Code</span> <span class="variable">code</span> <span class="operator">=</span> e.getCode();</span><br><span class="line">            <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">                <span class="keyword">case</span> RollbackDone:</span><br><span class="line">                    <span class="keyword">throw</span> e.getOriginalException();</span><br><span class="line">                <span class="keyword">case</span> BeginFailure:</span><br><span class="line">                    succeed = <span class="literal">false</span>;</span><br><span class="line">                    failureHandler.onBeginFailure(e.getTransaction(), e.getCause());</span><br><span class="line">                    <span class="keyword">throw</span> e.getCause();</span><br><span class="line">                <span class="keyword">case</span> CommitFailure:</span><br><span class="line">                    succeed = <span class="literal">false</span>;</span><br><span class="line">                    failureHandler.onCommitFailure(e.getTransaction(), e.getCause());</span><br><span class="line">                    <span class="keyword">throw</span> e.getCause();</span><br><span class="line">                <span class="keyword">case</span> RollbackFailure:</span><br><span class="line">                    failureHandler.onRollbackFailure(e.getTransaction(), e.getOriginalException());</span><br><span class="line">                    <span class="keyword">throw</span> e.getOriginalException();</span><br><span class="line">                <span class="keyword">case</span> RollbackRetrying:</span><br><span class="line">                    failureHandler.onRollbackRetrying(e.getTransaction(), e.getOriginalException());</span><br><span class="line">                    <span class="keyword">throw</span> e.getOriginalException();</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ShouldNeverHappenException</span>(String.format(<span class="string">&quot;Unknown TransactionalExecutor.Code: %s&quot;</span>, code));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (degradeCheck) &#123;</span><br><span class="line">                EVENT_BUS.post(<span class="keyword">new</span> <span class="title class_">DegradeCheckEvent</span>(succeed));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在这里我们，主要关注一个重点方法  <code>execute()</code> ，这个方法主要用来执行事务的具体流程：</p>
<ul>
<li>获取事务信息</li>
<li>执行全局事务</li>
<li>发生异常全局回滚，各个数据通过 UndoLog 进行事务补偿</li>
<li>全局事务提交</li>
<li>清除所有资源</li>
</ul>
<p>这个位置也是一个非常核心的一个位置，因为我们所有的业务进来以后都会去走这个位置，具体源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">execute</span><span class="params">(TransactionalExecutor business)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 1. Get transactionInfo</span></span><br><span class="line">    <span class="comment">//获取事务信息</span></span><br><span class="line">    <span class="type">TransactionInfo</span> <span class="variable">txInfo</span> <span class="operator">=</span> business.getTransactionInfo();</span><br><span class="line">    <span class="keyword">if</span> (txInfo == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ShouldNeverHappenException</span>(<span class="string">&quot;transactionInfo does not exist&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.1 Get current transaction, if not null, the tx role is &#x27;GlobalTransactionRole.Participant&#x27;.</span></span><br><span class="line">    <span class="comment">//获取当前事务，主要获取XID</span></span><br><span class="line">    <span class="type">GlobalTransaction</span> <span class="variable">tx</span> <span class="operator">=</span> GlobalTransactionContext.getCurrent();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.2 Handle the transaction propagation.</span></span><br><span class="line">    <span class="comment">//根据配置的不同事务传播行为，执行不同的逻辑</span></span><br><span class="line">    <span class="type">Propagation</span> <span class="variable">propagation</span> <span class="operator">=</span> txInfo.getPropagation();</span><br><span class="line">    <span class="type">SuspendedResourcesHolder</span> <span class="variable">suspendedResourcesHolder</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (propagation) &#123;</span><br><span class="line">            <span class="keyword">case</span> NOT_SUPPORTED:</span><br><span class="line">                <span class="comment">// If transaction is existing, suspend it.</span></span><br><span class="line">                <span class="keyword">if</span> (existingTransaction(tx)) &#123;</span><br><span class="line">                    suspendedResourcesHolder = tx.suspend();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Execute without transaction and return.</span></span><br><span class="line">                <span class="keyword">return</span> business.execute();</span><br><span class="line">            <span class="keyword">case</span> REQUIRES_NEW:</span><br><span class="line">                <span class="comment">// If transaction is existing, suspend it, and then begin new transaction.</span></span><br><span class="line">                <span class="keyword">if</span> (existingTransaction(tx)) &#123;</span><br><span class="line">                    suspendedResourcesHolder = tx.suspend();</span><br><span class="line">                    tx = GlobalTransactionContext.createNew();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Continue and execute with new transaction</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SUPPORTS:</span><br><span class="line">                <span class="comment">// If transaction is not existing, execute without transaction.</span></span><br><span class="line">                <span class="keyword">if</span> (notExistingTransaction(tx)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> business.execute();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Continue and execute with new transaction</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> REQUIRED:</span><br><span class="line">                <span class="comment">// If current transaction is existing, execute with current transaction,</span></span><br><span class="line">                <span class="comment">// else continue and execute with new transaction.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> NEVER:</span><br><span class="line">                <span class="comment">// If transaction is existing, throw exception.</span></span><br><span class="line">                <span class="keyword">if</span> (existingTransaction(tx)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransactionException</span>(</span><br><span class="line">                        String.format(<span class="string">&quot;Existing transaction found for transaction marked with propagation &#x27;never&#x27;, xid = %s&quot;</span></span><br><span class="line">                                , tx.getXid()));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Execute without transaction and return.</span></span><br><span class="line">                    <span class="keyword">return</span> business.execute();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> MANDATORY:</span><br><span class="line">                <span class="comment">// If transaction is not existing, throw exception.</span></span><br><span class="line">                <span class="keyword">if</span> (notExistingTransaction(tx)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransactionException</span>(<span class="string">&quot;No existing transaction found for transaction marked with propagation &#x27;mandatory&#x27;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Continue and execute with current transaction.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransactionException</span>(<span class="string">&quot;Not Supported Propagation:&quot;</span> + propagation);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.3 If null, create new transaction with role &#x27;GlobalTransactionRole.Launcher&#x27;.</span></span><br><span class="line">        <span class="comment">//如果当前事务为空，创建一个新的事务</span></span><br><span class="line">        <span class="keyword">if</span> (tx == <span class="literal">null</span>) &#123;</span><br><span class="line">            tx = GlobalTransactionContext.createNew();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// set current tx config to holder</span></span><br><span class="line">        <span class="type">GlobalLockConfig</span> <span class="variable">previousConfig</span> <span class="operator">=</span> replaceGlobalLockConfig(txInfo);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2. If the tx role is &#x27;GlobalTransactionRole.Launcher&#x27;, send the request of beginTransaction to TC,</span></span><br><span class="line">            <span class="comment">//    else do nothing. Of course, the hooks will still be triggered.</span></span><br><span class="line">            <span class="comment">//开始执行全局事务</span></span><br><span class="line">            beginTransaction(txInfo, tx);</span><br><span class="line"></span><br><span class="line">            Object rs;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Do Your Business</span></span><br><span class="line">                <span class="comment">// 执行当前业务逻辑</span></span><br><span class="line">                <span class="comment">//1、在TC注册当前分支事务，TC会在branch_table中插入一条分支事务数据</span></span><br><span class="line">                <span class="comment">//2、执行本地update语句，并在执行前后查询数据状态，并把数据前后镜像存入到undo_log中</span></span><br><span class="line">                <span class="comment">//3、远程调用其他应用，远程应用接收到XID，也会注册分支事务，写入branch_table以及本地undo_log表</span></span><br><span class="line">                <span class="comment">//4、会在lock_table表中插入全局锁数据（一个分支一条）</span></span><br><span class="line">                rs = business.execute();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="comment">// 3. The needed business exception to rollback.</span></span><br><span class="line">                <span class="comment">//发生异常全局回滚，每个事务通过undo_log表进行事务补偿</span></span><br><span class="line">                completeTransactionAfterThrowing(txInfo, tx, ex);</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. everything is fine, commit.</span></span><br><span class="line">            <span class="comment">//全局提交</span></span><br><span class="line">            commitTransaction(tx);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> rs;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//5. clear</span></span><br><span class="line">            <span class="comment">//清理所有资源</span></span><br><span class="line">            resumeGlobalLockConfig(previousConfig);</span><br><span class="line">            triggerAfterCompletion();</span><br><span class="line">            cleanUp();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// If the transaction is suspended, resume it.</span></span><br><span class="line">        <span class="keyword">if</span> (suspendedResourcesHolder != <span class="literal">null</span>) &#123;</span><br><span class="line">            tx.resume(suspendedResourcesHolder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这其中的第三步和第四步其实在向 TC（Seata-Server）发起全局事务的提交或者回滚，在这里我们首先关注执行全局事务的  <code>beginTransaction()</code>  方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向TC发起请求，采用模板模式</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">beginTransaction</span><span class="params">(TransactionInfo txInfo, GlobalTransaction tx)</span> <span class="keyword">throws</span> TransactionalExecutor.ExecutionException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        triggerBeforeBegin();</span><br><span class="line">        <span class="comment">//对TC发起请求</span></span><br><span class="line">        tx.begin(txInfo.getTimeOut(), txInfo.getName());</span><br><span class="line">        triggerAfterBegin();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TransactionException txe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransactionalExecutor</span>.ExecutionException(tx, txe,</span><br><span class="line">            TransactionalExecutor.Code.BeginFailure);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在来关注其中，向 TC 发起请求的  <code>tx.begin()</code>  方法，而调用 <code>begin()</code>  方法的类为： <code>DefaultGlobalTransaction</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">begin</span><span class="params">(<span class="type">int</span> timeout, String name)</span> <span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line">       <span class="comment">//判断调用者是否为TM</span></span><br><span class="line">       <span class="keyword">if</span> (role != GlobalTransactionRole.Launcher) &#123;</span><br><span class="line">           assertXIDNotNull();</span><br><span class="line">           <span class="keyword">if</span> (LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">               LOGGER.debug(<span class="string">&quot;Ignore Begin(): just involved in global transaction [&#123;&#125;]&quot;</span>, xid);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       assertXIDNull();</span><br><span class="line">       <span class="type">String</span> <span class="variable">currentXid</span> <span class="operator">=</span> RootContext.getXID();</span><br><span class="line">       <span class="keyword">if</span> (currentXid != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Global transaction already exists,&quot;</span> +</span><br><span class="line">               <span class="string">&quot; can&#x27;t begin a new global transaction, currentXid = &quot;</span> + currentXid);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//获取XID</span></span><br><span class="line">       xid = transactionManager.begin(<span class="literal">null</span>, <span class="literal">null</span>, name, timeout);</span><br><span class="line">       status = GlobalStatus.Begin;</span><br><span class="line">       <span class="comment">//绑定XID</span></span><br><span class="line">       RootContext.bind(xid);</span><br><span class="line">       <span class="keyword">if</span> (LOGGER.isInfoEnabled()) &#123;</span><br><span class="line">           LOGGER.info(<span class="string">&quot;Begin new global transaction [&#123;&#125;]&quot;</span>, xid);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>再来看一下  <code>transactionManager.begin()</code>  方法，这个时候使用的是  <code>DefaultTransactionManager.begin</code>  默认的事务管理者，来获取 XID，传入事务相关的信息 ，最好 TC 返回对应的全局事务 XID，它调用的是 <code>DefaultTransactionManager.begin()</code>  方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">begin</span><span class="params">(String applicationId, String transactionServiceGroup, String name, <span class="type">int</span> timeout)</span></span><br><span class="line">    <span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line">    <span class="type">GlobalBeginRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GlobalBeginRequest</span>();</span><br><span class="line">    request.setTransactionName(name);</span><br><span class="line">    request.setTimeout(timeout);</span><br><span class="line">    <span class="comment">//发送请求得到响应</span></span><br><span class="line">    <span class="type">GlobalBeginResponse</span> <span class="variable">response</span> <span class="operator">=</span> (GlobalBeginResponse) syncCall(request);</span><br><span class="line">    <span class="keyword">if</span> (response.getResultCode() == ResultCode.Failed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TmTransactionException</span>(TransactionExceptionCode.BeginFailed, response.getMsg());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回XID</span></span><br><span class="line">    <span class="keyword">return</span> response.getXid();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里我们需要关注一个 <code>syncCall</code> ，在这里采用的是 Netty 通讯方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AbstractTransactionResponse <span class="title function_">syncCall</span><span class="params">(AbstractTransactionRequest request)</span> <span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过Netty发送请求</span></span><br><span class="line">        <span class="keyword">return</span> (AbstractTransactionResponse) TmNettyRemotingClient.getInstance().sendSyncRequest(request);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TmTransactionException</span>(TransactionExceptionCode.IO, <span class="string">&quot;RPC timeout&quot;</span>, toe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体图解如下：</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/58f1038f3648c3d95be79c183eb151b6.png" alt="img"></p>
<p>在这里我们需要重点了解  <code>GlobalTransactionScanner</code>  这个类型，在这个类型中继承了一些接口和抽象类，这个类主要作用就是扫描有注解的 Bean，并做 AOP 增强。</p>
<ul>
<li><code>ApplicationContextAware</code> ：继承这个类型以后，需要实现其方法  <code>setApplicationContext()</code> ，当 Spring 启动完成以后，会自动调用这个类型，将  <code>ApplicationContext</code>  给  <code>bean</code> ，也就是说，  <code>GlobalTransactionScanner</code>  能够很自然的使用 Spring 环境</li>
<li><code>InitializingBean</code> ： 继承这个接口，需要实现  <code>afterPropertiesSet()</code>  ，但凡是继承这个接口的类，在初始化的时候，当所有的  <code>properties</code>  设置完成以后，会执行这个方法</li>
<li><code>DisposableBean</code>  ： 这个类，实现了一个  <code>destroy()</code>  这个方法是在销毁的时候去调用</li>
<li><code>AbstractAutoProxyCreator</code> ： 这个类是 Spring 实现 AOP 的一种方式，本质上是一个  <code>BeanPostProcessor</code>  ，在 Bean 初始化至去年，调用内部  <code>createProxy()</code>  ，创建一个 Bean 的 AOP 代理 Bean 并返回，对 Bean 进行增强。</li>
</ul>
<h2 id="seata数据源代理"><a class="markdownIt-Anchor" href="#seata数据源代理">#</a> Seata 数据源代理</h2>
<p>在上面的环节中，我们讲解了 Seata AT 模式 2PC 的执行流程，那么现在我们就来带大家了解一下关于 AT 数据源代理的信息，这也是 AT 模式中非常关键的一个重要知识点，大家可以拿起小本子，记下来。</p>
<p>首先 AT 模式的核心主要分为一下两个</p>
<ul>
<li>开启全局事务，获取全局锁。</li>
<li>解析 SQL 并写入 undoLog 中。</li>
</ul>
<p>关于第一点我们已经分析清楚了，第二点就是关于 AT 模式如何解析 SQL 并写入 undoLog 中，但是在这之前，我们需要知道 Seata 是如何选择数据源，并进行数据源代理的。虽然全局事务拦截成功后最终还是执行了业务方法进行 SQL 提交和操作，但是由于 Seata 对数据源进行了代理，所以 SQL 的解析和 undoLog 的操作，是在数据源代理中进行完成的。</p>
<p>数据源代理是 Seata 中一个非常重要的知识点，在<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1&amp;spm=1001.2101.3001.7020">分布式事务</a>运行过程中，undoLog 的记录、资源的锁定，用户都是无感知的，因为这些操作都是数据源的代理中完成了，恰恰是这样，我们才要去了解，这样不仅有利于我们了解 Seata 的核心操作，还能对以后源码阅读有所帮助，因为其实很多底层代码都会去使用这样用户无感知的方式 (代理) 去实现。</p>
<p>同样，我们在之前的寻找源码入口的时候，通过我们项目中引入的 jar 找到一个  <code>SeataAutoConfiguration</code>  类，我们在里面找到一个 <code>SeataDataSourceBeanPostProcessor()</code> ，这个就是我们数据源代理的入口方法</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/78c4564099e2c372a310458314d545e9.png" alt="img"></p>
<p>我们进入 <code>SeataDataSourceBeanPostProcessor</code>  类里面，发现继承了一个  <code>BeanPostProcessor</code>  , 这个接口我们应该很熟悉，这个是 Sprng 的拓展接口，所有的 Bean 对象，都有进入两个方法  <code>postProcessAfterInitialization()</code>  和  <code>postProcessBeforeInitialization()</code>  这两个方法都是由  <code>BeanPostProcessor</code>  提供的，这两个方法，一个是初始化之前执行 <code>Before</code> 。一个是在初始化之后执行 <code>After</code> ，主要用来对比我们的的 Bean 是否为数据源代理对象。</p>
<p>在这里我们需要关注到一个 <code>postProcessAfterInitialization.proxyDataSource()</code>  方法，这个里面</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">proxyDataSource</span><span class="params">(Object originBean)</span> &#123;</span><br><span class="line">    <span class="type">DataSourceProxy</span> <span class="variable">dataSourceProxy</span> <span class="operator">=</span> DataSourceProxyHolder.get().putDataSource((DataSource) originBean);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.useJdkProxy) &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), SpringProxyUtils.getAllInterfaces(originBean), (proxy, method, args) -&gt; handleMethodProxy(dataSourceProxy, method, args, originBean));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Enhancer.create(originBean.getClass(), (MethodInterceptor) (proxy, method, args, methodProxy) -&gt; handleMethodProxy(dataSourceProxy, method, args, originBean));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有一个 <code>DataSourceProxy</code>  代理对象，我们需要看的就是这个类，这个就是我们数据库代理的对象，我们从我们下载的源码项目中，搜索这个代理对象，当我们打开这个类的目录时发现，除了这个，还有 <code>ConnectionProxy</code>  连接对象、 <code>StatementProxy</code> 、 <code>PreparedStatementProxy</code>  SQL 执行对象，这些都被 Seata 进行了代理，为什么要对这些都进行代理，代理的目的其实为了执行 Seata 的业务逻辑，生成 undoLog，全局事务的开启，事务的提交回滚等操作</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/ef54a9c5142d96cf230b7938f60a9145.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">DataSourceProxy` 具体做了什么，主要功能有哪些，我们来看一下。他在源码中是如何体现的，我们需要关注的是`init()</span><br><span class="line">public class DataSourceProxy extends AbstractDataSourceProxy implements Resource &#123;</span><br><span class="line"></span><br><span class="line">    private String resourceGroupId;</span><br><span class="line"></span><br><span class="line">    private void init(DataSource dataSource, String resourceGroupId) &#123;</span><br><span class="line">        //资源组ID，默认是“default”这个默认值</span><br><span class="line">        this.resourceGroupId = resourceGroupId;</span><br><span class="line">        try (Connection connection = dataSource.getConnection()) &#123;</span><br><span class="line">            //根据原始数据源得到JDBC连接和数据库类型</span><br><span class="line">            jdbcUrl = connection.getMetaData().getURL();</span><br><span class="line">            dbType = JdbcUtils.getDbType(jdbcUrl);</span><br><span class="line">            if (JdbcConstants.ORACLE.equals(dbType)) &#123;</span><br><span class="line">                userName = connection.getMetaData().getUserName();</span><br><span class="line">            &#125; else if (JdbcConstants.MARIADB.equals(dbType)) &#123;</span><br><span class="line">                dbType = JdbcConstants.MYSQL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;can not init dataSource&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        initResourceId();</span><br><span class="line">        DefaultResourceManager.get().registerResource(this);</span><br><span class="line">        if (ENABLE_TABLE_META_CHECKER_ENABLE) &#123;</span><br><span class="line">            //如果配置开关打开，会定时在线程池不断更新表的元数据缓存信息</span><br><span class="line">            tableMetaExecutor.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">                try (Connection connection = dataSource.getConnection()) &#123;</span><br><span class="line">                    TableMetaCacheFactory.getTableMetaCache(DataSourceProxy.this.getDbType())</span><br><span class="line">                        .refresh(connection, DataSourceProxy.this.getResourceId());</span><br><span class="line">                &#125; catch (Exception ignore) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, 0, TABLE_META_CHECKER_INTERVAL, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //Set the default branch type to &#x27;AT&#x27; in the RootContext.</span><br><span class="line">        RootContext.setDefaultBranchType(this.getBranchType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面我们可以看出，他主要做了以下几点的增强：</p>
<ol>
<li>给每个数据源标识资源组 ID</li>
<li>如果打开配置，会有一个定时线程池定时更新表的元数据信息并缓存到本地</li>
<li>生成代理连接  <code>ConnectionProxy</code>  对象</li>
</ol>
<p>在这三个增强功能里面，第三个是最重要的，在 AT 模式里面，会自动记录 undoLog，资源锁定，都是通过 <code>ConnectionProxy</code>  完成的，除此之外  <code>DataSrouceProxy</code>  重写了一个方法  <code>getConnection</code> ，因为这里返回的是一个  <code>ConnectionProxy</code> ，而不是原生的 <code>Connection</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ConnectionProxy <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">targetConnection</span> <span class="operator">=</span> targetDataSource.getConnection();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConnectionProxy</span>(<span class="built_in">this</span>, targetConnection);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ConnectionProxy <span class="title function_">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">targetConnection</span> <span class="operator">=</span> targetDataSource.getConnection(username, password);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConnectionProxy</span>(<span class="built_in">this</span>, targetConnection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="connectionproxy"><a class="markdownIt-Anchor" href="#connectionproxy">#</a> ConnectionProxy</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConnectionProxy` 继承 `AbstractConnectionProxy` ，在这个父类中有很多公用的方法，在这个父类有 `PreparedStatementProxy` 、`StatementProxy` 、`DataSourceProxy</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f16ce360addfb4ffbc43b040f0493fc5.png" alt="img"></p>
<p>所以我们需要先来看一下 <code>AbstractConnectionProxy</code> ，因为这里封装了需要我们用到的通用方法和逻辑，在其中我们需要关注的主要在于  <code>PreparedStatementProxy</code>  和  <code>StatementProxy</code>  ，在这里的逻辑主要是数据源连接的步骤，连接获取，创建执行对象等等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Statement <span class="title function_">createStatement</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="comment">//调用真实连接对象获取Statement对象</span></span><br><span class="line">    <span class="type">Statement</span> <span class="variable">targetStatement</span> <span class="operator">=</span> getTargetConnection().createStatement();</span><br><span class="line">    <span class="comment">//创建Statement的代理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StatementProxy</span>(<span class="built_in">this</span>, targetStatement);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PreparedStatement <span class="title function_">prepareStatement</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="comment">//获取数据库类型 mysql/oracle</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">dbType</span> <span class="operator">=</span> getDbType();</span><br><span class="line">    <span class="comment">// support oracle 10.2+</span></span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">targetPreparedStatement</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//如果是AT模式且开启全局事务</span></span><br><span class="line">    <span class="keyword">if</span> (BranchType.AT == RootContext.getBranchType()) &#123;</span><br><span class="line">        List&lt;SQLRecognizer&gt; sqlRecognizers = SQLVisitorFactory.get(sql, dbType);</span><br><span class="line">        <span class="keyword">if</span> (sqlRecognizers != <span class="literal">null</span> &amp;&amp; sqlRecognizers.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">SQLRecognizer</span> <span class="variable">sqlRecognizer</span> <span class="operator">=</span> sqlRecognizers.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (sqlRecognizer != <span class="literal">null</span> &amp;&amp; sqlRecognizer.getSQLType() == SQLType.INSERT) &#123;</span><br><span class="line">                <span class="comment">//获取表的元数据</span></span><br><span class="line">                <span class="type">TableMeta</span> <span class="variable">tableMeta</span> <span class="operator">=</span> TableMetaCacheFactory.getTableMetaCache(dbType).getTableMeta(getTargetConnection(),</span><br><span class="line">                        sqlRecognizer.getTableName(), getDataSourceProxy().getResourceId());</span><br><span class="line">                <span class="comment">//得到表的主键列名</span></span><br><span class="line">                String[] pkNameArray = <span class="keyword">new</span> <span class="title class_">String</span>[tableMeta.getPrimaryKeyOnlyName().size()];</span><br><span class="line">                tableMeta.getPrimaryKeyOnlyName().toArray(pkNameArray);</span><br><span class="line">                targetPreparedStatement = getTargetConnection().prepareStatement(sql,pkNameArray);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (targetPreparedStatement == <span class="literal">null</span>) &#123;</span><br><span class="line">        targetPreparedStatement = getTargetConnection().prepareStatement(sql);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建PreparedStatementProxy代理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PreparedStatementProxy</span>(<span class="built_in">this</span>, targetPreparedStatement, sql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这两个代理对象中，都用到了以下几个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ResultSet <span class="title function_">executeQuery</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="built_in">this</span>.targetSQL = sql;</span><br><span class="line">    <span class="keyword">return</span> ExecuteTemplate.execute(<span class="built_in">this</span>, (statement, args) -&gt; statement.executeQuery((String) args[<span class="number">0</span>]), sql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">executeUpdate</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="built_in">this</span>.targetSQL = sql;</span><br><span class="line">    <span class="keyword">return</span> ExecuteTemplate.execute(<span class="built_in">this</span>, (statement, args) -&gt; statement.executeUpdate((String) args[<span class="number">0</span>]), sql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">execute</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="built_in">this</span>.targetSQL = sql;</span><br><span class="line">    <span class="keyword">return</span> ExecuteTemplate.execute(<span class="built_in">this</span>, (statement, args) -&gt; statement.execute((String) args[<span class="number">0</span>]), sql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这些方法中都调用了  <code>ExecuteTemplate.execute()</code> ，所以我们就看一下在  <code>ExecuteTemplate</code>  类中具体是做了什么操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecuteTemplate</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, S <span class="keyword">extends</span> <span class="title class_">Statement</span>&gt; T <span class="title function_">execute</span><span class="params">(List&lt;SQLRecognizer&gt; sqlRecognizers,</span></span><br><span class="line"><span class="params">                                                     StatementProxy&lt;S&gt; statementProxy,</span></span><br><span class="line"><span class="params">                                                     StatementCallback&lt;T, S&gt; statementCallback,</span></span><br><span class="line"><span class="params">                                                     Object... args)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">//如果没有全局锁，并且不是AT模式，直接执行SQL</span></span><br><span class="line">        <span class="keyword">if</span> (!RootContext.requireGlobalLock() &amp;&amp; BranchType.AT != RootContext.getBranchType()) &#123;</span><br><span class="line">            <span class="comment">// Just work as original statement</span></span><br><span class="line">            <span class="keyword">return</span> statementCallback.execute(statementProxy.getTargetStatement(), args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到数据库类型- mysql/oracle</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">dbType</span> <span class="operator">=</span> statementProxy.getConnectionProxy().getDbType();</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(sqlRecognizers)) &#123;</span><br><span class="line">            <span class="comment">//sqlRecognizers 为SQL语句的解析器，获取执行的SQL，通过它可以获得SQL语句表名、相关的列名、类型等信息，最后解析出对应的SQL表达式</span></span><br><span class="line">            sqlRecognizers = SQLVisitorFactory.get(</span><br><span class="line">                    statementProxy.getTargetSQL(),</span><br><span class="line">                    dbType);</span><br><span class="line">        &#125;</span><br><span class="line">        Executor&lt;T&gt; executor;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(sqlRecognizers)) &#123;</span><br><span class="line">            <span class="comment">//如果seata没有找到合适的SQL语句解析器，那么便创建简单执行器PlainExecutor</span></span><br><span class="line">            <span class="comment">//PlainExecutor直接使用原生的Statment对象执行SQL</span></span><br><span class="line">            executor = <span class="keyword">new</span> <span class="title class_">PlainExecutor</span>&lt;&gt;(statementProxy, statementCallback);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (sqlRecognizers.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">SQLRecognizer</span> <span class="variable">sqlRecognizer</span> <span class="operator">=</span> sqlRecognizers.get(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">switch</span> (sqlRecognizer.getSQLType()) &#123;</span><br><span class="line">                    <span class="comment">//新增</span></span><br><span class="line">                    <span class="keyword">case</span> INSERT:</span><br><span class="line">                        executor = EnhancedServiceLoader.load(InsertExecutor.class, dbType,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;StatementProxy.class, StatementCallback.class, SQLRecognizer.class&#125;,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;statementProxy, statementCallback, sqlRecognizer&#125;);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                        <span class="comment">//修改</span></span><br><span class="line">                    <span class="keyword">case</span> UPDATE:</span><br><span class="line">                        executor = <span class="keyword">new</span> <span class="title class_">UpdateExecutor</span>&lt;&gt;(statementProxy, statementCallback, sqlRecognizer);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                        <span class="comment">//删除</span></span><br><span class="line">                    <span class="keyword">case</span> DELETE:</span><br><span class="line">                        executor = <span class="keyword">new</span> <span class="title class_">DeleteExecutor</span>&lt;&gt;(statementProxy, statementCallback, sqlRecognizer);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                        <span class="comment">//加锁</span></span><br><span class="line">                    <span class="keyword">case</span> SELECT_FOR_UPDATE:</span><br><span class="line">                        executor = <span class="keyword">new</span> <span class="title class_">SelectForUpdateExecutor</span>&lt;&gt;(statementProxy, statementCallback, sqlRecognizer);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                        <span class="comment">//插入加锁</span></span><br><span class="line">                    <span class="keyword">case</span> INSERT_ON_DUPLICATE_UPDATE:</span><br><span class="line">                        <span class="keyword">switch</span> (dbType) &#123;</span><br><span class="line">                            <span class="keyword">case</span> JdbcConstants.MYSQL:</span><br><span class="line">                            <span class="keyword">case</span> JdbcConstants.MARIADB:</span><br><span class="line">                                executor =</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">MySQLInsertOrUpdateExecutor</span>(statementProxy, statementCallback, sqlRecognizer);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">default</span>:</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotSupportYetException</span>(dbType + <span class="string">&quot; not support to INSERT_ON_DUPLICATE_UPDATE&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                        <span class="comment">//原生</span></span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        executor = <span class="keyword">new</span> <span class="title class_">PlainExecutor</span>&lt;&gt;(statementProxy, statementCallback);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//批量处理SQL语句</span></span><br><span class="line">                executor = <span class="keyword">new</span> <span class="title class_">MultiExecutor</span>&lt;&gt;(statementProxy, statementCallback, sqlRecognizers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        T rs;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//执行</span></span><br><span class="line">            rs = executor.execute(args);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(ex <span class="keyword">instanceof</span> SQLException)) &#123;</span><br><span class="line">                <span class="comment">// Turn other exception into SQLException</span></span><br><span class="line">                ex = <span class="keyword">new</span> <span class="title class_">SQLException</span>(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> (SQLException) ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在  <code>ExecuteTemplate</code>  就一个  <code>execute()</code> ，Seata 将 SQL 执行委托给不同的执行器 (模板)，Seata 提供了 6 种执行器也就是我们代码 case 中（ <code>INSERT</code> ， <code>UPDATE</code> ， <code>DELETE</code> ， <code>SELECT_FOR_UPDATE</code> , <code>INSERT_ON_DUPLICATE_UPDATE</code> ），这些执行器的父类都是 <code>AbstractDMLBaseExecutor</code></p>
<ul>
<li><code>UpdateExecutor</code> : 执行 update 语句</li>
<li><code>InsertExecutor</code> : 执行 insert 语句</li>
<li><code>DeleteExecutor</code> : 执行 delete 语句</li>
<li><code>SelectForUpdateExecutor</code> : 执行 select for update 语句</li>
<li><code>PlainExecutor</code> : 执行普通查询语句</li>
<li><code>MultiExecutor</code> : 复合执行器，在一条 SQL 语句中执行多条语句</li>
</ul>
<p>关系图如下：</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/f16af649be708d3642cf86a1c451fcf7.png" alt="img"></p>
<p>然后我们找到 <code> rs = executor.execute(args);</code>  最终执行的方法，找到最顶级的父类 <code>BaseTransactionalExecutor.execute()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">execute</span><span class="params">(Object... args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">xid</span> <span class="operator">=</span> RootContext.getXID();</span><br><span class="line">    <span class="keyword">if</span> (xid != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//获取XID</span></span><br><span class="line">        statementProxy.getConnectionProxy().bind(xid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置全局锁</span></span><br><span class="line">    statementProxy.getConnectionProxy().setGlobalLockRequire(RootContext.requireGlobalLock());</span><br><span class="line">    <span class="keyword">return</span> doExecute(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在根据 <code>doExecute(args);</code>  找到其中的重写方法  <code>AbstractDMLBaseExecutor.doExecute()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">doExecute</span><span class="params">(Object... args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">AbstractConnectionProxy</span> <span class="variable">connectionProxy</span> <span class="operator">=</span> statementProxy.getConnectionProxy();</span><br><span class="line">    <span class="comment">//是否自动提交</span></span><br><span class="line">    <span class="keyword">if</span> (connectionProxy.getAutoCommit()) &#123;</span><br><span class="line">        <span class="keyword">return</span> executeAutoCommitTrue(args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> executeAutoCommitFalse(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于数据库而言，本身都是自动提交的，所以我们进入 <code>executeAutoCommitTrue()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">protected</span> T <span class="title function_">executeAutoCommitTrue</span><span class="params">(Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">ConnectionProxy</span> <span class="variable">connectionProxy</span> <span class="operator">=</span> statementProxy.getConnectionProxy();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//设置为手动提交</span></span><br><span class="line">            connectionProxy.changeAutoCommit();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LockRetryPolicy</span>(connectionProxy).execute(() -&gt; &#123;</span><br><span class="line">                <span class="comment">//调用手动提交方法，得到分支执行的最终结果</span></span><br><span class="line">                <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> executeAutoCommitFalse(args);</span><br><span class="line">                <span class="comment">//执行提交</span></span><br><span class="line">                connectionProxy.commit();</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// when exception occur in finally,this exception will lost, so just print it here</span></span><br><span class="line">            LOGGER.error(<span class="string">&quot;execute executeAutoCommitTrue error:&#123;&#125;&quot;</span>, e.getMessage(), e);</span><br><span class="line">            <span class="keyword">if</span> (!LockRetryPolicy.isLockRetryPolicyBranchRollbackOnConflict()) &#123;</span><br><span class="line">                connectionProxy.getTargetConnection().rollback();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            connectionProxy.getContext().reset();</span><br><span class="line">            connectionProxy.setAutoCommit(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">connectionProxy.changeAutoCommit()`方法，修改为手动提交后，我们看来最关键的代码`executeAutoCommitFalse()</span><br><span class="line">    <span class="keyword">protected</span> T <span class="title function_">executeAutoCommitFalse</span><span class="params">(Object[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) &amp;&amp; isMultiPk()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotSupportYetException</span>(<span class="string">&quot;multi pk only support mysql!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取前镜像</span></span><br><span class="line">        <span class="type">TableRecords</span> <span class="variable">beforeImage</span> <span class="operator">=</span> beforeImage();</span><br><span class="line">        <span class="comment">//执行具体业务</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> statementCallback.execute(statementProxy.getTargetStatement(), args);</span><br><span class="line">        <span class="comment">//获取执行数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">updateCount</span> <span class="operator">=</span> statementProxy.getUpdateCount();</span><br><span class="line">        <span class="comment">//判断如果执行数量大于0</span></span><br><span class="line">        <span class="keyword">if</span> (updateCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//获取后镜像</span></span><br><span class="line">            <span class="type">TableRecords</span> <span class="variable">afterImage</span> <span class="operator">=</span> afterImage(beforeImage);</span><br><span class="line">            <span class="comment">//暂存到undolog中，在Commit的时候保存到数据库</span></span><br><span class="line">            prepareUndoLog(beforeImage, afterImage);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们再回到 <code>executeAutoCommitTrue</code>  中，去看看提交做了哪些操作 <code>connectionProxy.commit();</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        lockRetryPolicy.execute(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//具体执行</span></span><br><span class="line">            doCommit();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (targetConnection != <span class="literal">null</span> &amp;&amp; !getAutoCommit() &amp;&amp; !getContext().isAutoCommitChanged()) &#123;</span><br><span class="line">            rollback();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入到 <code>doCommit()</code>  中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doCommit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="comment">//判断是否存在全局事务</span></span><br><span class="line">    <span class="keyword">if</span> (context.inGlobalTransaction()) &#123;</span><br><span class="line">        processGlobalTransactionCommit();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context.isGlobalLockRequire()) &#123;</span><br><span class="line">        processLocalCommitWithGlobalLocks();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        targetConnection.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作为分布式事务，一定是存在全局事务的，所以我们进入  <code>processGlobalTransactionCommit()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processGlobalTransactionCommit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//注册分支事务</span></span><br><span class="line">          register();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (TransactionException e) &#123;</span><br><span class="line">          recognizeLockKeyConflictException(e, context.buildLockKeys());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//写入数据库undolog</span></span><br><span class="line">          UndoLogManagerFactory.getUndoLogManager(<span class="built_in">this</span>.getDbType()).flushUndoLogs(<span class="built_in">this</span>);</span><br><span class="line">          <span class="comment">//执行原生提交 一阶段提交</span></span><br><span class="line">          targetConnection.commit();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">          LOGGER.error(<span class="string">&quot;process connectionProxy commit error: &#123;&#125;&quot;</span>, ex.getMessage(), ex);</span><br><span class="line">          report(<span class="literal">false</span>);</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (IS_REPORT_SUCCESS_ENABLE) &#123;</span><br><span class="line">          report(<span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      context.reset();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>register()</code>  方法就是注册分支事务的方法，同时还会将 undoLog 写入数据库和执行提交等操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册分支事务，生成分支事务ID</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">()</span> <span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line">    <span class="keyword">if</span> (!context.hasUndoLog() || !context.hasLockKey()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注册分支事务</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">branchId</span> <span class="operator">=</span> DefaultResourceManager.get().branchRegister(BranchType.AT, getDataSourceProxy().getResourceId(),</span><br><span class="line">        <span class="literal">null</span>, context.getXid(), context.getApplicationData(), context.buildLockKeys());</span><br><span class="line">    context.setBranchId(branchId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们在回到 <code>processGlobalTransactionCommit</code>  中，看看写入数据库中的 <code>flushUndoLogs()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flushUndoLogs</span><span class="params">(ConnectionProxy cp)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">       <span class="type">ConnectionContext</span> <span class="variable">connectionContext</span> <span class="operator">=</span> cp.getContext();</span><br><span class="line">       <span class="keyword">if</span> (!connectionContext.hasUndoLog()) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//获取XID</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">xid</span> <span class="operator">=</span> connectionContext.getXid();</span><br><span class="line">       <span class="comment">//获取分支ID</span></span><br><span class="line">       <span class="type">long</span> <span class="variable">branchId</span> <span class="operator">=</span> connectionContext.getBranchId();</span><br><span class="line"></span><br><span class="line">       <span class="type">BranchUndoLog</span> <span class="variable">branchUndoLog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BranchUndoLog</span>();</span><br><span class="line">       branchUndoLog.setXid(xid);</span><br><span class="line">       branchUndoLog.setBranchId(branchId);</span><br><span class="line">       branchUndoLog.setSqlUndoLogs(connectionContext.getUndoItems());</span><br><span class="line"></span><br><span class="line">       <span class="type">UndoLogParser</span> <span class="variable">parser</span> <span class="operator">=</span> UndoLogParserFactory.getInstance();</span><br><span class="line">       <span class="type">byte</span>[] undoLogContent = parser.encode(branchUndoLog);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">           LOGGER.debug(<span class="string">&quot;Flushing UNDO LOG: &#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>(undoLogContent, Constants.DEFAULT_CHARSET));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">CompressorType</span> <span class="variable">compressorType</span> <span class="operator">=</span> CompressorType.NONE;</span><br><span class="line">       <span class="keyword">if</span> (needCompress(undoLogContent)) &#123;</span><br><span class="line">           compressorType = ROLLBACK_INFO_COMPRESS_TYPE;</span><br><span class="line">           undoLogContent = CompressorFactory.getCompressor(compressorType.getCode()).compress(undoLogContent);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//写入数据库具体位置</span></span><br><span class="line">       insertUndoLogWithNormal(xid, branchId, buildContext(parser.getName(), compressorType), undoLogContent, cp.getTargetConnection());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>具体写入方法，此时我们使用的是 MySql，所以执行的是 MySql 实现类 <code>MySQLUndoLogManager.insertUndoLogWithNormal()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">insertUndoLogWithNormal</span><span class="params">(String xid, <span class="type">long</span> branchId, String rollbackCtx, <span class="type">byte</span>[] undoLogContent,</span></span><br><span class="line"><span class="params">                                       Connection conn)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    insertUndoLog(xid, branchId, rollbackCtx, undoLogContent, State.Normal, conn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//具体写入操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insertUndoLog</span><span class="params">(String xid, <span class="type">long</span> branchId, String rollbackCtx, <span class="type">byte</span>[] undoLogContent,</span></span><br><span class="line"><span class="params">                           State state, Connection conn)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">PreparedStatement</span> <span class="variable">pst</span> <span class="operator">=</span> conn.prepareStatement(INSERT_UNDO_LOG_SQL)) &#123;</span><br><span class="line">        pst.setLong(<span class="number">1</span>, branchId);</span><br><span class="line">        pst.setString(<span class="number">2</span>, xid);</span><br><span class="line">        pst.setString(<span class="number">3</span>, rollbackCtx);</span><br><span class="line">        pst.setBytes(<span class="number">4</span>, undoLogContent);</span><br><span class="line">        pst.setInt(<span class="number">5</span>, state.getValue());</span><br><span class="line">        pst.executeUpdate();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(e <span class="keyword">instanceof</span> SQLException)) &#123;</span><br><span class="line">            e = <span class="keyword">new</span> <span class="title class_">SQLException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> (SQLException) e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体流程如下所示：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/cc94f7cbd5363484c839ed9e69b95c5d.png" alt="img"></p>
<h2 id="seata-服务端"><a class="markdownIt-Anchor" href="#seata-服务端">#</a> Seata 服务端</h2>
<p>我们找到 <code>Server.java</code>  这里就是启动入口，在这个入口中找到协调者，因为 TC 整体的操作就是协调整体的全局事务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认协调者</span></span><br><span class="line"><span class="type">DefaultCoordinator</span> <span class="variable">coordinator</span> <span class="operator">=</span> DefaultCoordinator.getInstance(nettyRemotingServer);</span><br></pre></td></tr></table></figure>
<p>在 <code>DefaultCoordinator</code>  类中我们找到 一个 <code>doGlobalBegin</code>  这个就是处理全局事务开始的方法，以及全局提交  <code>doGlobalCommit</code>  和全局回滚  <code>doGlobalRollback</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//处理全局事务</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGlobalBegin</span><span class="params">(GlobalBeginRequest request, GlobalBeginResponse response, RpcContext rpcContext)</span><span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line">        <span class="comment">//响应客户端xid</span></span><br><span class="line">response.setXid(core.begin(rpcContext.getApplicationId(), rpcContext.getTransactionServiceGroup(),</span><br><span class="line">                request.getTransactionName(), request.getTimeout()));</span><br><span class="line"><span class="keyword">if</span> (LOGGER.isInfoEnabled()) &#123;</span><br><span class="line">    LOGGER.info(<span class="string">&quot;Begin new global transaction applicationId: &#123;&#125;,transactionServiceGroup: &#123;&#125;, transactionName: &#123;&#125;,timeout:&#123;&#125;,xid:&#123;&#125;&quot;</span>,</span><br><span class="line">       rpcContext.getApplicationId(), rpcContext.getTransactionServiceGroup(), request.getTransactionName(), request.getTimeout(), response.getXid());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//处理全局提交</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGlobalCommit</span><span class="params">(GlobalCommitRequest request, GlobalCommitResponse response, RpcContext rpcContext)</span><span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line">     MDC.put(RootContext.MDC_KEY_XID, request.getXid());</span><br><span class="line">     response.setGlobalStatus(core.commit(request.getXid()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理全局回滚</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGlobalRollback</span><span class="params">(GlobalRollbackRequest request, GlobalRollbackResponse response,</span></span><br><span class="line"><span class="params">                                    RpcContext rpcContext)</span> <span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line">    MDC.put(RootContext.MDC_KEY_XID, request.getXid());</span><br><span class="line">    response.setGlobalStatus(core.rollback(request.getXid()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里我们首先关注  <code>doGlobalBegin</code>  中  <code>core.begin()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">begin</span><span class="params">(String applicationId, String transactionServiceGroup, String name, <span class="type">int</span> timeout)</span></span><br><span class="line">    <span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line">    <span class="comment">//创建全局事务Session</span></span><br><span class="line">    <span class="type">GlobalSession</span> <span class="variable">session</span> <span class="operator">=</span> GlobalSession.createGlobalSession(applicationId, transactionServiceGroup, name,</span><br><span class="line">        timeout);</span><br><span class="line">    MDC.put(RootContext.MDC_KEY_XID, session.getXid());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为Session重添加回调监听，SessionHolder.getRootSessionManager() 获取一个全局Session管理器DataBaseSessionManager</span></span><br><span class="line">    <span class="comment">//观察者设计模式，创建DataBaseSessionManager</span></span><br><span class="line">    session.addSessionLifecycleListener(SessionHolder.getRootSessionManager());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//全局事务开始</span></span><br><span class="line">    session.begin();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// transaction start event</span></span><br><span class="line">    MetricsPublisher.postSessionDoingEvent(session, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> session.getXid();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们在来看一下 <code>SessionHolder.getRootSessionManager()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gets root session manager.</span></span><br><span class="line"><span class="comment"> * 获取一个全局Session管理器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the root session manager</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SessionManager <span class="title function_">getRootSessionManager</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ROOT_SESSION_MANAGER == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ShouldNeverHappenException</span>(<span class="string">&quot;SessionManager is NOT init!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ROOT_SESSION_MANAGER;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(String mode)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(mode)) &#123;</span><br><span class="line">        mode = CONFIG.getConfig(ConfigurationKeys.STORE_SESSION_MODE,</span><br><span class="line">                CONFIG.getConfig(ConfigurationKeys.STORE_MODE, SERVER_DEFAULT_STORE_MODE));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">StoreMode</span> <span class="variable">storeMode</span> <span class="operator">=</span> StoreMode.get(mode);</span><br><span class="line">    <span class="comment">//判断Seata模式，当前为DB</span></span><br><span class="line">    <span class="keyword">if</span> (StoreMode.DB.equals(storeMode)) &#123;</span><br><span class="line">        <span class="comment">//通过SPI机制读取SessionManager接口实现类，读取的META-INF.services目录，在通过反射机制创建对象DataBaseSessionManager</span></span><br><span class="line">        ROOT_SESSION_MANAGER = EnhancedServiceLoader.load(SessionManager.class, StoreMode.DB.getName());</span><br><span class="line">        ........</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里他其实读取的是 DB 模式下  <code>io.seata.server.session.SessionManager</code>  文件的内容</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/4dd908fc36e0128e646e3c8c0b03262a.png" alt="img"></p>
<p>我们在回到 <code>begin</code>  方法中，去查看 <code>session.begin()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">begin</span><span class="params">()</span> <span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line">    <span class="comment">//声明全局事务开始</span></span><br><span class="line">    <span class="built_in">this</span>.status = GlobalStatus.Begin;</span><br><span class="line">    <span class="comment">//开始时间</span></span><br><span class="line">    <span class="built_in">this</span>.beginTime = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//激活全局事务</span></span><br><span class="line">    <span class="built_in">this</span>.active = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//将SessionManager放入到集合中，调用onBegin方法</span></span><br><span class="line">    <span class="keyword">for</span> (SessionLifecycleListener lifecycleListener : lifecycleListeners) &#123;</span><br><span class="line">        <span class="comment">//调用父级抽象类的方法</span></span><br><span class="line">        lifecycleListener.onBegin(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里我们来看一下  <code>onBegin()</code>  方法，调用的是父级的方法，在这其中我们要关注  <code>addGlobalSession()</code>  方法，但是要注意，这里我们用的是 db 模式所以调用的是 db 模式的  <code>DateBaseSessionManager</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onBegin</span><span class="params">(GlobalSession globalSession)</span> <span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line">    <span class="comment">//这里调用的是DateBaseSessionManager</span></span><br><span class="line">    addGlobalSession(globalSession);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addGlobalSession</span><span class="params">(GlobalSession session)</span> <span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(taskName)) &#123;</span><br><span class="line">        <span class="comment">//写入session</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">ret</span> <span class="operator">=</span> transactionStoreManager.writeSession(LogOperation.GLOBAL_ADD, session);</span><br><span class="line">        <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StoreException</span>(<span class="string">&quot;addGlobalSession failed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">ret</span> <span class="operator">=</span> transactionStoreManager.writeSession(LogOperation.GLOBAL_UPDATE, session);</span><br><span class="line">        <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StoreException</span>(<span class="string">&quot;addGlobalSession failed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在看查询其中关键的方法 <code>DataBaseTransactionStoreManager.writeSession()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">writeSession</span><span class="params">(LogOperation logOperation, SessionStorable session)</span> &#123;</span><br><span class="line">       <span class="comment">//第一次进入是写入 会进入当前方法</span></span><br><span class="line">       <span class="comment">//全局添加</span></span><br><span class="line">       <span class="keyword">if</span> (LogOperation.GLOBAL_ADD.equals(logOperation)) &#123;</span><br><span class="line">           <span class="keyword">return</span> logStore.insertGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));</span><br><span class="line">           <span class="comment">//全局修改</span></span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (LogOperation.GLOBAL_UPDATE.equals(logOperation)) &#123;</span><br><span class="line">           <span class="keyword">return</span> logStore.updateGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));</span><br><span class="line">           <span class="comment">//全局删除</span></span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (LogOperation.GLOBAL_REMOVE.equals(logOperation)) &#123;</span><br><span class="line">           <span class="keyword">return</span> logStore.deleteGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));</span><br><span class="line">           <span class="comment">//分支添加</span></span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (LogOperation.BRANCH_ADD.equals(logOperation)) &#123;</span><br><span class="line">           <span class="keyword">return</span> logStore.insertBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));</span><br><span class="line">           <span class="comment">//分支更新</span></span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (LogOperation.BRANCH_UPDATE.equals(logOperation)) &#123;</span><br><span class="line">           <span class="keyword">return</span> logStore.updateBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));</span><br><span class="line">           <span class="comment">//分支移除</span></span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (LogOperation.BRANCH_REMOVE.equals(logOperation)) &#123;</span><br><span class="line">           <span class="keyword">return</span> logStore.deleteBranchTransactionDO(SessionConverter.convertBranchTransactionDO(session));</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StoreException</span>(<span class="string">&quot;Unknown LogOperation:&quot;</span> + logOperation.name());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>我们就看第一次进去的方法 <code>logStore.insertGlobalTransactionDO(SessionConverter.convertGlobalTransactionDO(session));</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insertGlobalTransactionDO</span><span class="params">(GlobalTransactionDO globalTransactionDO)</span> &#123;</span><br><span class="line">     <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> LogStoreSqlsFactory.getLogStoreSqls(dbType).getInsertGlobalTransactionSQL(globalTable);</span><br><span class="line">     <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">     <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">         conn = logStoreDataSource.getConnection();</span><br><span class="line">         conn.setAutoCommit(<span class="literal">true</span>);</span><br><span class="line">         ps = conn.prepareStatement(sql);</span><br><span class="line">         ps.setString(index++, globalTransactionDO.getXid());</span><br><span class="line">         ps.setLong(index++, globalTransactionDO.getTransactionId());</span><br><span class="line">         ps.setInt(index++, globalTransactionDO.getStatus());</span><br><span class="line">         ps.setString(index++, globalTransactionDO.getApplicationId());</span><br><span class="line">         ps.setString(index++, globalTransactionDO.getTransactionServiceGroup());</span><br><span class="line">         <span class="type">String</span> <span class="variable">transactionName</span> <span class="operator">=</span> globalTransactionDO.getTransactionName();</span><br><span class="line">         transactionName = transactionName.length() &gt; transactionNameColumnSize ?</span><br><span class="line">             transactionName.substring(<span class="number">0</span>, transactionNameColumnSize) :</span><br><span class="line">             transactionName;</span><br><span class="line">         ps.setString(index++, transactionName);</span><br><span class="line">         ps.setInt(index++, globalTransactionDO.getTimeout());</span><br><span class="line">         ps.setLong(index++, globalTransactionDO.getBeginTime());</span><br><span class="line">         ps.setString(index++, globalTransactionDO.getApplicationData());</span><br><span class="line">         <span class="keyword">return</span> ps.executeUpdate() &gt; <span class="number">0</span>;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StoreException</span>(e);</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         IOUtil.close(ps, conn);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在这里有一个  <code>GlobalTransactionDO </code> 对象，里面有 <code>xid、transactionId</code>  等等，到这里是不是就很熟悉了、</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/5649458fda2717fb7c87a5d8d0df2741.png" alt="img"></p>
<p>还记得我们第一次使用 Seata 的时候会创建三张表</p>
<ol>
<li>branch_table 分支事务表</li>
<li>global_table 全局事务表</li>
<li>lock_table 全局锁表</li>
</ol>
<p>而这里就是对应我们的 <code>global_table</code>  表，其他两个也是差不多，都是一样的操作</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/6ef22513cae0ad8f2861cf18ec4cde0c.png" alt="img"><br>
 流程图如下：<br>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/c33801b28bbae2a960f6b14856d4e8cf.png" alt="img"></p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结">#</a> 总结</h2>
<p>完整流程图：</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/e615279306d5aaf9ad85b8e2f9905a35.png" alt="img"></p>
<p>对于 Seata 源码来说主要是了解从哪里入口以及核心点在哪里，遇到有疑问的，可以 Debug，对于 Seata AT 模式，我们主要掌握的核心点是</p>
<ul>
<li>如何获取全局锁、开启全局事务</li>
<li>解析 SQL 并写入 undolog</li>
</ul>
<h2 id="关于我"><a class="markdownIt-Anchor" href="#关于我">#</a> 关于我</h2>
<p>Brath 是一个热爱技术的 Java 程序猿，公众号「InterviewCoder」定期分享有趣有料的精品原创文章！</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png" alt="InterviewCoder"></p>
<p>非常感谢各位人才能看到这里，原创不易，文章如果有帮助可以关注、点赞、分享或评论，这都是对我的莫大支持！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-05-17T08:20:40.000Z" title="2023-5-17 16:20:40">2023-05-17</time>发表</span><span class="level-item"><time dateTime="2023-05-17T08:28:47.563Z" title="2023-5-17 16:28:47">2023-05-17</time>更新</span><span class="level-item">2 分钟读完 (大约298个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/05/17/%E3%80%90Java%E3%80%91%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%EF%BC%9A%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E6%97%A0%E5%93%8D%E5%BA%94/">【Java】记一次线上故障：服务接口无响应</a></p><div class="content"><p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png" alt="InterviewCoder"></p>
<h2 id="事故起因"><a class="markdownIt-Anchor" href="#事故起因">#</a> 事故起因</h2>
<h5 id="中午公众号突然收到消息很多用户说chatgpt不回复询问我是不是程序坏掉了"><a class="markdownIt-Anchor" href="#中午公众号突然收到消息很多用户说chatgpt不回复询问我是不是程序坏掉了">#</a> 中午公众号突然收到消息，很多用户说 chatGPT 不回复，询问我是不是程序坏掉了</h5>
<h2 id="排查流程"><a class="markdownIt-Anchor" href="#排查流程">#</a> 排查流程</h2>
<h4 id="1进入docker查看服务日志发现日志都正常输出没有报错"><a class="markdownIt-Anchor" href="#1进入docker查看服务日志发现日志都正常输出没有报错">#</a> 1. 进入 docker 查看服务日志，发现日志都正常输出，没有报错</h4>
<h4 id="2在本地启动程序排查发现无异常"><a class="markdownIt-Anchor" href="#2在本地启动程序排查发现无异常">#</a> 2. 在本地启动程序排查，发现无异常</h4>
<h4 id="3使用接口工具调用其他接口和网关心跳接口尝试无响应"><a class="markdownIt-Anchor" href="#3使用接口工具调用其他接口和网关心跳接口尝试无响应">#</a> 3. 使用接口工具调用其他接口和网关心跳接口尝试，无响应</h4>
<h4 id="4查看线上cpu和内存使用率结果正常"><a class="markdownIt-Anchor" href="#4查看线上cpu和内存使用率结果正常">#</a> 4. 查看线上 CPU 和内存使用率，结果正常</h4>
<h4 id="5查看线上磁盘占用100"><a class="markdownIt-Anchor" href="#5查看线上磁盘占用100">#</a> 5. 查看线上磁盘：占用 100%</h4>
<h2 id="结果"><a class="markdownIt-Anchor" href="#结果">#</a> 结果</h2>
<p>​	清理掉 Nacos 的大量日志后，服务恢复正常。</p>
<h2 id="关于我"><a class="markdownIt-Anchor" href="#关于我">#</a> 关于我</h2>
<p>Brath 是一个热爱技术的 Java 程序猿，公众号「InterviewCoder」定期分享有趣有料的精品原创文章！</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png" alt="InterviewCoder"></p>
<p>非常感谢各位人才能看到这里，原创不易，文章如果有帮助可以关注、点赞、分享或评论，这都是对我的莫大支持！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-05-08T14:04:55.000Z" title="2023-5-8 22:04:55">2023-05-08</time>发表</span><span class="level-item"><time dateTime="2023-05-09T00:27:14.814Z" title="2023-5-9 8:27:14">2023-05-09</time>更新</span><span class="level-item">1 小时读完 (大约9856个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/05/08/%E3%80%90Java%E3%80%91HashMap%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E8%AF%BB/">【Java】HashMap核心原理解读</a></p><div class="content"><p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png" alt="InterviewCoder"></p>
<h1 id="javahashmap核心原理解读"><a class="markdownIt-Anchor" href="#javahashmap核心原理解读">#</a> 【Java】HashMap 核心原理解读</h1>
<h2 id="一-前言"><a class="markdownIt-Anchor" href="#一-前言">#</a> 一、前言</h2>
<p>得益于 <code>Doug Lea</code>  老爷子的操刀，让 <code>HashMap</code>  成为使用和面试最频繁的 API，没办法设计的太优秀了！</p>
<p>HashMap 最早出现在 JDK 1.2 中，底层基于散列算法实现。HashMap 允许 null 键和 null 值，在计算哈键的哈希值时，null 键哈希值为 0。HashMap 并不保证键值对的顺序，这意味着在进行某些操作后，键值对的顺序可能会发生变化。另外，需要注意的是，HashMap 是非线程安全类，在多线程环境下可能会存在问题。</p>
<h2 id="二-源码分析"><a class="markdownIt-Anchor" href="#二-源码分析">#</a> 二、源码分析</h2>
<h3 id="1-写一个最简单的hashmap"><a class="markdownIt-Anchor" href="#1-写一个最简单的hashmap">#</a> 1. 写一个最简单的 HashMap</h3>
<p>学习 HashMap 前，最好的方式是先了解这是一种怎么样的数据结构来存放数据。而 HashMap 经过多个版本的迭代后，乍一看代码还是很复杂的。就像你原来只穿个裤衩，现在还有秋裤和风衣。所以我们先来看看最根本的 HashMap 是什么样，也就是只穿裤衩是什么效果，之后再去分析它的源码。</p>
<p><strong>问题：</strong> 假设我们有一组 7 个字符串，需要存放到数组中，但要求在获取每个元素的时候时间复杂度是 O (1)。也就是说你不能通过循环遍历的方式进行获取，而是要定位到数组 ID 直接获取相应的元素。</p>
<p><strong>方案：</strong> 如果说我们需要通过 ID 从数组中获取元素，那么就需要把每个字符串都计算出一个在数组中的位置 ID。<em>字符串获取 ID 你能想到什么方式？</em> 一个字符串最直接的获取跟数字相关的信息就是 HashCode，可 HashCode 的取值范围太大了 <code>[-2147483648, 2147483647]</code> ，不可能直接使用。那么就需要使用 HashCode 与数组长度做与运算，得到一个可以在数组中出现的位置。如果说有两个元素得到同样的 ID，那么这个数组 ID 下就存放两个字符串。</p>
<p>以上呢其实就是我们要把字符串散列到数组中的一个基本思路，接下来我们就把这个思路用代码实现出来。</p>
<h4 id="11-代码实现"><a class="markdownIt-Anchor" href="#11-代码实现">#</a> 1.1 代码实现</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一组字符串</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;jlkk&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;lopi&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;小傅哥&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;e4we&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;alpo&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;yhjk&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;plop&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义要存放的数组</span></span><br><span class="line">String[] tab = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环存放</span></span><br><span class="line"><span class="keyword">for</span> (String key : list) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);  <span class="comment">// 计算索引位置</span></span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;key值=%s Idx=%d&quot;</span>, key, idx));</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == tab[idx]) &#123;</span><br><span class="line">        tab[idx] = key;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tab[idx] = tab[idx] + <span class="string">&quot;-&gt;&quot;</span> + key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出测试结果</span></span><br><span class="line">System.out.println(JSON.toJSONString(tab));</span><br></pre></td></tr></table></figure>
<p>这段代码整体看起来也是非常简单，并没有什么复杂度，主要包括以下内容；</p>
<ol>
<li>初始化一组字符串集合，这里初始化了 7 个。</li>
<li>定义一个数组用于存放字符串，注意这里的长度是 8，也就是 2 的 3 次幂。这样的数组长度才会出现一个  <code>0111</code>  除高位以外都是 1 的特征，也是为了散列。</li>
<li>接下来就是循环存放数据，计算出每个字符串在数组中的位置。 <code>key.hashCode() &amp; (tab.length - 1)</code> 。</li>
<li>在字符串存放到数组的过程，如果遇到相同的元素，进行连接操作 <code>模拟链表的过程</code> 。</li>
<li>最后输出存放结果。</li>
</ol>
<p><strong>测试结果</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">key值=jlkk Idx=<span class="number">2</span></span><br><span class="line">key值=lopi Idx=<span class="number">4</span></span><br><span class="line">key值=小傅哥 Idx=<span class="number">7</span></span><br><span class="line">key值=e4we Idx=<span class="number">5</span></span><br><span class="line">key值=alpo Idx=<span class="number">2</span></span><br><span class="line">key值=yhjk Idx=<span class="number">0</span></span><br><span class="line">key值=plop Idx=<span class="number">5</span></span><br><span class="line">测试结果：[<span class="string">&quot;yhjk&quot;</span>,<span class="literal">null</span>,<span class="string">&quot;jlkk-&gt;alpo&quot;</span>,<span class="literal">null</span>,<span class="string">&quot;lopi&quot;</span>,<span class="string">&quot;e4we-&gt;plop&quot;</span>,<span class="literal">null</span>,<span class="string">&quot;小傅哥&quot;</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>在测试结果首先是计算出每个元素在数组的 Idx，也有出现重复的位置。</li>
<li>最后是测试结果的输出，1、3、6，位置是空的，2、5，位置有两个元素被链接起来 <code>e4we-&gt;plop</code> 。</li>
<li>这就达到了我们一个最基本的要求，将串元素散列存放到数组中，最后通过字符串元素的索引 ID 进行获取对应字符串。这样是 HashMap 的一个最基本原理，有了这个基础后面就会更容易理解 HashMap 的源码实现。</li>
</ul>
<h4 id="12-hash散列示意图"><a class="markdownIt-Anchor" href="#12-hash散列示意图">#</a> 1.2 Hash 散列示意图</h4>
<p>如果上面的测试结果不能在你的头脑中很好的建立出一个数据结构，那么可以看以下这张散列示意图，方便理解；</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/interview-4-01.png" alt="bugstack.cn Hash散列示意图"></p>
<ul>
<li>这张图就是上面代码实现的全过程，将每一个字符串元素通过 Hash 计算索引位置，存放到数组中。</li>
<li>黄色的索引 ID 是没有元素存放、绿色的索引 ID 存放了一个元素、红色的索引 ID 存放了两个元素。</li>
</ul>
<h4 id="httpsbugstackcnmdjavainterview2020-08-07-面经手册-第3篇hashmap核心知识扰动函数-负载因子-扩容链表拆分深度学习html_1-3-这个简单的hashmap有哪些问题13-这个简单的hashmap有哪些问题"><a class="markdownIt-Anchor" href="#httpsbugstackcnmdjavainterview2020-08-07-面经手册-第3篇hashmap核心知识扰动函数-负载因子-扩容链表拆分深度学习html_1-3-这个简单的hashmap有哪些问题13-这个简单的hashmap有哪些问题">#</a> [#](<a target="_blank" rel="noopener" href="https://bugstack.cn/md/java/interview/2020-08-07-%E9%9D%A2%E7%BB%8F%E6%89%8B%E5%86%8C">https://bugstack.cn/md/java/interview/2020-08-07 - 面经手册</a>・第 3 篇《HashMap 核心知识，扰动函数、负载因子、扩容链表拆分，深度学习》.html#_1-3 - 这个简单的 hashmap 有哪些问题) 1.3 这个简单的 HashMap 有哪些问题</h4>
<p>以上我们实现了一个简单的 HashMap，或者说还算不上 HashMap，只能算做一个散列数据存放的雏形。但这样的一个数据结构放在实际使用中，会有哪些问题呢？</p>
<ol>
<li>这里所有的元素存放都需要获取一个索引位置，而如果元素的位置不够散列碰撞严重，那么就失去了散列表存放的意义，没有达到预期的性能。</li>
<li>在获取索引 ID 的计算公式中，需要数组长度是 2 的幂次方，那么怎么进行初始化这个数组大小。</li>
<li>数组越小碰撞的越大，数组越大碰撞的越小，时间与空间如何取舍。</li>
<li>目前存放 7 个元素，已经有两个位置都存放了 2 个字符串，那么链表越来越长怎么优化。</li>
<li>随着元素的不断添加，数组长度不足扩容时，怎么把原有的元素，拆分到新的位置上去。</li>
</ol>
<p>以上这些问题可以归纳为； <code>扰动函数</code> 、 <code>初始化容量</code> 、 <code>负载因子</code> 、 <code>扩容方法</code> 以及 <code>链表和红黑树</code> 转换的使用等。接下来我们会逐个问题进行分析。</p>
<h3 id="2-扰动函数"><a class="markdownIt-Anchor" href="#2-扰动函数">#</a> 2. 扰动函数</h3>
<p>在 HashMap 存放元素时候有这样一段代码来处理哈希值，这是 <code>java 8</code>  的散列值扰动函数，用于优化散列效果；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="21-为什么使用扰动函数"><a class="markdownIt-Anchor" href="#21-为什么使用扰动函数">#</a> 2.1 为什么使用扰动函数</h4>
<p>理论上来说字符串的 <code>hashCode</code>  是一个 int 类型值，那可以直接作为数组下标了，且不会出现碰撞。但是这个 <code>hashCode</code>  的取值范围是 [-2147483648, 2147483647]，有将近 40 亿的长度，谁也不能把数组初始化的这么大，内存也是放不下的。</p>
<p>我们默认初始化的 Map 大小是 16 个长度  <code>DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4</code> ，所以获取的 Hash 值并不能直接作为下标使用，需要与数组长度进行取模运算得到一个下标值，也就是我们上面做的散列列子。</p>
<p>那么，hashMap 源码这里不只是直接获取哈希值，还进行了一次扰动计算， <code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code> 。把哈希值右移 16 位，也就正好是自己长度的一半，之后与原哈希值做异或运算，这样就混合了原哈希值中的高位和低位，增大了<strong>随机性</strong>。计算方式如下图；</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/interview-4-02.png" alt="bugstack.cn 扰动函数"></p>
<ul>
<li>说白了，使用扰动函数就是为了增加随机性，让数据元素更加均衡的散列，减少碰撞。</li>
</ul>
<h4 id="22-实验验证扰动函数"><a class="markdownIt-Anchor" href="#22-实验验证扰动函数">#</a> 2.2 实验验证扰动函数</h4>
<p>从上面的分析可以看出，扰动函数使用了哈希值的高半区和低半区做异或，混合原始哈希码的高位和低位，以此来加大低位区的随机性。</p>
<p>但看不到实验数据的话，这终究是一段理论，具体这段哈希值真的被增加了随机性没有，并不知道。所以这里我们要做一个实验，这个实验是这样做；</p>
<ol>
<li>选取 10 万个单词词库</li>
<li>定义 128 位长度的数组格子</li>
<li>分别计算在扰动和不扰动下，10 万单词的下标分配到 128 个格子的数量</li>
<li>统计各个格子数量，生成波动曲线。如果扰动函数下的波动曲线相对更平稳，那么证明扰动函数有效果。</li>
</ol>
<h5 id="221-扰动代码测试"><a class="markdownIt-Anchor" href="#221-扰动代码测试">#</a> 2.2.1 扰动代码测试</h5>
<p><strong>扰动函数对比方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Disturb</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">disturbHashIdx</span><span class="params">(String key, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (size - <span class="number">1</span>) &amp; (key.hashCode() ^ (key.hashCode() &gt;&gt;&gt; <span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hashIdx</span><span class="params">(String key, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (size - <span class="number">1</span>) &amp; key.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>disturbHashIdx</code>  扰动函数下，下标值计算</li>
<li><code>hashIdx</code>  非扰动函数下，下标值计算</li>
</ul>
<p><strong>单元测试</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 10万单词已经初始化到words中</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_disturb</span><span class="params">()</span> &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">        <span class="comment">// 使用扰动函数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> Disturb.disturbHashIdx(word, <span class="number">128</span>);</span><br><span class="line">        <span class="comment">// 不使用扰动函数</span></span><br><span class="line">        <span class="comment">// int idx = Disturb.hashIdx(word, 128);</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(idx)) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> map.get(idx);</span><br><span class="line">            map.put(idx, ++integer);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(idx, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(map.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上分别统计两种函数下的下标值分配，最终将统计结果放到 excel 中生成图表。</p>
<h5 id="httpsbugstackcnmdjavainterview2020-08-07-面经手册-第3篇hashmap核心知识扰动函数-负载因子-扩容链表拆分深度学习html_2-2-2-扰动函数散列图表222-扰动函数散列图表"><a class="markdownIt-Anchor" href="#httpsbugstackcnmdjavainterview2020-08-07-面经手册-第3篇hashmap核心知识扰动函数-负载因子-扩容链表拆分深度学习html_2-2-2-扰动函数散列图表222-扰动函数散列图表">#</a> [#](<a target="_blank" rel="noopener" href="https://bugstack.cn/md/java/interview/2020-08-07-%E9%9D%A2%E7%BB%8F%E6%89%8B%E5%86%8C">https://bugstack.cn/md/java/interview/2020-08-07 - 面经手册</a>・第 3 篇《HashMap 核心知识，扰动函数、负载因子、扩容链表拆分，深度学习》.html#_2-2-2 - 扰动函数散列图表) 2.2.2 扰动函数散列图表</h5>
<p>以上的两张图，分别是没有使用扰动函数和使用扰动函数的，下标分配。实验数据；</p>
<ol>
<li>10 万个不重复的单词</li>
<li>128 个格子，相当于 128 长度的数组</li>
</ol>
<p><strong>未使用扰动函数</strong></p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/interview-4-03.png" alt="bugstack.cn 未使用扰动函数"></p>
<p><strong>使用扰动函数</strong></p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/interview-4-04.png" alt="bugstack.cn 使用扰动函数"></p>
<ul>
<li>从这两种的对比图可以看出来，在使用了扰动函数后，数据分配的更加均匀了。</li>
<li>数据分配均匀，也就是散列的效果更好，减少了 hash 的碰撞，让数据存放和获取的效率更佳。</li>
</ul>
<h3 id="3-初始化容量和负载因子"><a class="markdownIt-Anchor" href="#3-初始化容量和负载因子">#</a> 3. 初始化容量和负载因子</h3>
<p>接下来我们讨论下一个问题，从我们模仿 HashMap 的例子中以及 HashMap 默认的初始化大小里，都可以知道，散列数组需要一个 2 的幂次方的长度，因为只有 2 的幂次方在减 1 的时候，才会出现 <code>01111</code>  这样的值。</p>
<p>那么这里就有一个问题，我们在初始化 HashMap 的时候，如果传一个 17 个的值 <code>new HashMap&lt;&gt;(17);</code> ，它会怎么处理呢？</p>
<h4 id="31-寻找2的幂次方最小值"><a class="markdownIt-Anchor" href="#31-寻找2的幂次方最小值">#</a> 3.1 寻找 2 的幂次方最小值</h4>
<p>在 HashMap 的初始化中，有这样一段方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>阈值 <code>threshold</code> ，通过方法 <code>tableSizeFor</code>  进行计算，是根据初始化来计算的。</li>
<li>这个方法也就是要寻找比初始值大的，最小的那个 2 进制数值。比如传了 17，我应该找到的是 32（2 的 4 次幂是 16&lt;17, 所以找到 2 的 5 次幂 32）。</li>
</ul>
<p>计算阈值大小的方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>MAXIMUM_CAPACITY = 1 &lt;&lt; 30，这个是临界范围，也就是最大的 Map 集合。</li>
<li>乍一看可能有点晕😵怎么都在向右移位 1、2、4、8、16，这主要是为了把二进制的各个位置都填上 1，当二进制的各个位置都是 1 以后，就是一个标准的 2 的幂次方减 1 了，最后把结果加 1 再返回即可。</li>
</ul>
<p>那这里我们把 17 这样一个初始化计算阈值的过程，用图展示出来，方便理解；</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/interview-4-05.png" alt="bugstack.cn 计算阈值"></p>
<h4 id="32-负载因子"><a class="markdownIt-Anchor" href="#32-负载因子">#</a> 3.2 负载因子</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;  </span><br></pre></td></tr></table></figure>
<p><strong>负载因子是做什么的？</strong></p>
<p>负载因子，可以理解成一辆车可承重重量超过某个阈值时，把货放到新的车上。</p>
<p>那么在 HashMap 中，负载因子决定了数据量多少了以后进行扩容。<em>这里要提到上面做的 HashMap 例子，我们准备了 7 个元素，但是最后还有 3 个位置空余，2 个位置存放了 2 个元素。</em> 所以可能即使你数据比数组容量大时也是不一定能正正好好的把数组占满的，而是在某些小标位置出现了大量的碰撞，只能在同一个位置用链表存放，那么这样就失去了 Map 数组的性能。</p>
<p>所以，要选择一个合理的大小下进行扩容，默认值 0.75 就是说当阈值容量占了 3/4 时赶紧扩容，减少 Hash 碰撞。</p>
<p>同时 0.75 是一个默认构造值，在创建 HashMap 也可以调整，比如你希望用更多的空间换取时间，可以把负载因子调的更小一些，减少碰撞。</p>
<h3 id="4-扩容元素拆分"><a class="markdownIt-Anchor" href="#4-扩容元素拆分">#</a> 4. 扩容元素拆分</h3>
<p>为什么扩容，因为数组长度不足了。那扩容最直接的问题，就是需要把元素拆分到新的数组中。拆分元素的过程中，原 jdk1.7 中会需要重新计算哈希值，但是到 jdk1.8 中已经进行优化，不再需要重新计算，提升了拆分的性能，设计的还是非常巧妙的。</p>
<h4 id="41-测试数据"><a class="markdownIt-Anchor" href="#41-测试数据">#</a> 4.1 测试数据</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_hashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;jlkk&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;lopi&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;jmdw&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;e4we&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;io98&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;nmhg&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;vfg6&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;gfrt&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;alpo&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;vfbh&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;bnhj&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;zuio&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;iu8e&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;yhjk&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;plop&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;dd0p&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String key : list) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode() ^ (key.hashCode() &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串：&quot;</span> + key + <span class="string">&quot; \tIdx(16)：&quot;</span> + ((<span class="number">16</span> - <span class="number">1</span>) &amp; hash) + <span class="string">&quot; \tBit值：&quot;</span> + Integer.toBinaryString(hash) + <span class="string">&quot; - &quot;</span> + Integer.toBinaryString(hash &amp; <span class="number">16</span>) + <span class="string">&quot; \t\tIdx(32)：&quot;</span> + ((</span><br><span class="line">        System.out.println(Integer.toBinaryString(key.hashCode()) +<span class="string">&quot; &quot;</span>+ Integer.toBinaryString(hash) + <span class="string">&quot; &quot;</span> + Integer.toBinaryString((<span class="number">32</span> - <span class="number">1</span>) &amp; hash));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p><strong>测试结果</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">字符串：jlkk 	<span class="title function_">Idx</span><span class="params">(<span class="number">16</span>)</span>：<span class="number">3</span> 	Bit值：<span class="number">1100011101001000010011</span> - <span class="number">10000</span> 		Idx(<span class="number">32</span>)：<span class="number">19</span></span><br><span class="line"><span class="number">1100011101001000100010</span> <span class="number">1100011101001000010011</span> <span class="number">10011</span></span><br><span class="line">字符串：lopi 	<span class="title function_">Idx</span><span class="params">(<span class="number">16</span>)</span>：<span class="number">14</span> 	Bit值：<span class="number">1100101100011010001110</span> - <span class="number">0</span> 		Idx(<span class="number">32</span>)：<span class="number">14</span></span><br><span class="line"><span class="number">1100101100011010111100</span> <span class="number">1100101100011010001110</span> <span class="number">1110</span></span><br><span class="line">字符串：jmdw 	<span class="title function_">Idx</span><span class="params">(<span class="number">16</span>)</span>：<span class="number">7</span> 	Bit值：<span class="number">1100011101010100100111</span> - <span class="number">0</span> 		Idx(<span class="number">32</span>)：<span class="number">7</span></span><br><span class="line"><span class="number">1100011101010100010110</span> <span class="number">1100011101010100100111</span> <span class="number">111</span></span><br><span class="line">字符串：e4we 	<span class="title function_">Idx</span><span class="params">(<span class="number">16</span>)</span>：<span class="number">3</span> 	Bit值：<span class="number">1011101011101101010011</span> - <span class="number">10000</span> 		Idx(<span class="number">32</span>)：<span class="number">19</span></span><br><span class="line"><span class="number">1011101011101101111101</span> <span class="number">1011101011101101010011</span> <span class="number">10011</span></span><br><span class="line">字符串：io98 	<span class="title function_">Idx</span><span class="params">(<span class="number">16</span>)</span>：<span class="number">4</span> 	Bit值：<span class="number">1100010110001011110100</span> - <span class="number">10000</span> 		Idx(<span class="number">32</span>)：<span class="number">20</span></span><br><span class="line"><span class="number">1100010110001011000101</span> <span class="number">1100010110001011110100</span> <span class="number">10100</span></span><br><span class="line">字符串：nmhg 	<span class="title function_">Idx</span><span class="params">(<span class="number">16</span>)</span>：<span class="number">13</span> 	Bit值：<span class="number">1100111010011011001101</span> - <span class="number">0</span> 		Idx(<span class="number">32</span>)：<span class="number">13</span></span><br><span class="line"><span class="number">1100111010011011111110</span> <span class="number">1100111010011011001101</span> <span class="number">1101</span></span><br><span class="line">字符串：vfg6 	<span class="title function_">Idx</span><span class="params">(<span class="number">16</span>)</span>：<span class="number">8</span> 	Bit值：<span class="number">1101110010111101101000</span> - <span class="number">0</span> 		Idx(<span class="number">32</span>)：<span class="number">8</span></span><br><span class="line"><span class="number">1101110010111101011111</span> <span class="number">1101110010111101101000</span> <span class="number">1000</span></span><br><span class="line">字符串：gfrt 	<span class="title function_">Idx</span><span class="params">(<span class="number">16</span>)</span>：<span class="number">1</span> 	Bit值：<span class="number">1100000101111101010001</span> - <span class="number">10000</span> 		Idx(<span class="number">32</span>)：<span class="number">17</span></span><br><span class="line"><span class="number">1100000101111101100001</span> <span class="number">1100000101111101010001</span> <span class="number">10001</span></span><br><span class="line">字符串：alpo 	<span class="title function_">Idx</span><span class="params">(<span class="number">16</span>)</span>：<span class="number">7</span> 	Bit值：<span class="number">1011011011101101000111</span> - <span class="number">0</span> 		Idx(<span class="number">32</span>)：<span class="number">7</span></span><br><span class="line"><span class="number">1011011011101101101010</span> <span class="number">1011011011101101000111</span> <span class="number">111</span></span><br><span class="line">字符串：vfbh 	<span class="title function_">Idx</span><span class="params">(<span class="number">16</span>)</span>：<span class="number">1</span> 	Bit值：<span class="number">1101110010111011000001</span> - <span class="number">0</span> 		Idx(<span class="number">32</span>)：<span class="number">1</span></span><br><span class="line"><span class="number">1101110010111011110110</span> <span class="number">1101110010111011000001</span> <span class="number">1</span></span><br><span class="line">字符串：bnhj 	<span class="title function_">Idx</span><span class="params">(<span class="number">16</span>)</span>：<span class="number">0</span> 	Bit值：<span class="number">1011100011011001100000</span> - <span class="number">0</span> 		Idx(<span class="number">32</span>)：<span class="number">0</span></span><br><span class="line"><span class="number">1011100011011001001110</span> <span class="number">1011100011011001100000</span> <span class="number">0</span></span><br><span class="line">字符串：zuio 	<span class="title function_">Idx</span><span class="params">(<span class="number">16</span>)</span>：<span class="number">8</span> 	Bit值：<span class="number">1110010011100110011000</span> - <span class="number">10000</span> 		Idx(<span class="number">32</span>)：<span class="number">24</span></span><br><span class="line"><span class="number">1110010011100110100001</span> <span class="number">1110010011100110011000</span> <span class="number">11000</span></span><br><span class="line">字符串：iu8e 	<span class="title function_">Idx</span><span class="params">(<span class="number">16</span>)</span>：<span class="number">8</span> 	Bit值：<span class="number">1100010111100101101000</span> - <span class="number">0</span> 		Idx(<span class="number">32</span>)：<span class="number">8</span></span><br><span class="line"><span class="number">1100010111100101011001</span> <span class="number">1100010111100101101000</span> <span class="number">1000</span></span><br><span class="line">字符串：yhjk 	<span class="title function_">Idx</span><span class="params">(<span class="number">16</span>)</span>：<span class="number">8</span> 	Bit值：<span class="number">1110001001010010101000</span> - <span class="number">0</span> 		Idx(<span class="number">32</span>)：<span class="number">8</span></span><br><span class="line"><span class="number">1110001001010010010000</span> <span class="number">1110001001010010101000</span> <span class="number">1000</span></span><br><span class="line">字符串：plop 	<span class="title function_">Idx</span><span class="params">(<span class="number">16</span>)</span>：<span class="number">9</span> 	Bit值：<span class="number">1101001000110011101001</span> - <span class="number">0</span> 		Idx(<span class="number">32</span>)：<span class="number">9</span></span><br><span class="line"><span class="number">1101001000110011011101</span> <span class="number">1101001000110011101001</span> <span class="number">1001</span></span><br><span class="line">字符串：dd0p 	<span class="title function_">Idx</span><span class="params">(<span class="number">16</span>)</span>：<span class="number">14</span> 	Bit值：<span class="number">1011101111001011101110</span> - <span class="number">0</span> 		Idx(<span class="number">32</span>)：<span class="number">14</span></span><br><span class="line"><span class="number">1011101111001011000000</span> <span class="number">1011101111001011101110</span> <span class="number">1110</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这里我们随机使用一些字符串计算他们分别在 16 位长度和 32 位长度数组下的索引分配情况，看哪些数据被重新路由到了新的地址。</li>
<li>同时，这里还可以观察🕵出一个非常重要的信息，原哈希值与扩容新增出来的长度 16，进行 &amp; 运算，如果值等于 0，则下标位置不变。如果不为 0，那么新的位置则是原来位置上加 16。｛这个地方需要好好理解下，并看实验数据｝</li>
<li>这样一来，就不需要在重新计算每一个数组中元素的哈希值了。</li>
</ul>
<p>4.2 数据迁移</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/interview-4-06.png" alt="bugstack.cn 数据迁移"></p>
<ul>
<li>这张图就是原 16 位长度数组元素，向 32 位扩容后数组转移的过程。</li>
<li>对 31 取模保留低 5 位，对 15 取模保留低 4 位，两者的差异就在于第 5 位是否为 1，是的话则需要加上增量，为 0 的话则不需要改变</li>
<li>其中黄色区域元素 <code>zuio</code>  因计算结果  <code>hash &amp; oldCap</code>  低位第 5 位为 1，则被迁移到下标位置 24。</li>
<li>同时还是用重新计算哈希值的方式验证了，确实分配到 24 的位置，因为这是在二进制计算中补 1 的过程，所以可以通过上面简化的方式确定哈希值的位置。</li>
</ul>
<p>那么为什么 e.hash &amp; oldCap == 0 为什么可以判断当前节点是否需要移位，而不是再次计算 hash;</p>
<p>仍然是原始长度为 16 举例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">old:</span><br><span class="line"><span class="number">10</span>: <span class="number">0000</span> <span class="number">1010</span></span><br><span class="line"><span class="number">15</span>: <span class="number">0000</span> <span class="number">1111</span></span><br><span class="line">&amp;: <span class="number">0000</span> <span class="number">1010</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span>:</span><br><span class="line"><span class="number">10</span>: <span class="number">0000</span> <span class="number">1010</span></span><br><span class="line"><span class="number">31</span>: <span class="number">0001</span> <span class="number">1111</span></span><br><span class="line">&amp;: <span class="number">0000</span> <span class="number">1010</span> </span><br></pre></td></tr></table></figure>
<p>从上面的示例可以很轻易的看出，两次 indexFor () 的差别只是第二次参与位于比第一次左边有一位从 0 变为 1, 而这个变化的 1 刚好是 oldCap, 那么只需要判断原 key 的 hash 这个位上是否为 1: 若是 1, 则需要移动至 oldCap + i 的槽位，若为 0, 则不需要移动；</p>
<p>这也是 HashMap 的长度必须保证是 2 的幂次方的原因，正因为这种环环相扣的设计，HashMap.loadFactor 的选值是 3/4 就能理解了，table.length * 3/4 可以被优化为 ((table.length&gt;&gt; 2) &lt;&lt; 2) - (table.length &gt;&gt; 2) == table.length - (table.length &gt;&gt; 2), JAVA 的位运算比乘除的效率更高，所以取 3/4 在保证 hash 冲突小的情况下兼顾了效率；</p>
<h1 id="面试题总结"><a class="markdownIt-Anchor" href="#面试题总结">#</a> 面试题总结</h1>
<h1 id="question"><a class="markdownIt-Anchor" href="#question">#</a> Question</h1>
<h4 id="1为什么hashmap哈希表中数组长度总是取-2-的幂次方"><a class="markdownIt-Anchor" href="#1为什么hashmap哈希表中数组长度总是取-2-的幂次方">#</a> 1. 为什么 HashMap 哈希表中数组长度总是取 2 的幂次方？</h4>
<h6 id="散列数组需要一个2的幂次方的长度因为只有2的幂次方在减1的时候才会出现01111这样的值"><a class="markdownIt-Anchor" href="#散列数组需要一个2的幂次方的长度因为只有2的幂次方在减1的时候才会出现01111这样的值">#</a> 散列数组需要一个 2 的幂次方的长度，因为只有 2 的幂次方在减 1 的时候，才会出现 01111 这样的值。</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过获取存储内容的hashcode，并且对长度是 2 的幂次方的数组长度-1进行与运算得到一个可以在数组中出现的位置</span></span><br><span class="line"><span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">哈希表中数组长度总是取 <span class="number">2</span> 的幂次方，这是因为对于大多数的质数来说，它们的二进制表示中只有少数位是为 <span class="number">1</span>。如果使用一个不是 <span class="number">2</span> 的幂次方的数组长度，那么当元素的哈希映射到索引时，就会出现某些索引永远无法被访问到的情况，这就浪费了哈希表的空间。</span><br><span class="line"></span><br><span class="line">举个例子，比如我们要在一个大小为 <span class="number">5</span> 的数组中插入 <span class="number">10</span> 个元素 &#123;a,b,c,d,e,f,g,h,i,j&#125;，而哈希函数将他们依次映射到下标位置：[<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]，可以看到，有三个下标（<span class="number">5</span>、<span class="number">6</span>、<span class="number">7</span>）始终没有被映射到，完全浪费了这几个下标的存储空间。但如果数组长度为 <span class="number">8</span>，那么上述元素的哈希值按照上面的映射规则可以得到的下标分别是 [<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] % <span class="number">8</span> = [<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]，不会出现任何下标被浪费的情况。</span><br><span class="line"></span><br><span class="line">这种情况下，如果将数组长度改为 <span class="number">7</span>，那么上述元素的哈希值按照上面的映射规则可以得到的下标分别是 [<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] % <span class="number">7</span> = [<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>]，可以看到，索引为 <span class="number">5</span>、<span class="number">6</span> 的空间仍然被浪费了。</span><br><span class="line"></span><br><span class="line">因此，为了避免在哈希表中浪费存储空间，我们一般都会选择使用 <span class="number">2</span> 的幂次方作为哈希表的大小。这样，在计算元素的位置时，只需要对哈希码进行位运算即可，不需要进行除法等复杂的计算。同时，由于 <span class="number">2</span> 的幂次方满足 <span class="number">2</span>^n2*n*，所以用位运算来代替除法或取模操作也能够提高运行效率。</span><br></pre></td></tr></table></figure>
<h4 id="2hashmap怎么保证哈希表长度是-2-的幂次方"><a class="markdownIt-Anchor" href="#2hashmap怎么保证哈希表长度是-2-的幂次方">#</a> 2.HashMap 怎么保证哈希表长度是 2 的幂次方？</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在 Java 中，哈希表的长度总是 <span class="number">2</span> 的幂次方。这是通过 HashMap 类中的一个名为 `tableSizeFor(<span class="type">int</span> cap)` 的静态方法来实现的。</span><br><span class="line"></span><br><span class="line">这个方法会首先将传入的参数减去 <span class="number">1</span>，然后将结果右移一位，在这个值上加 <span class="number">1</span>，最终得到的结果就是大于等于原始参数且最接近原始参数的 <span class="number">2</span> 的幂次方。例如，如果传入的参数是 <span class="number">7</span>，则按照上述算法可以得到 <span class="number">8</span>：(((<span class="number">7</span> - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>) = ((<span class="number">0110</span>)_2 &gt;&gt;&gt; <span class="number">1</span> + <span class="number">1</span>) = (<span class="number">0011</span>)_2 + (<span class="number">0001</span>)_2 = (<span class="number">0100</span>)_2 = <span class="number">8</span>(((<span class="number">7</span>−<span class="number">1</span>)&gt;&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>)=((<span class="number">0110</span>)<span class="number">2</span>&gt;&gt;&gt;<span class="number">1</span>+<span class="number">1</span>)=(<span class="number">0011</span>)<span class="number">2</span>+(<span class="number">0001</span>)<span class="number">2</span>=(<span class="number">0100</span>)<span class="number">2</span>=<span class="number">8</span>。</span><br><span class="line"></span><br><span class="line">因此，当我们创建一个新的哈希表时，只需要将初始容量设置为需要存储的元素数目除以负载因子（load factor），然后调用 `tableSizeFor` 方法进行处理即可。这样就能够保证哈希表的长度始终是 <span class="number">2</span> 的幂次方，并达到较好的性能和空间利用率。</span><br><span class="line"></span><br><span class="line">需要注意的是，虽然这种方式确实可以保证哈希表的长度是 <span class="number">2</span> 的幂次方，但有时候也可能会出现哈希冲突的情况。因此，在实际应用中，还需要根据具体情况选择合适的哈希函数、负载因子等参数来避免哈希冲突，并提高哈希表的性能。</span><br></pre></td></tr></table></figure>
<h4 id="3在hashmap存放元素时候有这样一段代码来处理哈希值这是java-8的散列值扰动函数用于优化散列效果"><a class="markdownIt-Anchor" href="#3在hashmap存放元素时候有这样一段代码来处理哈希值这是java-8的散列值扰动函数用于优化散列效果">#</a> 3. 在 HashMap 存放元素时候有这样一段代码来处理哈希值，这是 java 8 的散列值扰动函数，用于优化散列效果</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span>&#123;</span><br><span class="line">	<span class="type">int</span> h;</span><br><span class="line">	<span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashcode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4hash为什么用31计算"><a class="markdownIt-Anchor" href="#4hash为什么用31计算">#</a> 4.Hash 为什么用 31 计算？</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	使用 <span class="number">31</span> 这个系数的原因是因为它既是一个质数，又可以通过移位和减法等简单的运算来实现乘法。同时，由于 <span class="number">31</span> 在二进制中只有一个非零的比特位，因此用 <span class="number">31</span> 进行乘法相当于进行了位运算和加法的组合，这样不仅能够保证高效运算，还能够避免哈希冲突。</span><br><span class="line">	</span><br><span class="line"><span class="number">31</span>具有两个优点：</span><br><span class="line">	<span class="number">1.</span>小质数：<span class="number">31</span> 是一个较小的质数，在哈希表中被用来乘以键的哈希码，使得结果不会太大，从而提高性能。相对于其他的质数，<span class="number">31</span> 更易于被 CPU 缓存，这也有助于提升哈希表的查询速度。</span><br><span class="line">	<span class="number">2.</span>可逆性：因为 <span class="number">31</span> 是质数且比较小，所以只要哈希表的大小足够大，在乘法过程中产生的数据溢出是不会影响哈希结果的。而且，<span class="number">31</span> 的逆元 <span class="number">0x9e3779b1</span> 是一个固定的常量，也很容易计算，这有助于在需要恢复哈希码时进行逆运算。</span><br><span class="line"></span><br><span class="line">	在实现哈希函数时，使用系数 <span class="number">31</span> 可以保证高效性、可逆性和低冲突率，因此在 Java 中被广泛使用。</span><br></pre></td></tr></table></figure>
<h4 id="5hashmap扰动函数的作用是什么以及它可以被应用在哪些地方"><a class="markdownIt-Anchor" href="#5hashmap扰动函数的作用是什么以及它可以被应用在哪些地方">#</a> 5.HashMap 扰动函数的作用是什么，以及它可以被应用在哪些地方？</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">扰动函数是一种用于增强哈希函数的技术。它通常被用来对原始哈希值进行混淆和扰动，从而减小哈希冲突的发生率。</span><br><span class="line">	</span><br><span class="line">	具体来说，扰动函数会将原始哈希值与另一个数值进行混合，并再次运用哈希函数产生最终的哈希值。这个额外的数值可以是任意的固定值或随机数，目的是使得不同的哈希值在进行混淆之后，仍然能够保持一定的分散性，从而减小哈希冲突的概率。</span><br><span class="line"></span><br><span class="line">扰动函数可以被应用在许多地方，例如：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>哈希表：在哈希表中，扰动函数可以用来增加键的随机性，减少哈希冲突的发生率，从而提高哈希表的性能。Java 中的 HashMap 就使用了扰动函数对键的哈希码进行混淆。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>加密算法：在一些加密算法中，也会使用扰动函数来增加密码熵，并提高加密强度。例如，MD5 算法就采用了一系列扰动函数对数据进行混淆。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>图像处理：在图像处理中，扰动函数可以用来对像素值随机化，增加图像的噪声，从而实现一些特殊效果，如毛玻璃效果、雨滴效果等。</span><br><span class="line"></span><br><span class="line">总之，扰动函数是一种通用的技术，可以在许多场景下使用。通过引入随机数和混淆操作，扰动函数可以增强数据的随机性和复杂性，从而提高系统的安全性和性能。</span><br></pre></td></tr></table></figure>
<h4 id="6hashmap负载因子"><a class="markdownIt-Anchor" href="#6hashmap负载因子">#</a> 6.HashMap 负载因子？</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">负载因子，可以理解成一辆车可承重重量超过某个阈值时，把货放到新的车上。</span><br><span class="line"></span><br><span class="line">	那么在HashMap中，负载因子决定了数据量多少了以后进行扩容。这里要提到上面做的HashMap例子，我们准备了<span class="number">7</span>个元素，但是最后还有<span class="number">3</span>个位置空余，<span class="number">2</span>个位置存放了<span class="number">2</span>个元素。 所以可能即使你数据比数组容量大时也是不一定能正正好好的把数组占满的，而是在某些小标位置出现了大量的碰撞，只能在同一个位置用链表存放，那么这样就失去了Map数组的性能。</span><br><span class="line"></span><br><span class="line">	所以，要选择一个合理的大小下进行扩容，默认值<span class="number">0.75</span>就是说当阈值容量占了<span class="number">3</span>/<span class="number">4</span>时赶紧扩容，减少Hash碰撞。</span><br><span class="line"></span><br><span class="line">	同时<span class="number">0.75</span>是一个默认构造值，在创建HashMap也可以调整，比如你希望用更多的空间换取时间，可以把负载因子调的更小一些，减少碰撞。</span><br></pre></td></tr></table></figure>
<h4 id="7hashmap是开放寻址还是拉链寻址"><a class="markdownIt-Anchor" href="#7hashmap是开放寻址还是拉链寻址">#</a> 7.HashMap 是开放寻址还是拉链寻址？</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HashMap 是一种拉链式哈希表，也就是说，它使用了链表来解决哈希冲突。</span><br><span class="line"></span><br><span class="line">	具体来说，当多个不同的键映射到同一个桶时，HashMap 会将它们存储在同一个桶中，并通过链表或红黑树等数据结构组织起来。这样，在进行查找、插入、删除等操作时，就可以遍历对应桶中的链表，找到所需的元素。</span><br><span class="line"></span><br><span class="line">	相对于开放寻址法，拉链法能够更好地处理哈希冲突，并且支持动态扩容。因为在拉链法中，哈希表的每个桶都可以存储多个元素，而在开放寻址法中，每个位置只能存储一个元素，这使得动态扩容变得更加困难和低效。</span><br><span class="line"></span><br><span class="line">	但是，由于链表的空间和时间开销，当哈希冲突较为频繁时，拉链法可能会导致性能下降。为了解决这个问题，Java8 引入了基于红黑树的优化机制，即当链表长度超过一定阈值时，将链表转换为红黑树，以提高查询效率。</span><br><span class="line"></span><br><span class="line">总之，HashMap 是一种基于拉链法实现的哈希表，能够高效处理哈希冲突，并且支持动态扩容和基于红黑树的优化。</span><br></pre></td></tr></table></figure>
<h4 id="8hashmap链表什么时候树化以及迁移数据算法是什么"><a class="markdownIt-Anchor" href="#8hashmap链表什么时候树化以及迁移数据算法是什么">#</a> 8.HashMap 链表什么时候树化以及迁移数据算法是什么？</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在JDK1<span class="number">.8</span>中，HashMap是以数组+链表+红黑树构成的。</span><br><span class="line"></span><br><span class="line">	具体来说，当某个桶中的链表长度超过了阈值时，HashMap 会将这个链表转换成一棵红黑树，以便支持更快的查找、插入和删除等操作。这个过程中，需要进行以下步骤：</span><br><span class="line"></span><br><span class="line">	<span class="number">1.</span>创建一棵空的红黑树，并将原始链表中的所有元素插入到这棵树中。</span><br><span class="line">	<span class="number">2.</span>删除原始链表中的所有元素，并设置哈希表的结构类型为 TREEBIN。</span><br><span class="line">	<span class="number">3.</span>在进行插入、删除等操作时，先判断当前桶的数据结构类型，如果是链表，则采用链表的方法进行操作；否则，采用红黑树的方法进行操作。</span><br><span class="line"></span><br><span class="line">	总之，在 JDK8 及以后版本中，HashMap 在树化和迁移数据方面做了一些优化，使得它能够更好地支持大规模并发和高效内存使用。</span><br></pre></td></tr></table></figure>
<h4 id="9hashmap-中的-key若为-object类型-则需实现哪些方法"><a class="markdownIt-Anchor" href="#9hashmap-中的-key若为-object类型-则需实现哪些方法">#</a> 9.HashMap 中的 key 若为 Object 类型， 则需实现哪些方法？</h4>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/12e5dce6bacfa7d4db320d87936b45db.jpeg" alt="HashMap 在 JDK1.7 和 JDK1.8 中有哪些区别？_数组_07"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果 HashMap 中的 key 是 Object 类型，则该对象需要正确地实现 equals() 和 hashCode() 方法。这两个方法用于确定两个对象是否相等，并计算对象的哈希码。</span><br><span class="line"></span><br><span class="line">具体来说，equals() 方法用于比较两个对象是否相等。在 HashMap 中，当两个 key 的哈希值相同时，会调用它们的 equals() 方法进行比较，以确定它们是否真正相等。因此，正确实现 equals() 方法可以防止哈希冲突和键值对重复的问题。</span><br><span class="line">       </span><br><span class="line">hashCode() 方法用于计算对象的哈希码，它将一个对象映射到一个整数值，用于确定该对象在哈希表中的位置。在 HashMap 中，当插入或查找键值对时，会首先计算 key 的哈希码，并根据哈希码查找对应的桶。因此，正确实现 hashCode() 方法可以提高哈希表的性能和效率。</span><br><span class="line"></span><br><span class="line">需要注意的是，如果在 HashMap 中使用自定义的对象作为 key，默认情况下，它们的 equals() 方法和 hashCode() 方法是通过继承 Object 类而来的，这可能导致 key 的比较和哈希码计算不准确。因此，我们通常需要自己重写 equals() 和 hashCode() 方法，以满足我们的具体需求。同时，还需要遵循一些规则，例如：如果两个对象相等，那么它们的哈希码必须相等；反之亦然。</span><br></pre></td></tr></table></figure>
<h4 id="10hashmap中的扰动函数是如何计算的"><a class="markdownIt-Anchor" href="#10hashmap中的扰动函数是如何计算的">#</a> 10.HashMap 中的扰动函数是如何计算的？</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用扰动函数就是为了增加随机性，让数据元素更加均衡的散列，减少碰撞</span></span><br><span class="line"><span class="comment"> * 把哈希值右移16位，也就正好是自己长度的一半，之后与原哈希值做异或运算</span></span><br><span class="line"><span class="comment"> * 这样就混合了原哈希值中的高位和低位，增大了随机性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">hashIndex</span> <span class="operator">=</span> (size - <span class="number">1</span>) &amp; (key.hashCode() ^ (key.hashCode() &gt;&gt;&gt; <span class="number">16</span>));</span><br></pre></td></tr></table></figure>
<h4 id="11为什么hashmap中要使用-1-30-来作为最大限制"><a class="markdownIt-Anchor" href="#11为什么hashmap中要使用-1-30-来作为最大限制">#</a> 11. 为什么 hashMap 中要使用 （1 &lt;&lt; 30） 来作为最大限制</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在 HashMap 中，使用 <span class="number">1</span> &lt;&lt; <span class="number">30</span> 来作为容量的最大限制是因为 Java 中的数组长度不能超过 Integer.MAX_VALUE（即 <span class="number">2</span>^<span class="number">31</span>-<span class="number">1</span>）。而 HashMap 内部的实现需要使用一个数组来保存数据，因此其容量也必须受到这个限制。</span><br><span class="line"></span><br><span class="line">为了保证 HashMap 的最大容量不超过 Integer.MAX_VALUE，同时又要尽可能地提高 HashMap 的容量，Java 开发团队选择了 <span class="number">1</span> &lt;&lt; <span class="number">30</span> 作为 HashMap 的最大容量。这个值是一个 <span class="number">2</span> 的幂次方，可以充分利用位运算的优势，同时又不会超过数组长度的最大限制。</span><br><span class="line"></span><br><span class="line">需要注意的是，HashMap 实际上并不会直接使用 <span class="number">1</span> &lt;&lt; <span class="number">30</span> 作为容量的最大限制。在初始化 HashMap 时，如果传入的初始容量大于等于 <span class="number">1</span> &lt;&lt; <span class="number">30</span>，则会将容量设置为 Integer.MAX_VALUE；如果传入的初始容量小于 <span class="number">1</span> &lt;&lt; <span class="number">30</span>，则会将容量调整为大于等于传入值且最接近 <span class="number">2</span> 的幂次方的数。这样可以确保 HashMap 容量的合理性，同时避免出现数组长度超过 Integer.MAX_VALUE 的情况。</span><br></pre></td></tr></table></figure>
<h4 id="12hashmap如何寻找2的幂次方最小值"><a class="markdownIt-Anchor" href="#12hashmap如何寻找2的幂次方最小值">#</a> 12.HashMap 如何寻找 2 的幂次方最小值？</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK1.8中：把二进制的各个位置都填上1，当二进制的各个位置都是1以后，就是一个标准的2的幂次方减1了，最后把结果加1再返回即可。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//JDK1.8之后：（二分法）通过多次右移和减小位宽的方式来逐步缩小搜索范围，最终得到最高位 0 的个数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> -<span class="number">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class="number">1</span>);</span><br><span class="line">     <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="12为什么重写equals一定要重写hashcode"><a class="markdownIt-Anchor" href="#12为什么重写equals一定要重写hashcode">#</a> 12. 为什么重写 equals 一定要重写 hashcode</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">在 Java 中，每个类都继承了 Object 类，Object 类提供了两个有关哈希值的方法，一个是 equals() 方法，另一个是 hashCode() 方法。其中，equals() 方法用于判断两个对象是否相等，而 hashCode() 方法则返回该对象的哈希码。</span><br><span class="line"></span><br><span class="line">如果在一个类中重写了 equals() 方法，但没有重写 hashCode() 方法，则可能会导致出现以下情况：</span><br><span class="line"></span><br><span class="line">	在使用 HashMap、HashSet 等哈希数据结构时，由于不同的对象可以返回相同的哈希值，因此可能会将这些对象误认为是同一个对象，从而引发程序错误。</span><br><span class="line">	在使用自定义对象作为键来进行 Map 操作时，由于不同的键可以返回相同的哈希值，因此可能无法正确地定位到对应的键值对，从而导致数据丢失或查找失败。</span><br><span class="line">因此，如果要重写 equals() 方法，则必须同时重写 hashCode() 方法，以确保它们的行为一致并满足一些约定：</span><br><span class="line"></span><br><span class="line">	如果两个对象使用 equals() 方法比较返回相等，则它们的 hashCode() 值必须相等。</span><br><span class="line">	如果两个对象的 hashCode() 值相等，则它们不一定相等（即可能存在哈希冲突），因此需要再次使用 equals() 方法进行比较。</span><br><span class="line">通过遵循这些约定，可以保证在使用哈希数据结构或自定义对象作为键值对时不会出现问题。</span><br></pre></td></tr></table></figure>
<h4 id="13为什么在-java-的-hashmap-实现中数组的大小即容量必须始终保持为-2-的幂次方"><a class="markdownIt-Anchor" href="#13为什么在-java-的-hashmap-实现中数组的大小即容量必须始终保持为-2-的幂次方">#</a> 13. 为什么在 Java 的 HashMap 实现中，数组的大小（即容量）必须始终保持为 2 的幂次方？</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashMap的长度必须保证是<span class="number">2</span>的幂次方，是为了避免出现HashMap为空或者HashMap中存储的元素个数不足<span class="number">2</span>的幂次方的情况。</span><br><span class="line"></span><br><span class="line">如果HashMap的长度不是<span class="number">2</span>的幂次方，可能会导致以下问题：</span><br><span class="line"></span><br><span class="line">	如果HashMap的长度为<span class="number">1</span>，那么它的哈希冲突解决方式只能是链地址法（即将冲突的键值对插入到链表中），这种方式不能处理哈希冲突。</span><br><span class="line">	如果HashMap的长度为<span class="number">0</span>，那么它的哈希冲突解决方式只能是开放地址法（即将冲突的键值对直接放在HashMap中），这种方式不能处理哈希冲突。</span><br><span class="line"></span><br><span class="line">因此，为了保证HashMap的正确性和性能，我们需要确保它的长度是<span class="number">2</span>的幂次方，或者为一个固定的最大值。如果需要动态地调整HashMap的长度，可以使用链表法或者开放地址法。</span><br></pre></td></tr></table></figure>
<h4 id="14为什么hashmaploadfactor的选值是34而不是24"><a class="markdownIt-Anchor" href="#14为什么hashmaploadfactor的选值是34而不是24">#</a> 14. 为什么 HashMap.loadFactor 的选值是 3/4，而不是 2/4?</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先，当loadFactor的值比较小的时候，虽然能够减少空间的浪费，但是会导致哈希表更加频繁地进行扩容操作，这会影响到HashMap的性能。</span><br><span class="line">其次，当loadFactor的值比较大的时候，虽然能够减少扩容操作的次数，但是会导致哈希链表长度过长，查找效率会变得较低。</span><br><span class="line">因此，为了平衡空间利用率和时间效率，选择一个适当的loadFactor值非常重要。经过实验和分析，发现loadFactor取<span class="number">0.75</span>时，可以在保证哈希表查找效率的同时，稍微减少空间的浪费。另外，这个值也是比较常见的一个取值，很多编程语言中也采用了类似的值。</span><br></pre></td></tr></table></figure>
<h4 id="15hashmap什么时候会触发扩容机制如何扩容"><a class="markdownIt-Anchor" href="#15hashmap什么时候会触发扩容机制如何扩容">#</a> 15.HashMap 什么时候会触发扩容机制？如何扩容？</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">HashMap在存储键值对时，会将键通过哈希函数映射到桶里面，每个桶是一个链表或红黑树。当HashMap中的元素数量增加到超过了负载因子（默认为0.75），就会触发扩容机制。</span><br><span class="line"></span><br><span class="line">具体地说，在添加元素时，如果当前的元素数量达到了阈值（即容量乘以负载因子），就会启动扩容机制。这个阈值通过如下公式计算：</span><br><span class="line"></span><br><span class="line">threshold = capacity * loadFactor</span><br><span class="line"></span><br><span class="line">其中capacity是当前HashMap的容量，loadFactor是负载因子，默认值为0.75。当HashMap中元素个数达到了threshold值时，就会触发扩容机制。</span><br><span class="line"></span><br><span class="line">扩容操作包括以下几个步骤：</span><br><span class="line"></span><br><span class="line">	1.创建一个新的Entry数组，长度为原数组的两倍。</span><br><span class="line">	2.将原来数组中所有的元素重新分配到新的数组中，这一步需要重新计算每个元素的hash值，并且根据新的数组长度求出它们在新数组中的位置。</span><br><span class="line">	3.在重新分配元素的过程中，如果某个位置上有多个元素，则会形成一个链表或红黑树，这取决于链表长度是否大于等于8，并且桶容量大于64。如果链表长度大于等于8并且桶容量大于64的话，则会将其转换为红黑树，否则仍然使用链表。这一步是为了提高查询效率，因为红黑树的查询时间复杂度是O(log n)，而链表的查询时间复杂度是O(n)。</span><br><span class="line">	4.更新HashMap的容量和阈值。</span><br><span class="line">	</span><br><span class="line">扩容操作会比较耗时，因为需要重新计算hash值、重新分配元素等，所以应该尽可能避免频繁触发扩容。可以通过调整负载因子的大小来控制HashMap的性能和空间占用</span><br></pre></td></tr></table></figure>
<h2 id="关于我"><a class="markdownIt-Anchor" href="#关于我">#</a> 关于我</h2>
<p>Brath 是一个热爱技术的 Java 程序猿，公众号「InterviewCoder」定期分享有趣有料的精品原创文章！</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png" alt="InterviewCoder"></p>
<p>非常感谢各位人才能看到这里，原创不易，文章如果有帮助可以关注、点赞、分享或评论，这都是对我的莫大支持！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-05-05T01:57:09.000Z" title="2023-5-5 9:57:09">2023-05-05</time>发表</span><span class="level-item"><time dateTime="2023-05-05T02:04:28.525Z" title="2023-5-5 10:04:28">2023-05-05</time>更新</span><span class="level-item">14 分钟读完 (大约2151个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/05/05/%E3%80%90IDEA%E3%80%91IDEA%E7%9A%84debug%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7%E8%AF%A6%E8%A7%A3/">【IDEA】IDEA的debug调试技巧详解</a></p><div class="content"><p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png" alt="InterviewCoder"></p>
<h1 id="ideaidea的debug调试技巧详解转自csdn"><a class="markdownIt-Anchor" href="#ideaidea的debug调试技巧详解转自csdn">#</a> 【IDEA】IDEA 的 debug 调试技巧详解（转自 CSDN）</h1>
<p>目录</p>
<p><a href="#%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0">一、概述</a></p>
<p><a href="#%E4%BA%8C%E3%80%81debug%E6%93%8D%E4%BD%9C%E5%88%86%E6%9E%90">二、debug 操作分析</a></p>
<p><a href="#1%E3%80%81%E6%89%93%E6%96%AD%E7%82%B9">1、打断点</a></p>
<p><a href="#2%E3%80%81%E8%BF%90%E8%A1%8Cdebug%E6%A8%A1%E5%BC%8F">2、运行 debug 模式</a></p>
<p><a href="#3%E3%80%81%E9%87%8D%E6%96%B0%E6%89%A7%E8%A1%8Cdebug">3、重新执行 debug</a></p>
<p><a href="#4%E3%80%81%E8%AE%A9%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E5%88%B0%E4%B8%8B%E4%B8%80%E6%AC%A1%E6%96%AD%E7%82%B9%E5%90%8E%E6%9A%82%E5%81%9C">4、让程序执行到下一次断点后暂停</a></p>
<p><a href="#5%E3%80%81%E8%AE%A9%E6%96%AD%E7%82%B9%E5%A4%84%E7%9A%84%E4%BB%A3%E7%A0%81%E5%86%8D%E5%8A%A0%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81">5、让断点处的代码再加一行代码</a></p>
<p><a href="#6%E3%80%81%E5%81%9C%E6%AD%A2debug%E7%A8%8B%E5%BA%8F">6、停止 debug 程序</a></p>
<p><a href="#7%E3%80%81%E6%98%BE%E7%A4%BA%E6%89%80%E6%9C%89%E6%96%AD%E7%82%B9">7、显示所有断点</a></p>
<p><a href="#8%E3%80%81%E6%B7%BB%E5%8A%A0%E6%96%AD%E7%82%B9%E8%BF%90%E8%A1%8C%E7%9A%84%E6%9D%A1%E4%BB%B6">8、添加断点运行的条件</a></p>
<p><a href="#9%E3%80%81%E5%B1%8F%E8%94%BD%E6%89%80%E6%9C%89%E6%96%AD%E7%82%B9">9、屏蔽所有断点</a></p>
<p><a href="#10%E3%80%81%E6%8A%8A%E5%85%89%E6%A0%87%E7%A7%BB%E5%88%B0%E5%BD%93%E5%89%8D%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E4%BD%8D%E7%BD%AE">10、把光标移到当前程序运行位置</a></p>
<p><a href="#11%E3%80%81%E5%8D%95%E6%AD%A5%E8%B7%B3%E8%BF%87">11、单步跳过</a></p>
<p><a href="#12%E3%80%81%E5%8F%AF%E4%BB%A5%E8%B7%B3%E5%85%A5%E6%96%B9%E6%B3%95%E5%86%85%E9%83%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%93%8D%E4%BD%9C">12、可以跳入方法内部的执行一行代码操作</a></p>
<p><a href="#13%E3%80%81%E8%B7%B3%E5%87%BA%E6%96%B9%E6%B3%95">13、跳出方法</a></p>
<p><a href="#14%E3%80%81%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8C%E5%88%B0%E5%85%89%E6%A0%87%E6%89%80%E5%9C%A8%E4%BD%8D%E7%BD%AE">14、直接执行到光标所在位置</a></p>
<p><a href="#15%E3%80%81%E5%9C%A8%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%94%B9%E5%8F%98%E6%AD%A3%E5%9C%A8debug%E7%9A%84%E6%95%B0%E6%8D%AE">15、在控制台改变正在 debug 的数据</a></p>
<hr>
<h1 id="一-概述"><a class="markdownIt-Anchor" href="#一-概述">#</a> 一、概述</h1>
<ul>
<li>debug 调试也叫断点调试</li>
<li>在程序的某一行打上断点，则在 debug 模式下运行到断点位置时会暂停，便于程序员观察代码的执行情况</li>
<li>学会 debug，有助于在程序运行未达到理想情况时，对程序的各个流程进行分析</li>
<li>本文只详细描述了 debug 的一些基本的常用操作，如果有缺漏欢迎评论区留言～</li>
</ul>
<h1 id="二-debug操作分析"><a class="markdownIt-Anchor" href="#二-debug操作分析">#</a> 二、debug 操作分析</h1>
<h2 id="1-打断点"><a class="markdownIt-Anchor" href="#1-打断点">#</a> 1、打断点</h2>
<ul>
<li>在程序的某一行位置，数字右边的空白部分使用鼠标左键点击一下，出现红点即为打上了一个断点</li>
</ul>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/9e3026905fcd4c7a9a7b0dce93f324e9.png" width="422" height="362" />
<h2 id="2-运行debug模式"><a class="markdownIt-Anchor" href="#2-运行debug模式">#</a> 2、运行 debug 模式</h2>
<ul>
<li>方式一
<ul>
<li>选中要进行 debug 的程序，点击右上角的 debug 按钮</li>
</ul>
</li>
</ul>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/f52559e407cf4dd9af9438fc616abca5.png" width="288" height="82" />
<ul>
<li>方式二
<ul>
<li>在要进行 debug 的程序处右键，选中下图选项</li>
</ul>
</li>
</ul>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/a703e498d8dc4e91be40b3ba06a7a5be.png" width="386" height="449" />
<h2 id="3-重新执行debug"><a class="markdownIt-Anchor" href="#3-重新执行debug">#</a> 3、重新执行 debug</h2>
<ul>
<li>点击下图按钮，会关闭当前 debug 的程序并重新启动 debug</li>
</ul>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/6a18ce960271427892dbc4a8df8e568d.png" width="832" height="308" />
<h2 id="4-让程序执行到下一次断点后暂停"><a class="markdownIt-Anchor" href="#4-让程序执行到下一次断点后暂停">#</a> 4、让程序执行到下一次断点后暂停</h2>
<ul>
<li>点击下图的按钮，debug 会继续运行程序，直到遇到下一次断点后暂停</li>
</ul>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/5347586e6a414e7fbacc2863e4e7f44d.png" width="851" height="301" />
<ul>
<li>举例
<ul>
<li>下图是一个循环操作，在打断点的位置点击上面说的按钮，相当于再循环一次，到代码第 9 行时停止</li>
</ul>
</li>
</ul>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/4653841c52c54a3183914354054609dd.png" width="818" height="336" />
<h2 id="5-让断点处的代码再加一行代码"><a class="markdownIt-Anchor" href="#5-让断点处的代码再加一行代码">#</a> 5、让断点处的代码再加一行代码</h2>
<ul>
<li>点击下图的加号，可以在断点处加一行代码，比如下图中的 count++ 即为新添加的代码
<ul>
<li>选中 count++，右键点击 Edit 可以编辑该代码</li>
<li>选中该行代码（count++），点击加号下面的减号，可以删除该行代码</li>
</ul>
</li>
</ul>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/b7843e76b1b64b488e93c9cd8b6e72a6.png" width="865" height="266" />
<ul>
<li>选中下图的眼镜，变为分屏操作</li>
</ul>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/ac95d9ee4ebb4c2c8e573e623e34f779.png" width="1200" height="324" />
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/18ec87566c3340689daa95295557fa12.png" width="1200" height="302" />
<hr>
<p><strong>举例</strong></p>
<ul>
<li>下图是没添加额外代码之前的截图</li>
</ul>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/155c34d01574452f9924b608cb26a642.png" width="1163" height="567" />
<ul>
<li>添加一句 count++，并点击左边红色框中的按钮，执行到下一次断点，即循环了一次</li>
</ul>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/33ebf61346304b9c9679c6f836ed99b7.png" width="1139" height="659" />
<ul>
<li>效果和运行步骤见下图</li>
</ul>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/0994f7950ff1421ca6cf4116e1fafe23.png" width="1200" height="666" />
<h2 id="6-停止debug程序"><a class="markdownIt-Anchor" href="#6-停止debug程序">#</a> 6、停止 debug 程序</h2>
<ul>
<li>点击下图按钮停止 debug 程序</li>
<li>注意
<ul>
<li>运行的如果是 javaSE 项目，点一下就停止</li>
<li>运行的如果是 javaWeb 项目，需要点两下
<ul>
<li>第一下停止代码的当前线程</li>
<li>第二下停止服务器</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/7ce1d0c26f4a45ec9050155f0f653557.png" width="882" height="304" />
<h2 id="7-显示所有断点"><a class="markdownIt-Anchor" href="#7-显示所有断点">#</a> 7、显示所有断点</h2>
<ul>
<li>点击下图按钮，会显示所有断点</li>
</ul>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/5651d84b51cf45d1bab9072c4c7d1ccc.png" width="830" height="272" />
<ul>
<li>点击后出现下图所示界面，可以添加断点运行的条件，见下一条功能解释</li>
</ul>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/93a8e0b13c4d45e3a4adf260d9ca24b6.png" width="1108" height="670" />
<h2 id="8-添加断点运行的条件"><a class="markdownIt-Anchor" href="#8-添加断点运行的条件">#</a> 8、添加断点运行的条件</h2>
<ul>
<li>选中断点，右键后即可编辑断点运行的条件
<ul>
<li>满足条件时程序才会在该断点处停下</li>
</ul>
</li>
</ul>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/e6b57eeaa0294cdf9364c2b0f6a6cb25.png" width="1006" height="513" />
<ul>
<li>比如添加 i&gt;=5，重新 debug 后的效果如下图所示</li>
</ul>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/82a7ffe03cd54958a8801e21eceb704a.png" width="918" height="645" />
<ul>
<li>此时会发现第 7 条显示所有断点信息处，可以看到下图效果</li>
</ul>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/daab0ee1bfe94a329aa68db1c95f2080.png" width="1022" height="281" />
<h2 id="9-屏蔽所有断点"><a class="markdownIt-Anchor" href="#9-屏蔽所有断点">#</a> 9、屏蔽所有断点</h2>
<ul>
<li>点击下图按钮，可以屏蔽所有断点</li>
</ul>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/f7e06ed221044991be85af4fca6748f9.png" width="583" height="361" />
<ul>
<li>屏蔽前<br>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/677a8547e65844eebac684de9f46bc71.png" width="102" height="73" /></li>
<li>屏蔽后<br>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/46bb93d283a640df802eec5d8fd1bbab.png" width="81" height="56" /></li>
<li>屏蔽的断点在 debug 的时候不会运行
<ul>
<li>如果程序调试后觉得没问题了，可以屏蔽掉所有断点继续运行程序查看效果</li>
</ul>
</li>
</ul>
<h2 id="10-把光标移到当前程序运行位置"><a class="markdownIt-Anchor" href="#10-把光标移到当前程序运行位置">#</a> 10、把光标移到当前程序运行位置</h2>
<ul>
<li>点击下图按钮后，会把鼠标光标移动到当前程序运行位置
<ul>
<li>当程序代码量很大的时候，可以通过该按钮快速定位到程序运行位置</li>
</ul>
</li>
</ul>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/a44a214ccd894d52884cd8cd20e9665c.png" width="617" height="245" />
<ul>
<li>如下图所示
<ul>
<li>假设程序运行到第 9 行断点处，鼠标光标在第 11 行，点击该按钮后光标就会移动到第 9 行</li>
</ul>
</li>
</ul>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/15566342c22e47b390f7922e06c080e9.png" width="648" height="129" />
<h2 id="11-单步跳过"><a class="markdownIt-Anchor" href="#11-单步跳过">#</a> 11、单步跳过</h2>
<ul>
<li>点击下图按钮，会一行一行执行自己编写的代码
<ul>
<li>如果碰到方法，该按钮不会进入到该方法内部</li>
<li>快捷键 F8</li>
</ul>
</li>
</ul>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/1c54b8240f6e4d719f8aae936a925fb2.png" width="544" height="201" />
<h2 id="12-可以跳入方法内部的执行一行代码操作"><a class="markdownIt-Anchor" href="#12-可以跳入方法内部的执行一行代码操作">#</a> 12、可以跳入方法内部的执行一行代码操作</h2>
<ul>
<li>下图中的蓝色箭头和红色箭头都可以执行一行代码，如果遇到方法时会进入方法内部，区别在于
<ul>
<li>蓝色箭头只会跳进自己写的方法，如果是系统已经写好的方法，蓝色箭头无法跳入该方法</li>
<li>红色箭头不管是自己写的方法，还是系统已经定义好的方法，都可以跳入方法内部</li>
</ul>
</li>
</ul>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/23a065624b024b29ba358d96c1e827eb.png" width="852" height="271" />
<ul>
<li>如下图所示
<ul>
<li>ArrayList 的 add 方法是系统已经写好的，蓝色箭头无法跳入方法内部，但是红色箭头可以跳入方法内部</li>
<li>printMessage（）是自定义方法，红色和蓝色箭头都可以跳入该方法内部</li>
</ul>
</li>
</ul>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/f24471618ac74e69842c047606635c13.png" width="811" height="762" />
<h2 id="13-跳出方法"><a class="markdownIt-Anchor" href="#13-跳出方法">#</a> 13、跳出方法</h2>
<ul>
<li>下图的两个按钮都可以跳出方法
<ul>
<li>第二个按钮是关闭窗口的意思，同样可以起到跳出方法的作用</li>
<li>在进入方法内部的时候使用这两个按钮</li>
</ul>
</li>
</ul>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/0deedd480bd94b0f9d93aab8bc5d33d1.png" width="514" height="238" />
<h2 id="14-直接执行到光标所在位置"><a class="markdownIt-Anchor" href="#14-直接执行到光标所在位置">#</a> 14、直接执行到光标所在位置</h2>
<ul>
<li>点击下图的按钮，程序会执行到光标所在的位置
<ul>
<li>前提是光标前面没有断点，否则程序还是会在光标前面的断点处暂停</li>
</ul>
</li>
</ul>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/75d500280cad4a7497a31bb49c1a73a4.png" width="616" height="247" />
<h2 id="15-在控制台改变正在debug的数据"><a class="markdownIt-Anchor" href="#15-在控制台改变正在debug的数据">#</a> 15、在控制台改变正在 debug 的数据</h2>
<ul>
<li>在控制台选中某个变量，右键点击 Set Value 可以改变该变量的值
<ul>
<li>如果想测试某个地方的数据如果是正确的会是什么效果，可以手动更改该处变量的值</li>
</ul>
</li>
</ul>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/9fcd3a72eebf47a9be694fabec9549cd.png" width="1003" height="304" />
<p>补充：debug 调试看代码时，一般用 F9 跳到下一个断点，打断点的目的是你想看程序执行到这个位置时会有什么效果，或者是到达断点的位置后再继续往下看实现的过程；用 F7 去跳进方法内部，看具体的实现细节；用 F8 去看当前位置代码往下的执行情况（不跳入具体方法的内部）</p>
<h4 id="原文链接httpsblogcsdnnetfuture_god_qrarticledetails121250865"><a class="markdownIt-Anchor" href="#原文链接httpsblogcsdnnetfuture_god_qrarticledetails121250865">#</a> 原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/future_god_qr/article/details/121250865">https://blog.csdn.net/future_god_qr/article/details/121250865</a></h4>
<h2 id="关于我"><a class="markdownIt-Anchor" href="#关于我">#</a> 关于我</h2>
<p>Brath 是一个热爱技术的 Java 程序猿，公众号「InterviewCoder」定期分享有趣有料的精品原创文章！</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png" alt="InterviewCoder"></p>
<p>非常感谢各位人才能看到这里，原创不易，文章如果有帮助可以关注、点赞、分享或评论，这都是对我的莫大支持！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-05-05T01:57:09.000Z" title="2023-5-5 9:57:09">2023-05-05</time>发表</span><span class="level-item"><time dateTime="2023-05-05T02:03:30.951Z" title="2023-5-5 10:03:30">2023-05-05</time>更新</span><span class="level-item">11 分钟读完 (大约1580个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/05/05/%E3%80%90%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80%E3%80%91%E7%99%BE%E5%BA%A6%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80%E5%A4%A7%E5%9E%8B%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E6%8E%A5%E5%85%A5%E6%95%99%E7%A8%8B/">【文心一言】百度文心一言大型语言模型接入教程</a></p><div class="content"><p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png" alt="InterviewCoder"></p>
<h1 id="文心一言百度文心一言大型语言模型接入教程"><a class="markdownIt-Anchor" href="#文心一言百度文心一言大型语言模型接入教程">#</a> 【文心一言】百度文心一言大型语言模型接入教程</h1>
<h5 id="文心一言是百度的智能对话产品它可以与用户进行流畅-自然-有趣的多轮对话涵盖了生活-娱乐-教育-商务等多个领域和场景-文心一言不仅可以作为一个独立的应用供用户使用也可以通过百度智能云的api调用接口为各行各业的企业客户提供强大而灵活的ai能力赋能更多行业伙伴"><a class="markdownIt-Anchor" href="#文心一言是百度的智能对话产品它可以与用户进行流畅-自然-有趣的多轮对话涵盖了生活-娱乐-教育-商务等多个领域和场景-文心一言不仅可以作为一个独立的应用供用户使用也可以通过百度智能云的api调用接口为各行各业的企业客户提供强大而灵活的ai能力赋能更多行业伙伴">#</a> 文心一言是百度的智能对话产品，它可以与用户进行流畅、自然、有趣的多轮对话，涵盖了生活、娱乐、教育、商务等多个领域和场景。文心一言不仅可以作为一个独立的应用供用户使用，也可以通过百度智能云的 API 调用接口，为各行各业的企业客户提供强大而灵活的 AI 能力，赋能更多行业伙伴。</h5>
<h5 id="那么作为一个企业客户如何接入文心一言呢本文将为您介绍百度智能云提供的全面的ai解决方案帮助您快速实现与文心一言的对接和集成"><a class="markdownIt-Anchor" href="#那么作为一个企业客户如何接入文心一言呢本文将为您介绍百度智能云提供的全面的ai解决方案帮助您快速实现与文心一言的对接和集成">#</a> 那么，作为一个企业客户，如何接入文心一言呢？本文将为您介绍百度智能云提供的全面的 AI 解决方案，帮助您快速实现与文心一言的对接和集成。</h5>
<h2 id="01第一步注册百度智能云账号"><a class="markdownIt-Anchor" href="#01第一步注册百度智能云账号">#</a> <strong>01</strong> 第一步：注册百度智能云账号</h2>
<p>要使用百度智能云提供的服务和产品，您首先需要注册一个百度智能云账号。您可以通过以下方式进行注册：</p>
<ul>
<li>访问百度智能云官网 (<a target="_blank" rel="noopener" href="https://cloud.baidu.com/">https://cloud.baidu.com/</a>)，点击右上角 “免费注册” 按钮。</li>
<li>输入您的手机号码，并获取验证码。</li>
<li>设置您的登录密码，并同意服务协议。</li>
<li>完成实名认证，并选择账号类型 (个人或企业)。</li>
<li>完成以上步骤后，您就成功注册了一个百度智能云账号。</li>
</ul>
<h2 id="02第二步申请文心一言api调用权限"><a class="markdownIt-Anchor" href="#02第二步申请文心一言api调用权限">#</a> <strong>02</strong> 第二步：申请文心一言 API 调用权限</h2>
<p>​		要使用文心一言 API 调用接口，您需要申请相应的权限。您可以通过以下方式进行申请：</p>
<ul>
<li><strong>登录百度智能云控制台 (<a target="_blank" rel="noopener" href="https://console.bce.baidu.com/">https://console.bce.baidu.com/</a>)，点击左侧导航栏 “人工智能” 下拉菜单中的 “自然语言处理” 选项。</strong></li>
<li><strong>在自然语言处理页面中，找到 “文心一言” 产品，并点击 “立即使用” 按钮。</strong></li>
<li><strong>在弹出窗口中填写相关信息，并提交申请。</strong></li>
<li><strong>等待审核结果。审核通过后，您就可以在控制台中查看并管理您的文心一言 API 调用权限。</strong></li>
</ul>
<h2 id="03第三步配置并测试文心一言api调用接口"><a class="markdownIt-Anchor" href="#03第三步配置并测试文心一言api调用接口">#</a> <strong>03</strong> 第三步：配置并测试文心一言 API 调用接口</h2>
<p>​		进入：<a target="_blank" rel="noopener" href="https://wenxin.baidu.com/user/key">https://wenxin.baidu.com/user/key</a></p>
<p>​		使用文心一言 API 调用接口，您需要配置相关参数，并进行测试。您可以通过以下方式进行配置和测试：</p>
<ul>
<li>在控制台中进入 “自然语言处理” 页面，并点击 “文心一言” 产品下方的 “管理” 按钮，进入文心一言 API 调用接口的配置页面。</li>
<li>在配置页面中，您可以查看并修改您的文心一言 API 调用接口的基本信息，如应用名称、应用描述、应用类型等。</li>
<li>您还可以在配置页面中设置您的文心一言 API 调用接口的安全认证方式，如 Access Key ID 和 Secret Access Key。这些是您调用文心一言 API 时需要提供的身份凭证，建议您妥善保管，并定期更换。</li>
<li>您还可以在配置页面中设置您的文心一言 API 调用接口的配额和限流策略，如每日请求次数、每秒请求次数等。这些是为了保障您和其他用户的服务质量和安全性，建议您根据自己的业务需求合理分配，并避免超出限制。</li>
<li>在完成以上配置后，您就可以在配置页面中点击 “在线测试” 按钮，进行文心一言 API 调用接口的测试。测试时，您需要输入一个对话语句，并选择一个对话领域和场景。然后点击 “发送” 按钮，即可查看文心一言 API 返回的对话回复。</li>
</ul>
<h2 id="04第四步集成并使用文心一言api调用接口"><a class="markdownIt-Anchor" href="#04第四步集成并使用文心一言api调用接口">#</a> <strong>04</strong> 第四步：集成并使用文心一言 API 调用接口</h2>
<p>​		要集成并使用文心一言 API 调用接口，您需要根据自己的开发环境和语言选择合适的 SDK 或工具，并编写相应的代码。百度智能云提供了多种语言和平台支持的 SDK 或工具，如 Java、Python、PHP、Node.js、Android、iOS 等。您可以通过以下方式进行集成和使用：</p>
<ul>
<li>在控制台中进入 “自然语言处理” 页面，并点击 “文心一言” 产品下方的 “文档” 按钮，进入文心一言 API 调用接口的文档页面。</li>
<li>在文档页面中，您可以查看并下载您所需要的 SDK 或工具，并参考相关的示例代码和说明进行集成和使用。</li>
<li>在完成集成和使用后，您就可以在您的应用中调用文心一言 API，实现与用户的智能对话功能。</li>
</ul>
<h1 id="结语"><a class="markdownIt-Anchor" href="#结语">#</a> 结语：</h1>
<p>​		文心一言是百度智能云推出的一款基于大规模自然语言生成模型 (ChatGPT) 的智能对话产品，它可以与用户进行流畅、自然、有趣的多轮对话，涵盖了生活、娱乐、教育、商务等多个领域和场景。本文介绍了作为一个企业客户，如何通过百度智能云提供的全面的 AI 解决方案，快速实现与文心一言的对接和集成。</p>
<h2 id="关于我"><a class="markdownIt-Anchor" href="#关于我">#</a> 关于我</h2>
<p>Brath 是一个热爱技术的 Java 程序猿，公众号「InterviewCoder」定期分享有趣有料的精品原创文章！</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png" alt="InterviewCoder"></p>
<p>非常感谢各位人才能看到这里，原创不易，文章如果有帮助可以关注、点赞、分享或评论，这都是对我的莫大支持！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-04-29T11:42:37.000Z" title="2023-4-29 19:42:37">2023-04-29</time>发表</span><span class="level-item"><time dateTime="2023-04-29T11:44:45.229Z" title="2023-4-29 19:44:45">2023-04-29</time>更新</span><span class="level-item">2 小时读完 (大约20643个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/04/29/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%9123%20%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%88%E5%85%A823%E7%A7%8D%EF%BC%89/">【设计模式】23 种设计模式详解（全23种）</a></p><div class="content"><p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png" alt="InterviewCoder"></p>
<h1 id="设计模式23-种设计模式详解全23种"><a class="markdownIt-Anchor" href="#设计模式23-种设计模式详解全23种">#</a> 【设计模式】23 种设计模式详解（全 23 种）</h1>
<h1 id="设计模式的分类"><a class="markdownIt-Anchor" href="#设计模式的分类">#</a> 设计模式的分类</h1>
<p>总体来说设计模式分为三大类：</p>
<p>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p>
<p>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p>
<p>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>
<h2 id=""><a class="markdownIt-Anchor" href="#">#</a> </h2>
<h1 id="a-创建模式5种"><a class="markdownIt-Anchor" href="#a-创建模式5种">#</a> A、创建模式（5 种）</h1>
<p><strong>工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</strong></p>
<h2 id="1-工厂模式"><a class="markdownIt-Anchor" href="#1-工厂模式">#</a> 1 工厂模式</h2>
<h3 id="11-简单工厂模式"><a class="markdownIt-Anchor" href="#11-简单工厂模式">#</a> 1.1 简单工厂模式</h3>
<p>** 定义：** 定义了一个创建对象的类，由这个类来封装实例化对象的行为。</p>
<p><strong>举例：</strong>（我们举一个 pizza 工厂的例子）</p>
<p>pizza 工厂一共生产三种类型的 pizza：chesse,pepper,greak。通过工厂类（SimplePizzaFactory）实例化这三种类型的对象。类图如下：</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609001610870.png" class="has" width="503" height="276" />
<p>工厂类的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimplePizzaFactory</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> Pizza <span class="title function_">CreatePizza</span><span class="params">(String ordertype)</span> &#123;</span><br><span class="line">              <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">              <span class="keyword">if</span> (ordertype.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">                     pizza = <span class="keyword">new</span> <span class="title class_">CheesePizza</span>();</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ordertype.equals(<span class="string">&quot;greek&quot;</span>)) &#123;</span><br><span class="line">                     pizza = <span class="keyword">new</span> <span class="title class_">GreekPizza</span>();</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ordertype.equals(<span class="string">&quot;pepper&quot;</span>)) &#123;</span><br><span class="line">                     pizza = <span class="keyword">new</span> <span class="title class_">PepperPizza</span>();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> pizza;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>简单工厂存在的问题与解决方法：</strong> 简单工厂模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了开闭原则，所以，从设计角度考虑，有一定的问题，如何解决？我们可以定义一个创建对象的抽象方法并创建多个不同的工厂类实现该抽象方法，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。这种方法也就是我们接下来要说的工厂方法模式。</p>
<h3 id="12-工厂方法模式"><a class="markdownIt-Anchor" href="#12-工厂方法模式">#</a> 1.2 工厂方法模式</h3>
<p>** 定义：** 定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。</p>
<p><strong>举例：</strong>（我们依然举 pizza 工厂的例子，不过这个例子中，pizza 产地有两个：伦敦和纽约）。添加了一个新的产地，如果用简单工厂模式的的话，我们要去修改工厂代码，并且会增加一堆的 if else 语句。而工厂方法模式克服了简单工厂要修改代码的缺点，它会直接创建两个工厂，纽约工厂和伦敦工厂。类图如下：</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609001610872.png" class="has" width="279" height="144" />
<p>OrderPizza 中有个抽象的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abstract Pizza createPizza();</span><br></pre></td></tr></table></figure>
<p>两个工厂类继承 OrderPizza 并实现抽象方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class LDOrderPizza extends OrderPizza &#123;</span><br><span class="line">       Pizza createPizza(String ordertype) &#123;</span><br><span class="line">              Pizza pizza = null;</span><br><span class="line">              if (ordertype.equals(&quot;cheese&quot;)) &#123;</span><br><span class="line">                     pizza = new LDCheesePizza();</span><br><span class="line">              &#125; else if (ordertype.equals(&quot;pepper&quot;)) &#123;</span><br><span class="line">                     pizza = new LDPepperPizza();</span><br><span class="line">              &#125;</span><br><span class="line">              return pizza;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class NYOrderPizza extends OrderPizza &#123;</span><br><span class="line"></span><br><span class="line">    Pizza createPizza(String ordertype) &#123;</span><br><span class="line">        Pizza pizza = null;</span><br><span class="line"></span><br><span class="line">        if (ordertype.equals(&quot;cheese&quot;)) &#123;</span><br><span class="line">            pizza = new NYCheesePizza();</span><br><span class="line">        &#125; else if (ordertype.equals(&quot;pepper&quot;)) &#123;</span><br><span class="line">            pizza = new NYPepperPizza();</span><br><span class="line">        &#125;</span><br><span class="line">        return pizza;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>、通过不同的工厂会得到不同的实例化的对象，PizzaStroe 的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class PizzaStroe &#123;</span><br><span class="line">       public static void main(String[] args) &#123;</span><br><span class="line">              OrderPizza mOrderPizza;</span><br><span class="line">              mOrderPizza = new NYOrderPizza();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>** 解决了简单工厂模式的问题：** 增加一个新的 pizza 产地（北京），只要增加一个 BJOrderPizza 类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class BJOrderPizza extends OrderPizza &#123;</span><br><span class="line">       Pizza createPizza(String ordertype) &#123;</span><br><span class="line">              Pizza pizza = null;</span><br><span class="line">              if (ordertype.equals(&quot;cheese&quot;)) &#123;</span><br><span class="line">                     pizza = new LDCheesePizza();</span><br><span class="line">              &#125; else if (ordertype.equals(&quot;pepper&quot;)) &#123;</span><br><span class="line">                     pizza = new LDPepperPizza();</span><br><span class="line">              &#125;</span><br><span class="line">              return pizza;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这个模式的好处就是，如果你现在想增加一个功能，只需做一个实现类就 OK 了，无需去改动现成的代码。这样做，拓展性较好！</p>
<p>** 工厂方法存在的问题与解决方法：** 客户端需要创建类的具体的实例。简单来说就是用户要订纽约工厂的披萨，他必须去纽约工厂，想订伦敦工厂的披萨，必须去伦敦工厂。 当伦敦工厂和纽约工厂发生变化了，用户也要跟着变化，这无疑就增加了用户的操作复杂性。为了解决这一问题，我们可以把工厂类抽象为接口，用户只需要去找默认的工厂提出自己的需求（传入参数），便能得到自己想要产品，而不用根据产品去寻找不同的工厂，方便用户操作。这也就是我们接下来要说的抽象工厂模式。</p>
<h3 id="13-抽象工厂模式"><a class="markdownIt-Anchor" href="#13-抽象工厂模式">#</a> 1.3 抽象工厂模式</h3>
<p>** 定义：** 定义了一个接口用于创建相关或有依赖关系的对象族，而无需明确指定具体类。</p>
<p><strong>举例：</strong>（我们依然举 pizza 工厂的例子，pizza 工厂有两个：纽约工厂和伦敦工厂）。类图如下：</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609001610898.png" class="has" width="433" height="208" />
<p>工厂的接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface AbsFactory &#123;</span><br><span class="line">       Pizza CreatePizza(String ordertype) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>工厂的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class LDFactory implements AbsFactory &#123;</span><br><span class="line">       @Override</span><br><span class="line">       public Pizza CreatePizza(String ordertype) &#123;</span><br><span class="line">              Pizza pizza = null;</span><br><span class="line">              if (&quot;cheese&quot;.equals(ordertype)) &#123;</span><br><span class="line">                     pizza = new LDCheesePizza();</span><br><span class="line">              &#125; else if (&quot;pepper&quot;.equals(ordertype)) &#123;</span><br><span class="line">                     pizza = new LDPepperPizza();</span><br><span class="line">              &#125;</span><br><span class="line">              return pizza;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PizzaStroe 的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class PizzaStroe &#123;</span><br><span class="line">       public static void main(String[] args) &#123;</span><br><span class="line">              OrderPizza mOrderPizza;</span><br><span class="line">              mOrderPizza = new OrderPizza(&quot;London&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>** 解决了工厂方法模式的问题：** 在抽象工厂中 PizzaStroe 中只需要传入参数就可以实例化对象。</p>
<h3 id="14-工厂模式适用的场合"><a class="markdownIt-Anchor" href="#14-工厂模式适用的场合">#</a> 1.4 工厂模式适用的场合</h3>
<p>大量的产品需要创建，并且这些产品具有共同的接口 。</p>
<h3 id="15-三种工厂模式的使用选择"><a class="markdownIt-Anchor" href="#15-三种工厂模式的使用选择">#</a> 1.5  三种工厂模式的使用选择</h3>
<p>简单工厂 ： 用来生产同一等级结构中的任意产品。（不支持拓展增加产品）</p>
<p>工厂方法 ：用来生产同一等级结构中的固定产品。（支持拓展增加产品）</p>
<p>抽象工厂 ：用来生产不同产品族的全部产品。（支持拓展增加产品；支持增加产品族）</p>
<p>** 简单工厂的适用场合：** 只有伦敦工厂（只有这一个等级），并且这个工厂只生产三种类型的 pizza：chesse,pepper,greak（固定产品）。</p>
<p><strong>工厂方法的适用场合</strong>：现在不光有伦敦工厂，还增设了纽约工厂（仍然是同一等级结构，但是支持了产品的拓展），这两个工厂依然只生产三种类型的 pizza：chesse,pepper,greak（固定产品）。</p>
<p>** 抽象工厂的适用场合：** 不光增设了纽约工厂（仍然是同一等级结构，但是支持了产品的拓展），这两个工厂还增加了一种新的类型的 pizza：chinese pizza（增加产品族）。</p>
<p>** 所以说抽象工厂就像工厂，而工厂方法则像是工厂的一种产品生产线。<strong>因此，我们可以用抽象工厂模式创建工厂，而用工厂方法模式创建生产线。比如，我们可以使用抽象工厂模式创建伦敦工厂和纽约工厂，使用工厂方法实现 cheese pizza 和 greak pizza 的生产。类图如下：</strong>     **</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609001610907.png" class="has" width="697" height="258" />
<p>总结一下三种模式：</p>
<p><strong>简单工厂模式就是建立一个实例化对象的类，在该类中对多个对象实例化。工厂方法模式是定义了一个创建对象的抽象方法，由子类决定要实例化的类。这样做的好处是再有新的类型的对象需要实例化只要增加子类即可。抽象工厂模式定义了一个接口用于创建对象族，而无需明确指定具体类。抽象工厂也是把对象的实例化交给了子类，即支持拓展。同时提供给客户端接口，避免了用户直接操作子类工厂。</strong></p>
<h3 id="-2"><a class="markdownIt-Anchor" href="#-2">#</a> </h3>
<h2 id="2-单例模式"><a class="markdownIt-Anchor" href="#2-单例模式">#</a> 2 单例模式</h2>
<p>** 定义：** 确保一个类最多只有一个实例，并提供一个全局访问点</p>
<p>单例模式可以分为两种：预加载和懒加载</p>
<h3 id="21-预加载"><a class="markdownIt-Anchor" href="#21-预加载">#</a> 2.1 预加载</h3>
<p>顾名思义，就是预先加载。再进一步解释就是还没有使用该单例对象，但是，该单例对象就已经被加载到内存了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class PreloadSingleton &#123;</span><br><span class="line">       </span><br><span class="line">       public static PreloadSingleton instance = new PreloadSingleton();</span><br><span class="line">   </span><br><span class="line">       //其他的类无法实例化单例类的对象</span><br><span class="line">       private PreloadSingleton() &#123;</span><br><span class="line">       &#125;;</span><br><span class="line">       </span><br><span class="line">       public static PreloadSingleton getInstance() &#123;</span><br><span class="line">              return instance;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>很明显，没有使用该单例对象，该对象就被加载到了内存，会造成内存的浪费。</strong></p>
<h3 id="22-懒加载"><a class="markdownIt-Anchor" href="#22-懒加载">#</a> 2.2 懒加载</h3>
<p>为了避免内存的浪费，我们可以采用懒加载，即用到该单例对象的时候再创建。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">       </span><br><span class="line">       private static Singleton instance=null;</span><br><span class="line">       </span><br><span class="line">       private Singleton()&#123;</span><br><span class="line">       &#125;;</span><br><span class="line">       </span><br><span class="line">       public static Singleton getInstance()</span><br><span class="line">       &#123;</span><br><span class="line">              if(instance==null)</span><br><span class="line">              &#123;</span><br><span class="line">                     instance=new Singleton();</span><br><span class="line">              &#125;</span><br><span class="line">              return instance;</span><br><span class="line">              </span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="23-单例模式和线程安全"><a class="markdownIt-Anchor" href="#23-单例模式和线程安全">#</a> 2.3 单例模式和线程安全</h3>
<p>（1）预加载只有一条语句 return instance, 这显然可以保证线程安全。但是，我们知道预加载会造成内存的浪费。</p>
<p>（2）懒加载不浪费内存，但是无法保证线程的安全。首先，if 判断以及其内存执行代码是非原子性的。其次，new Singleton () 无法保证执行的顺序性。</p>
<p>不满足原子性或者顺序性，线程肯定是不安全的，这是基本的常识，不再赘述。我主要讲一下为什么 new Singleton () 无法保证顺序性。我们知道创建一个对象分三步:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">memory=allocate();//1:初始化内存空间</span><br><span class="line"></span><br><span class="line">ctorInstance(memory);//2:初始化对象</span><br><span class="line"></span><br><span class="line">instance=memory();//3:设置instance指向刚分配的内存地址</span><br></pre></td></tr></table></figure>
<p>**jvm 为了提高程序执行性能，会对没有依赖关系的代码进行重排序，上面 2 和 3 行代码可能被重新排序。** 我们用两个线程来说明线程是不安全的。线程 A 和线程 B 都创建对象。其中，A2 和 A3 的重排序，将导致线程 B 在 B1 处判断出 instance 不为空，线程 B 接下来将访问 instance 引用的对象。此时，线程 B 将会访问到一个还未初始化的对象（线程不安全）。</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609030328860.png" class="has" width="674" height="386" />
<h3 id="24-保证懒加载的线程安全"><a class="markdownIt-Anchor" href="#24-保证懒加载的线程安全">#</a> 2.4 保证懒加载的线程安全</h3>
<p><span style="color:#000000;">我们首先想到的就是使用</span><span style="color:#f33b45;">synchronized</span><span style="color:#000000;">关键字。</span><span style="color:#f33b45;">synchronized</span>加载 getInstace () 函数上确实保证了线程的安全。但是，如果要经常的调用<span style="color:#000000;"><span style="color:#7f0055;"><span style="color:#7f0055;"><span style="color:#333333;">getInstance () 方法，不管有没有初始化实例，都会唤醒和阻塞线程。为了避免线程的上下文切换消耗大量时间，如果对象已经实例化了，我们没有必要再使用</span></span></span></span><span style="color:#f33b45;">synchronized</span><span style="color:#000000;"><span style="color:#7f0055;"><span style="color:#7f0055;"><span style="color:#333333;">加锁，直接返回对象。</span></span></span></span></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">       private static Singleton instance = null;</span><br><span class="line">       private Singleton() &#123;</span><br><span class="line">       &#125;;</span><br><span class="line">       public static synchronized Singleton getInstance() &#123;</span><br><span class="line">              if (instance == null) &#123;</span><br><span class="line">                     instance = new Singleton();</span><br><span class="line">              &#125;</span><br><span class="line">              return instance;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们把<span style="color:#f33b45;">sychronized</span>加在 if (instance==null) 判断语句里面，<strong>保证 instance 未实例化的时候才加锁</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">       private static Singleton instance = null;</span><br><span class="line">       private Singleton() &#123;</span><br><span class="line">       &#125;;</span><br><span class="line">       public static synchronized Singleton getInstance() &#123;</span><br><span class="line">              if (instance == null) &#123;</span><br><span class="line">                     synchronized (Singleton.class) &#123;</span><br><span class="line">                           if (instance == null) &#123;</span><br><span class="line">                                  instance = new Singleton();</span><br><span class="line">                           &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              return instance;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们经过 2.3 的讨论知道 new 一个对象的代码是无法保证顺序性的，因此，我们需要使用另一个关键字<span style="color:#f33b45;">volatile</span>保证对象实例化过程的顺序性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">       private static volatile Singleton instance = null;</span><br><span class="line">       private Singleton() &#123;</span><br><span class="line">       &#125;;</span><br><span class="line">       public static synchronized Singleton getInstance() &#123;</span><br><span class="line">              if (instance == null) &#123;</span><br><span class="line">                     synchronized (instance) &#123;</span><br><span class="line">                           if (instance == null) &#123;</span><br><span class="line">                                  instance = new Singleton();</span><br><span class="line">                           &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              return instance;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>到此，我们就保证了懒加载的线程安全。</strong></p>
<h2 id="3-生成器模式"><a class="markdownIt-Anchor" href="#3-生成器模式">#</a> 3 生成器模式</h2>
<p>** 定义：** 封装一个复杂对象构造过程，并允许按步骤构造。</p>
<p><strong>定义解释：</strong> 我们可以将生成器模式理解为，假设我们有一个对象需要建立，这个对象是由多个组件（Component）组合而成，每个组件的建立都比较复杂，但运用组件来建立所需的对象非常简单，所以我们就可以将构建复杂组件的步骤与运用组件构建对象分离，使用 builder 模式可以建立。</p>
<h3 id="31-模式的结构和代码示例"><a class="markdownIt-Anchor" href="#31-模式的结构和代码示例">#</a> 3.1 模式的结构和代码示例</h3>
<p>生成器模式结构中包括四种角色：</p>
<p>（1）产品 (Product)：具体生产器要构造的复杂对象；</p>
<p>（2）抽象生成器 (Bulider)：抽象生成器是一个接口，该接口除了为创建一个 Product 对象的各个组件定义了若干个方法之外，还要定义返回 Product 对象的方法（<strong>定义构造步骤</strong>）；</p>
<p>（3）具体生产器 (ConcreteBuilder)：实现 Builder 接口的类，具体生成器将实现 Builder 接口所定义的方法（<strong>生产各个组件</strong>）；</p>
<p>（4）指挥者 (Director)：指挥者是一个类，该类需要含有 Builder 接口声明的变量。指挥者的职责是负责向用户提供具体生成器，即指挥者将请求具体生成器类来构造用户所需要的 Product 对象，如果所请求的具体生成器成功地构造出 Product 对象，指挥者就可以让该具体生产器返回所构造的 Product 对象。（<strong>按照步骤组装部件，并返回 Product</strong>）</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609172340456.png" class="has" width="680" height="225" />
<p><strong>举例</strong>（我们如果构建生成一台电脑，那么我们可能需要这么几个步骤（1）需要一个主机（2）需要一个显示器（3）需要一个键盘（4）需要一个鼠标）</p>
<p>虽然我们具体在构建一台主机的时候，每个对象的实际步骤是不一样的，比如，有的对象构建了 i7cpu 的主机，有的对象构建了 i5cpu 的主机，有的对象构建了普通键盘，有的对象构建了机械键盘等。但不管怎样，你总是需要经过一个步骤就是构建一台主机，一台键盘。对于这个例子，我们就可以使用生成器模式来生成一台电脑，他需要通过多个步骤来生成。类图如下：</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609172340477.png" class="has" width="470" height="437" />
<p>ComputerBuilder 类定义构造步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ComputerBuilder &#123;</span><br><span class="line">   </span><br><span class="line">    protected Computer computer;</span><br><span class="line">   </span><br><span class="line">    public Computer getComputer() &#123;</span><br><span class="line">        return computer;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public void buildComputer() &#123;</span><br><span class="line">        computer = new Computer();</span><br><span class="line">        System.out.println(&quot;生成了一台电脑！！！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public abstract void buildMaster();</span><br><span class="line">    public abstract void buildScreen();</span><br><span class="line">    public abstract void buildKeyboard();</span><br><span class="line">    public abstract void buildMouse();</span><br><span class="line">    public abstract void buildAudio();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HPComputerBuilder 定义各个组件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class HPComputerBuilder extends ComputerBuilder &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void buildMaster() &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        computer.setMaster(&quot;i7,16g,512SSD,1060&quot;);</span><br><span class="line">        System.out.println(&quot;(i7,16g,512SSD,1060)的惠普主机&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void buildScreen() &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        computer.setScreen(&quot;1080p&quot;);</span><br><span class="line">        System.out.println(&quot;(1080p)的惠普显示屏&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void buildKeyboard() &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        computer.setKeyboard(&quot;cherry 青轴机械键盘&quot;);</span><br><span class="line">        System.out.println(&quot;(cherry 青轴机械键盘)的键盘&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void buildMouse() &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        computer.setMouse(&quot;MI 鼠标&quot;);</span><br><span class="line">        System.out.println(&quot;(MI 鼠标)的鼠标&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void buildAudio() &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        computer.setAudio(&quot;飞利浦 音响&quot;);</span><br><span class="line">        System.out.println(&quot;(飞利浦 音响)的音响&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Director 类对组件进行组装并生成产品</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Director &#123;</span><br><span class="line">   </span><br><span class="line">    private ComputerBuilder computerBuilder;</span><br><span class="line">    public void setComputerBuilder(ComputerBuilder computerBuilder) &#123;</span><br><span class="line">        this.computerBuilder = computerBuilder;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public Computer getComputer() &#123;</span><br><span class="line">        return computerBuilder.getComputer();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public void constructComputer() &#123;</span><br><span class="line">        computerBuilder.buildComputer();</span><br><span class="line">        computerBuilder.buildMaster();</span><br><span class="line">        computerBuilder.buildScreen();</span><br><span class="line">        computerBuilder.buildKeyboard();</span><br><span class="line">        computerBuilder.buildMouse();</span><br><span class="line">        computerBuilder.buildAudio();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="32-生成器模式的优缺点"><a class="markdownIt-Anchor" href="#32-生成器模式的优缺点">#</a> 3.2 生成器模式的优缺点</h3>
<h3 id="优点"><a class="markdownIt-Anchor" href="#优点">#</a> 优点</h3>
<ul>
<li>
<p>将一个对象分解为各个组件</p>
</li>
<li>
<p>将对象组件的构造封装起来</p>
</li>
<li>
<p>可以控制整个对象的生成过程</p>
</li>
</ul>
<h3 id="缺点"><a class="markdownIt-Anchor" href="#缺点">#</a> 缺点</h3>
<ul>
<li>对不同类型的对象需要实现不同的具体构造器的类，这可能回答大大增加类的数量</li>
</ul>
<h3 id="33-生成器模式与工厂模式的不同"><a class="markdownIt-Anchor" href="#33-生成器模式与工厂模式的不同">#</a> 3.3 生成器模式与工厂模式的不同</h3>
<p>生成器模式构建对象的时候，对象通常构建的过程中需要多个步骤，就像我们例子中的先有主机，再有显示屏，再有鼠标等等，生成器模式的作用就是将这些复杂的构建过程封装起来。工厂模式构建对象的时候通常就只有一个步骤，调用一个工厂方法就可以生成一个对象。</p>
<h2 id="4-原型模式"><a class="markdownIt-Anchor" href="#4-原型模式">#</a> 4 原型模式</h2>
<p>** 定义：** 通过复制现有实例来创建新的实例，无需知道相应类的信息。</p>
<p>简单地理解，其实就是当需要创建一个指定的对象时，我们刚好有一个这样的对象，但是又不能直接使用，我会 clone 一个一毛一样的新对象来使用；基本上这就是原型模式。关键字：<strong>Clone</strong>。</p>
<h3 id="41-深拷贝和浅拷贝"><a class="markdownIt-Anchor" href="#41-深拷贝和浅拷贝">#</a> 4.1 深拷贝和浅拷贝</h3>
<p>浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。</p>
<p>深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。clone 明显是深复制，clone 出来的对象是是不能去影响原型对象的</p>
<h3 id="42-原型模式的结构和代码示例"><a class="markdownIt-Anchor" href="#42-原型模式的结构和代码示例">#</a> 4.2 原型模式的结构和代码示例</h3>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609184856243.png" class="has" width="367" height="237" />
<p>Client：使用者</p>
<p>Prototype：接口（抽象类），声明具备 clone 能力，例如 java 中得 Cloneable 接口</p>
<p>ConcretePrototype：具体的原型类</p>
<p>可以看出设计模式还是比较简单的，重点在于 Prototype 接口和 Prototype 接口的实现类 ConcretePrototype。原型模式的具体实现：一个原型类，只需要实现 Cloneable 接口，覆写 clone 方法，此处 clone 方法可以改成任意的名称，因为 Cloneable 接口是个空接口，你可以任意定义实现类的方法名，如 cloneA 或者 cloneB，因为此处的重点是 super.clone () 这句话，super.clone () 调用的是 Object 的 clone () 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Prototype implements Cloneable &#123;  </span><br><span class="line">     public Object clone() throws CloneNotSupportedException &#123;  </span><br><span class="line">         Prototype proto = (Prototype) super.clone();  </span><br><span class="line">         return proto;  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>** 举例（<strong>银行发送大量邮件，使用 clone 和不使用 clone 的时间对比</strong>）：** 我们模拟创建一个对象需要耗费比较长的时间，因此，在构造函数中我们让当前线程 sleep 一会</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public Mail(EventTemplate et) &#123;</span><br><span class="line">              this.tail = et.geteventContent();</span><br><span class="line">              this.subject = et.geteventSubject();</span><br><span class="line">              try &#123;</span><br><span class="line">                     Thread.sleep(1000);</span><br><span class="line">              &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                     // TODO Auto-generated catch block</span><br><span class="line">                     e.printStackTrace();</span><br><span class="line">              &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>不使用 clone, 发送十个邮件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">              int i = 0;</span><br><span class="line">              int MAX_COUNT = 10;</span><br><span class="line">              EventTemplate et = new EventTemplate(&quot;9月份信用卡账单&quot;, &quot;国庆抽奖活动...&quot;);</span><br><span class="line">              long start = System.currentTimeMillis();</span><br><span class="line">              while (i &lt; MAX_COUNT) &#123;</span><br><span class="line">                     // 以下是每封邮件不同的地方</span><br><span class="line">                     Mail mail = new Mail(et);</span><br><span class="line">                     mail.setContent(getRandString(5) + &quot;,先生（女士）:你的信用卡账单...&quot; + mail.getTail());</span><br><span class="line">                     mail.setReceiver(getRandString(5) + &quot;@&quot; + getRandString(8) + &quot;.com&quot;);</span><br><span class="line">                     // 然后发送邮件</span><br><span class="line">                     sendMail(mail);</span><br><span class="line">                     i++;</span><br><span class="line">              &#125;</span><br><span class="line">              long end = System.currentTimeMillis();</span><br><span class="line">              System.out.println(&quot;用时:&quot; + (end - start));</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p><strong>用时：10001</strong></p>
<p>使用 clone, 发送十个邮件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">          int i = 0;</span><br><span class="line">          int MAX_COUNT = 10;</span><br><span class="line">          EventTemplate et = new EventTemplate(&quot;9月份信用卡账单&quot;, &quot;国庆抽奖活动...&quot;);</span><br><span class="line">          long start=System.currentTimeMillis();</span><br><span class="line">          Mail mail = new Mail(et);         </span><br><span class="line">          while (i &lt; MAX_COUNT) &#123;</span><br><span class="line">                 Mail cloneMail = mail.clone();</span><br><span class="line">                 mail.setContent(getRandString(5) + &quot;,先生（女士）:你的信用卡账单...&quot;</span><br><span class="line">                              + mail.getTail());</span><br><span class="line">                 mail.setReceiver(getRandString(5) + &quot;@&quot; + getRandString(8) + &quot;.com&quot;);</span><br><span class="line">                 sendMail(cloneMail);</span><br><span class="line">                 i++;</span><br><span class="line">          &#125;</span><br><span class="line">          long end=System.currentTimeMillis();</span><br><span class="line">          System.out.println(&quot;用时:&quot;+(end-start));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><strong>用时：1001</strong></p>
<h3 id="43-总结"><a class="markdownIt-Anchor" href="#43-总结">#</a> 4.3 总结</h3>
<p><strong>原型模式的本质就是 clone，可以解决构建复杂对象的资源消耗问题，能再某些场景中提升构建对象的效率；还有一个重要的用途就是保护性拷贝，可以通过返回一个拷贝对象的形式，实现只读的限制。</strong></p>
<h1 id="b-结构模式7种"><a class="markdownIt-Anchor" href="#b-结构模式7种">#</a> B、结构模式（7 种）</h1>
<p>适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p>
<h3 id="-3"><a class="markdownIt-Anchor" href="#-3">#</a> </h3>
<h2 id="5-适配器模式"><a class="markdownIt-Anchor" href="#5-适配器模式">#</a> 5 适配器模式</h2>
<p><strong>定义：</strong> 适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。</p>
<p>** 主要分为三类：** 类的适配器模式、对象的适配器模式、接口的适配器模式。</p>
<h3 id="51-类适配器模式"><a class="markdownIt-Anchor" href="#51-类适配器模式">#</a> 5.1 类适配器模式</h3>
<p>通过多重<strong>继承</strong>目标接口和被适配者类方式来实现适配</p>
<p><strong>举例</strong> (将 USB 接口转为 VGA 接口)，类图如下：</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609210401275.png" class="has" width="329" height="268" />
<p>USBImpl 的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class USBImpl implements USB&#123;</span><br><span class="line">       @Override</span><br><span class="line">       public void showPPT() &#123;</span><br><span class="line">              // TODO Auto-generated method stub</span><br><span class="line">              System.out.println(&quot;PPT内容演示&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AdatperUSB2VGA 首先继承 USBImpl 获取 USB 的功能，其次，实现 VGA 接口，表示该类的类型为 VGA。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class AdapterUSB2VGA extends USBImpl implements VGA &#123;</span><br><span class="line">       @Override</span><br><span class="line">       public void projection() &#123;</span><br><span class="line">              super.showPPT();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Projector 将 USB 映射为 VGA，只有 VGA 接口才可以连接上投影仪进行投影</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Projector&lt;T&gt; &#123;</span><br><span class="line">       public void projection(T t) &#123;</span><br><span class="line">              if (t instanceof VGA) &#123;</span><br><span class="line">                     System.out.println(&quot;开始投影&quot;);</span><br><span class="line">                     VGA v = new VGAImpl();</span><br><span class="line">                     v = (VGA) t;</span><br><span class="line">                     v.projection();</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                     System.out.println(&quot;接口不匹配，无法投影&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>test 代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test2()&#123;</span><br><span class="line">       //通过适配器创建一个VGA对象，这个适配器实际是使用的是USB的showPPT（）方法</span><br><span class="line">       VGA a=new AdapterUSB2VGA();</span><br><span class="line">       //进行投影</span><br><span class="line">       Projector p1=new Projector();</span><br><span class="line">       p1.projection(a);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="52-对象适配器模式"><a class="markdownIt-Anchor" href="#52-对象适配器模式">#</a> 5.2 对象适配器模式</h3>
<p>对象适配器和类适配器使用了不同的方法实现适配，对象适配器使用组合，类适配器使用继承。</p>
<p><strong>举例</strong> (将 USB 接口转为 VGA 接口)，类图如下：</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609210401318.png" class="has" width="356" height="278" />
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class AdapterUSB2VGA implements VGA &#123;</span><br><span class="line">       USB u = new USBImpl();</span><br><span class="line">       @Override</span><br><span class="line">       public void projection() &#123;</span><br><span class="line">              u.showPPT();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现 VGA 接口，表示适配器类是 VGA 类型的，适配器方法中直接使用 USB 对象。</p>
<h3 id="53-接口适配器模式"><a class="markdownIt-Anchor" href="#53-接口适配器模式">#</a> 5.3 接口适配器模式</h3>
<p>当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求，<strong>它适用于一个接口不想使用其所有的方法的情况。</strong></p>
<p><strong>举例</strong> (将 USB 接口转为 VGA 接口，VGA 中的 b () 和 c () 不会被实现)，类图如下：</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609210401289.png" class="has" width="451" height="351" />
<p><span style="color:#333333;">AdapterUSB2VGA</span>抽象类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AdapterUSB2VGA implements VGA &#123;</span><br><span class="line">       USB u = new USBImpl();</span><br><span class="line">       @Override</span><br><span class="line">       public void projection() &#123;</span><br><span class="line">              u.showPPT();</span><br><span class="line">       &#125;</span><br><span class="line">       @Override</span><br><span class="line">       public void b() &#123;</span><br><span class="line">       &#125;;</span><br><span class="line">       @Override</span><br><span class="line">       public void c() &#123;</span><br><span class="line">       &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span style="color:#333333;">AdapterUSB2VGA 实现，不用去实现 b () 和 c () 方法。</span></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class AdapterUSB2VGAImpl extends AdapterUSB2VGA &#123;</span><br><span class="line">       public void projection() &#123;</span><br><span class="line">              super.projection();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="54-总结"><a class="markdownIt-Anchor" href="#54-总结">#</a> 5.4 总结</h3>
<p>总结一下三种适配器模式的应用场景：</p>
<p><strong>类适配器模式：<strong>当希望将</strong>一个类</strong>转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。</p>
<p>** 对象适配器模式：** 当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个 Wrapper 类，持有原类的一个实例，在 Wrapper 类的方法中，调用实例的方法就行。</p>
<p>** 接口适配器模式：** 当不希望实现一个接口中所有的方法时，可以创建一个抽象类 Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可。</p>
<p><strong>命名规则：</strong></p>
<p><strong>我个人理解，三种命名方式，是根据 src 是以怎样的形式给到 Adapter（在 Adapter 里的形式）来命名的。</strong></p>
<p>类适配器，以类给到，在 Adapter 里，就是将 src 当做类，继承，</p>
<p>对象适配器，以对象给到，在 Adapter 里，将 src 作为一个对象，持有。</p>
<p>接口适配器，以接口给到，在 Adapter 里，将 src 作为一个接口，实现。</p>
<p><strong>使用选择：</strong></p>
<p><strong>根据合成复用原则，组合大于继承。因此，类的适配器模式应该少用。</strong></p>
<h3 id="-4"><a class="markdownIt-Anchor" href="#-4">#</a> </h3>
<h2 id="6-装饰者模式"><a class="markdownIt-Anchor" href="#6-装饰者模式">#</a> 6 装饰者模式</h2>
<p><strong>定义：</strong><span style="color:#4d4d4d;">动态的将新功能附加到对象上。在对象功能扩展方面，它</span><span style="color:#4d4d4d;">比继承更有弹性。</span></p>
<h3 id="span-stylecolor4d4d4d61-装饰者模式结构图与代码示例span"><a class="markdownIt-Anchor" href="#span-stylecolor4d4d4d61-装饰者模式结构图与代码示例span">#</a> <span style="color:#4d4d4d;">6.1 装饰者模式结构图与代码示例</span></h3>
<p><span style="color:#4d4d4d;">1.Component（被装饰对象的基类）</span></p>
<p><span style="color:#4d4d4d;">   定义一个对象接口，可以给这些对象动态地添加职责。</span></p>
<p><span style="color:#4d4d4d;">2.ConcreteComponent（具体被装饰对象）</span></p>
<p><span style="color:#4d4d4d;">   定义一个对象，可以给这个对象添加一些职责。</span></p>
<p><span style="color:#4d4d4d;">3.Decorator（装饰者抽象类）</span></p>
<p><span style="color:#4d4d4d;">   维持一个指向 Component 实例的引用，并定义一个与 Component 接口一致的接口。</span></p>
<p><span style="color:#4d4d4d;">4.ConcreteDecorator（具体装饰者）</span></p>
<p><span style="color:#4d4d4d;">   具体的装饰对象，给内部持有的具体被装饰对象，增加具体的职责。</span></p>
<p><strong>被装饰对象和修饰者继承自同一个超类</strong></p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609223457210.png" class="has" width="561" height="287" />
<p><strong><span style="color:#4d4d4d;">举例</span></strong><span style="color:#4d4d4d;">(<span style="color:#4d4d4d;">咖啡馆订单项目：</span></span><span style="color:#4d4d4d;">1）、咖啡种类：Espresso、ShortBlack、LongBlack、Decaf</span><span style="color:#4d4d4d;">2）、<strong>调料（装饰者）</strong>：Milk、Soy、Chocolate</span><span style="color:#4d4d4d;">)，类图如下：</span></p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190609222716270.png" class="has" width="561" height="287" />
<p>被装饰的对象和装饰者都继承自同一个超类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Drink &#123;</span><br><span class="line">       public String description=&quot;&quot;;</span><br><span class="line">       private float price=0f;;</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       public void setDescription(String description)</span><br><span class="line">       &#123;</span><br><span class="line">              this.description=description;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       public String getDescription()</span><br><span class="line">       &#123;</span><br><span class="line">              return description+&quot;-&quot;+this.getPrice();</span><br><span class="line">       &#125;</span><br><span class="line">       public float getPrice()</span><br><span class="line">       &#123;</span><br><span class="line">              return price;</span><br><span class="line">       &#125;</span><br><span class="line">       public void setPrice(float price)</span><br><span class="line">       &#123;</span><br><span class="line">              this.price=price;</span><br><span class="line">       &#125;</span><br><span class="line">       public abstract float cost();</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>被装饰的对象，不用去改造。原来怎么样写，现在还是怎么写。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public  class Coffee extends Drink &#123;</span><br><span class="line">       @Override</span><br><span class="line">       public float cost() &#123;</span><br><span class="line">              // TODO Auto-generated method stub</span><br><span class="line">              return super.getPrice();</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>coffee 类的实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Decaf extends Coffee &#123;</span><br><span class="line">       public Decaf()</span><br><span class="line">       &#123;</span><br><span class="line">              super.setDescription(&quot;Decaf&quot;);</span><br><span class="line">              super.setPrice(3.0f);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>装饰者</p>
<p>装饰者不仅要考虑自身，还要考虑被它修饰的对象，它是在被修饰的对象上继续添加修饰。例如，咖啡里面加牛奶，再加巧克力。加糖后价格为 coffee+milk。再加牛奶价格为 coffee+milk+chocolate。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Decorator extends Drink &#123;</span><br><span class="line">       private Drink Obj;</span><br><span class="line">       public Decorator(Drink Obj) &#123;</span><br><span class="line">              this.Obj = Obj;</span><br><span class="line">       &#125;;</span><br><span class="line">       @Override</span><br><span class="line">       public float cost() &#123;</span><br><span class="line">              // TODO Auto-generated method stub</span><br><span class="line">              return super.getPrice() + Obj.cost();</span><br><span class="line">       &#125;</span><br><span class="line">       @Override</span><br><span class="line">       public String getDescription() &#123;</span><br><span class="line">              return super.description + &quot;-&quot; + super.getPrice() + &quot;&amp;&amp;&quot; + Obj.getDescription();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>装饰者实例化（加牛奶）。这里面要对被修饰的对象进行实例化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Milk extends Decorator &#123;</span><br><span class="line">       public Milk(Drink Obj) &#123;          </span><br><span class="line">              super(Obj);</span><br><span class="line">              // TODO Auto-generated constructor stub</span><br><span class="line">              super.setDescription(&quot;Milk&quot;);</span><br><span class="line">              super.setPrice(2.0f);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>coffee 店：初始化一个被修饰对象，修饰者实例需要对被修改者实例化，才能对具体的被修饰者进行修饰。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class CoffeeBar &#123;</span><br><span class="line">       public static void main(String[] args) &#123;</span><br><span class="line">              Drink order;</span><br><span class="line">              order = new Decaf();</span><br><span class="line">              System.out.println(&quot;order1 price:&quot; + order.cost());</span><br><span class="line">              System.out.println(&quot;order1 desc:&quot; + order.getDescription());</span><br><span class="line">              System.out.println(&quot;****************&quot;);</span><br><span class="line">              order = new LongBlack();</span><br><span class="line">              order = new Milk(order);</span><br><span class="line">              order = new Chocolate(order);</span><br><span class="line">              order = new Chocolate(order);</span><br><span class="line">              System.out.println(&quot;order2 price:&quot; + order.cost());</span><br><span class="line">              System.out.println(&quot;order2 desc:&quot; + order.getDescription());</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6.2 总结</p>
<p><strong>装饰者和被装饰者之间必须是一样的类型，也就是要有共同的超类。在这里应用继承并不是实现方法的复制，而是实现类型的匹配。因为装饰者和被装饰者是同一个类型，因此装饰者可以取代被装饰者，这样就使被装饰者拥有了装饰者独有的行为。根据装饰者模式的理念，我们可以在任何时候，实现新的装饰者增加新的行为。如果是用继承，每当需要增加新的行为时，就要修改原程序了。</strong></p>
<h3 id="-5"><a class="markdownIt-Anchor" href="#-5">#</a> </h3>
<h3 id="-6"><a class="markdownIt-Anchor" href="#-6">#</a> </h3>
<h2 id="7-代理模式"><a class="markdownIt-Anchor" href="#7-代理模式">#</a> 7 代理模式</h2>
<p>** 定义：** 代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活中常见的中介。</p>
<p>举个例子来说明：假如说我现在想买一辆二手车，虽然我可以自己去找车源，做质量检测等一系列的车辆过户流程，但是这确实太浪费我得时间和精力了。我只是想买一辆车而已为什么我还要额外做这么多事呢？于是我就通过中介公司来买车，他们来给我找车源，帮我办理车辆过户流程，我只是负责选择自己喜欢的车，然后付钱就可以了。用图表示如下：</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/2019061001123986.png" class="has" width="633" height="210" />
<h3 id="71-为什么要用代理模式"><a class="markdownIt-Anchor" href="#71-为什么要用代理模式">#</a> 7.1 为什么要用代理模式？</h3>
<p>** 中介隔离作用：** 在某些情况下，一个客户类不想或者不能直接引用一个委托对象，而代理类对象可以在客户类和委托对象之间起到中介的作用，其特征是代理类和委托类实现相同的接口。</p>
<p>** 开闭原则，增加功能：** 代理类除了是客户类和委托类的中介之外，我们还可以通过给代理类增加额外的功能来扩展委托类的功能，这样做我们只需要修改代理类而不需要再修改委托类，符合代码设计的开闭原则。代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后对返回结果的处理等。代理类本身并不真正实现服务，而是同过调用委托类的相关方法，来提供特定的服务。真正的业务功能还是由委托类来实现，但是可以在业务功能执行的前后加入一些公共的服务。例如我们想给项目加入缓存、日志这些功能，我们就可以使用代理类来完成，而没必要打开已经封装好的委托类。</p>
<p><strong>代理模式分为三类：1. 静态代理 2. 动态代理 3. CGLIB 代理</strong></p>
<p>7.2 静态代理</p>
<p><span style="color:#4d4d4d;"><strong>举例</strong></span><span style="color:#4d4d4d;">(买房</span><span style="color:#4d4d4d;">），类图如下：</span></p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/2019061001123984.png" class="has" width="359" height="179" />
<p>第一步：创建服务类接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface BuyHouse &#123;</span><br><span class="line">    void buyHosue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二步：实现服务接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class BuyHouseImpl implements BuyHouse &#123;</span><br><span class="line">       @Override</span><br><span class="line">       public void buyHosue() &#123;</span><br><span class="line">              System.out.println(&quot;我要买房&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三步：创建代理类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class BuyHouseProxy implements BuyHouse &#123;</span><br><span class="line">       private BuyHouse buyHouse;</span><br><span class="line">       public BuyHouseProxy(final BuyHouse buyHouse) &#123;</span><br><span class="line">              this.buyHouse = buyHouse;</span><br><span class="line">       &#125;</span><br><span class="line">       @Override</span><br><span class="line">       public void buyHosue() &#123;</span><br><span class="line">              System.out.println(&quot;买房前准备&quot;);</span><br><span class="line">              buyHouse.buyHosue();</span><br><span class="line">              System.out.println(&quot;买房后装修&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<p>优点：可以做到在符合开闭原则的情况下对目标对象进行功能扩展。</p>
<p>缺点： <strong>代理对象与目标对象要实现相同的接口，我们得为每一个服务都得创建代理类，工作量太大</strong>，不易管理。同时接口一旦发生改变，代理类也得相应修改。</p>
<h3 id="73-动态代理"><a class="markdownIt-Anchor" href="#73-动态代理">#</a> 7.3 动态代理</h3>
<p>动态代理有以下特点:</p>
<p>1. 代理对象，不需要实现接口</p>
<p>2. 代理对象的生成，是利用 JDK 的 API, 动态的在内存中构建代理对象 (需要我们指定创建代理对象 / 目标对象实现的接口的类型)</p>
<p>代理类不用再实现接口了。但是，要求被代理对象必须有接口。</p>
<p><strong>动态代理实现：</strong></p>
<p>Java.lang.reflect.Proxy 类可以直接生成一个代理对象</p>
<ul>
<li>
<p>Proxy.newProxyInstance (ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 生成一个代理对象</p>
<ul>
<li>
<p>参数 1:ClassLoader loader 代理对象的类加载器 一般使用被代理对象的类加载器</p>
</li>
<li>
<p>参数 2:Class&lt;?&gt;[] interfaces 代理对象的要实现的接口 一般使用的被代理对象实现的接口</p>
</li>
<li>
<p>参数 3:InvocationHandler h (接口) 执行处理类</p>
</li>
</ul>
</li>
<li>
<p>InvocationHandler 中的 invoke (Object proxy, Method method, Object [] args) 方法：调用代理类的任何方法，此方法都会执行</p>
<ul>
<li>
<p>参数 3.1: 代理对象 (慎用)</p>
</li>
<li>
<p>参数 3.2: 当前执行的方法</p>
</li>
<li>
<p>参数 3.3: 当前执行的方法运行时传递过来的参数</p>
</li>
</ul>
</li>
</ul>
<p>第一步：编写动态处理器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicProxyHandler implements InvocationHandler &#123;</span><br><span class="line">       private Object object;</span><br><span class="line">       public DynamicProxyHandler(final Object object) &#123;</span><br><span class="line">              this.object = object;</span><br><span class="line">       &#125;</span><br><span class="line">       @Override</span><br><span class="line">       public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">              System.out.println(&quot;买房前准备&quot;);</span><br><span class="line">              Object result = method.invoke(object, args);</span><br><span class="line">              System.out.println(&quot;买房后装修&quot;);</span><br><span class="line">              return result;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二步：编写测试类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicProxyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BuyHouse buyHouse = new BuyHouseImpl();</span><br><span class="line">        BuyHouse proxyBuyHouse = (BuyHouse) Proxy.newProxyInstance(BuyHouse.class.getClassLoader(), new</span><br><span class="line">                Class[]&#123;BuyHouse.class&#125;, new DynamicProxyHandler(buyHouse));</span><br><span class="line">        proxyBuyHouse.buyHosue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>** 动态代理总结：** 虽然相对于静态代理，动态代理大大减少了我们的开发任务，同时减少了对业务接口的依赖，降低了耦合度。但是还是有一点点小小的遗憾之处，那就是它始终无法摆脱仅支持 interface 代理的桎梏（我们要使用被代理的对象的接口），因为它的设计注定了这个遗憾。</p>
<p>7.4 CGLIB 代理</p>
<p><strong>CGLIB 原理</strong>：动态生成一个要代理类的子类，子类重写要代理的类的所有不是 final 的方法。在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。它比使用 java 反射的 JDK 动态代理要快。</p>
<p><strong>CGLIB 底层</strong>：使用字节码处理框架 ASM，来转换字节码并生成新的类。不鼓励直接使用 ASM，因为它要求你必须对 JVM 内部结构包括 class 文件的格式和指令集都很熟悉。</p>
<p><strong>CGLIB 缺点</strong>：对于 final 方法，无法进行代理。</p>
<p>CGLIB 的实现步骤：</p>
<p>第一步：建立拦截器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public Object intercept(Object object, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;买房前准备&quot;);</span><br><span class="line"></span><br><span class="line">        Object result = methodProxy.invoke(object, args);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;买房后装修&quot;);</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>参数：Object 为由 CGLib 动态生成的代理类实例，Method 为上文中实体类所调用的被代理的方法引用，Object [] 为参数值列表，MethodProxy 为生成的代理类对方法的代理引用。</p>
<p>返回：从代理实例的方法调用返回的值。</p>
<p>其中，<strong>proxy.invokeSuper(obj,arg)</strong> 调用代理类实例上的 proxy 方法的父类方法（即实体类 TargetObject 中对应的方法）</p>
<p>第二步： 生成动态代理类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class CglibProxy implements MethodInterceptor &#123;</span><br><span class="line">    private Object target;</span><br><span class="line">    public Object getInstance(final Object target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">        Enhancer enhancer = new Enhancer();</span><br><span class="line">        enhancer.setSuperclass(this.target.getClass());</span><br><span class="line">        enhancer.setCallback(this);</span><br><span class="line">        return enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">    public Object intercept(Object object, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;买房前准备&quot;);</span><br><span class="line">        Object result = methodProxy.invoke(object, args);</span><br><span class="line">        System.out.println(&quot;买房后装修&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 Enhancer 类是 CGLib 中的一个字节码增强器，它可以方便的对你想要处理的类进行扩展，以后会经常看到它。</p>
<p>首先将被代理类 TargetObject 设置成父类，然后设置拦截器 TargetInterceptor，最后执行 enhancer.create () 动态生成一个代理类，并从 Object 强制转型成父类型 TargetObject。</p>
<p>第三步：测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class CglibProxyTest &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        BuyHouse buyHouse = new BuyHouseImpl();</span><br><span class="line">        CglibProxy cglibProxy = new CglibProxy();</span><br><span class="line">        BuyHouseImpl buyHouseCglibProxy = (BuyHouseImpl) cglibProxy.getInstance(buyHouse);</span><br><span class="line">        buyHouseCglibProxy.buyHosue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CGLIB 代理总结：** CGLIB 创建的动态代理对象比 JDK 创建的动态代理对象的性能更高，但是 CGLIB 创建代理对象时所花费的时间却比 JDK 多得多。所以对于单例的对象，因为无需频繁创建对象，用 CGLIB 合适，反之使用 JDK 方式要更为合适一些。同时由于 CGLib 由于是采用动态创建子类的方法，对于 final 修饰的方法无法进行代理。**</p>
<h2 id="8-外观模式"><a class="markdownIt-Anchor" href="#8-外观模式">#</a> 8 外观模式</h2>
<p><strong>定义：</strong> 隐藏了系统的复杂性，并向客户端提供了一个可以访问系统的接口。</p>
<h3 id="81-模式结构和代码示例"><a class="markdownIt-Anchor" href="#81-模式结构和代码示例">#</a> 8.1 模式结构和代码示例</h3>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610154828945.png" class="has" width="666" height="408" />
<p>简单来说，该模式就是把一些复杂的流程封装成一个接口供给外部用户更简单的使用。这个模式中，设计到 3 个角色。</p>
<p>1）. 门面角色：外观模式的核心。它被客户角色调用，它熟悉子系统的功能。内部根据客户角色的需求预定了几种功能的组合。（<strong>客户调用，同时自身调用子系统功能</strong>）</p>
<p>2）. 子系统角色：实现了子系统的功能。它对客户角色和 Facade 时未知的。它内部可以有系统内的相互交互，也可以由供外界调用的接口。（实现具体功能）</p>
<p>3）. 客户角色：通过调用 Facede 来完成要实现的功能（<strong>调用门面角色</strong>）。</p>
<p>举例（每个 Computer 都有 CPU、Memory、Disk。在 Computer 开启和关闭的时候，相应的部件也会开启和关闭），类图如下：</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610154828952.png" class="has" width="473" height="187" />
<p>首先是子系统类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class CPU &#123;</span><br><span class="line"></span><br><span class="line">    public void start() &#123;</span><br><span class="line">        System.out.println(&quot;cpu is start...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void shutDown() &#123;</span><br><span class="line">        System.out.println(&quot;CPU is shutDown...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Disk &#123;</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        System.out.println(&quot;Disk is start...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void shutDown() &#123;</span><br><span class="line">        System.out.println(&quot;Disk is shutDown...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Memory &#123;</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        System.out.println(&quot;Memory is start...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void shutDown() &#123;</span><br><span class="line">        System.out.println(&quot;Memory is shutDown...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是，门面类 Facade</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Computer &#123;</span><br><span class="line"></span><br><span class="line">    private CPU cpu;</span><br><span class="line">    private Memory memory;</span><br><span class="line">    private Disk disk;</span><br><span class="line"></span><br><span class="line">    public Computer() &#123;</span><br><span class="line">        cpu = new CPU();</span><br><span class="line">        memory = new Memory();</span><br><span class="line">        disk = new Disk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void start() &#123;</span><br><span class="line">        System.out.println(&quot;Computer start begin&quot;);</span><br><span class="line">        cpu.start();</span><br><span class="line">        disk.start();</span><br><span class="line">        memory.start();</span><br><span class="line">        System.out.println(&quot;Computer start end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void shutDown() &#123;</span><br><span class="line">        System.out.println(&quot;Computer shutDown begin&quot;);</span><br><span class="line">        cpu.shutDown();</span><br><span class="line">        disk.shutDown();</span><br><span class="line">        memory.shutDown();</span><br><span class="line">        System.out.println(&quot;Computer shutDown end...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后为，客户角色</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Computer computer = new Computer();</span><br><span class="line">        computer.start();</span><br><span class="line">        System.out.println(&quot;=================&quot;);</span><br><span class="line">        computer.shutDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="82-优点"><a class="markdownIt-Anchor" href="#82-优点">#</a> 8.2 优点</h3>
<p>**　- 松散耦合 **</p>
<p>使得客户端和子系统之间解耦，让子系统内部的模块功能更容易扩展和维护；</p>
<p>**　　- 简单易用 **</p>
<p>客户端根本不需要知道子系统内部的实现，或者根本不需要知道子系统内部的构成，它只需要跟 Facade 类交互即可。</p>
<p>**　- 更好的划分访问层次 **</p>
<p>有些方法是对系统外的，有些方法是系统内部相互交互的使用的。子系统把那些暴露给外部的功能集中到门面中，这样就可以实现客户端的使用，很好的隐藏了子系统内部的细节。</p>
<h2 id="9-桥接模式"><a class="markdownIt-Anchor" href="#9-桥接模式">#</a> 9 桥接模式</h2>
<p><strong>定义：</strong> 将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p>
<h3 id="91-案例"><a class="markdownIt-Anchor" href="#91-案例">#</a> 9.1 案例</h3>
<p>看下图手机与手机软件的类图</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610180930798.png" class="has" width="710" height="417" />
<p>增加一款新的手机软件，需要在所有手机品牌类下添加对应的手机软件类，当手机软件种类较多时，将导致类的个数急剧膨胀，难以维护</p>
<p>手机和手机中的软件是什么关系？</p>
<p>手机中的软件从本质上来说并不是一种手机，手机软件运行在手机中，是一种包含与被包含关系，而不是一种父与子或者说一般与特殊的关系，通过继承手机类实现手机软件类的设计是违反一般规律的。</p>
<p>如果 Oppo 手机实现了 wifi 功能，继承它的 Oppo 应用商城也会继承 wifi 功能，并且 Oppo 手机类的任何变动，都会影响其子类</p>
<p>换一种解决思路</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610180930823.png" class="has" width="710" height="430" />
<p>从类图上看起来更像是手机软件类图，涉及到手机本身相关的功能，比如说：wifi 功能，放到哪个类中实现呢？放到 OppoAppStore 中实现显然是不合适的</p>
<p>引起整个结构变化的元素有两个，一个是手机品牌，一个是手机软件，所以我们将这两个点抽出来，分别进行封装</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610180930831.png" class="has" width="690" height="331" />
<h3 id="92-桥接模式结构和代码示例"><a class="markdownIt-Anchor" href="#92-桥接模式结构和代码示例">#</a> 9.2 桥接模式结构和代码示例</h3>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610180930861.png" class="has" width="556" height="274" />
<p><strong>类图：</strong></p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610180930821.png" class="has" width="451" height="197" />
<p><strong>实现：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public interface Software &#123;</span><br><span class="line">    public void run();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class AppStore implements Software &#123;</span><br><span class="line">     </span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;run app store&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Camera implements Software &#123;</span><br><span class="line">     </span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;run camera&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Phone &#123;</span><br><span class="line"></span><br><span class="line">    protected Software software;</span><br><span class="line"></span><br><span class="line">    public void setSoftware(Software software) &#123;</span><br><span class="line">        this.software = software;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void run();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class Oppo extends Phone &#123;</span><br><span class="line">     </span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        software.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Vivo extends Phone &#123;</span><br><span class="line">     </span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        software.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比最初的设计，将抽象部分（手机）与它的实现部分（手机软件类）分离，将实现部分抽象成单独的类，使它们都可以独立地变化。整个类图看起来像一座桥，所以称为桥接模式</p>
<p>继承是一种强耦合关系，子类的实现与它的父类有非常紧密的依赖关系，父类的任何变化 都会导致子类发生变化，因此继承或者说强耦合关系严重影响了类的灵活性，并最终限制了可复用性</p>
<p>从桥接模式的设计上我们可以看出聚合是一种比继承要弱的关联关系，手机类和软件类都可独立的进行变化，不会互相影响</p>
<h3 id="span-stylecolor00000093-适用场景span"><a class="markdownIt-Anchor" href="#span-stylecolor00000093-适用场景span">#</a> <span style="color:#000000;">9.3 适用场景</span></h3>
<p>桥接模式通常适用于以下场景。</p>
<ol>
<li>
<p>当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。</p>
</li>
<li>
<p>当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。</p>
</li>
<li>
<p>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。</p>
</li>
</ol>
<h3 id="span-stylecolor00000094-优缺点span"><a class="markdownIt-Anchor" href="#span-stylecolor00000094-优缺点span">#</a> <span style="color:#000000;">9.4 优缺点</span></h3>
<p><strong>优点：</strong></p>
<p>(1) 在很多情况下，桥接模式可以取代多层继承方案，多层继承方案违背了 “单一职责原则”，复用性较差，且类的个数非常多，桥接模式是比多层继承方案更好的解决方法，它极大减少了子类的个数。</p>
<p>(2) 桥接模式提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，符合 “开闭原则”。</p>
<p><strong>缺点：</strong></p>
<p>桥接模式的使用会增加系统的理解与设计难度，由于关联关系建立在抽象层，要求开发者一开始就针对抽象层进行设计与编程。</p>
<h2 id="10-组合模式"><a class="markdownIt-Anchor" href="#10-组合模式">#</a> 10 组合模式</h2>
<p>** 定义：** 有时又叫作<span style="color:#006400;">部分 - 整体模式</span>，它是一种将对象组合成树状的层次结构的模式，用来表示 “部分 - 整体” 的关系，使用户对单个对象和组合对象具有一致的访问性。</p>
<p>** 意图：** 将对象组合成树形结构以表示 &quot;部分 - 整体&quot; 的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<p>** 主要解决：** 它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。</p>
<p><strong>何时使用：</strong> 1、您想表示对象的部分 - 整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</p>
<p>** 如何解决：** 树枝和叶子实现统一接口，树枝内部组合该接口。</p>
<p>** 关键代码：** 树枝内部组合该接口，并且含有内部属性 List，里面放 Component。</p>
<p>组合模式的主要优点有：</p>
<ol>
<li>
<p>组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；</p>
</li>
<li>
<p>更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足 “开闭原则”；</p>
</li>
</ol>
<p>其主要缺点是：</p>
<ol>
<li>
<p>设计较复杂，客户端需要花更多时间理清类之间的层次关系；</p>
</li>
<li>
<p>不容易限制容器中的构件；</p>
</li>
<li>
<p>不容易用继承的方法来增加构件的新功能；</p>
</li>
</ol>
<h3 id="101-模式结构和代码示例"><a class="markdownIt-Anchor" href="#101-模式结构和代码示例">#</a> 10.1 模式结构和代码示例</h3>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612191511416.png" class="has" width="529" height="565" />
<ul>
<li>
<p>抽象构件（Component）角色：它的主要作用是为树叶构件和树枝构件声明公共接口，并实现它们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。</p>
</li>
<li>
<p>树叶构件（Leaf）角色：是组合中的叶节点对象，它没有子节点，用于实现抽象构件角色中 声明的公共接口。</p>
</li>
<li>
<p>树枝构件（Composite）角色：是组合中的分支节点对象，它有子节点。它实现了抽象构件角色中声明的接口，它的主要作用是存储和管理子部件，通常包含 Add ()、Remove ()、GetChild () 等方法</p>
</li>
</ul>
<p>举例（访问一颗树），类图如下：</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/201906121917147.png" class="has" width="286" height="216" />
<p>1 组件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Component &#123;</span><br><span class="line">    public void add(Component c);</span><br><span class="line">    public void remove(Component c);</span><br><span class="line">    public Component getChild(int i);</span><br><span class="line">    public void operation();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2 叶子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Leaf implements Component&#123;</span><br><span class="line">    </span><br><span class="line">    private String name;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    public Leaf(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void add(Component c) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void remove(Component c) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Component getChild(int i) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void operation() &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">         System.out.println(&quot;树叶&quot;+name+&quot;：被访问！&quot;); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3 树枝</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Composite implements Component &#123;</span><br><span class="line"></span><br><span class="line">    private ArrayList&lt;Component&gt; children = new ArrayList&lt;Component&gt;();</span><br><span class="line"></span><br><span class="line">    public void add(Component c) &#123;</span><br><span class="line">        children.add(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void remove(Component c) &#123;</span><br><span class="line">        children.remove(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Component getChild(int i) &#123;</span><br><span class="line">        return children.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void operation() &#123;</span><br><span class="line">        for (Object obj : children) &#123;</span><br><span class="line">            ((Component) obj).operation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="-7"><a class="markdownIt-Anchor" href="#-7">#</a> </h3>
<h2 id="11-享元模式"><a class="markdownIt-Anchor" href="#11-享元模式">#</a> 11 享元模式</h2>
<p>** 定义：** 通过共享的方式高效的支持大量细粒度的对象。</p>
<p>** 主要解决：** 在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。</p>
<p><strong>何时使用：</strong> 1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 5、系统不依赖于这些对象身份，这些对象是不可分辨的。</p>
<p>** 如何解决：** 用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。</p>
<p>** 关键代码：** 用 HashMap 存储这些对象。</p>
<p><strong>应用实例：</strong> 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。</p>
<p>** 优点：** 大大减少对象的创建，降低系统的内存，使效率提高。</p>
<p>** 缺点：** 提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。</p>
<p><span style="color:#f33b45;">简单来说，我们抽取出一个对象的外部状态（不能共享）和内部状态（可以共享）。然后根据外部状态的决定是否创建内部状态对象。内部状态对象是通过哈希表保存的，当外部状态相同的时候，不再重复的创建内部状态对象，从而减少要创建对象的数量。</span></p>
<h3 id="111-享元模式的结构图和代码示例"><a class="markdownIt-Anchor" href="#111-享元模式的结构图和代码示例">#</a> 11.1 享元模式的结构图和代码示例</h3>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610202655697.png" class="has" width="563" height="320" />
<p>1、Flyweight (享元抽象类)：一般是接口或者抽象类，定义了享元类的公共方法。这些方法可以分享内部状态的数据，也可以调用这些方法修改外部状态。</p>
<p>2、ConcreteFlyweight (具体享元类)：具体享元类实现了抽象享元类的方法，为享元对象开辟了内存空间来保存享元对象的内部数据，同时可以通过和单例模式结合只创建一个享元对象。</p>
<p>3、FlyweightFactory (享元工厂类)：享元工厂类创建并且管理享元类，享元工厂类针对享元类来进行编程，通过提供一个享元池来进行享元对象的管理。一般享元池设计成<strong>键值对</strong>，或者其他的存储结构来存储。当客户端进行享元对象的请求时，如果享元池中有对应的享元对象则直接返回对应的对象，否则工厂类创建对应的享元对象并保存到享元池。</p>
<p>举例（JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面）。类图如下：</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610202655744.png" class="has" width="310" height="187" />
<p>（1）创建享元对象接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface IFlyweight &#123;</span><br><span class="line">    void print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）创建具体享元对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Flyweight implements IFlyweight &#123;</span><br><span class="line">    private String id;</span><br><span class="line">    public Flyweight(String id)&#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void print() &#123;</span><br><span class="line">        System.out.println(&quot;Flyweight.id = &quot; + getId() + &quot; ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public String getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）创建工厂，这里要特别注意，为了避免享元对象被重复创建，我们使用 HashMap 中的 key 值保证其唯一。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class FlyweightFactory &#123;</span><br><span class="line">    private Map&lt;String, IFlyweight&gt; flyweightMap = new HashMap();</span><br><span class="line">    public IFlyweight getFlyweight(String str)&#123;</span><br><span class="line">        IFlyweight flyweight = flyweightMap.get(str);</span><br><span class="line">        if(flyweight == null)&#123;</span><br><span class="line">            flyweight = new Flyweight(str);</span><br><span class="line">            flyweightMap.put(str, flyweight);</span><br><span class="line">        &#125;</span><br><span class="line">        return  flyweight;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getFlyweightMapSize()&#123;</span><br><span class="line">        return flyweightMap.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（4）测试，我们创建三个字符串，但是只会产生两个享元对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class MainTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        FlyweightFactory flyweightFactory = new FlyweightFactory();</span><br><span class="line">        IFlyweight flyweight1 = flyweightFactory.getFlyweight(&quot;A&quot;);</span><br><span class="line">        IFlyweight flyweight2 = flyweightFactory.getFlyweight(&quot;B&quot;);</span><br><span class="line">        IFlyweight flyweight3 = flyweightFactory.getFlyweight(&quot;A&quot;);</span><br><span class="line">        flyweight1.print();</span><br><span class="line">        flyweight2.print();</span><br><span class="line">        flyweight3.print();</span><br><span class="line">        System.out.println(flyweightFactory.getFlyweightMapSize());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610203118380.png" class="has" width="466" height="100" />
<h2 id="-8"><a class="markdownIt-Anchor" href="#-8">#</a> </h2>
<h1 id="c-关系模式11种"><a class="markdownIt-Anchor" href="#c-关系模式11种">#</a> <strong>C、关系模式（11 种）</strong></h1>
<p>先来张图，看看这 11 中模式的关系：</p>
<p>第一类：通过父类与子类的关系进行实现。</p>
<p>第二类：两个类之间。</p>
<p>第三类：类的状态。</p>
<p>第四类：通过中间类</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610215352532.png" class="has" width="675" height="323" />
<h2 id="12-策略模式"><a class="markdownIt-Anchor" href="#12-策略模式">#</a> 12 策略模式</h2>
<p><strong>定义：</strong> 策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。</p>
<p>** 意图：** 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。</p>
<p>** 主要解决：** 在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。</p>
<p>** 何时使用：** 一个系统有许多许多类，而区分它们的只是他们直接的行为。</p>
<p>** 如何解决：** 将这些算法封装成一个一个的类，任意地替换。</p>
<p>** 关键代码：** 实现同一个接口。</p>
<p><strong>优点：</strong> 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。</p>
<p><strong>缺点：</strong> 1、策略类会增多。 2、所有策略类都需要对外暴露。</p>
<h3 id="121-策略模式结构和示例代码"><a class="markdownIt-Anchor" href="#121-策略模式结构和示例代码">#</a> 12.1 策略模式结构和示例代码</h3>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610215352527.png" class="has" width="725" height="311" />
<p><strong>抽象策略角色:</strong> 这个是一个抽象的角色，通常情况下使用接口或者抽象类去实现。对比来说，就是我们的 Comparator 接口。</p>
<p><strong>具体策略角色:</strong> 包装了具体的算法和行为。对比来说，就是实现了 Comparator 接口的实现一组实现类。</p>
<p><strong>环境角色:</strong> 内部会持有一个抽象角色的引用，给客户端调用。</p>
<p>举例如下（ 实现一个加减的功能），类图如下：</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190610215352523.png" class="has" width="335" height="261" />
<p>1、定义抽象策略角色</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Strategy &#123;</span><br><span class="line"></span><br><span class="line">    public int calc(int num1,int num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、定义具体策略角色</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class AddStrategy implements Strategy &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int calc(int num1, int num2) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        return num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class SubstractStrategy implements Strategy &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int calc(int num1, int num2) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        return num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、环境角色</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Environment &#123;</span><br><span class="line">    private Strategy strategy;</span><br><span class="line"></span><br><span class="line">    public Environment(Strategy strategy) &#123;</span><br><span class="line">        this.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int calculate(int a, int b) &#123;</span><br><span class="line">        return strategy.calc(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class MainTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        </span><br><span class="line">        Environment environment=new Environment(new AddStrategy());</span><br><span class="line">        int result=environment.calculate(20, 5);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        </span><br><span class="line">        Environment environment1=new Environment(new SubstractStrategy());</span><br><span class="line">        int result1=environment1.calculate(20, 5);</span><br><span class="line">        System.out.println(result1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="-9"><a class="markdownIt-Anchor" href="#-9">#</a> </h3>
<h2 id="13-模板模式"><a class="markdownIt-Anchor" href="#13-模板模式">#</a> 13 模板模式</h2>
<p>** 定义：** 定义一个操作中算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变算法的结构即可重定义该算法的某些特定步骤。</p>
<p>通俗点的理解就是 ：完成一件事情，有固定的数个步骤，但是每个步骤根据对象的不同，而实现细节不同；就可以在父类中定义一个完成该事情的总方法，按照完成事件需要的步骤去调用其每个步骤的实现方法。每个步骤的具体实现，由子类完成。</p>
<h3 id="131-模式结构和代码示例"><a class="markdownIt-Anchor" href="#131-模式结构和代码示例">#</a> 13.1 模式结构和代码示例</h3>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612192139396.png" class="has" width="713" height="582" />
<p>抽象父类（AbstractClass）：实现了模板方法，定义了算法的骨架。</p>
<p>具体类（ConcreteClass)：实现抽象类中的抽象方法，即不同的对象的具体实现细节。</p>
<p>举例（ 我们做菜可以分为三个步骤 （1）备料 （2）具体做菜 （3）盛菜端给客人享用，这三部就是算法的骨架 ；然而做不同菜需要的料，做的方法，以及如何盛装给客人享用都是不同的这个就是不同的实现细节。）。类图如下：</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612192139362.png" class="has" width="425" height="250" />
<p>a. 先来写一个抽象的做菜父类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Dish &#123;    </span><br><span class="line">    /**</span><br><span class="line">     * 具体的整个过程</span><br><span class="line">     */</span><br><span class="line">    protected void dodish()&#123;</span><br><span class="line">        this.preparation();</span><br><span class="line">        this.doing();</span><br><span class="line">        this.carriedDishes();</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 备料</span><br><span class="line">     */</span><br><span class="line">    public abstract void preparation();</span><br><span class="line">    /**</span><br><span class="line">     * 做菜</span><br><span class="line">     */</span><br><span class="line">    public abstract void doing();</span><br><span class="line">    /**</span><br><span class="line">     * 上菜</span><br><span class="line">     */</span><br><span class="line">    public abstract void carriedDishes ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>b. 下来做两个番茄炒蛋（EggsWithTomato）和红烧肉（Bouilli）实现父类中的抽象方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class EggsWithTomato extends Dish &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void preparation() &#123;</span><br><span class="line">        System.out.println(&quot;洗并切西红柿，打鸡蛋。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doing() &#123;</span><br><span class="line">        System.out.println(&quot;鸡蛋倒入锅里，然后倒入西红柿一起炒。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void carriedDishes() &#123;</span><br><span class="line">        System.out.println(&quot;将炒好的西红寺鸡蛋装入碟子里，端给客人吃。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class Bouilli extends Dish&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void preparation() &#123;</span><br><span class="line">        System.out.println(&quot;切猪肉和土豆。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doing() &#123;</span><br><span class="line">        System.out.println(&quot;将切好的猪肉倒入锅中炒一会然后倒入土豆连炒带炖。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void carriedDishes() &#123;</span><br><span class="line">        System.out.println(&quot;将做好的红烧肉盛进碗里端给客人吃。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>c. 在测试类中我们来做菜：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MainTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Dish eggsWithTomato = new EggsWithTomato();</span><br><span class="line">        eggsWithTomato.dodish();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;-----------------------------&quot;);</span><br><span class="line"></span><br><span class="line">        Dish bouilli = new Bouilli();</span><br><span class="line">        bouilli.dodish();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="132-模板模式的优点和缺点"><a class="markdownIt-Anchor" href="#132-模板模式的优点和缺点">#</a> 13.2  模板模式的优点和缺点</h3>
<p>优点：</p>
<p>（1）具体细节步骤实现定义在子类中，子类定义详细处理算法是不会改变算法整体结构。</p>
<p>（2）代码复用的基本技术，在数据库设计中尤为重要。</p>
<p>（3）存在一种反向的控制结构，通过一个父类调用其子类的操作，通过子类对父类进行扩展增加新的行为，符合 “开闭原则”。</p>
<h3 id="缺点-2"><a class="markdownIt-Anchor" href="#缺点-2">#</a> 缺点：</h3>
<pre><code>每个不同的实现都需要定义一个子类，会导致类的个数增加，系统更加庞大。
</code></pre>
<h3 id="-10"><a class="markdownIt-Anchor" href="#-10">#</a> </h3>
<h2 id="14-观察者模式"><a class="markdownIt-Anchor" href="#14-观察者模式">#</a> 14 观察者模式</h2>
<p><strong>定义：</strong> 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
<p>** 主要解决：** 一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。</p>
<p>** 何时使用：** 一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。</p>
<p>** 如何解决：** 使用面向对象技术，可以将这种依赖关系弱化。</p>
<p>** 关键代码：** 在抽象类里有一个 ArrayList 存放观察者们。</p>
<p><strong>优点：</strong> 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。</p>
<p><strong>缺点：</strong> 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</p>
<h3 id="141-模式结构图和代码示例"><a class="markdownIt-Anchor" href="#141-模式结构图和代码示例">#</a> 14.1 模式结构图和代码示例</h3>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190611172644555.png" class="has" width="505" height="416" />
<ul>
<li>
<p><strong>抽象被观察者角色</strong>：也就是一个抽象主题，它把所有对观察者对象的引用保存在一个集合中，每个主题都可以有任意数量的观察者。抽象主题提供一个接口，可以增加和删除观察者角色。一般用一个抽象类和接口来实现。</p>
</li>
<li>
<p><strong>抽象观察者角色</strong>：为所有的具体观察者定义一个接口，在得到主题通知时更新自己。</p>
</li>
<li>
<p><strong>具体被观察者角色</strong>：也就是一个具体的主题，在集体主题的内部状态改变时，所有登记过的观察者发出通知。</p>
</li>
<li>
<p><strong>具体观察者角色</strong>：实现抽象观察者角色所需要的更新接口，一边使本身的状态与制图的状态相协调。</p>
</li>
</ul>
<p>举例（有一个微信公众号服务，不定时发布一些消息，关注公众号就可以收到推送消息，取消关注就收不到推送消息。）类图如下：</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190611172644540.png" class="has" width="545" height="359" />
<p>1、定义一个抽象被观察者接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Subject &#123;</span><br><span class="line">    </span><br><span class="line">      public void registerObserver(Observer o);</span><br><span class="line">      public void removeObserver(Observer o);</span><br><span class="line">      public void notifyObserver();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、定义一个抽象观察者接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Observer &#123;</span><br><span class="line">    </span><br><span class="line">    public void update(String message);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、定义被观察者，实现了 Observerable 接口，对 Observerable 接口的三个方法进行了具体实现，同时有一个 List 集合，用以保存注册的观察者，等需要通知观察者时，遍历该集合即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class WechatServer implements Subject &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;Observer&gt; list;</span><br><span class="line">    private String message;</span><br><span class="line"></span><br><span class="line">    public WechatServer() &#123;</span><br><span class="line">        list = new ArrayList&lt;Observer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void registerObserver(Observer o) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        list.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void removeObserver(Observer o) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        if (!list.isEmpty()) &#123;</span><br><span class="line">            list.remove(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void notifyObserver() &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        for (Observer o : list) &#123;</span><br><span class="line">            o.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setInfomation(String s) &#123;</span><br><span class="line">        this.message = s;</span><br><span class="line">        System.out.println(&quot;微信服务更新消息： &quot; + s);</span><br><span class="line">        // 消息更新，通知所有观察者</span><br><span class="line">        notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、定义具体观察者，微信公众号的具体观察者为用户 User</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class User implements Observer &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private String message;</span><br><span class="line"></span><br><span class="line">    public User(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void update(String message) &#123;</span><br><span class="line">        this.message = message;</span><br><span class="line">        read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void read() &#123;</span><br><span class="line">        System.out.println(name + &quot; 收到推送消息： &quot; + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、编写一个测试类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class MainTest &#123;</span><br><span class="line">    </span><br><span class="line">     public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">            WechatServer server = new WechatServer();</span><br><span class="line">            </span><br><span class="line">            Observer userZhang = new User(&quot;ZhangSan&quot;);</span><br><span class="line">            Observer userLi = new User(&quot;LiSi&quot;);</span><br><span class="line">            Observer userWang = new User(&quot;WangWu&quot;);</span><br><span class="line">            </span><br><span class="line">            server.registerObserver(userZhang);</span><br><span class="line">            server.registerObserver(userLi);</span><br><span class="line">            server.registerObserver(userWang);</span><br><span class="line">            server.setInfomation(&quot;PHP是世界上最好用的语言！&quot;);</span><br><span class="line">            </span><br><span class="line">            System.out.println(&quot;----------------------------------------------&quot;);</span><br><span class="line">            server.removeObserver(userZhang);</span><br><span class="line">            server.setInfomation(&quot;JAVA是世界上最好用的语言！&quot;);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="15-迭代器模式"><a class="markdownIt-Anchor" href="#15-迭代器模式">#</a> 15 迭代器模式</h2>
<p>** 定义：** 提供一种方法顺序访问一个聚合对象中各个元素，而又无须暴露该对象的内部表示。</p>
<p><strong>简单来说，不同种类的对象可能需要不同的遍历方式，我们对每一种类型的对象配一个迭代器，最后多个迭代器合成一个。</strong></p>
<p>** 主要解决：** 不同的方式来遍历整个整合对象。</p>
<p>** 何时使用：** 遍历一个聚合对象。</p>
<p>** 如何解决：** 把在元素之间游走的责任交给迭代器，而不是聚合对象。</p>
<p>** 关键代码：** 定义接口：hasNext, next。</p>
<p>** 应用实例：**JAVA 中的 iterator。</p>
<p><strong>优点：</strong> 1、它支持以不同的方式遍历一个聚合对象。 2、迭代器简化了聚合类。 3、在同一个聚合上可以有多个遍历。 4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。</p>
<p>** 缺点：** 由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</p>
<h3 id="151-模式结构和代码示例"><a class="markdownIt-Anchor" href="#151-模式结构和代码示例">#</a> 15.1 模式结构和代码示例</h3>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190611195714196.png" class="has" width="726" height="380" />
<p>(1) 迭代器角色（Iterator）: 定义遍历元素所需要的方法，一般来说会有这么三个方法：取得下一个元素的方法 next ()，判断是否遍历结束的方法 hasNext ()），移出当前对象的方法 remove (),</p>
<p>(2) 具体迭代器角色（Concrete Iterator）：实现迭代器接口中定义的方法，完成集合的迭代。</p>
<p>(3) 容器角色 (Aggregate):  一般是一个接口，提供一个 iterator () 方法，例如 java 中的 Collection 接口，List 接口，Set 接口等</p>
<p>(4) 具体容器角色（ConcreteAggregate）：就是抽象容器的具体实现类，比如 List 接口的有序列表实现 ArrayList，List 接口的链表实现 LinkList，Set 接口的哈希列表的实现 HashSet 等。</p>
<p>举例（咖啡厅和中餐厅合并，他们两个餐厅的菜单一个是数组保存的，一个是 ArrayList 保存的。遍历方式不一样，使用迭代器聚合访问，只需要一种方式）</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190611195714224.png" class="has" width="494" height="360" />
<p>1 迭代器接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface Iterator &#123;</span><br><span class="line">    </span><br><span class="line">    public boolean hasNext();</span><br><span class="line">    public Object next();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2 咖啡店菜单和咖啡店菜单遍历器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class CakeHouseMenu &#123;</span><br><span class="line">    private ArrayList&lt;MenuItem&gt; menuItems;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    public CakeHouseMenu() &#123;</span><br><span class="line">        menuItems = new ArrayList&lt;MenuItem&gt;();</span><br><span class="line">        </span><br><span class="line">        addItem(&quot;KFC Cake Breakfast&quot;,&quot;boiled eggs&amp;toast&amp;cabbage&quot;,true,3.99f);</span><br><span class="line">        addItem(&quot;MDL Cake Breakfast&quot;,&quot;fried eggs&amp;toast&quot;,false,3.59f);</span><br><span class="line">        addItem(&quot;Stawberry Cake&quot;,&quot;fresh stawberry&quot;,true,3.29f);</span><br><span class="line">        addItem(&quot;Regular Cake Breakfast&quot;,&quot;toast&amp;sausage&quot;,true,2.59f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void addItem(String name, String description, boolean vegetable,</span><br><span class="line">            float price) &#123;</span><br><span class="line">        MenuItem menuItem = new MenuItem(name, description, vegetable, price);</span><br><span class="line">        menuItems.add(menuItem);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public Iterator getIterator()</span><br><span class="line">    &#123;</span><br><span class="line">        return new CakeHouseIterator() ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class CakeHouseIterator implements  Iterator</span><br><span class="line">     &#123;      </span><br><span class="line">        private int position=0;</span><br><span class="line">        public CakeHouseIterator()</span><br><span class="line">        &#123;</span><br><span class="line">              position=0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">            @Override</span><br><span class="line">            public boolean hasNext() &#123;</span><br><span class="line">            // TODO Auto-generated method stub</span><br><span class="line">            if(position&lt;menuItems.size())</span><br><span class="line">            &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Object next() &#123;</span><br><span class="line">            // TODO Auto-generated method stub</span><br><span class="line">            MenuItem menuItem =menuItems.get(position);</span><br><span class="line">            position++;</span><br><span class="line">            return menuItem;</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">    //鍏朵粬鍔熻兘浠ｇ爜</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3 中餐厅菜单和中餐厅菜单遍历器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class DinerMenu &#123;</span><br><span class="line">    private final static int Max_Items = 5;</span><br><span class="line">    private int numberOfItems = 0;</span><br><span class="line">    private MenuItem[] menuItems;</span><br><span class="line"></span><br><span class="line">    public DinerMenu() &#123;</span><br><span class="line">        menuItems = new MenuItem[Max_Items];</span><br><span class="line">        addItem(&quot;vegetable Blt&quot;, &quot;bacon&amp;lettuce&amp;tomato&amp;cabbage&quot;, true, 3.58f);</span><br><span class="line">        addItem(&quot;Blt&quot;, &quot;bacon&amp;lettuce&amp;tomato&quot;, false, 3.00f);</span><br><span class="line">        addItem(&quot;bean soup&quot;, &quot;bean&amp;potato salad&quot;, true, 3.28f);</span><br><span class="line">        addItem(&quot;hotdog&quot;, &quot;onions&amp;cheese&amp;bread&quot;, false, 3.05f);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void addItem(String name, String description, boolean vegetable,</span><br><span class="line">            float price) &#123;</span><br><span class="line">        MenuItem menuItem = new MenuItem(name, description, vegetable, price);</span><br><span class="line">        if (numberOfItems &gt;= Max_Items) &#123;</span><br><span class="line">            System.err.println(&quot;sorry,menu is full!can not add another item&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            menuItems[numberOfItems] = menuItem;</span><br><span class="line">            numberOfItems++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Iterator getIterator() &#123;</span><br><span class="line">        return new DinerIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class DinerIterator implements Iterator &#123;</span><br><span class="line">        private int position;</span><br><span class="line"></span><br><span class="line">        public DinerIterator() &#123;</span><br><span class="line">            position = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean hasNext() &#123;</span><br><span class="line">            // TODO Auto-generated method stub</span><br><span class="line">            if (position &lt; numberOfItems) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Object next() &#123;</span><br><span class="line">            // TODO Auto-generated method stub</span><br><span class="line">            MenuItem menuItem = menuItems[position];</span><br><span class="line">            position++;</span><br><span class="line">            return menuItem;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4 女服务员</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class Waitress &#123;</span><br><span class="line">    private ArrayList&lt;Iterator&gt; iterators = new ArrayList&lt;Iterator&gt;();</span><br><span class="line"></span><br><span class="line">    public Waitress() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addIterator(Iterator iterator) &#123;</span><br><span class="line">        iterators.add(iterator);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printMenu() &#123;</span><br><span class="line">        Iterator iterator;</span><br><span class="line">        MenuItem menuItem;</span><br><span class="line">        for (int i = 0, len = iterators.size(); i &lt; len; i++) &#123;</span><br><span class="line">            iterator = iterators.get(i);</span><br><span class="line"></span><br><span class="line">            while (iterator.hasNext()) &#123;</span><br><span class="line">                menuItem = (MenuItem) iterator.next();</span><br><span class="line">                System.out</span><br><span class="line">                        .println(menuItem.getName() + &quot;***&quot; + menuItem.getPrice() + &quot;***&quot; + menuItem.getDescription());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printBreakfastMenu() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printLunchMenu() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printVegetableMenu() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="16-责任链模式"><a class="markdownIt-Anchor" href="#16-责任链模式">#</a> 16 责任链模式</h2>
<p>** 定义：** 如果有多个对象有机会处理请求，责任链可使请求的发送者和接受者解耦，请求沿着责任链传递，直到有一个对象处理了它为止。</p>
<p>** 主要解决：** 职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p>
<p>** 何时使用：** 在处理消息的时候以过滤很多道。</p>
<p>** 如何解决：** 拦截的类都实现统一接口。</p>
<p>** 关键代码：**Handler 里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。</p>
<h3 id="161-模式的结构和代码示例"><a class="markdownIt-Anchor" href="#161-模式的结构和代码示例">#</a> 16.1 模式的结构和代码示例</h3>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/2019061120335378.png" class="has" width="468" height="272" />
<ol>
<li>
<p>抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</p>
</li>
<li>
<p>具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</p>
</li>
<li>
<p>客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</p>
</li>
</ol>
<p>举例（购买请求决策，价格不同要由不同的级别决定：组长、部长、副部、总裁）。类图如下：</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190611203353118.png" class="has" width="1041" height="363" />
<p>1 决策者抽象类，包含对请求处理的函数，同时还包含指定下一个决策者的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Approver &#123;</span><br><span class="line">     Approver successor;</span><br><span class="line">     String Name;</span><br><span class="line">    public Approver(String Name)</span><br><span class="line">    &#123;</span><br><span class="line">        this.Name=Name;</span><br><span class="line">    &#125;</span><br><span class="line">    public abstract void ProcessRequest( PurchaseRequest request);</span><br><span class="line">    public void SetSuccessor(Approver successor) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        this.successor=successor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2 客户端以及请求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class PurchaseRequest &#123;</span><br><span class="line">    private int Type = 0;</span><br><span class="line">    private int Number = 0;</span><br><span class="line">    private float Price = 0;</span><br><span class="line">    private int ID = 0;</span><br><span class="line"></span><br><span class="line">    public PurchaseRequest(int Type, int Number, float Price) &#123;</span><br><span class="line">        this.Type = Type;</span><br><span class="line">        this.Number = Number;</span><br><span class="line">        this.Price = Price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int GetType() &#123;</span><br><span class="line">        return Type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public float GetSum() &#123;</span><br><span class="line">        return Number * Price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int GetID() &#123;</span><br><span class="line">        return (int) (Math.random() * 1000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">    public Client() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PurchaseRequest sendRequst(int Type, int Number, float Price) &#123;</span><br><span class="line">        return new PurchaseRequest(Type, Number, Price);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3 组长、部长。。。继承决策者抽象类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class GroupApprover extends Approver &#123;</span><br><span class="line"></span><br><span class="line">    public GroupApprover(String Name) &#123;</span><br><span class="line">        super(Name + &quot; GroupLeader&quot;);</span><br><span class="line">        // TODO Auto-generated constructor stub</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void ProcessRequest(PurchaseRequest request) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">        if (request.GetSum() &lt; 5000) &#123;</span><br><span class="line">            System.out.println(&quot;**This request &quot; + request.GetID() + &quot; will be handled by &quot; + this.Name + &quot; **&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            successor.ProcessRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class DepartmentApprover extends Approver &#123;</span><br><span class="line"></span><br><span class="line">    public DepartmentApprover(String Name) &#123;</span><br><span class="line">        super(Name + &quot; DepartmentLeader&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void ProcessRequest(PurchaseRequest request) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">        if ((5000 &lt;= request.GetSum()) &amp;&amp; (request.GetSum() &lt; 10000)) &#123;</span><br><span class="line">            System.out.println(&quot;**This request &quot; + request.GetID()</span><br><span class="line">                    + &quot; will be handled by &quot; + this.Name + &quot; **&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            successor.ProcessRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4 测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class MainTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Client mClient = new Client();</span><br><span class="line">        Approver GroupLeader = new GroupApprover(&quot;Tom&quot;);</span><br><span class="line">        Approver DepartmentLeader = new DepartmentApprover(&quot;Jerry&quot;);</span><br><span class="line">        Approver VicePresident = new VicePresidentApprover(&quot;Kate&quot;);</span><br><span class="line">        Approver President = new PresidentApprover(&quot;Bush&quot;);</span><br><span class="line"></span><br><span class="line">        GroupLeader.SetSuccessor(VicePresident);</span><br><span class="line">        DepartmentLeader.SetSuccessor(President);</span><br><span class="line">        VicePresident.SetSuccessor(DepartmentLeader);</span><br><span class="line">        President.SetSuccessor(GroupLeader);</span><br><span class="line"></span><br><span class="line">        GroupLeader.ProcessRequest(mClient.sendRequst(1, 10000, 40));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="-11"><a class="markdownIt-Anchor" href="#-11">#</a> </h2>
<h2 id="17-命令模式"><a class="markdownIt-Anchor" href="#17-命令模式">#</a> 17 命令模式</h2>
<p>** 定义：** 将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。</p>
<p>** 意图：** 将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。</p>
<p>** 主要解决：** 在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。</p>
<p>** 何时使用：** 在某些场合，比如要对行为进行 &quot;记录、撤销 / 重做、事务&quot; 等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将 &quot;行为请求者&quot; 与 &quot;行为实现者&quot; 解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。</p>
<p>** 如何解决：** 通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。</p>
<h3 id="171模式结构和代码示例"><a class="markdownIt-Anchor" href="#171模式结构和代码示例">#</a> 17.1 模式结构和代码示例</h3>
<h2 id="img-srchttpsbrath4oss-cn-shenzhenaliyuncscompicgo20190612194014850gif-classhas-width550-height612"><a class="markdownIt-Anchor" href="#img-srchttpsbrath4oss-cn-shenzhenaliyuncscompicgo20190612194014850gif-classhas-width550-height612">#</a> <img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612194014850.gif" class="has" width="550" height="612" /></h2>
<ol>
<li>抽象命令类（Command）角色：声明执行命令的接口，拥有执行命令的抽象方法 execute ()。</li>
<li>具体命令角色（Concrete    Command）角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。</li>
<li>实现者 / 接收者（Receiver）角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者。</li>
<li>调用者 / 请求者（Invoker）角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。</li>
</ol>
<p>代码举例（开灯和关灯），类图如下：</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612194307560.png" class="has" width="420" height="277" />
<p>1 命令抽象类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface Command &#123;</span><br><span class="line">    </span><br><span class="line">    public void excute();</span><br><span class="line">    public void undo();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2 具体命令对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class TurnOffLight implements Command &#123;</span><br><span class="line"></span><br><span class="line">    private Light light;</span><br><span class="line"></span><br><span class="line">    public TurnOffLight(Light light) &#123;</span><br><span class="line">        this.light = light;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void excute() &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        light.Off();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void undo() &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        light.On();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3 实现者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Light &#123;</span><br><span class="line"></span><br><span class="line">    String loc = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    public Light(String loc) &#123;</span><br><span class="line">        this.loc = loc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void On() &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(loc + &quot; On&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Off() &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(loc + &quot; Off&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4 请求者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Contral&#123;</span><br><span class="line"></span><br><span class="line">    public void CommandExcute(Command command) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        command.excute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void CommandUndo(Command command) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        command.undo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="-12"><a class="markdownIt-Anchor" href="#-12">#</a> </h2>
<h2 id="18-状态模式"><a class="markdownIt-Anchor" href="#18-状态模式">#</a> 18 状态模式</h2>
<p><strong>定义</strong>： 在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。</p>
<p>简单理解，一个拥有状态的 context 对象，在不同的状态下，其行为会发生改变。</p>
<p>** 意图：** 允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。</p>
<p>** 主要解决：** 对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。</p>
<p>** 何时使用：** 代码中包含大量与对象状态有关的条件语句。</p>
<p>** 如何解决：** 将各种具体的状态类抽象出来。</p>
<p>** 关键代码：** 通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if…else 等条件选择语句。</p>
<p><strong>优点：</strong> 1、封装了转换规则。 2、枚举可能的状态，在枚举状态之前需要确定状态种类。 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</p>
<p><strong>缺点：</strong> 1、状态模式的使用必然会增加系统类和对象的个数。 2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 3、状态模式对 &quot;开闭原则&quot; 的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。</p>
<h3 id="181-模式结构和代码示例"><a class="markdownIt-Anchor" href="#181-模式结构和代码示例">#</a> 18.1 模式结构和代码示例</h3>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612003537747.png" class="has" width="585" height="357" />
<ul>
<li>
<p><strong>State 抽象状态角色</strong></p>
<p>接口或抽象类，负责对象状态定义，并且封装环境角色以实现状态切换。</p>
</li>
<li>
<p><strong>ConcreteState 具体状态角色</strong></p>
<p>具体状态主要有两个职责：一是处理本状态下的事情，二是从本状态如何过渡到其他状态。</p>
</li>
<li>
<p><strong>Context 环境角色</strong></p>
<p>定义客户端需要的接口，并且负责具体状态的切换。</p>
</li>
</ul>
<p>举例（人物在地点 A 向地点 B 移动，在地点 B 向地点 A 移动）。类图如下：</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612003537942.png" class="has" width="473" height="324" />
<p>1 state 接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface State &#123;</span><br><span class="line">    public void stop();</span><br><span class="line">    public void move();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2 状态实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class PlaceA implements State &#123;</span><br><span class="line"></span><br><span class="line">    private Player context;</span><br><span class="line"></span><br><span class="line">    public PlaceA(Player context) &#123;</span><br><span class="line">        this.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void move() &#123;</span><br><span class="line">        System.out.println(&quot;处于地点A,开始向B移动&quot;);</span><br><span class="line">        System.out.println(&quot;--------&quot;);</span><br><span class="line">        context.setDirection(&quot;AB&quot;);</span><br><span class="line">        context.setState(context.onMove);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void stop() &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        System.out.println(&quot;正处在地点A，不用停止移动&quot;);</span><br><span class="line">        System.out.println(&quot;--------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3 context (player) 拥有状态的对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class Player &#123;</span><br><span class="line"></span><br><span class="line">    State placeA;</span><br><span class="line">    State placeB;</span><br><span class="line">    State onMove;</span><br><span class="line">    private State state;</span><br><span class="line">    private String direction;</span><br><span class="line"></span><br><span class="line">    public Player() &#123;</span><br><span class="line">        direction = &quot;AB&quot;;</span><br><span class="line">        placeA = new PlaceA(this);</span><br><span class="line">        placeB = new PlaceB(this);</span><br><span class="line">        onMove = new OnMove(this);</span><br><span class="line">        this.state = placeA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void move() &#123;</span><br><span class="line">        System.out.println(&quot;指令:开始移动&quot;);</span><br><span class="line">        state.move();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void stop() &#123;</span><br><span class="line">        System.out.println(&quot;指令:停止移动&quot;);</span><br><span class="line">        state.stop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public State getState() &#123;</span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setState(State state) &#123;</span><br><span class="line">        this.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDirection(String direction) &#123;</span><br><span class="line">        this.direction = direction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDirection() &#123;</span><br><span class="line">        return direction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="-13"><a class="markdownIt-Anchor" href="#-13">#</a> </h3>
<h2 id="19-备忘录模式"><a class="markdownIt-Anchor" href="#19-备忘录模式">#</a> 19 备忘录模式</h2>
<p>定义： 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式<span style="color:#b22222;">又叫快照模式。</span></p>
<p>备忘录模式是一种对象行为型模式，其主要优点如下。</p>
<ul>
<li>
<p>提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。</p>
</li>
<li>
<p>实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。</p>
</li>
<li>
<p>简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。</p>
</li>
</ul>
<p>其主要缺点是：资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。</p>
<h3 id="191-模式结构图和代码示例"><a class="markdownIt-Anchor" href="#191-模式结构图和代码示例">#</a> 19.1 模式结构图和代码示例</h3>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612143829622.png" class="has" width="564" height="405" />
<ol>
<li>
<p>发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。</p>
</li>
<li>
<p>备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。</p>
</li>
<li>
<p>管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。</p>
</li>
</ol>
<p>举例（发起者通过备忘录存储信息和获取信息），类图如下：</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612143829817.png" class="has" width="401" height="198" />
<p>1 备忘录接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface MementoIF &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2 备忘录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Memento implements MementoIF&#123;</span><br><span class="line">    </span><br><span class="line">    private String state;</span><br><span class="line"></span><br><span class="line">    public Memento(String state) &#123;</span><br><span class="line">        this.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getState()&#123;</span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3 发起者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Originator &#123;</span><br><span class="line"></span><br><span class="line">    private String state;</span><br><span class="line"></span><br><span class="line">    public String getState() &#123;</span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setState(String state) &#123;</span><br><span class="line">        this.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Memento saveToMemento() &#123;</span><br><span class="line">        return new Memento(state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getStateFromMemento(MementoIF memento) &#123;</span><br><span class="line">        return ((Memento) memento).getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4 管理者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class CareTaker &#123;</span><br><span class="line">    </span><br><span class="line">    private List&lt;MementoIF&gt; mementoList = new ArrayList&lt;MementoIF&gt;();</span><br><span class="line"></span><br><span class="line">    public void add(MementoIF memento) &#123;</span><br><span class="line">        mementoList.add(memento);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MementoIF get(int index) &#123;</span><br><span class="line">        return mementoList.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="20-访问者模式"><a class="markdownIt-Anchor" href="#20-访问者模式">#</a> 20 访问者模式</h2>
<p>** 定义：** 将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离。</p>
<p>访问者（Visitor）模式是一种对象行为型模式，其主要优点如下。</p>
<ol>
<li>
<p>扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。</p>
</li>
<li>
<p>复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。</p>
</li>
<li>
<p>灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。</p>
</li>
<li>
<p>符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。</p>
</li>
</ol>
<p>访问者（Visitor）模式的主要缺点如下。</p>
<ol>
<li>
<p>增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了 “开闭原则”。</p>
</li>
<li>
<p>破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。</p>
</li>
<li>
<p>违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。</p>
</li>
</ol>
<h3 id="201-模式结构和代码示例"><a class="markdownIt-Anchor" href="#201-模式结构和代码示例">#</a> 20.1 模式结构和代码示例</h3>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612154308216.gif" class="has" width="500" height="443" />
<p>访问者模式包含以下主要角色。</p>
<ol>
<li>
<p>抽象访问者（Visitor）角色：定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作 visit () ，该操作中的参数类型标识了被访问的具体元素。</p>
</li>
<li>
<p>具体访问者（ConcreteVisitor）角色：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。</p>
</li>
<li>
<p>抽象元素（Element）角色：声明一个包含接受操作 accept () 的接口，被接受的访问者对象作为 accept () 方法的参数。</p>
</li>
<li>
<p>具体元素（ConcreteElement）角色：实现抽象元素角色提供的 accept () 操作，其方法体通常都是 visitor.visit (this) ，另外具体元素中可能还包含本身业务逻辑的相关操作。</p>
</li>
<li>
<p>对象结构（Object Structure）角色：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map 等聚合类实现。</p>
</li>
</ol>
<p>1 抽象访问者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Visitor &#123;</span><br><span class="line"></span><br><span class="line">    abstract public void Visit(Element element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2 具体访问者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class CompensationVisitor implements Visitor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void Visit(Element element) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        Employee employee = ((Employee) element);</span><br><span class="line"></span><br><span class="line">        System.out.println(</span><br><span class="line">                employee.getName() + &quot;&#x27;s Compensation is &quot; + (employee.getDegree() * employee.getVacationDays() * 10));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3 抽象元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Element &#123;</span><br><span class="line">    abstract public void Accept(Visitor visitor);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4 具体元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class CompensationVisitor implements Visitor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void Visit(Element element) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        Employee employee = ((Employee) element);</span><br><span class="line"></span><br><span class="line">        System.out.println(</span><br><span class="line">                employee.getName() + &quot;&#x27;s Compensation is &quot; + (employee.getDegree() * employee.getVacationDays() * 10));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5 对象结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class ObjectStructure &#123;</span><br><span class="line">    private HashMap&lt;String, Employee&gt; employees;</span><br><span class="line"></span><br><span class="line">    public ObjectStructure() &#123;</span><br><span class="line">        employees = new HashMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Attach(Employee employee) &#123;</span><br><span class="line">        employees.put(employee.getName(), employee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Detach(Employee employee) &#123;</span><br><span class="line">        employees.remove(employee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Employee getEmployee(String name) &#123;</span><br><span class="line">        return employees.get(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Accept(Visitor visitor) &#123;</span><br><span class="line">        for (Employee e : employees.values()) &#123;</span><br><span class="line">            e.Accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="-14"><a class="markdownIt-Anchor" href="#-14">#</a> </h3>
<h2 id="21-中介者模式"><a class="markdownIt-Anchor" href="#21-中介者模式">#</a> 21 中介者模式</h2>
<p>** 定义：** 定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。中介者模式又叫调停模式，它是迪米特法则的典型应用。</p>
<p>中介者模式是一种对象行为型模式，其主要优点如下。</p>
<ol>
<li>
<p>降低了对象之间的耦合性，使得对象易于独立地被复用。</p>
</li>
<li>
<p>将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展。</p>
</li>
</ol>
<p>其主要缺点是：当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。</p>
<h3 id="211-模式结构和代码示例"><a class="markdownIt-Anchor" href="#211-模式结构和代码示例">#</a> 21.1 模式结构和代码示例</h3>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612175348613.png" class="has" width="803" height="457" />
<ol>
<li>
<p>抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。</p>
</li>
<li>
<p>具体中介者（ConcreteMediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。</p>
</li>
<li>
<p>抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。</p>
</li>
<li>
<p>具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。</p>
</li>
</ol>
<p>举例（通过中介卖方），类图如下：</p>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/20190612175348612.png" class="has" width="577" height="290" />
<p>1 抽象中介者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Mediator &#123;</span><br><span class="line"></span><br><span class="line">    void register(Colleague colleague); // 客户注册</span><br><span class="line"></span><br><span class="line">    void relay(String from, String to,String ad); // 转发</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2 具体中介者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteMediator implements Mediator &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;Colleague&gt; colleagues = new ArrayList&lt;Colleague&gt;();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void register(Colleague colleague) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        if (!colleagues.contains(colleague)) &#123;</span><br><span class="line">            colleagues.add(colleague);</span><br><span class="line">            colleague.setMedium(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void relay(String from, String to, String ad) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        for (Colleague cl : colleagues) &#123;</span><br><span class="line"></span><br><span class="line">            String name = cl.getName();</span><br><span class="line">            if (name.equals(to)) &#123;</span><br><span class="line">                cl.receive(from, ad);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3 抽象同事类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Colleague &#123;</span><br><span class="line"></span><br><span class="line">    protected Mediator mediator;</span><br><span class="line">    protected String name;</span><br><span class="line"></span><br><span class="line">    public Colleague(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMedium(Mediator mediator) &#123;</span><br><span class="line"></span><br><span class="line">        this.mediator = mediator;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void Send(String to, String ad);</span><br><span class="line"></span><br><span class="line">    public abstract void receive(String from, String ad);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4 具体同事类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Buyer extends Colleague &#123;</span><br><span class="line"></span><br><span class="line">    public Buyer(String name) &#123;</span><br><span class="line"></span><br><span class="line">        super(name);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void Send(String to, String ad) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        mediator.relay(name, to, ad);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void receive(String from, String ad) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        System.out.println(name + &quot;接收到来自&quot; + from + &quot;的消息:&quot; + ad);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关于我"><a class="markdownIt-Anchor" href="#关于我">#</a> 关于我</h2>
<p>Brath 是一个热爱技术的 Java 程序猿，公众号「InterviewCoder」定期分享有趣有料的精品原创文章！</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png" alt="InterviewCoder"></p>
<p>非常感谢各位人才能看到这里，原创不易，文章如果有帮助可以关注、点赞、分享或评论，这都是对我的莫大支持！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-04-27T09:20:49.000Z" title="2023-4-27 17:20:49">2023-04-27</time>发表</span><span class="level-item"><time dateTime="2023-04-27T09:21:31.402Z" title="2023-4-27 17:21:31">2023-04-27</time>更新</span><span class="level-item">32 分钟读完 (大约4825个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/04/27/%E3%80%90MySql%E3%80%9121%E4%B8%AAMySQL%E8%A1%A8%E8%AE%BE%E8%AE%A1%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%87%86%E5%88%99/">【MySql】21个MySQL表设计的经验准则</a></p><div class="content"><p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png" alt="InterviewCoder"></p>
<h2 id="mysql21个mysql表设计的经验准则"><a class="markdownIt-Anchor" href="#mysql21个mysql表设计的经验准则">#</a> 【MySql】21 个 MySQL 表设计的经验准则</h2>
<div id="content_views" class="markdown_views prism-atom-one-dark"> 
 <svg xmlns="http://www.w3.org/2000/svg" style="display: none;"> <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path> 
 </svg> 
 <h2><a id="1_0"></a>1.命名规范</h2> 
 <p>数据库表名、字段名、索引名等都需要命名规范，可读性高(一般要求用英文)，让别人一看命名，就知道这个字段表示什么意思。</p> 
 <p>比如一个表的账号字段，<strong>反例如下</strong>：</p> 
 <pre><code>acc_no,1_acc_no,zhanghao
</code></pre> 
 <p><strong>正例：</strong></p> 
 <pre><code>account_no,account_number
</code></pre> 
 <ul>
  <li>表名、字段名必须使用小写字母或者数字，禁止使用数字开头，禁止使用拼音，并且一般不使用英文缩写。</li>
  <li>主键索引名为<code>pk_字段名</code>；唯一索引名为<code>uk_字段名</code>；普通索引名则为<code>idx_字段名</code>。</li>
 </ul> 
 <h2><a id="2_18"></a>2.选择合适的字段类型</h2> 
 <p>设计表时，我们需要选择合适的字段类型，比如：</p> 
 <ul>
  <li>尽可能选择存储空间小的字段类型，就好像数字类型的，从<code>tinyint、smallint、int、bigint</code>从左往右开始选择</li>
  <li>小数类型如金额，则选择 <code>decimal</code>，禁止使用 <code>float</code> 和 <code>double</code>。</li>
  <li>如果存储的字符串长度几乎相等，使用 <code>char</code> 定长字符串类型。</li>
  <li><code>varchar</code>是可变长字符串，不预先分配存储空间，长度不要超过<code>5000</code>。</li>
  <li>如果存储的值太大，建议字段类型修改为<code>text</code>，同时抽出单独一张表，用主键与之对应。</li>
  <li>同一表中，所有<code>varchar</code>字段的长度加起来，不能大于<code>65535</code>. 如果有这样的需求，请使用<code>TEXT/LONGTEXT</code> 类型。</li>
 </ul> 
 <h2><a id="3__29"></a>3. 主键设计要合理</h2> 
 <p>主键设计的话，最好不要与业务逻辑有所关联。有些业务上的字段，比如身份证，虽然是唯一的，一些开发者喜欢用它来做主键，但是不是很建议哈。主键最好是毫无意义的一串独立不重复的数字，比如<code>UUID</code>，又或者<code>Auto_increment</code>自增的主键，或者是雪花算法生成的主键等等;</p> 
 <p><img src="https://img-blog.csdnimg.cn/img_convert/ccd1bc85b0ee0b89a50656597486178d.png" alt=""></p> 
 <h2><a id="4__35"></a>4. 选择合适的字段长度</h2> 
 <p>先问大家一个问题，大家知道数据库字段长度表示<strong>字符长度</strong>还是<strong>字节长度</strong>嘛？</p> 
 <blockquote> 
  <p>其实在mysql中，<code>varchar</code>和<code>char</code>类型表示字符长度，而其他类型表示的长度都表示字节长度。比如<code>char(10)</code>表示字符长度是10，而<code>bigint（4）</code>表示显示长度是<code>4</code>个字节，但是因为bigint实际长度是<code>8</code>个字节，所以bigint（4）的实际长度就是8个字节。</p> 
 </blockquote> 
 <p>我们在设计表的时候，需要充分考虑一个字段的长度，比如一个用户名字段（它的长度5~20个字符），你觉得应该设置多长呢？可以考虑设置为 <code>username varchar（32）</code>。字段长度一般设置为2的幂哈（也就是<code>2的n</code>次方）。’;</p> 
 <h2><a id="5_43"></a>5，优先考虑逻辑删除，而不是物理删除</h2> 
 <p>什么是物理删除？什么是逻辑删除？</p> 
 <ul>
  <li>物理删除：把数据从硬盘中删除，可释放存储空间</li>
  <li>逻辑删除：给数据添加一个字段，比如<code>is_deleted</code>，以标记该数据已经逻辑删除。</li>
 </ul> 
 <p>物理删除就是执行<code>delete</code>语句，如删除<code>account_no =‘666’</code>的账户信息SQL如下：</p> 
 <pre><code>delete from account_info_tab whereaccount_no ='666';
</code></pre> 
 <p>逻辑删除呢，就是这样：</p> 
 <pre><code>update account_info_tab set is_deleted = 1 where account_no ='666';
</code></pre> 
 <p><strong>为什么推荐用逻辑删除，不推荐物理删除呢？</strong></p> 
 <blockquote> 
  <ul>
   <li>为什么不推荐使用物理删除，因为恢复数据很困难</li>
   <li>物理删除会使自增主键不再连续</li>
   <li>核心业务表 的数据不建议做物理删除，只适合做状态变更。</li>
  </ul> 
 </blockquote> 
 <h2><a id="6_create_timemodifed_time_66"></a>6. 每个表都需要添加这几个通用字段如主键、create_time、modifed_time等</h2> 
 <p>表必备一般来说，或具备这几个字段：</p> 
 <ul>
  <li>id：主键，一个表必须得有主键，必须</li>
  <li>create_time：创建时间，必须</li>
  <li>modifed_time/update_time: 修改时间，必须，更新记录时，需要更新它</li>
  <li>version : 数据记录的版本号，用于乐观锁，非必须</li>
  <li>remark ：数据记录备注，非必须</li>
  <li>modified_by :修改人，非必须</li>
  <li>creator ：创建人，非必须</li>
 </ul> 
 <p><img src="https://img-blog.csdnimg.cn/img_convert/5c0c0ff67e3189ae7899070386491415.png" alt=""></p> 
 <h2><a id="7__80"></a>7. 一张表的字段不宜过多</h2> 
 <p>我们建表的时候，要牢记，一张表的字段不宜过多哈，一般尽量不要超过20个字段哈。笔者记得上个公司，有伙伴设计开户表，加了五十多个字段。。。</p> 
 <p>如果一张表的字段过多，表中保存的数据可能就会很大，查询效率就会很低。因此，一张表不要设计太多字段哈，如果业务需求，实在需要很多字段，可以把一张大的表，拆成多张小的表，它们的主键相同即可。</p> 
 <p>当表的字段数非常多时，可以将表分成两张表，一张作为条件查询表，一张作为详细内容表 (主要是为了性能考虑)。</p> 
 <h2><a id="8_not_null_88"></a>8. 尽可能使用not null定义字段</h2> 
 <p>如果没有特殊的理由， 一般都建议将字段定义为 <code>NOT NULL</code> 。</p> 
 <p><strong>为什么呢？</strong></p> 
 <ul>
  <li>首先， <code>NOT NULL</code> 可以防止出现空指针问题。</li>
  <li>其次，<code>NULL</code>值存储也需要额外的空间的，它也会导致比较运算更为复杂，使优化器难以优化SQL。</li>
  <li><code>NULL</code>值有可能会导致索引失效</li>
  <li>如果将字段默认设置成一个空字符串或常量值并没有什么不同，且都不会影响到应用逻辑， 那就可以将这个字段设置为<code>NOT NULL</code>。</li>
 </ul> 
 <h2><a id="9__99"></a>9. 设计表时，评估哪些字段需要加索引</h2> 
 <p>首先，评估你的表数据量。如果你的表数据量只有一百几十行，就没有必要加索引。否则设计表的时候，如果有查询条件的字段，一般就需要建立索引。但是索引也不能滥用：</p> 
 <ul>
  <li>索引也不要建得太多，一般单表索引个数不要超过<code>5</code>个。因为创建过多的索引，会降低写得速度。</li>
  <li>区分度不高的字段，不能加索引，如性别等</li>
  <li>索引创建完后，还是要注意避免索引失效的情况，如使用mysql的内置函数，会导致索引失效的</li>
  <li>索引过多的话，可以通过联合索引的话方式来优化。然后的话，索引还有一些规则，如覆盖索引，最左匹配原则等等。。</li>
 </ul> 
 <p>假设你新建一张用户表，如下：</p> 
 <pre><code>CREATE TABLE user_info_tab (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL,
  `age` int(11) DEFAULT NULL,
  `name` varchar(255) NOT NULL,
  `create_time` datetime NOT NULL,
  `modifed_time` datetime NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
</code></pre> 
 <p>对于这张表，很可能会有根据<code>user_id</code>或者<code>name</code>查询用户信息，并且，<code>user_id</code>是唯一的。因此，你是可以给<code>user_id</code>加上唯一索引，<code>name</code>加上普通索引。</p> 
 <pre><code>CREATE TABLE user_info_tab (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL,
  `age` int(11) DEFAULT NULL,
  `name` varchar(255) NOT NULL,
  `create_time` datetime NOT NULL,
  `modifed_time` datetime NOT NULL,
  PRIMARY KEY (`id`),
  KEY `idx_name` (`name`) USING BTREE,
  UNIQUE KEY un_user_id (user_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
</code></pre> 
 <h2><a id="10__3NF_138"></a>10. 不需要严格遵守 3NF，通过业务字段冗余来减少表关联</h2> 
 <p>什么是数据库三范式（<code>3NF</code>），大家是否还有印象吗？</p> 
 <ul>
  <li>第一范式：对属性的原子性，要求属性具有原子性，不可再分解；</li>
  <li>第二范式：对记录的唯一性，要求记录有唯一标识，即实体的唯一性，即不存在部分依赖；</li>
  <li>第三方式：对字段的冗余性，要求任何字段不能由其他字段派生出来，它要求字段没有冗余，即不存在传递依赖；</li>
 </ul> 
 <p>我们设计表及其字段之间的关系, 应尽量满足第三范式。但是有时候，可以适当冗余，来提高效率。比如以下这张表</p> 
 <table>
  <thead>
   <tr>
    <th>商品名称</th>
    <th>商品型号</th>
    <th>单价</th>
    <th>数量</th>
    <th>总金额</th>
   </tr>
  </thead>
  <tbody>
   <tr>
    <td>手机</td>
    <td>华为</td>
    <td>8000</td>
    <td>5</td>
    <td>40000</td>
   </tr>
  </tbody>
 </table> 
 <p>以上这张存放商品信息的基本表。<code>总金额</code>这个字段的存在，表明该表的设计不满足第三范式，因为<code>总金额</code>可以由<code>单价*数量</code>得到，说明<code>总金额</code>是冗余字段。但是，增加<code>总金额</code>这个冗余字段，可以提高查询统计的速度，这就是以空间换时间的作法。</p> 
 <p>当然，这只是个小例子哈，大家开发设计的时候，要结合具体业务分析哈。</p> 
 <h2><a id="11_MySQL_156"></a>11. 避免使用MySQL保留字</h2> 
 <p>如果库名、表名、字段名等属性含有保留字时，<code>SQL</code>语句必须用反引号来引用属性名称，这将使得SQL语句书写、SHELL脚本中变量的转义等变得非常复杂。</p> 
 <p>因此，我们一般避免使用<code>MySQL</code>保留字，如<code>select、interval、desc</code>等等</p> 
 <h2><a id="12__162"></a>12. 不搞外键关联，一般都在代码维护</h2> 
 <p>什么是外键呢？</p> 
 <blockquote> 
  <p>外键，也叫<code>FOREIGN KEY</code>，它是用于将两个表连接在一起的键。<code>FOREIGN KEY</code>是一个表中的一个字段（或字段集合），它引用另一个表中的<code>PRIMARY KEY</code>。它是用来保证数据的一致性和完整性的。</p> 
 </blockquote> 
 <p>阿里的<code>Java</code>规范也有这么一条：</p> 
 <blockquote> 
  <p>【强制】<strong>不得使用外键与级联</strong>，一切外键概念必须在应用层解决。</p> 
 </blockquote> 
 <p>我们为什么不推荐使用<strong>外键</strong>呢？</p> 
 <blockquote> 
  <ul>
   <li>使用外键存在性能问题、并发死锁问题、使用起来不方便等等。每次做<code>DELETE</code>或者<code>UPDATE</code>都必须考虑外键约束，会导致开发的时候很难受,测试数据造数据也不方便。</li>
   <li>还有一个场景不能使用外键，就是分库分表。</li>
  </ul> 
 </blockquote> 
 <h2><a id="13_INNODB_177"></a>13. 一般都选择INNODB存储引擎</h2> 
 <p>建表是需要选择<strong>存储引擎</strong>的，我们一般都选择<code>INNODB</code>存储引擎，除非读写比率小于<code>1%</code>, 才考虑使用<code>MyISAM</code> 。</p> 
 <p>有些小伙伴可能会有疑惑，不是还有<code>MEMORY</code>等其他存储引擎吗？什么时候使用它呢？其实其他存储引擎一般除了都建议在<code>DBA</code>的指导下使用。</p> 
 <p>我们来复习一下这<code>MySQL</code>这三种存储引擎的对比区别吧：</p> 
 <table>
  <thead>
   <tr>
    <th>特性</th>
    <th>INNODB</th>
    <th>MyISAM</th>
    <th>MEMORY</th>
   </tr>
  </thead>
  <tbody>
   <tr>
    <td>事务安全</td>
    <td>支持</td>
    <td>无</td>
    <td>无</td>
   </tr>
   <tr>
    <td>存储限制</td>
    <td>64TB</td>
    <td>有</td>
    <td>有</td>
   </tr>
   <tr>
    <td>空间使用</td>
    <td>高</td>
    <td>低</td>
    <td>低</td>
   </tr>
   <tr>
    <td>内存使用</td>
    <td>高</td>
    <td>低</td>
    <td>高</td>
   </tr>
   <tr>
    <td>插入数据速度</td>
    <td>低</td>
    <td>高</td>
    <td>高</td>
   </tr>
   <tr>
    <td>是否支持外键</td>
    <td>支持</td>
    <td>无</td>
    <td>无</td>
   </tr>
  </tbody>
 </table> 
 <h2><a id="14__194"></a>14. 选择合适统一的字符集。</h2> 
 <p>数据库库、表、开发程序等都需要统一字符集，通常中英文环境用<code>utf8</code>。</p> 
 <p>MySQL支持的字符集有<code>utf8、utf8mb4、GBK、latin1</code>等。</p> 
 <ul>
  <li>utf8：支持中英文混合场景，国际通过，3个字节长度</li>
  <li>utf8mb4: &nbsp; 完全兼容utf8，4个字节长度，一般存储<strong>emoji表情</strong>需要用到它。</li>
  <li>GBK ：支持中文，但是不支持国际通用字符集，2个字节长度</li>
  <li>latin1：MySQL默认字符集，1个字节长度</li>
 </ul> 
 <h2><a id="15_comment_205"></a>15. 如果你的数据库字段是枚举类型的，需要在comment注释清楚</h2> 
 <p>如果你设计的数据库字段是枚举类型的话，就需要在<code>comment</code>后面注释清楚每个枚举的意思，以便于维护</p> 
 <p>正例如下：</p> 
 <pre><code>`session_status` varchar(2) COLLATE utf8_bin NOT NULL COMMENT 'session授权态 00：在线-授权态有效 01：下线-授权态失效 02：下线-主动退出 03：下线-在别处被登录'
</code></pre> 
 <p>反例：</p> 
 <pre><code>`session_status` varchar(2) COLLATE utf8_bin NOT NULL COMMENT 'session授权态'
</code></pre> 
 <p>并且，如果你的枚举类型在未来的版本有增加修改的话，也需要同时维护到<code>comment</code>后面。</p> 
 <h2><a id="16_222"></a>16.时间的类型选择</h2> 
 <p>我们设计表的时候，一般都需要加通用时间的字段，如<code>create_time、modified_time</code>等等。那对于时间的类型，我们该如何选择呢？</p> 
 <p>对于MySQL来说，主要有<code>date、datetime、time、timestamp 和 year</code>。</p> 
 <ul>
  <li>date ：表示的日期值, 格式<code>yyyy-mm-dd</code>,范围<code>1000-01-01 到 9999-12-31</code>，3字节</li>
  <li>time ：表示的时间值，格式 <code>hh:mm:ss</code>，范围<code>-838:59:59 到 838:59:59</code>，3字节</li>
  <li>datetime：表示的日期时间值，格式<code>yyyy-mm-dd hh:mm:ss</code>，范围<code>1000-01-01 00:00:00到</code>9999-12-31 23:59:59```,8字节，跟时区无关</li>
  <li>timestamp：表示的时间戳值，格式为<code>yyyymmddhhmmss</code>，范围<code>1970-01-01 00:00:01到2038-01-19 03:14:07</code>，4字节，跟时区有关</li>
  <li>year：年份值，格式为<code>yyyy</code>。范围<code>1901到2155</code>，1字节</li>
 </ul> 
 <p>推荐优先使用<code>datetime</code>类型来保存日期和时间，因为存储范围更大，且跟时区无关。</p> 
 <h2><a id="17_Stored_procedure___236"></a>17. 不建议使用Stored procedure (包括存储过程，触发器) 。</h2> 
 <p><strong>什么是存储过程</strong></p> 
 <p>已预编译为一个可执行过程的一个或多个SQL语句。</p> 
 <p><strong>什么是触发器</strong></p> 
 <p>触发器，指一段代码，当触发某个事件时，自动执行这些代码。使用场景：</p> 
 <ul>
  <li>可以通过数据库中的相关表实现级联更改。</li>
  <li>实时监控某张表中的某个字段的更改而需要做出相应的处理。</li>
  <li>例如可以生成某些业务的编号。</li>
  <li>注意不要滥用，否则会造成数据库及应用程序的维护困难。</li>
 </ul> 
 <p>对于MYSQL来说，存储过程、触发器等还不是很成熟， 并没有完善的出错记录处理，不建议使用。</p> 
 <h2><a id="18_1N__253"></a>18. 1:N 关系的设计</h2> 
 <p>日常开发中，<code>1</code>对多的关系应该是非常常见的。比如一个班级有多个学生，一个部门有多个员工等等。这种的建表原则就是：在从表（<code>N</code>的这一方）创建一个字段，以字段作为外键指向主表（<code>1</code>的这一方）的主键。示意图如下:</p> 
 <p><img src="https://img-blog.csdnimg.cn/img_convert/16838d39a5d92370407a0bb83f69c511.png" alt=""></p> 
 <p>学生表是多（<code>N</code>）的一方，会有个字段<code>class_id</code>保存班级表的主键。当然，一班不加外键约束哈，只是单纯保存这个关系而已。</p> 
 <p>有时候两张表存在<code>N:N</code>关系时，我们应该消除这种关系。通过增加第三张表，把<code>N:N</code>修改为两个 <code>1:N</code>。比如图书和读者，是一个典型的多对多的关系。一本书可以被多个读者借，一个读者又可以借多本书。我们就可以设计一个借书表，包含图书表的主键，以及读者的主键，以及借还标记等字段。</p> 
 <h2><a id="19__263"></a>19. 大字段</h2> 
 <p>设计表的时候，我们尤其需要关注一些大字段，即占用较多存储空间的字段。比如用来记录用户评论的字段，又或者记录博客内容的字段，又或者保存合同数据的字段。如果直接把表字段设计成text类型的话，就会浪费存储空间，查询效率也不好。</p> 
 <p>在MySQl中，这种方式保存的设计方案，其实是不太合理的。这种非常大的数据，可以保存到<code>mongodb</code>中，然后，在业务表保存对应<code>mongodb</code>的<code>id</code>即可。</p> 
 <p>这种设计思想类似于，我们表字段保存图片时，为什么不是保存图片内容，而是直接保存图片url即可。</p> 
 <h2><a id="20__271"></a>20. 考虑是否需要分库分表</h2> 
 <p><strong>什么是分库分表呢？</strong></p> 
 <ul>
  <li>分库：就是一个数据库分成多个数据库，部署到不同机器。</li>
 </ul> 
 <p><img src="https://img-blog.csdnimg.cn/img_convert/b2cf7a062366981d0097856ac608eb09.png" alt=""></p> 
 <ul>
  <li>分表：就是一个数据库表分成多个表。</li>
 </ul> 
 <p><img src="https://img-blog.csdnimg.cn/img_convert/4198e1532e4032a024e81f66f904f38c.png" alt=""></p> 
 <p>我们在设计表的时候，其实可以提前估算一下，是否需要做<strong>分库分表</strong>。比如一些用户信息，未来可能数据量到达百万设置千万的话，就可以提前考虑分库分表。</p> 
 <blockquote> 
  <p><strong>为什么需要分库分表</strong>: 数据量太大的话，SQL的查询就会变慢。如果一个查询SQL没命中索引，千百万数据量级别的表可能会拖垮整个数据库。即使SQL命中了索引，如果表的数据量超过一千万的话，查询也是会明显变慢的。这是因为索引一般是B+树结构，数据千万级别的话，B+树的高度会增高，查询就变慢啦。</p> 
 </blockquote> 
 <p>分库分表主要有水平拆分、垂直拆分的说法，拆分策略有<code>range范围、hash取模</code>。而分库分表主要有这些问题：</p> 
 <ul>
  <li>事务问题</li>
  <li>跨库关联</li>
  <li>排序问题</li>
  <li>分页问题</li>
  <li>分布式ID</li>
 </ul> 
 <h2><a id="21_sqL__295"></a>21. sqL 编写的一些优化经验</h2> 
 <p>最后的话，跟大家聊来一些写SQL的经验吧：</p> 
 <ul>
  <li>查询SQL尽量不要使用<code>select *</code>，而是<code>select</code>具体字段</li>
  <li>如果知道查询结果只有一条或者只要最大/最小一条记录，建议用<code>limit 1</code></li>
  <li>应尽量避免在<code>where</code>子句中使用<code>or</code>来连接条件</li>
  <li>注意优化<code>limit</code>深分页问题</li>
  <li>使用<code>where</code>条件限定要查询的数据，避免返回多余的行</li>
  <li>尽量避免在索引列上使用<code>mysql</code>的内置函数</li>
  <li>应尽量避免在 <code>where</code>子句中对字段进行表达式操作</li>
  <li>应尽量避免在<code>where</code> 子句中使用<code>!=</code>或<code>&lt;&gt;</code>操作符</li>
  <li>使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则。</li>
  <li>对查询进行优化，应考虑在<code>where 及 order by</code>涉及的列上建立索引</li>
  <li>如果插入数据过多，考虑批量插入</li>
  <li>在适当的时候，使用覆盖索引</li>
  <li>使用explain 分析你SQL的计划</li>
 </ul> 
<h2 id="关于我"><a class="markdownIt-Anchor" href="#关于我">#</a> 关于我</h2>
<p>Brath 是一个热爱技术的 Java 程序猿，公众号「InterviewCoder」定期分享有趣有料的精品原创文章！</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png" alt="InterviewCoder"></p>
<p>非常感谢各位人才能看到这里，原创不易，文章如果有帮助可以关注、点赞、分享或评论，这都是对我的莫大支持！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-04-27T09:20:49.000Z" title="2023-4-27 17:20:49">2023-04-27</time>发表</span><span class="level-item"><time dateTime="2023-04-27T09:22:38.119Z" title="2023-4-27 17:22:38">2023-04-27</time>更新</span><span class="level-item">17 分钟读完 (大约2530个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/04/27/%E3%80%90Zookeeper%E3%80%91Zookeeper%E5%85%A5%E9%97%A8%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/">【Zookeeper】Zookeeper入门看这篇就够了</a></p><div class="content"><p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png" alt="InterviewCoder"></p>
<h2 id="zookeeperzookeeper入门看这篇就够了"><a class="markdownIt-Anchor" href="#zookeeperzookeeper入门看这篇就够了">#</a> 【Zookeeper】Zookeeper 入门看这篇就够了</h2>
<div id="content_views" class="htmledit_views"> <strong><a target="_blank" rel="noopener" href="https://www.roncoo.com/course/list.html?courseName=Zookeeper">Zookeeper是什么</a></strong> 
 <br> 
 <br>官方文档上这么解释zookeeper，它是一个分布式服务框架，是Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。 
 <br> 
 <br>上面的解释有点抽象，简单来说zookeeper=文件系统+监听通知机制。 
 <br> 
 <br>1、 文件系统 
 <br> 
 <br> 
 <p>Zookeeper维护一个类似文件系统的数据结构：</p> 
 <p><img src="https://img-blog.csdn.net/201807121434154?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phdmFfNjY2NjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></p> 
 <p></p> 
 <p style="line-height:28px;color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);">每个子目录项如 NameService 都被称作为 znode(目录节点)，和文件系统一样，我们能够自由的增加、删除znode，在一个znode下增加、删除子znode，唯一的不同在于znode是可以存储数据的。</p> 
 <p style="line-height:28px;color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);">有四种类型的znode：</p> 
 <ul style="margin-left:30px;color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);">
  <li><p style="line-height:28px;"><span style="font-weight:bolder;">PERSISTENT-持久化目录节点</span></p><p style="line-height:28px;">客户端与zookeeper断开连接后，该节点依旧存在</p></li>
  <li><p style="line-height:28px;"><span style="font-weight:bolder;">PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点</span></p><p style="line-height:28px;">客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号</p></li>
  <li><p style="line-height:28px;"><span style="font-weight:bolder;">EPHEMERAL-临时目录节点</span></p><p style="line-height:28px;">客户端与zookeeper断开连接后，该节点被删除</p></li>
  <li><p style="line-height:28px;"><span style="font-weight:bolder;">EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点</span></p><p style="line-height:28px;">客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号</p></li>
 </ul> 
 <p style="line-height:28px;color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><span style="font-weight:bolder;">2、 监听通知机制</span></p> 
 <p style="line-height:28px;color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);">客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变、被删除、子目录节点增加删除）时，zookeeper会通知客户端。</p> 
 <p style="line-height:28px;color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);">就这么简单，下面我们看看Zookeeper能做点什么呢？</p> <span id="OSC_h1_2" style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"></span> <span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"></span> 
 <h1 id="h1_2" style="font-size:24px;font-family:'PingFang SC', 'Helvetica Neue', 'Microsoft YaHei UI', 'Microsoft YaHei', 'Noto Sans CJK SC', Sathu, EucrosiaUPC, Arial, Helvetica, sans-serif;line-height:1.28571em;font-weight:500;color:rgb(61,70,77);background-color:rgb(255,255,255);"><span style="font-weight:bolder;">Zookeeper能做什么</span></h1> 
 <p style="line-height:28px;color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);">zookeeper功能非常强大，可以实现诸如分布式应用配置管理、统一命名服务、状态同步服务、集群管理等功能，我们这里拿比较简单的分布式应用配置管理为例来说明。</p> 
 <p style="line-height:28px;color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);">假设我们的程序是分布式部署在多台机器上，如果我们要改变程序的配置文件，需要逐台机器去修改，非常麻烦，现在把这些配置全部放到zookeeper上去，保存在 zookeeper 的某个目录节点中，然后所有相关应用程序对这个目录节点进行监听，一旦配置信息发生变化，每个应用程序就会收到 zookeeper 的通知，然后从 zookeeper 获取新的配置信息应用到系统中。</p> 
 <p><img src="https://img-blog.csdn.net/20180712143454552?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phdmFfNjY2NjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p> 
 <p></p> 
 <p style="line-height:28px;color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);">如上，你大致应该了解zookeeper是个什么东西，大概能做些什么了，我们马上来学习下zookeeper的安装及使用，并开发一个小程序来实现zookeeper这个分布式配置管理的功能。</p> <span id="OSC_h1_3" style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"></span> <span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"></span> 
 <h1 id="h1_3" style="font-size:24px;font-family:'PingFang SC', 'Helvetica Neue', 'Microsoft YaHei UI', 'Microsoft YaHei', 'Noto Sans CJK SC', Sathu, EucrosiaUPC, Arial, Helvetica, sans-serif;line-height:1.28571em;font-weight:500;color:rgb(61,70,77);background-color:rgb(255,255,255);"><span style="font-weight:bolder;">Zookeeper单机模式安装</span></h1> 
 <p style="line-height:28px;color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><span style="font-weight:bolder;">Step1</span>：配置JAVA环境，检验环境：java -version</p> 
 <p style="line-height:28px;color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><span style="font-weight:bolder;">Step2</span>：下载并解压zookeeper</p> 
 <pre><code class="language-java"># cd /usr/local
# wget http://mirror.bit.edu.cn/apache/zookeeper/stable/zookeeper-3.4.12.tar.gz
# tar -zxvf zookeeper-3.4.12.tar.gz
# cd zookeeper-3.4.12</code></pre> 
 <p><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><strong>Step3</strong></span><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);">：重命名配置文件zoo_sample.cfg</span><br></p> 
 <pre><code class="language-java"># cp conf/zoo_sample.cfg conf/zoo.cfg</code></pre> 
 <p><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><strong>Step4</strong></span><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);">：启动zookeeper</span></p> 
 <pre><code class="language-java"># bin/zkServer.sh start</code></pre> 
 <p><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><strong>Step5</strong></span><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);">：检测是否成功启动，用zookeeper客户端连接下服务端</span></p> 
 <pre><code class="language-java"># bin/zkCli.sh</code></pre> 
 <h1 id="h1_4" style="font-size:24px;font-family:'PingFang SC', 'Helvetica Neue', 'Microsoft YaHei UI', 'Microsoft YaHei', 'Noto Sans CJK SC', Sathu, EucrosiaUPC, Arial, Helvetica, sans-serif;line-height:1.28571em;font-weight:500;color:rgb(61,70,77);background-color:rgb(255,255,255);"><span style="font-weight:bolder;">Zookeeper使用</span></h1> <span id="OSC_h3_5" style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"></span> <span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"></span> 
 <h3 id="h3_5" style="font-family:'PingFang SC', 'Helvetica Neue', 'Microsoft YaHei UI', 'Microsoft YaHei', 'Noto Sans CJK SC', Sathu, EucrosiaUPC, Arial, Helvetica, sans-serif;line-height:1.28571em;font-weight:500;font-size:20px;color:rgb(61,70,77);background-color:rgb(255,255,255);"><span style="font-weight:bolder;">使用客户端命令操作zookeeper</span></h3> 
 <p style="line-height:28px;color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);">1、使用 ls 命令来查看当前 ZooKeeper 中所包含的内容</p> 
 <img src="https://img-blog.csdn.net/20180712143716167?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phdmFfNjY2NjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""> 
 <br> 
 <p><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><br></span></p> 
 <p><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);">2、创建一个新的 znode ，使用 create /zkPro myData</span><br></p> 
 <p><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><img src="https://img-blog.csdn.net/2018071214374133?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phdmFfNjY2NjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></span></p> 
 <p><span style="background-color:rgb(255,255,255);color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;">3、再次使用 ls 命令来查看现在 zookeeper 中所包含的内容：</span></p> 
 <p><span style="background-color:rgb(255,255,255);color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;"><img src="https://img-blog.csdn.net/20180712143805771?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phdmFfNjY2NjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></span></p> 
 <p><span style="background-color:rgb(255,255,255);color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;"><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);">4、下面我们运行 get 命令来确认第二步中所创建的 znode 是否包含我们所创建的字符串：</span><br></span></p> 
 <p><span style="background-color:rgb(255,255,255);color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;"><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><img src="https://img-blog.csdn.net/20180712143823808?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phdmFfNjY2NjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></span></span></p> 
 <p><span style="background-color:rgb(255,255,255);color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;"><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);">5、下面我们通过 set 命令来对 zk 所关联的字符串进行设置：</span><br></span></span></p> 
 <p><span style="background-color:rgb(255,255,255);color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;"><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><img src="https://img-blog.csdn.net/2018071214384160?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phdmFfNjY2NjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></span></span></span></p> 
 <p><span style="background-color:rgb(255,255,255);color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;"><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);">6、下面我们将刚才创建的 znode 删除</span><br></span></span></span></p> 
 <p><span style="background-color:rgb(255,255,255);color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;"><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><img src="https://img-blog.csdn.net/20180712143857281?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phdmFfNjY2NjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></span></span></span></span></p> 
 <p><span style="background-color:rgb(255,255,255);color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;"><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"></span></span></span></span></p> 
 <h3 id="h3_6" style="font-family:'PingFang SC', 'Helvetica Neue', 'Microsoft YaHei UI', 'Microsoft YaHei', 'Noto Sans CJK SC', Sathu, EucrosiaUPC, Arial, Helvetica, sans-serif;line-height:1.28571em;font-weight:500;font-size:20px;color:rgb(61,70,77);background-color:rgb(255,255,255);"><span style="font-weight:bolder;">使用Java API操作zookeeper</span></h3> 
 <p style="line-height:28px;color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);">使用Java API操作zookeeper需要引用下面的包</p> 
 <p><span style="background-color:rgb(255,255,255);color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;"><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><img src="https://img-blog.csdn.net/20180712143918407?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phdmFfNjY2NjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></span></span></span></span></p> 
 <p><span style="background-color:rgb(255,255,255);color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;"><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"></span></span></span></span></p> 
 <p style="line-height:28px;color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);">下面我们来实现上面说的分布式配置中心：</p> 
 <p style="line-height:28px;color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);">1、在zookeeper里增加一个目录节点，并且把配置信息存储在里面</p> 
 <p><span style="background-color:rgb(255,255,255);color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;"><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><img src="https://img-blog.csdn.net/20180712143937411?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phdmFfNjY2NjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></span></span></span></span></p> 
 <p><span style="background-color:rgb(255,255,255);color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;"><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);">2、启动两个zookeeper客户端程序，代码如下所示</span><br></span></span></span></span></p> 
 <pre><code class="language-java">import java.util.concurrent.CountDownLatch;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.apache.zookeeper.Watcher.Event.EventType;
import org.apache.zookeeper.Watcher.Event.KeeperState;
import org.apache.zookeeper.ZooKeeper;
import org.apache.zookeeper.data.Stat;
<p>/**</p>
<ul>
<li>分布式配置中心 demo</li>
<li>@author</li>
<li></li>
</ul>
<p>*/<br>
public class ZooKeeperProSync implements Watcher &#123;</p>
<pre><code>private static CountDownLatch connectedSemaphore = new CountDownLatch(1);
private static ZooKeeper zk = null;
private static Stat stat = new Stat();

public static void main(String[] args) throws Exception &#123;
    //zookeeper配置数据存放路径
    String path = &quot;/username&quot;;
    //连接zookeeper并且注册一个默认的监听器
    zk = new ZooKeeper(&quot;192.168.31.100:2181&quot;, 5000, //
            new ZooKeeperProSync());
    //等待zk连接成功的通知
    connectedSemaphore.await();
    //获取path目录节点的配置数据，并注册默认的监听器
    System.out.println(new String(zk.getData(path, true, stat)));

    Thread.sleep(Integer.MAX_VALUE);
&#125;

public void process(WatchedEvent event) &#123;
    if (KeeperState.SyncConnected == event.getState()) &#123;  //zk连接成功通知事件
        if (EventType.None == event.getType() &amp;amp;&amp;amp; null == event.getPath()) &#123;
            connectedSemaphore.countDown();
        &#125; else if (event.getType() == EventType.NodeDataChanged) &#123;  //zk目录节点数据变化通知事件
            try &#123;
                System.out.println(&quot;配置已修改，新值为：&quot; + new String(zk.getData(event.getPath(), true, stat)));
            &#125; catch (Exception e) &#123;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>}</code></pre></p>
 <p style="line-height:28px;color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);">两个程序启动后都正确的读取到了zookeeper的/username目录节点下的数据'qingfeng'</p> 
 <p style="line-height:28px;color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);">3、我们在zookeeper里修改下目录节点/username下的数据</p> 
 <img src="https://img-blog.csdn.net/20180712144020208?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phdmFfNjY2NjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""> 
 <br> 
 <p><span style="background-color:rgb(255,255,255);color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;"><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);">修改完成后，我们看见两个程序后台都及时收到了他们监听的目录节点数据变更后的值，如下所示</span><br></span></span></span></span></p> 
 <p><span style="background-color:rgb(255,255,255);color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;"><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><img src="https://img-blog.csdn.net/20180712144042598?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phdmFfNjY2NjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></span></span></span></span></span></p> 
 <p><span style="background-color:rgb(255,255,255);color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;"><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"></span></span></span></span></span></p> 
 <h1 id="h1_7" style="font-size:24px;font-family:'PingFang SC', 'Helvetica Neue', 'Microsoft YaHei UI', 'Microsoft YaHei', 'Noto Sans CJK SC', Sathu, EucrosiaUPC, Arial, Helvetica, sans-serif;line-height:1.28571em;font-weight:500;color:rgb(61,70,77);background-color:rgb(255,255,255);"><span style="font-weight:bolder;">Zookeeper集群模式安装</span></h1> 
 <p style="line-height:28px;color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);">本例搭建的是伪集群模式，即一台机器上启动三个zookeeper实例组成集群，真正的集群模式无非就是实例IP地址不同，搭建方法没有区别</p> 
 <p style="line-height:28px;color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><span style="font-weight:bolder;">Step1</span>：配置JAVA环境，检验环境：java -version</p> 
 <p style="line-height:28px;color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><span style="font-weight:bolder;">Step2</span>：下载并解压zookeeper</p> 
 <pre><code class="language-java"># cd /usr/local
# wget http://mirror.bit.edu.cn/apache/zookeeper/stable/zookeeper-3.4.12.tar.gz
# tar -zxvf zookeeper-3.4.12.tar.gz
# cd zookeeper-3.4.12</code></pre> 
 <p><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><strong>Step3</strong></span><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);">：重命名 zoo_sample.cfg文件</span></p> 
 <pre><code class="language-java"># cp conf/zoo_sample.cfg conf/zoo-1.cfg</code></pre> 
 <p><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><strong>Step4</strong></span><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);">：修改配置文件zoo-1.cfg，原配置文件里有的，修改成下面的值，没有的则加上</span></p> 
 <pre><code class="language-java"># vim conf/zoo-1.cfg
dataDir=/tmp/zookeeper-1
clientPort=2181
server.1=127.0.0.1:2888:3888
server.2=127.0.0.1:2889:3889
server.3=127.0.0.1:2890:3890</code></pre> 
 <p style="line-height:28px;color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><span style="font-weight:bolder;">配置说明</span></p> 
 <ul style="margin-left:30px;color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);">
  <li>tickTime：这个时间是作为 Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。</li>
  <li>initLimit：这个配置项是用来配置 Zookeeper 接受客户端（这里所说的客户端不是用户连接 Zookeeper 服务器的客户端，而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过 10个心跳的时间（也就是 tickTime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是 10*2000=20 秒</li>
  <li>syncLimit：这个配置项标识 Leader 与 Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 5*2000=10秒</li>
  <li>dataDir：顾名思义就是 Zookeeper 保存数据的目录，默认情况下，Zookeeper 将写数据的日志文件也保存在这个目录里。</li>
  <li>clientPort：这个端口就是客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。</li>
  <li>server.A=B：C：D：其中 A 是一个数字，表示这个是第几号服务器；B 是这个服务器的 ip 地址；C 表示的是这个服务器与集群中的 Leader 服务器交换信息的端口；D 表示的是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。如果是伪集群的配置方式，由于 B 都是一样，所以不同的 Zookeeper 实例通信端口号不能一样，所以要给它们分配不同的端口号。</li>
 </ul> 
 <p style="line-height:28px;color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><span style="font-weight:bolder;">Step4</span>：再从zoo-1.cfg复制两个配置文件zoo-2.cfg和zoo-3.cfg，只需修改dataDir和clientPort不同即可</p> 
 <pre><code class="language-java"># cp conf/zoo-1.cfg conf/zoo-2.cfg
# cp conf/zoo-1.cfg conf/zoo-3.cfg
# vim conf/zoo-2.cfg
dataDir=/tmp/zookeeper-2
clientPort=2182
# vim conf/zoo-2.cfg
dataDir=/tmp/zookeeper-3
clientPort=2183</code></pre> 
 <p style="line-height:28px;color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><span style="font-weight:bolder;">Step5</span>：标识Server ID</p> 
 <p style="line-height:28px;color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);">创建三个文件夹/tmp/zookeeper-1，/tmp/zookeeper-2，/tmp/zookeeper-2，在每个目录中创建文件myid 文件，写入当前实例的server id，即1.2.3</p> 
 <pre><code class="language-java"># cd /tmp/zookeeper-1
# vim myid
1
# cd /tmp/zookeeper-2
# vim myid
2
# cd /tmp/zookeeper-3
# vim myid
3</code></pre> 
 <p><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><strong>Step6</strong></span><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);">：启动三个zookeeper实例</span></p> 
 <pre><code class="language-java"># bin/zkServer.sh start conf/zoo-1.cfg
# bin/zkServer.sh start conf/zoo-2.cfg
# bin/zkServer.sh start conf/zoo-3.cfg</code></pre> 
 <p><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><strong>Step7</strong></span><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);">：检测集群状态，也可以直接用命令“zkCli.sh -server IP:PORT”连接zookeeper服务端检测</span></p> 
 <p><span style="color:rgb(61,70,77);font-family:'Pingfang SC', STHeiti, 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, sans-serif;background-color:rgb(255,255,255);"><img src="https://img-blog.csdn.net/20180712144336907?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phdmFfNjY2NjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></span></p> 
 <p>至此，我们对zookeeper就算有了一个入门的了解，当然zookeeper远比我们这里描述的功能多，比如用zookeeper实现集群管理，分布式锁，分布式队列，zookeeper集群leader选举等等<br></p> 
 <p>推荐阅读：<a target="_blank" rel="noopener" href="https://www.roncoo.com/course/view/255bac222b1b4300b42838b58fea3a2e">https://www.roncoo.com/course/view/255bac222b1b4300b42838b58fea3a2e</a></p> 
 <p>文章来源：https://my.oschina.net/u/3796575/blog/1845035</p> 
</div>
## 关于我
<p>Brath 是一个热爱技术的 Java 程序猿，公众号「InterviewCoder」定期分享有趣有料的精品原创文章！</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png" alt="InterviewCoder"></p>
<p>非常感谢各位人才能看到这里，原创不易，文章如果有帮助可以关注、点赞、分享或评论，这都是对我的莫大支持！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-04-27T09:20:49.000Z" title="2023-4-27 17:20:49">2023-04-27</time>发表</span><span class="level-item"><time dateTime="2023-04-29T11:04:20.517Z" title="2023-4-29 19:04:20">2023-04-29</time>更新</span><span class="level-item">1 小时读完 (大约11033个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/04/27/%E3%80%90Dubbo%E3%80%91Dubbo%E8%AF%A6%E8%A7%A3%EF%BC%8C%E7%94%A8%E5%BF%83%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91/">【Dubbo】Dubbo详解，用心看这一篇文章就够了【重点】</a></p><div class="content"><p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png" alt="InterviewCoder"></p>
<h2 id="dubbodubbo详解用心看这一篇文章就够了重点"><a class="markdownIt-Anchor" href="#dubbodubbo详解用心看这一篇文章就够了重点">#</a> 【Dubbo】Dubbo 详解，用心看这一篇文章就够了【重点】</h2>
<h2 id="11-dubbo概述"><a class="markdownIt-Anchor" href="#11-dubbo概述">#</a> 1.1  <code>Dubbo</code>  概述</h2>
<p><strong> <code>Dubbo</code>  是阿里巴巴开源的基于  <code>Java</code>  的高性能 <code>RPC</code> （一种远程调用） 分布式服务框架，致力于提供高性能和透明化的 <code>RPC</code>  远程服务调用方案，以及 <code>SOA</code>  服务治理方案</strong>。</p>
<p>每天为 <code>2</code>  千多个服务提供大于 <code>30</code>  亿次访问量支持，并被广泛应用于阿里巴巴集团的各成员站点以及别的公司的业务中。</p>
<p>简单的说， <code>Dubbo</code>  就是个服务框架，如果没有分布式的需求，其实是不需要用的，只有在分布式的时候，才有 <code>Dubbo</code>  这样的分布式服务框架的需求。</p>
<p>并且本质上是个远程服务调用的分布式框架（告别 <code>Web Service</code>  模式中的 <code>WSdl</code> ，以服务者与消费者的方式在 <code>Dubbo</code>  上注册）</p>
<p>其核心部分包含：</p>
<p>1、<strong>远程通讯</strong>：提供对多种基于长连接的 <code>NIO</code>  框架抽象封装，包括多种线程模型，序列化，以及 “请求 - 响应” 模式的信息交换方式。<br>
2、<strong>集群容错</strong>：提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。<br>
3、<strong>自动发现</strong>：基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。</p>
<h2 id="12-dubbo背景"><a class="markdownIt-Anchor" href="#12-dubbo背景">#</a> 1.2  <code>Dubbo</code>  背景</h2>
<p><code>Dubbo</code>  开始于电商系统，因此在这里先从电商系统的演变讲起。</p>
<h3 id="121-单一应用框架"><a class="markdownIt-Anchor" href="#121-单一应用框架">#</a> 1.2.1 单一应用框架</h3>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/9529d3b51c5f4fa4944fc793a542688a.png" alt="在这里插入图片描述"><br>
当网站流量很小时，只需一个应用，将所有功能如下单支付等都部署在一起，以减少部署节点和成本。</p>
<p><strong>缺点</strong>：单一的系统架构，使得在开发过程中，占用的资源越来越多，而且随着流量的增加越来越难以维护。</p>
<h3 id="122-垂直应用框架"><a class="markdownIt-Anchor" href="#122-垂直应用框架">#</a> 1.2.2 垂直应用框架</h3>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/a7579c9f3b0e4a928d2bedde32fd2f1f.png" alt="在这里插入图片描述"><br>
垂直应用架构解决了单一应用架构所面临的扩容问题，流量能够分散到各个子系统当中，且系统的体积可控，一定程度上降低了开发人员之间协同以及维护的成本，提升了开发效率。</p>
<p><strong>缺点</strong>：但是在垂直架构中相同逻辑代码需要不断的复制，不能复用。</p>
<h3 id="123-分布式应用架构rpc"><a class="markdownIt-Anchor" href="#123-分布式应用架构rpc">#</a> 1.2.3 分布式应用架构 ( <code>RPC</code> )</h3>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/36242cd9be084aea8c2c30643485c960.png" alt="在这里插入图片描述"><br>
当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心。</p>
<h3 id="124-流动计算架构soa"><a class="markdownIt-Anchor" href="#124-流动计算架构soa">#</a> 1.2.4 流动计算架构 ( <code>SOA</code> )</h3>
<p>随着服务化的进一步发展，服务越来越多，服务之间的调用和依赖关系也越来越复杂，诞生了面向服务的架构体系 ( <code>SOA</code> )，也因此衍生出了一系列相应的技术，如对服务提供、服务调用、连接处理、通信协议、序列化方式、服务发现、服务路由、日志输出等行为进行封装的服务框架。</p>
<h3 id="125-架构演变详解"><a class="markdownIt-Anchor" href="#125-架构演变详解">#</a> 1.2.5 架构演变详解</h3>
<p>从以上是电商系统的演变可以看出架构演变的过程：<br>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/58b4c7452c0243fdb318d0282d603f94.png" alt="在这里插入图片描述"><br>
 1、单应用单服务器；<br>
2、单应用拆分成多个应用并部署到多个服务器；<br>
3、单应用拆分成多个应用并实现分布式部署；<br>
4、流动计算框架（用于提高机器利用率的资源调度和治理中心）</p>
<h4 id="1251-单一应用架构"><a class="markdownIt-Anchor" href="#1251-单一应用架构">#</a> 1.2.5.1 单一应用架构</h4>
<p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。 此时，用于简化增删改查工作量的 数据访问框架 ( <code>ORM</code> ) 是关键。</p>
<h4 id="1252-垂直应用架构"><a class="markdownIt-Anchor" href="#1252-垂直应用架构">#</a> 1.2.5.2 垂直应用架构</h4>
<p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的  <code>Web</code>  框架 ( <code>MVC</code> ) 是关键。</p>
<h4 id="1253-分布式服务架构"><a class="markdownIt-Anchor" href="#1253-分布式服务架构">#</a> 1.2.5.3 分布式服务架构</h4>
<p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的 分布式服务框架 ( <code>RPC</code> ) 是关键。</p>
<h4 id="1254-流动计算架构"><a class="markdownIt-Anchor" href="#1254-流动计算架构">#</a> 1.2.5.4 流动计算架构</h4>
<p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的 资源调度和治理中心 ( <code>SOA</code> ) 是关键。</p>
<h3 id="126-rpc的简介"><a class="markdownIt-Anchor" href="#126-rpc的简介">#</a> 1.2.6  <code>RPC</code>  的简介</h3>
<p><strong> <code>RPC(Remote Procedure Call Protocol)</code> ：远程过程调用</strong></p>
<p>两台服务器 <code>A、B</code> ，分别部署不同的应用 <code>a,b</code> 。当 <code>A</code>  服务器想要调用 <code>B</code>  服务器上应用 <code>b</code>  提供的函数或方法的时候，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义传达调用的数据。<br>
说白了，就是你在你的机器上写了一个程序，我这边是无法直接调用的，这个时候就出现了一个远程服务调用的概念。</p>
<p><code>RPC</code>  是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。 <code>RPC</code>  协议假定某些传输协议的存在，如 <code>TCP</code>  或 <code>UDP</code> ，为通信程序之间携带信息数据。在 <code>OSI</code>  网络通信模型中， <code>RPC</code>  跨越了传输层和应用层。 <code>RPC</code>  使得开发包括网络分布式多程序在内的应用程序更加容易。<br>
<strong> <code>RPC</code>  采用客户机 / 服务器模式</strong>。请求程序就是一个客户机，而服务提供程序就是一个服务器。首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。</p>
<h4 id="1261-rpc需要解决的问题"><a class="markdownIt-Anchor" href="#1261-rpc需要解决的问题">#</a> 1.2.6.1  <code>RPC</code>  需要解决的问题</h4>
<ul>
<li><strong>通讯问题</strong>：主要是通过在客户端和服务器之间建立 TCP 连接，远程过程调用的所有交换的数据都在这个连接里传输。连接可以是按需连接，调用结束后就断掉，也可以是长连接，多个远程过程调用共享同一个连接。</li>
<li><strong>寻址问题</strong>：A 服务器上的应用怎么告诉底层的 RPC 框架，如何连接到 B 服务器（如主机或 <code>IP</code>  地址）以及特定的端口，方法的名称名称是什么，这样才能完成调用。比如基于 <code>Web</code>  服务协议栈的 <code>RPC</code> ，就要提供一个 <code>endpoint URI</code> ，或者是从 <code>UDDI</code>  服务上查找。如果是 <code>RMI</code>  调用的话，还需要一个 <code>RMI Registry</code>  来注册服务的地址。</li>
<li><strong>序列化 与 反序列化</strong>：当 <code>A</code>  服务器上的应用发起远程过程调用时，方法的参数需要通过底层的网络协议如 <code>TCP</code>  传递到 <code>B</code>  服务器，由于网络协议是基于二进制的，内存中的参数的值要序列化成二进制的形式，也就是序列化（ <code>Serialize</code> ）或编组（ <code>marshal</code> ），通过寻址和传输将序列化的二进制发送给 <code>B</code>  服务器。<br>
同理， <code>B</code>  服务器接收参数要将参数反序列化。B 服务器应用调用自己的方法处理后返回的结果也要序列化给 <code>A</code>  服务器， <code>A</code>  服务器接收也要经过反序列化的过程。</li>
</ul>
<h2 id="13-dubbo作用"><a class="markdownIt-Anchor" href="#13-dubbo作用">#</a> 1.3  <code>Dubbo</code>  作用</h2>
<p>我们一起来看一下 <code>Dubbo</code>  的服务治理图：</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/b42b2f9c1b1e4c56b36ea55673c037fd.png" alt="在这里插入图片描述"></p>
<h3 id="131-为什么使用dubbo"><a class="markdownIt-Anchor" href="#131-为什么使用dubbo">#</a> 1.3.1 为什么使用 <code>Dubbo</code></h3>
<p>因为是阿里开源项目，国内很多互联网公司都在用，已经经过很多线上考验。内部使用了 <code>Netty、Zookeeper</code> ，保证了高性能高可用性。</p>
<ul>
<li><strong>使用 <code>Dubbo</code>  可以将核心业务抽取出来，作为独立的服务</strong>，逐渐形成稳定的服务中心，可用于提高业务复用灵活扩展，使前端应用能更快速的响应多变的市场需求。</li>
<li>分布式架构可以承受更大规模的并发流量。</li>
</ul>
<h3 id="132-dubbo能做什么"><a class="markdownIt-Anchor" href="#132-dubbo能做什么">#</a> 1.3.2  <code>Dubbo</code>  能做什么</h3>
<p>1、<strong>透明化的远程方法调用</strong>，就像调用本地方法一样调用远程方法，只需简单配置，没有任何 <code>API</code>  侵入。<br>
2、<strong>软负载均衡及容错机制</strong>，可在内网替代 <code>F5</code>  等硬件负载均衡器，降低成本，减少单点。<br>
3.、<strong>服务自动注册与发现</strong>，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的 <code>IP</code>  地址，并且能够平滑添加或删除服务提供者。</p>
<p><strong> <code>Dubbo</code>  采用全 <code>Spring</code>  配置方式，透明化接入应用，对应用没有任何 <code>API</code>  侵入，只需用 <code>Spring</code>  加载 <code>Dubbo</code>  的配置即可</strong>， <code>Dubbo</code>  基于 <code>Spring</code>  的 <code>Schema</code>  扩展进行加载。</p>
<h2 id="14-dubbo-和-spring-cloud区别"><a class="markdownIt-Anchor" href="#14-dubbo-和-spring-cloud区别">#</a> 1.4  <code>Dubbo</code>  和  <code>Spring Cloud</code>  区别</h2>
<p>1、<strong>通信方式不同</strong>： <code>Dubbo</code>  使用的是  <code>RPC</code>  通信，而 <code>Spring Cloud</code>  使用的是 <code>HTTP RESTFul</code>  方式。<br>
2、<strong>组成不一样</strong>：</p>
<ul>
<li><code>dubbo</code>  的服务注册中心为 <code>Zookeerper</code> ，服务监控中心为 <code>dubbo-monitor</code> ，无消息总线、服务跟踪、批量任务等组件；</li>
<li><code>Spring Cloud</code>  的服务注册中心为 <code>spring-cloud netflix enruka</code> ，服务监控中心为 <code>spring-boot admin</code> ，有消息总线、数据流、服务跟踪、批量任务等组件；</li>
</ul>
<h2 id="15-dubbo技术架构"><a class="markdownIt-Anchor" href="#15-dubbo技术架构">#</a> 1.5  <code>Dubbo</code>  技术架构</h2>
<p>首先我们一起来看一下 <code>Dubbo</code>  官网提供的架构图：<br>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/7792efd1449d4117b828af6c1022e089.png" alt="在这里插入图片描述"><br>
<strong>节点角色说明</strong></p>
<table>
<thead>
<tr>
<th>节点</th>
<th>角色说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Provider</td>
<td>暴露服务的服务提供方</td>
</tr>
<tr>
<td>Consumer</td>
<td>调用远程服务的服务消费方</td>
</tr>
<tr>
<td>Registry</td>
<td>服务注册与发现的注册中心</td>
</tr>
<tr>
<td>Monitor</td>
<td>统计服务的调用次数和调用时间的监控中心</td>
</tr>
<tr>
<td>Container</td>
<td>服务运行容器</td>
</tr>
</tbody>
</table>
<p>看了这几个概念后似乎发现其实 <code>Dubbo</code>  的架构也是很简单的 (其实现细节是复杂)，为什么这么说呢，有没有发现，其实很像<strong>生产者 - 消费者</strong>模型。只是在这种模型上，加上了<strong>注册中心和监控中心</strong>，用于管理提供方提供的 <code>url</code> ，以及管理整个过程。</p>
<p><strong>调用关系说明</strong></p>
<p>1、服务容器负责启动，加载，运行服务提供者。<br>
2、服务提供者在启动时，向注册中心注册自己提供的服务。<br>
3、服务消费者在启动时，向注册中心订阅自己所需的服务。<br>
4、注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。<br>
5、服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。<br>
6、服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</p>
<hr>
<p>那么，整个<strong>发布 - 订阅</strong>的过程就非常的简单了：</p>
<ul>
<li>启动容器，加载，运行服务提供者。</li>
<li>服务提供者在启动时，在注册中心发布注册自己提供的服务。</li>
<li>服务消费者在启动时，在注册中心订阅自己所需的服务。</li>
</ul>
<p>如果考虑<strong>失败或变更</strong>的情况，就需要考虑下面的过程：</p>
<ul>
<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>
<li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>
<li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li>
</ul>
<h2 id="16-dubbo入门案例"><a class="markdownIt-Anchor" href="#16-dubbo入门案例">#</a> 1.6  <code>Dubbo</code>  入门案例</h2>
<h3 id="161-服务端"><a class="markdownIt-Anchor" href="#161-服务端">#</a> 1.6.1 服务端</h3>
<p>首先，我们先把服务端的接口写好，因为其实 <code>dubbo</code>  的作用简单来说就是给消费端提供接口。</p>
<p><strong>接口定义</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * xml方式服务提供者接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProviderService</span> &#123;</span><br><span class="line">    String <span class="title function_">SayHello</span><span class="params">(String word)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个接口非常简单，只是包含一个  <code>SayHello</code>  的方法。</p>
<p>接着，定义它的<strong>实现类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * xml方式服务提供者实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProviderServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">ProviderService</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">SayHello</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> word;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就把我们的接口写好了，那么我们应该怎么将我们的服务暴露出去呢？</p>
<p><strong>导入 maven 依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ouyangsihai<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-provider<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/dubbo --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.101tec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zkclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.32.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里使用的 <code>dubbo</code>  的版本是 <code>2.6.6</code> ，需要注意的是，如果你只导入 <code>dubbo</code>  的包的时候是会报错的，找不到 <code>netty</code>  和 <code>curator</code>  的依赖，所以，在这里我们需要把这两个的依赖加上，就不会报错了。</p>
<p>另外，这里我们使用  <code>zookeeper</code>  作为注册中心。</p>
<p>到目前为止， <code>dubbo</code>  需要的环境就已经可以了，下面，我们就把上面刚刚定义的接口暴露出去。</p>
<p><strong>暴露接口（ <code>xml</code>  配置方法）</strong><br>
首先，我们在我们项目的 <code>resource</code>  目录下创建  <code>META-INF.spring</code>  包，然后再创建  <code>provider.xml</code>  文件，名字可以任取哦，如下图所示</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/5b512b42ca2b41ed82fd82aaeee060dd.png" alt="在这里插入图片描述"></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--当前项目在整个分布式架构里面的唯一名称，计算依赖关系的标签--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;provider&quot;</span> <span class="attr">owner</span>=<span class="string">&quot;sihai&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">&quot;qos.enable&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">&quot;qos.accept.foreign.ip&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">&quot;qos.port&quot;</span> <span class="attr">value</span>=<span class="string">&quot;55555&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dubbo:application</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:monitor</span> <span class="attr">protocol</span>=<span class="string">&quot;registry&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--dubbo这个服务所要暴露的服务地址所对应的注册中心--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;dubbo:registry address=&quot;N/A&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;N/A&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--当前服务发布所依赖的协议；webservice、Thrift、Hessain、http--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20880&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--服务发布的配置，需要暴露的服务接口--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span></span></span><br><span class="line"><span class="tag">            <span class="attr">interface</span>=<span class="string">&quot;com.sihai.dubbo.provider.service.ProviderService&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">ref</span>=<span class="string">&quot;providerService&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--Bean bean定义--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;providerService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.sihai.dubbo.provider.service.ProviderServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>说明：</p>
<p>1、上面的文件其实就是类似  <code>spring</code>  的配置文件，而且， <code>dubbo</code>  底层就是  <code>spring</code> 。<br>
2、节点： <code>dubbo:application</code> <br>
 就是整个项目在分布式架构中的唯一名称，可以在 <code>name</code>  属性中配置，另外还可以配置 <code>owner</code>  字段，表示属于谁。<br>
下面的参数是可以不配置的，这里配置是因为出现了端口的冲突，所以配置。<br>
3、节点： <code>dubbo:monitor</code> <br>
 监控中心配置， 用于配置连接监控中心相关信息，可以不配置，不是必须的参数。<br>
4、节点： <code>dubbo:registry</code> <br>
 配置注册中心的信息，比如，这里我们可以配置  <code>zookeeper</code>  作为我们的注册中心。 <code>address</code>  是注册中心的地址，这里我们配置的是  <code>N/A</code>  表示由  <code>dubbo</code>  自动分配地址。或者说是一种直连的方式，不通过注册中心。<br>
5、节点： <code>dubbo:protocol</code> <br>
 服务发布的时候  <code>dubbo</code>  依赖什么协议，可以配置 <code>dubbo</code> 、 <code>webservice</code> 、 <code>http</code>  等协议。<br>
6、节点： <code>dubbo:service</code> <br>
 这个节点就是我们的重点了，当我们服务发布的时候，我们就是通过这个配置将我们的服务发布出去的。 <code>interface</code>  是接口的包路径， <code>ref</code>  是第 ⑦ 点配置的接口的 <code>bean</code> 。<br>
7、最后，我们需要像配置 <code>spring</code>  的接口一样，配置接口的  <code>bean</code> 。</p>
<p>到这一步，关于服务端的配置就完成了，下面我们通过  <code>main</code>  方法将接口发布出去。</p>
<p><strong>发布接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sihai.dubbo.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ApplicationConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ProtocolConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.RegistryConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ServiceConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.container.Main;</span><br><span class="line"><span class="keyword">import</span> com.sihai.dubbo.provider.service.ProviderService;</span><br><span class="line"><span class="keyword">import</span> com.sihai.dubbo.provider.service.ProviderServiceImpl;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * xml方式启动</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//加载xml配置文件启动</span></span><br><span class="line">        <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;META-INF/spring/provider.xml&quot;</span>);</span><br><span class="line">        context.start();</span><br><span class="line">        System.in.read(); <span class="comment">// 按任意键退出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发布接口非常简单，因为 <code>dubbo</code>  底层就是依赖  <code>spring</code>  的，所以，我们只需要通过  <code>ClassPathXmlApplicationContext</code>  拿到我们刚刚配置好的  <code>xml</code> ，然后调用  <code>context.start()</code>  方法就启动了。</p>
<p>看到下面的截图，就算是启动成功了，接口也就发布出去了。</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/fb50e61a90ab4e6c873323a7bac4d345.png" alt="在这里插入图片描述"><br>
你以为到这里就结束了了，并不是的，我们拿到  <code>dubbo</code>  暴露出去的  <code>url</code>  分析分析。</p>
<p><strong>Dubbo 暴露的 URL</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dubbo://192.168.234.1:20880/com.sihai.dubbo.provider.service.ProviderService?anyhost=true&amp;application=provider&amp;bean.name=com.sihai.dubbo.provider.service.ProviderService&amp;bind.ip=192.168.234.1&amp;bind.port=20880&amp;dubbo=2.0.2&amp;generic=false&amp;interface=com.sihai.dubbo.provider.service.ProviderService&amp;methods=SayHello&amp;owner=sihai&amp;pid=8412&amp;qos.accept.foreign.ip=false&amp;qos.enable=true&amp;qos.port=55555&amp;side=provider&amp;timestamp=1562077289380</span><br></pre></td></tr></table></figure>
<p>分析如下：</p>
<p>1、首先，在形式上我们发现，其实这么牛逼的  <code>dubbo</code>  也是用类似于  <code>http</code>  的协议发布自己的服务的，只是这里我们用的是 <code>dubbo</code>  协议。<br>
2、 <code>dubbo://192.168.234.1:20880/com.sihai.dubbo.provider.service.ProviderService</code> <br>
 上面这段链接就是  <code>?</code>  之前的链接，构成：<strong>协议://ip: 端口 / 接口</strong>。发现是不是也没有什么神秘的。<br>
3、 <code>anyhost=true&amp;application=provider&amp;bean.name=com.sihai.dubbo.provider.service.ProviderService&amp;bind.ip=192.168.234.1&amp;bind.port=20880&amp;dubbo=2.0.2&amp;generic=false&amp;interface=com.sihai.dubbo.provider.service.ProviderService&amp;methods=SayHello&amp;owner=sihai&amp;pid=8412&amp;qos.accept.foreign.ip=false&amp;qos.enable=true&amp;qos.port=55555&amp;side=provider&amp;timestamp=1562077289380</code> <br>
 <code>?</code>  之后的字符串，分析后你发现，这些都是刚刚在 <code>provider.xml</code>  中配置的字段，然后通过 <code>&amp;</code>  拼接而成的，闻到了  <code>http</code>  的香味了吗？</p>
<p>终于， <code>dubbo</code>  服务端入门了。下面我们看看拿到了  <code>url</code>  后，怎么消费呢？</p>
<h3 id="162-消费端"><a class="markdownIt-Anchor" href="#162-消费端">#</a> 1.6.2 消费端</h3>
<p>上面提到，我们在服务端提供的只是点对点的方式提供服务，并没有使用注册中心，所以，下面的配置也是会有一些不一样的。</p>
<p><strong>消费端环境配置</strong><br>
首先，我们在消费端的  <code>resource</code>  下建立配置文件  <code>consumer.xml</code></p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/e6964bf9a44b442ca792e91ca7e098b0.png" alt="在这里插入图片描述"></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--当前项目在整个分布式架构里面的唯一名称，计算依赖关系的标签--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;consumer&quot;</span> <span class="attr">owner</span>=<span class="string">&quot;sihai&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--dubbo这个服务所要暴露的服务地址所对应的注册中心--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--点对点的方式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;N/A&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;dubbo:registry address=&quot;zookeeper://localhost:2181&quot; check=&quot;false&quot;/&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--生成一个远程服务的调用代理--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--点对点方式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;providerService&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">interface</span>=<span class="string">&quot;com.sihai.dubbo.provider.service.ProviderService&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">url</span>=<span class="string">&quot;dubbo://192.168.234.1:20880/com.sihai.dubbo.provider.service.ProviderService&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--&lt;dubbo:reference id=&quot;providerService&quot;  </span></span><br><span class="line"><span class="comment">                    interface=&quot;com.sihai.dubbo.provider.service.ProviderService&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>分析如下所示：</p>
<p>1、发现这里的  <code>dubbo:application</code>  和  <code>dubbo:registry</code>  是一致的<br>
 2、 <code>dubbo:reference</code>  ：我们这里采用点对点的方式，所以，需要配置在服务端暴露的  <code>url</code></p>
<p><strong>maven 依赖</strong><br>
和服务端一样</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ouyangsihai<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-consumer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ouyangsihai<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-provider<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/dubbo --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.101tec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zkclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.32.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>调用服务</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sihai.dubbo.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ApplicationConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ReferenceConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.RegistryConfig;</span><br><span class="line"><span class="keyword">import</span> com.sihai.dubbo.provider.service.ProviderService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * xml的方式调用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        ClassPathXmlApplicationContext context=<span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;consumer.xml&quot;</span>);</span><br><span class="line">        context.start();</span><br><span class="line">        <span class="type">ProviderService</span> <span class="variable">providerService</span> <span class="operator">=</span> (ProviderService) context.getBean(<span class="string">&quot;providerService&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> providerService.SayHello(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        System.in.read();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里和服务端的发布如出一辙<br>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/af173265c9fd4e72a6118916e5f4bf32.png" alt="在这里插入图片描述"><br>
如此，我们就成功调用接口了。</p>
<h2 id="17-加入zookeeper作为注册中心"><a class="markdownIt-Anchor" href="#17-加入zookeeper作为注册中心">#</a> 1.7 加入 <code>zookeeper</code>  作为注册中心</h2>
<p>在前面的案例中，我们没有使用任何的注册中心，而是用一种直连的方式进行的。但是，实际上很多时候，我们都是使用 <code>dubbo + zookeeper</code>  的方式，使用  <code>zookeeper</code>  作为注册中心，这里，我们就介绍一下  <code>zookeeper</code>  作为注册中心的使用方法。</p>
<p>这里，我们在前面的入门实例中进行改造。</p>
<h3 id="171-服务端"><a class="markdownIt-Anchor" href="#171-服务端">#</a> 1.7.1 服务端</h3>
<p>在服务端中，我们只需要修改 <code>provider.xml</code>  即可。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--当前项目在整个分布式架构里面的唯一名称，计算依赖关系的标签--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;provider&quot;</span> <span class="attr">owner</span>=<span class="string">&quot;sihai&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">&quot;qos.enable&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">&quot;qos.accept.foreign.ip&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">&quot;qos.port&quot;</span> <span class="attr">value</span>=<span class="string">&quot;55555&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dubbo:application</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:monitor</span> <span class="attr">protocol</span>=<span class="string">&quot;registry&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--dubbo这个服务所要暴露的服务地址所对应的注册中心--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;dubbo:registry address=&quot;N/A&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://localhost:2181&quot;</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--当前服务发布所依赖的协议；webservice、Thrift、Hessain、http--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20880&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--服务发布的配置，需要暴露的服务接口--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span></span></span><br><span class="line"><span class="tag">            <span class="attr">interface</span>=<span class="string">&quot;com.sihai.dubbo.provider.service.ProviderService&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">ref</span>=<span class="string">&quot;providerService&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--Bean bean定义--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;providerService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.sihai.dubbo.provider.service.ProviderServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>重点关注这句话</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:registry address=&quot;zookeeper://localhost:2181&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>在  <code>address</code>  中，使用我们的  <code>zookeeper</code>  的地址。</p>
<p>如果是 <code>zookeeper</code>  集群的话，使用下面的方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:registry protocol=&quot;zookeeper&quot; address=&quot;192.168.11.129:2181,192.168.11.137:2181,192.168.11.138:2181&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>服务端的配置就好了，其他的跟 入门案例 一样。</p>
<h3 id="172-消费端"><a class="markdownIt-Anchor" href="#172-消费端">#</a> 1.7.2 消费端</h3>
<p>跟服务端一样，在消费端，我们也只需要修改  <code>consumer.xml</code>  即可。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--当前项目在整个分布式架构里面的唯一名称，计算依赖关系的标签--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;consumer&quot;</span> <span class="attr">owner</span>=<span class="string">&quot;sihai&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--dubbo这个服务所要暴露的服务地址所对应的注册中心--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--点对点的方式--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;dubbo:registry address=&quot;N/A&quot; /&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://localhost:2181&quot;</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--生成一个远程服务的调用代理--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--点对点方式--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;dubbo:reference id=&quot;providerService&quot;</span></span><br><span class="line"><span class="comment">                     interface=&quot;com.sihai.dubbo.provider.service.ProviderService&quot;</span></span><br><span class="line"><span class="comment">                     url=&quot;dubbo://192.168.234.1:20880/com.sihai.dubbo.provider.service.ProviderService&quot;/&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;providerService&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">interface</span>=<span class="string">&quot;com.sihai.dubbo.provider.service.ProviderService&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>1、注册中心配置跟服务端一样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:registry address=&quot;zookeeper://localhost:2181&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>2、 <code>dubbo:reference</code> <br>
 由于我们这里使用  <code>zookeeper</code>  作为注册中心，所以，跟点对点的方式是不一样的，这里不再需要  <code>dubbo</code>  服务端提供的 url 了，只需要直接引用服务端提供的接口即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:reference id=&quot;providerService&quot;</span><br><span class="line">                     interface=&quot;com.sihai.dubbo.provider.service.ProviderService&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>好了，消费端也配置好了，这样就可以使用修改的入门案例，重新启动运行了。</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/7a5a1b4a974a48ceb5aa80f1d516f5f4.png" alt="在这里插入图片描述"><br>
同样成功了。</p>
<p>这时候的区别在于，<strong>将  <code>dubbo</code>  发布的 <code>url</code>  注册到了  <code>zookeeper</code> ，消费端从  <code>zookeeper</code>  消费， <code>zookeeper</code>  相当于一个中介，给消费者提供服务</strong>。</p>
<p>你以为这就完了？不，好戏才刚刚开始呢。</p>
<h2 id="18-多种配置方式"><a class="markdownIt-Anchor" href="#18-多种配置方式">#</a> 1.8 多种配置方式</h2>
<p>在入门实例的时候，我们使用的是  <code>xml</code>  配置的方式，对  <code>dubbo</code>  的环境进行了配置，但是，官方还提供了其他的配置方式，这里我们也一一分解。</p>
<h3 id="181-api配置方式"><a class="markdownIt-Anchor" href="#181-api配置方式">#</a> 1.8.1  <code>API</code>  配置方式</h3>
<p>这种方式其实官方是不太推荐的，官方推荐使用 <code>xml</code>  配置的方式，但是，在有的时候测试的时候，还是可以用的到的，另外，为了保证完整性，这些内容还是有必要讲讲的。</p>
<p>首先还是回到服务端工程。</p>
<p><strong>服务端</strong><br>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/e0f491e8de154c93b814e9e87df52f54.png" alt="在这里插入图片描述"><br>
这里我们使用  <code>api</code>  的方式配置，所以， <code>provider.xml</code>  这个配置文件就暂时不需要了，我们只需要在上面的  <code>AppApi</code>  这个类中的  <code>main</code>  方法中用 <code>api</code>  配置及启动即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sihai.dubbo.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ApplicationConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ProtocolConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.RegistryConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ServiceConfig;</span><br><span class="line"><span class="keyword">import</span> com.sihai.dubbo.provider.service.ProviderService;</span><br><span class="line"><span class="keyword">import</span> com.sihai.dubbo.provider.service.ProviderServiceImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Api方式启动</span></span><br><span class="line"><span class="comment"> * api的方式调用不需要其他的配置，只需要下面的代码即可。</span></span><br><span class="line"><span class="comment"> * 但是需要注意，官方建议：</span></span><br><span class="line"><span class="comment"> * Api方式用于测试用例使用，推荐xml的方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppApi</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 服务实现</span></span><br><span class="line">        <span class="type">ProviderService</span> <span class="variable">providerService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProviderServiceImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前应用配置</span></span><br><span class="line">        <span class="type">ApplicationConfig</span> <span class="variable">application</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApplicationConfig</span>();</span><br><span class="line">        application.setName(<span class="string">&quot;provider&quot;</span>);</span><br><span class="line">        application.setOwner(<span class="string">&quot;sihai&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接注册中心配置</span></span><br><span class="line">        <span class="type">RegistryConfig</span> <span class="variable">registry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RegistryConfig</span>();</span><br><span class="line">        registry.setAddress(<span class="string">&quot;zookeeper://localhost:2181&quot;</span>);</span><br><span class="line"><span class="comment">//        registry.setUsername(&quot;aaa&quot;);</span></span><br><span class="line"><span class="comment">//        registry.setPassword(&quot;bbb&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 服务提供者协议配置</span></span><br><span class="line">        <span class="type">ProtocolConfig</span> <span class="variable">protocol</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProtocolConfig</span>();</span><br><span class="line">        protocol.setName(<span class="string">&quot;dubbo&quot;</span>);</span><br><span class="line">        protocol.setPort(<span class="number">20880</span>);</span><br><span class="line">        <span class="comment">//protocol.setThreads(200);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：ServiceConfig为重对象，内部封装了与注册中心的连接，</span></span><br><span class="line">        <span class="comment">//以及开启服务端口</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 服务提供者暴露服务配置</span></span><br><span class="line">        <span class="comment">// 此实例很重，封装了与注册中心的连接，请自行缓存，</span></span><br><span class="line">        <span class="comment">//否则可能造成内存和连接泄漏</span></span><br><span class="line">        ServiceConfig&lt;ProviderService&gt; service = <span class="keyword">new</span> <span class="title class_">ServiceConfig</span>&lt;ProviderService&gt;(); </span><br><span class="line">        service.setApplication(application);</span><br><span class="line">        <span class="comment">// 多个注册中心可以用setRegistries()</span></span><br><span class="line">        service.setRegistry(registry); </span><br><span class="line">        <span class="comment">// 多个协议可以用setProtocols()</span></span><br><span class="line">        service.setProtocol(protocol); </span><br><span class="line">        service.setInterface(ProviderService.class);</span><br><span class="line">        service.setRef(providerService);</span><br><span class="line">        service.setVersion(<span class="string">&quot;1.0.0&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 暴露及注册服务</span></span><br><span class="line">        service.export();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析说明如下所示：</p>
<p>看到上面的代码是不是云里雾里，不要慌，我们通过对照  <code>xml</code>  的方式分析一下。</p>
<p><strong>registry 的 xml 方式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:registry protocol=&quot;zookeeper&quot; address=&quot;localhost:2181&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p><strong>API 的方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RegistryConfig</span> <span class="variable">registry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RegistryConfig</span>();</span><br><span class="line">registry.setAddress(<span class="string">&quot;zookeeper://localhost:2181&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><code>dubbo:registry</code>  节点对应 <code>RegistryConfig</code>  ， <code>xml</code>  的属性对应  <code>API</code>  方式用  <code>set</code>  方法就可以了。对比之下，你就会发现，如果  <code>API</code>  的方式不熟悉，可以对照 <code>xml</code>  配置方式就可以。</p>
<p><strong>其他 API</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">org.apache.dubbo.config.ServiceConfig</span><br><span class="line">org.apache.dubbo.config.ReferenceConfig</span><br><span class="line">org.apache.dubbo.config.ProtocolConfig</span><br><span class="line">org.apache.dubbo.config.RegistryConfig</span><br><span class="line">org.apache.dubbo.config.MonitorConfig</span><br><span class="line">org.apache.dubbo.config.ApplicationConfig</span><br><span class="line">org.apache.dubbo.config.ModuleConfig</span><br><span class="line">org.apache.dubbo.config.ProviderConfig</span><br><span class="line">org.apache.dubbo.config.ConsumerConfig</span><br><span class="line">org.apache.dubbo.config.MethodConfig</span><br><span class="line">org.apache.dubbo.config.ArgumentConfig</span><br></pre></td></tr></table></figure>
<p>更详细的可以查看官方文档：</p>
<blockquote>
<p>http://<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=dubbo&amp;spm=1001.2101.3001.7020">dubbo</a>.apache.org/zh-cn…</p>
</blockquote>
<p>我们再看看我配置的消费端的 <code>Api</code>  方式。</p>
<p><strong>消费端</strong><br>
同样，我们不需要  <code>consumer.xml</code>  配置文件了，只需要在  <code>main</code>  方法中启动即可。</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/99006e3f58d0417dbf27fa7068633b05.png" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sihai.dubbo.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ApplicationConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ReferenceConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.RegistryConfig;</span><br><span class="line"><span class="keyword">import</span> com.sihai.dubbo.provider.service.ProviderService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * api的方式调用</span></span><br><span class="line"><span class="comment"> * api的方式调用不需要其他的配置，只需要下面的代码即可。</span></span><br><span class="line"><span class="comment"> * 但是需要注意，官方建议：</span></span><br><span class="line"><span class="comment"> * Api方式用于测试用例使用，推荐xml的方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppApi</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 当前应用配置</span></span><br><span class="line">        <span class="type">ApplicationConfig</span> <span class="variable">application</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApplicationConfig</span>();</span><br><span class="line">        application.setName(<span class="string">&quot;consumer&quot;</span>);</span><br><span class="line">        application.setOwner(<span class="string">&quot;sihai&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接注册中心配置</span></span><br><span class="line">        <span class="type">RegistryConfig</span> <span class="variable">registry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RegistryConfig</span>();</span><br><span class="line">        registry.setAddress(<span class="string">&quot;zookeeper://localhost:2181&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：ReferenceConfig为重对象，内部封装了与注册中心的连接，</span></span><br><span class="line">        <span class="comment">//以及与服务提供方的连接</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 引用远程服务</span></span><br><span class="line">        ReferenceConfig&lt;ProviderService&gt; reference = <span class="keyword">new</span> <span class="title class_">ReferenceConfig</span>&lt;ProviderService&gt;(); <span class="comment">// 此实例很重，封装了与注册中心的连接以及与提供者的连接，请自行缓存，否则可能造成内存和连接泄漏</span></span><br><span class="line">        reference.setApplication(application);</span><br><span class="line">        reference.setRegistry(registry); <span class="comment">// 多个注册中心可以用setRegistries()</span></span><br><span class="line">        reference.setInterface(ProviderService.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 和本地bean一样使用xxxService</span></span><br><span class="line">        <span class="type">ProviderService</span> <span class="variable">providerService</span> <span class="operator">=</span> reference.get(); <span class="comment">// 注意：此代理对象内部封装了所有通讯细节，对象较重，请缓存复用</span></span><br><span class="line">        providerService.SayHello(<span class="string">&quot;hello dubbo! I am sihai!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分的  <code>API</code>  配置的方式就到这了，注意：官方推荐  <code>xml</code>  的配置方法</p>
<h3 id="182-注解配置方式"><a class="markdownIt-Anchor" href="#182-注解配置方式">#</a> 1.8.2 注解配置方式</h3>
<p>注解配置方式还是需要了解一下的，现在微服务都倾向于这种方式，这也是以后发展的趋势， <code>0</code>  配置应该是这几年的趋势。</p>
<p>那么如何对 <code>dubbo</code>  使用注解的方式呢？我们先看服务端。</p>
<p><strong>服务端</strong><br>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/1ad33df6d381480793d65ee4212b5ea6.png" alt="在这里插入图片描述"><br>
<strong>第一步：定义接口及实现类，在上面的截图中的  <code>annotation</code>  包下</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sihai.dubbo.provider.service.annotation;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解方式接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProviderServiceAnnotation</span> &#123;</span><br><span class="line">    String <span class="title function_">SayHelloAnnotation</span><span class="params">(String word)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sihai.dubbo.provider.service.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解方式实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service(timeout = 5000)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProviderServiceImplAnnotation</span> <span class="keyword">implements</span> <span class="title class_">ProviderServiceAnnotation</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">SayHelloAnnotation</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> word;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>@Service</strong></p>
<p><code>@Service</code>  用来配置  <code>Dubbo</code>  的服务提供方。</p>
<p><strong>第二步：组装服务提供方</strong>。通过  <code>Spring</code>  中  <code>Java Config</code>  的技术（ <code>@Configuration</code> ）和  <code>annotation</code>  扫描（ <code>@EnableDubbo</code> ）来发现、组装、并向外提供 <code>Dubbo</code>  的服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sihai.dubbo.provider.configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ApplicationConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ProtocolConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ProviderConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.RegistryConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.spring.context.annotation.EnableDubbo;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解方式配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableDubbo(scanBasePackages = &quot;com.sihai.dubbo.provider.service.annotation&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DubboConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">// #1 服务提供者信息配置</span></span><br><span class="line">    <span class="keyword">public</span> ProviderConfig <span class="title function_">providerConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ProviderConfig</span> <span class="variable">providerConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProviderConfig</span>();</span><br><span class="line">        providerConfig.setTimeout(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> providerConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">// #2 分布式应用信息配置</span></span><br><span class="line">    <span class="keyword">public</span> ApplicationConfig <span class="title function_">applicationConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ApplicationConfig</span> <span class="variable">applicationConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApplicationConfig</span>();</span><br><span class="line">        applicationConfig.setName(<span class="string">&quot;dubbo-annotation-provider&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> applicationConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">// #3 注册中心信息配置</span></span><br><span class="line">    <span class="keyword">public</span> RegistryConfig <span class="title function_">registryConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RegistryConfig</span> <span class="variable">registryConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RegistryConfig</span>();</span><br><span class="line">        registryConfig.setProtocol(<span class="string">&quot;zookeeper&quot;</span>);</span><br><span class="line">        registryConfig.setAddress(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        registryConfig.setPort(<span class="number">2181</span>);</span><br><span class="line">        <span class="keyword">return</span> registryConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">// #4 使用协议配置，这里使用 dubbo</span></span><br><span class="line">    <span class="keyword">public</span> ProtocolConfig <span class="title function_">protocolConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ProtocolConfig</span> <span class="variable">protocolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProtocolConfig</span>();</span><br><span class="line">        protocolConfig.setName(<span class="string">&quot;dubbo&quot;</span>);</span><br><span class="line">        protocolConfig.setPort(<span class="number">20880</span>);</span><br><span class="line">        <span class="keyword">return</span> protocolConfig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析说明如下：<br>
1、通过  <code>@EnableDubbo</code>  指定在 <code>com.sihai.dubbo.provider.service.annotation</code>  下扫描所有标注有  <code>@Service</code>  的类</p>
<p>2、通过  <code>@Configuration</code>  将  <code>DubboConfiguration</code>  中所有的  <code>@Bean</code>  通过 <code>Java Config</code>  的方式组装出来并注入给  <code>Dubbo</code>  服务，也就是标注有 <code>@Service</code>  的类。</p>
<p>这其中就包括了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ProviderConfig：服务提供方配置</span><br><span class="line">ApplicationConfig：应用配置</span><br><span class="line">RegistryConfig：注册中心配置</span><br><span class="line">ProtocolConfig：协议配置</span><br></pre></td></tr></table></figure>
<p>看起来很复杂，其实。。。<br>
<img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/7a607c56fd774c65acf83b23b10bc831.png" alt="在这里插入图片描述"><br>
<strong>第三步：启动服务</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sihai.dubbo.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.spring.context.annotation.DubboComponentScan;</span><br><span class="line"><span class="keyword">import</span> com.sihai.dubbo.provider.configuration.DubboConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"><span class="keyword">import</span> sun.applet.Main;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解启动方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppAnnotation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(DubboConfiguration.class); </span><br><span class="line">        context.start();</span><br><span class="line">        System.in.read(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现输出下面信息就表示  <code>success</code>  了</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/5f2fc6b4d06b48fea91f16dfb130eb70.png" alt="在这里插入图片描述"><br>
<strong>消费端</strong></p>
<p>同样我们下看看消费端的工程，有一个感性认识。</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/0ff7a379a9df48e5a08f4669871a8832.png" alt="在这里插入图片描述"><br>
<strong>第一步：引用服务</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sihai.dubbo.consumer.Annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Reference;</span><br><span class="line"><span class="keyword">import</span> com.sihai.dubbo.provider.service.annotation.ProviderServiceAnnotation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解方式的service</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component(&quot;annotatedConsumer&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerAnnotationService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    <span class="keyword">private</span> ProviderServiceAnnotation providerServiceAnnotation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doSayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> providerServiceAnnotation.SayHelloAnnotation(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在  <code>ConsumerAnnotationService</code>  类中，通过  <code>@Reference</code>  引用服务端提供的类，然后通过方法调用这个类的方式，给消费端提供接口。</p>
<p>注意：如果这里找不到  <code>ProviderServiceAnnotation</code>  类，请在服务端先把服务端工程用  <code>Maven intall</code>  一下，然后将服务端的依赖放到消费端的 <code>pom</code>  中。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;com.ouyangsihai&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;dubbo-provider&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>解释一下：引入的 <code>jar</code>  包里面只是未被实现的接口， <code>rpc</code>  需要在客户端服务端定义一套统一的接口，然后在服务端实现接口，实际上还是网络通信，只不过长得像本地实现</p>
<p><strong>第二步：组装服务消费者</strong></p>
<p>这一步和服务端是类似的，这里就不在重复了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sihai.dubbo.consumer.configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ApplicationConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ConsumerConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.RegistryConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.spring.context.annotation.EnableDubbo;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableDubbo(scanBasePackages = &quot;com.sihai.dubbo.consumer.Annotation&quot;)</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &#123;&quot;com.sihai.dubbo.consumer.Annotation&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">// 应用配置</span></span><br><span class="line">    <span class="keyword">public</span> ApplicationConfig <span class="title function_">applicationConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ApplicationConfig</span> <span class="variable">applicationConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApplicationConfig</span>();</span><br><span class="line">        applicationConfig.setName(<span class="string">&quot;dubbo-annotation-consumer&quot;</span>);</span><br><span class="line">        Map&lt;String, String&gt; stringStringMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">        stringStringMap.put(<span class="string">&quot;qos.enable&quot;</span>,<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        stringStringMap.put(<span class="string">&quot;qos.accept.foreign.ip&quot;</span>,<span class="string">&quot;false&quot;</span>);</span><br><span class="line">        stringStringMap.put(<span class="string">&quot;qos.port&quot;</span>,<span class="string">&quot;33333&quot;</span>);</span><br><span class="line">        applicationConfig.setParameters(stringStringMap);</span><br><span class="line">        <span class="keyword">return</span> applicationConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">// 服务消费者配置</span></span><br><span class="line">    <span class="keyword">public</span> ConsumerConfig <span class="title function_">consumerConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ConsumerConfig</span> <span class="variable">consumerConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConsumerConfig</span>();</span><br><span class="line">        consumerConfig.setTimeout(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">return</span> consumerConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">// 配置注册中心</span></span><br><span class="line">    <span class="keyword">public</span> RegistryConfig <span class="title function_">registryConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RegistryConfig</span> <span class="variable">registryConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RegistryConfig</span>();</span><br><span class="line">        registryConfig.setProtocol(<span class="string">&quot;zookeeper&quot;</span>);</span><br><span class="line">        registryConfig.setAddress(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        registryConfig.setPort(<span class="number">2181</span>);</span><br><span class="line">        <span class="keyword">return</span> registryConfig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第三步：发起远程调用</strong></p>
<p>在 <code>main</code>  方法中通过启动一个 <code>Spring Context</code> ，从其中查找到组装好的 <code>Dubbo</code>  的服务消费者，并发起一次<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8&amp;spm=1001.2101.3001.7020">远程调用</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sihai.dubbo.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sihai.dubbo.consumer.Annotation.ConsumerAnnotationService;</span><br><span class="line"><span class="keyword">import</span> com.sihai.dubbo.consumer.configuration.ConsumerConfiguration;</span><br><span class="line"><span class="keyword">import</span> com.sihai.dubbo.provider.service.ProviderService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解方式启动</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppAnnotation</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(ConsumerConfiguration.class); </span><br><span class="line">        context.start(); <span class="comment">// 启动</span></span><br><span class="line">        <span class="type">ConsumerAnnotationService</span> <span class="variable">consumerAnnotationService</span> <span class="operator">=</span> context.getBean(ConsumerAnnotationService.class); </span><br><span class="line">        <span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> consumerAnnotationService.doSayHello(<span class="string">&quot;annotation&quot;</span>); <span class="comment">// 调用方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;result: &quot;</span> + hello); <span class="comment">// 输出结果</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/994174d242d84c92a8eb2489b6bc8930.png" alt="在这里插入图片描述"></p>
<h2 id="19-常用场景"><a class="markdownIt-Anchor" href="#19-常用场景">#</a> 1.9 常用场景</h2>
<p>在下面的讲解中，都会是以 <code>xml</code>  配置的方式来讲解的，这也是 <code>dubbo</code>  官方比较推荐的方式。以下的操作都是在服务端的  <code>xml</code>  配置文件和消费端的配置文件来讲解的。</p>
<h3 id="191-启动时检查"><a class="markdownIt-Anchor" href="#191-启动时检查">#</a> 1.9.1 启动时检查</h3>
<p><code>Dubbo</code>  缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止  <code>Spring</code>  初始化完成，以便上线时，能及早发现问题，默认 <code>check=&quot;true&quot;</code> 。</p>
<p>但是，有的时候，我们并不是都需要启动时就检查的，比如测试的时候，我们是需要更快速的启动，所以，这种场景的时候，我们是需要关闭这个功能的。</p>
<p>下面，我们看看如何使用这个功能。</p>
<p>在服务端注册的时候（客户端注册时同样适用）；</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">protocol</span>=<span class="string">&quot;zookeeper&quot;</span> <span class="attr">address</span>=<span class="string">&quot;localhost:2181,localhost:2182,localhost:2183&quot;</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>在客户端引用服务端服务的时候；</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span> <span class="attr">id</span>=<span class="string">&quot;providerService&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">interface</span>=<span class="string">&quot;com.sihai.dubbo.provider.service.ProviderService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>就是这么简单，就是这么强！</p>
<h3 id="192-集群容错"><a class="markdownIt-Anchor" href="#192-集群容错">#</a> 1.9.2 集群容错</h3>
<p><code>dubbo</code>  也是支持集群容错的，同时也有很多可选的方案，其中，默认的方案是  <code>failover</code> ，也就是重试机制。</p>
<p>首先，我们先把所有的容错机制都整理一遍，然后再看看使用。</p>
<table>
<thead>
<tr>
<th>集群模式</th>
<th>说明</th>
<th>使用方法</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Failover Cluster</code></td>
<td>失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 <code>retries=&quot;2&quot;</code>  来设置重试次数 (不含第一次)。</td>
<td><code>cluster=&quot;xxx&quot;</code> xxx：集群模式名称 ，例如 <code>cluster=&quot;failover&quot;</code></td>
</tr>
<tr>
<td><code>Failfast Cluster</code></td>
<td>快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</td>
<td></td>
</tr>
<tr>
<td><code>Failsafe Cluster</code></td>
<td>失败安全，出现异常时，直接忽略。</td>
<td></td>
</tr>
<tr>
<td><code>Failback Cluster</code></td>
<td>失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</td>
<td></td>
</tr>
<tr>
<td><code>Forking Cluster</code></td>
<td>并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 <code>forks=&quot;2&quot;</code>  来设置最大并行数。</td>
<td></td>
</tr>
<tr>
<td><code>Broadcast Cluster</code></td>
<td>广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>使用实例</strong><br>
在发布服务或者引用服务的时候设置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--服务发布的配置，需要暴露的服务接口--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">cluster</span>=<span class="string">&quot;failover&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;2&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">interface</span>=<span class="string">&quot;com.sihai.dubbo.provider.service.ProviderService&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">ref</span>=<span class="string">&quot;providerService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">cluster</span>=<span class="string">&quot;failover&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;2&quot;</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span> <span class="attr">id</span>=<span class="string">&quot;providerService&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">interface</span>=<span class="string">&quot;com.sihai.dubbo.provider.service.ProviderService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="193-负载均衡"><a class="markdownIt-Anchor" href="#193-负载均衡">#</a> 1.9.3 负载均衡</h3>
<p>负载均衡想必是一个再熟悉不过的概念了，所以， <code>dubbo</code>  支持也是再正常不过了，这里也总结一下 <code>dubbo</code>  支持的负载均衡的一些方案及使用方法。</p>
<table>
<thead>
<tr>
<th>负载均衡模式</th>
<th>说明</th>
<th>使用方法</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Random LoadBalance</code></td>
<td>随机 按权重设置随机概率</td>
<td><code>&lt;dubbo:service loadbalance=&quot;xxx&quot;/&gt;</code> xxx：负载均衡方法</td>
</tr>
<tr>
<td><code>RoundRobin LoadBalance</code></td>
<td>轮询 按公约后的权重设置轮询比率。</td>
<td></td>
</tr>
<tr>
<td><code>LeastActive LoadBalance</code></td>
<td>最少活跃调用数 相同活跃数的随机，活跃数指调用前后计数差。</td>
<td></td>
</tr>
<tr>
<td><code>ConsistentHash LoadBalance</code></td>
<td>一致性  <code>Hash</code>  相同参数的请求总是发到同一提供者。 当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="194-直连提供者"><a class="markdownIt-Anchor" href="#194-直连提供者">#</a> 1.9.4 直连提供者</h3>
<p>在开发及测试环境下，经常需要绕过注册中心，只测试指定服务提供者，所以，这种情况下，我们只需要直接连接服务端的地即可，其实，这种方法在前面的讲解已经使用到了，第一种讲解的方式就是这种方式，因为这种方式简单。</p>
<p>使用方法如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;providerService&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">interface</span>=<span class="string">&quot;com.sihai.dubbo.provider.service.ProviderService&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">url</span>=<span class="string">&quot;dubbo://192.168.234.1:20880/com.sihai.dubbo.provider.service.ProviderService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>说明：可以看到，只要在消费端在・ <code>dubbo:reference</code>  节点使用 <code>url</code>  给出服务端的方法即可。</p>
<h3 id="195-只订阅"><a class="markdownIt-Anchor" href="#195-只订阅">#</a> 1.9.5 只订阅</h3>
<p>只订阅就是只能够订阅服务端的服务，而不能够注册。</p>
<p>引用官方的使用场景如下：</p>
<blockquote>
<p>为方便开发测试，经常会在线下共用一个所有服务可用的注册中心，这时，如果一个正在开发中的服务提供者注册，可能会影响消费者不能正常运行。<br>
可以让服务提供者开发方，只订阅服务 (开发的服务可能依赖其它服务)，而不注册正在开发的服务，通过直连测试正在开发的服务。</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">register</span>=<span class="string">&quot;false&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;zookeeper&quot;</span> <span class="attr">address</span>=<span class="string">&quot;localhost:2181,localhost:2182,localhost:2183&quot;</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>1、使用只订阅方式<br>
当在服务提供端使用  <code>register=&quot;false&quot;</code>  的时候，我们使用下面的方式获取服务端的服务；</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">cluster</span>=<span class="string">&quot;failover&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;2&quot;</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span> <span class="attr">id</span>=<span class="string">&quot;providerService&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">interface</span>=<span class="string">&quot;com.sihai.dubbo.provider.service.ProviderService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>启动信息</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/82d1dafceb4d4562a5bf143dd1bcaed9.png" alt="在这里插入图片描述"><br>
发现，这时候并不是向注册中心  <code>zookeeper</code>  注册，而只是做了发布服务和启动 <code>netty</code> 。</p>
<p>2、不使用只订阅方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:registry protocol=<span class="string">&quot;zookeeper&quot;</span> address=<span class="string">&quot;localhost:2181,localhost:2182,localhost:2183&quot;</span> check=<span class="string">&quot;false&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>启动信息</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/752b5bf0d635420980b39495b8bf029d.png" alt="在这里插入图片描述"><br>
可以发现，这里就向注册中心  <code>zookeeper</code>  注册了。</p>
<h3 id="196-只注册"><a class="markdownIt-Anchor" href="#196-只注册">#</a> 1.9.6 只注册</h3>
<p>只注册正好跟前面的只订阅相反，这个时候可以向注册中心注册，但是，消费端却不能够读到服务。</p>
<p><strong>应用场景</strong></p>
<blockquote>
<p>如果有两个镜像环境，两个注册中心，有一个服务只在其中一个注册中心有部署，另一个注册中心还没来得及部署，而两个注册中心的其它应用都需要依赖此服务。这个时候，可以让服务提供者方只注册服务到另一注册中心，而不从另一注册中心订阅服务。</p>
</blockquote>
<p><strong>使用说明</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">subscribe</span>=<span class="string">&quot;false&quot;</span> <span class="attr">address</span>=<span class="string">&quot;localhost:2181&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:registry</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在服务端的  <code>dubbo:registry</code>  节点下使用  <code>subscribe=&quot;false&quot;</code>  来声明这个服务是只注册的服务。</p>
<p>这个时候消费端调用的时候是不能调用的。</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/272a429bc9a547108334d08a1188e774.png" alt="在这里插入图片描述"></p>
<h3 id="197-多协议机制"><a class="markdownIt-Anchor" href="#197-多协议机制">#</a> 1.9.7 多协议机制</h3>
<p>在前面我们使用的协议都是  <code>dubbo</code>  协议，但是  <code>dubbo</code>  除了支持这种协议外还支持其他的协议，比如， <code>rmi、hessian</code>  等，另外，而且还可以用多种协议同时暴露一种服务。</p>
<p><strong>使用方法</strong></p>
<p><strong>1、一种接口使用一种协议</strong></p>
<p>先声明多种协议</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--当前服务发布所依赖的协议；webserovice、Thrift、Hessain、http--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20880&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;rmi&quot;</span> <span class="attr">port</span>=<span class="string">&quot;1099&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在发布接口的时候使用具体协议</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--服务发布的配置，需要暴露的服务接口--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">cluster</span>=<span class="string">&quot;failover&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;2&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">interface</span>=<span class="string">&quot;com.sihai.dubbo.provider.service.ProviderService&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">ref</span>=<span class="string">&quot;providerService&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">cluster</span>=<span class="string">&quot;failover&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;2&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">interface</span>=<span class="string">&quot;com.sihai.dubbo.provider.service.ProviderService&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">ref</span>=<span class="string">&quot;providerService&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;rmi&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>在输出日志中，就可以找到 <code>rmi</code>  发布的接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmi://192.168.234.1:1099/com.sihai.dubbo.provider.service.ProviderService?anyhost=true&amp;application=provider&amp;bean.name=com.sihai.dubbo.provider.service.ProviderService&amp;cluster=failover&amp;dubbo=2.0.2&amp;generic=false&amp;interface=com.sihai.dubbo.provider.service.ProviderService&amp;methods=SayHello&amp;owner=sihai&amp;pid=796&amp;retries=2&amp;side=provider&amp;timestamp=1564281053185, dubbo version: 2.6.6, current host: 192.168.234.1</span><br></pre></td></tr></table></figure>
<p><strong>2、一种接口使用多种协议</strong><br>
声明协议和上面的方式一样，在发布接口的时候有一点不一样。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">cluster</span>=<span class="string">&quot;failover&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;2&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">interface</span>=<span class="string">&quot;com.sihai.dubbo.provider.service.ProviderService&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">ref</span>=<span class="string">&quot;providerService&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;rmi,dubbo&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>说明： <code>protocol</code>  属性，可以用 <code>,</code>  隔开，使用多种协议。</p>
<h3 id="198-多注册中心"><a class="markdownIt-Anchor" href="#198-多注册中心">#</a> 1.9.8 多注册中心</h3>
<p><code>Dubbo</code>  支持同一服务向多注册中心同时注册，或者不同服务分别注册到不同的注册中心上去，甚至可以同时引用注册在不同注册中心上的同名服务。</p>
<p><strong>服务端多注册中心发布服务</strong></p>
<p>一个服务可以在不同的注册中心注册，当一个注册中心出现问题时，可以用其他的注册中心。</p>
<p><strong>注册</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--多注册中心--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">protocol</span>=<span class="string">&quot;zookeeper&quot;</span> <span class="attr">id</span>=<span class="string">&quot;reg1&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;10000&quot;</span> <span class="attr">address</span>=<span class="string">&quot;localhost:2181&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">protocol</span>=<span class="string">&quot;zookeeper&quot;</span> <span class="attr">id</span>=<span class="string">&quot;reg2&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;10000&quot;</span> <span class="attr">address</span>=<span class="string">&quot;localhost:2182&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">protocol</span>=<span class="string">&quot;zookeeper&quot;</span> <span class="attr">id</span>=<span class="string">&quot;reg3&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;10000&quot;</span> <span class="attr">address</span>=<span class="string">&quot;localhost:2183&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>发布服务</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--服务发布的配置，需要暴露的服务接口--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">cluster</span>=<span class="string">&quot;failover&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;2&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">interface</span>=<span class="string">&quot;com.sihai.dubbo.provider.service.ProviderService&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">ref</span>=<span class="string">&quot;providerService&quot;</span> <span class="attr">registry</span>=<span class="string">&quot;reg1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">cluster</span>=<span class="string">&quot;failover&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;2&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">interface</span>=<span class="string">&quot;com.sihai.dubbo.provider.service.ProviderService&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">ref</span>=<span class="string">&quot;providerService&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;rmi&quot;</span> <span class="attr">registry</span>=<span class="string">&quot;reg2&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>说明：使用 <code>registry=&quot;reg2&quot;</code>  指定该接口使用的注册中心，同时也可以使用多个 <code>，</code> 用，隔开，例如， <code>registry=&quot;reg1,,reg2&quot;</code> 。</p>
<p><strong>消费端多注册中心引用服务</strong></p>
<p>首先，先向不同注册中心注册；</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--多注册中心--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">protocol</span>=<span class="string">&quot;zookeeper&quot;</span> <span class="attr">id</span>=<span class="string">&quot;reg1&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;10000&quot;</span> <span class="attr">address</span>=<span class="string">&quot;localhost:2181&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">protocol</span>=<span class="string">&quot;zookeeper&quot;</span> <span class="attr">id</span>=<span class="string">&quot;reg2&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;10000&quot;</span> <span class="attr">address</span>=<span class="string">&quot;localhost:2182&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">protocol</span>=<span class="string">&quot;zookeeper&quot;</span> <span class="attr">id</span>=<span class="string">&quot;reg3&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;10000&quot;</span> <span class="attr">address</span>=<span class="string">&quot;localhost:2183&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>其次，不同的消费端服务引用使用不同的注册中心；</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--不同的服务使用不同的注册中心--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">cluster</span>=<span class="string">&quot;failover&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;2&quot;</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span> <span class="attr">id</span>=<span class="string">&quot;providerService&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">interface</span>=<span class="string">&quot;com.sihai.dubbo.provider.service.ProviderService&quot;</span> <span class="attr">registry</span>=<span class="string">&quot;reg1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">cluster</span>=<span class="string">&quot;failover&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;2&quot;</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span> <span class="attr">id</span>=<span class="string">&quot;providerService2&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">interface</span>=<span class="string">&quot;com.sihai.dubbo.provider.service.ProviderService&quot;</span> <span class="attr">registry</span>=<span class="string">&quot;reg2&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>说明：上面分别使用注册中心 <code>1</code>  和注册中心 <code>2</code> 。</p>
<h3 id="199-多版本"><a class="markdownIt-Anchor" href="#199-多版本">#</a> 1.9.9 多版本</h3>
<p>不同的服务是有版本不同的，版本可以更新并且升级，同时，不同的版本之间是不可以调用的。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--服务发布的配置，需要暴露的服务接口--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">cluster</span>=<span class="string">&quot;failover&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;2&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">interface</span>=<span class="string">&quot;com.sihai.dubbo.provider.service.ProviderService&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">ref</span>=<span class="string">&quot;providerService&quot;</span> <span class="attr">registry</span>=<span class="string">&quot;reg1&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.0.0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">cluster</span>=<span class="string">&quot;failover&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;2&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">interface</span>=<span class="string">&quot;com.sihai.dubbo.provider.service.ProviderService&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">ref</span>=<span class="string">&quot;providerService&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;rmi&quot;</span> <span class="attr">registry</span>=<span class="string">&quot;reg2&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.0.0&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>加入了版本控制。</p>
<h3 id="1910-日志管理"><a class="markdownIt-Anchor" href="#1910-日志管理">#</a> 1.9.10 日志管理</h3>
<p><code>dubbo</code>  也可以将日志信息记录或者保存到文件中的。</p>
<p>1、使用 <code>accesslog</code>  输出到 <code>log4j</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">accesslog</span>=<span class="string">&quot;true&quot;</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20880&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">accesslog</span>=<span class="string">&quot;true&quot;</span> <span class="attr">name</span>=<span class="string">&quot;rmi&quot;</span> <span class="attr">port</span>=<span class="string">&quot;1099&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>2、输出到文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">accesslog</span>=<span class="string">&quot;http://localhost/log.txt&quot;</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20880&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">accesslog</span>=<span class="string">&quot;http://localhost/log2.txt&quot;</span> <span class="attr">name</span>=<span class="string">&quot;rmi&quot;</span> <span class="attr">port</span>=<span class="string">&quot;1099&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="关于我"><a class="markdownIt-Anchor" href="#关于我">#</a> 关于我</h2>
<p>Brath 是一个热爱技术的 Java 程序猿，公众号「InterviewCoder」定期分享有趣有料的精品原创文章！</p>
<p><img src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png" alt="InterviewCoder"></p>
<p>非常感谢各位人才能看到这里，原创不易，文章如果有帮助可以关注、点赞、分享或评论，这都是对我的莫大支持！</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/page/0/">上一页</a></div><div class="pagination-next"><a href="/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/15/">15</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-05-23T02:04:23.000Z">2023-05-23</time></p><p class="title"><a href="/2023/05/23/%E3%80%90Linux%E3%80%91%E9%98%BF%E9%87%8C%E4%BA%91linux%20%E6%8C%82%E8%BD%BD%E6%95%B0%E6%8D%AE%E7%9B%98%E5%B9%B6docker%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%E8%BF%81%E7%A7%BB%E5%88%B0%E6%95%B0%E6%8D%AE%E7%9B%98/">【Linux】阿里云linux 挂载数据盘并docker工作目录迁移到数据盘</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-05-23T02:04:23.000Z">2023-05-23</time></p><p class="title"><a href="/2023/05/23/%E3%80%90Seata%E3%80%91%E6%9D%A5%E8%87%AA%E9%98%BF%E9%87%8C%E5%BC%80%E6%BA%90%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A1%86%E6%9E%B6-Seata%E7%9A%84%E5%8E%9F%E7%90%86/">【Seata】来自阿里开源分布式事务框架-Seata的原理</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-05-17T08:20:40.000Z">2023-05-17</time></p><p class="title"><a href="/2023/05/17/%E3%80%90Java%E3%80%91%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%EF%BC%9A%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E6%97%A0%E5%93%8D%E5%BA%94/">【Java】记一次线上故障：服务接口无响应</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-05-08T14:04:55.000Z">2023-05-08</time></p><p class="title"><a href="/2023/05/08/%E3%80%90Java%E3%80%91HashMap%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E8%A7%A3%E8%AF%BB/">【Java】HashMap核心原理解读</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-05-05T01:57:09.000Z">2023-05-05</time></p><p class="title"><a href="/2023/05/05/%E3%80%90IDEA%E3%80%91IDEA%E7%9A%84debug%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7%E8%AF%A6%E8%A7%A3/">【IDEA】IDEA的debug调试技巧详解</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">36</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/"><span class="level-start"><span class="level-item">2022</span></span><span class="level-end"><span class="level-item tag">60</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/"><span class="level-start"><span class="level-item">2021</span></span><span class="level-end"><span class="level-item tag">44</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/"><span class="level-start"><span class="level-item">2020</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://brath4.oss-cn-shenzhen.aliyuncs.com/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81plus.png" alt="InterviewCoder"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">InterviewCoder</p><p class="is-size-6 is-block">面试记官方公众号</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">145</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://mp.weixin.qq.com/s/jWs6lLHl5L-atXJhHc4YvA" target="_blank" rel="noopener">关注我</a></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://brath.cloud/me.png" alt="Brath"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Brath</p><p class="is-size-6 is-block">技能改变人生，知识改变命运。</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·江苏·无锡</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">145</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Guoqing815" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Guoqing815"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Gitee" href="https://gitee.com/Guoqing-Li"><i class="fab fa-gitee"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://schokolade.cn/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">泠灵(特别呜谢)</span></span><span class="level-right"><span class="level-item tag">schokolade.cn</span></span></a></li><li><a class="level is-mobile" href="https://gitee.com/Guoqing-Li" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Gitee(码云)</span></span><span class="level-right"><span class="level-item tag">gitee.com</span></span></a></li><li><a class="level is-mobile" href="https://blog.csdn.net/Brath?type=blog" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">CSDN</span></span><span class="level-right"><span class="level-item tag">blog.csdn.net</span></span></a></li><li><a class="level is-mobile" href="https://juejin.cn/user/settings/profile" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">掘金</span></span><span class="level-right"><span class="level-item tag">juejin.cn</span></span></a></li><li><a class="level is-mobile" href="https://oss.console.aliyun.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">AliCloud(阿里云)</span></span><span class="level-right"><span class="level-item tag">oss.console.aliyun.com</span></span></a></li><li><a class="level is-mobile" href="https://cloud.tencent.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">TencentCloud(腾讯云)</span></span><span class="level-right"><span class="level-item tag">cloud.tencent.com</span></span></a></li><li><a class="level is-mobile" href="https://www.zhipin.com/web/user/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">BOSS</span></span><span class="level-right"><span class="level-item tag">www.zhipin.com</span></span></a></li><li><a class="level is-mobile" href="https://www.bilibili.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bilibili(B站)</span></span><span class="level-right"><span class="level-item tag">www.bilibili.com</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://brath.cloud/avatar.png" alt="Brath-Blog" height="28"></a><p class="is-size-7"><span>&copy; 2023 Brath</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p><p class="is-size-7">© 2029</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>